class CompilerOptions {
	public dbg_lexer: bool
	public dbg_parser: bool
	public dbg_typechecker: bool
	public dbg_codegen: bool

	public codegen_only_reachable: bool
	public codegen_bitcode: bool

	public optimize: bool
	public link_static: bool
	public generate_debug_symbols: bool
	public strip_symbol_names: bool

	public build_dir: String
	public additional_llvm_ir_files: [String]

	public symbol_type: SymbolType

	public import_search_paths: [String]
}

enum SymbolType {
	Id
	Name
	Signature
}

struct FileInfo {
	path: String
	source: [u8]
	lines: [Span]
}

struct Span {
	start: usize
	end: usize

	fn empty() -> Span => Span(start: 0, end: 0)

	fn merge(this, anon other: Span) -> Span {
		return Span(start: .start, end: other.end)
	}

	fn format(this) throws -> String => format("[{}, {}]", .start, .end)
}

fn mergeSpans(start: Span, end: Span) -> Span {
	return start.merge(end)
}

fn cloneList<T>(anon list: [T]) throws -> [T] {
	mut tmp: [T] = []

	for entry in list {
		tmp.push(entry)
	}

	return tmp
}

fn panic(anon message: String) -> never {
	eprintln("internal error: {}", message)
	abort()
}

fn loadFile(anon path: String) throws -> FileInfo {
	let ErrNOENT = 2i32
	let ErrACCES = 13i32
	let ErrFBIG = 27i32
	let ErrNAMETOOLONG = 36i32

	mut result = FileInfo(
		path: "",
		source: [],
		lines: []
	)

	try {
		mut file = File::open_for_reading(path)
		let source = file.read_all()
		result = FileInfo(
			path,
			source,
			lines: gatherLineSpans(source)
		)
	} catch error {
		match error.code() {
			(ErrNOENT) =>		{ panic(format("\u001b[31;1mError\u001b[0m Could not access {}: File not found", path)) }
			(ErrACCES) =>		{ panic(format("\u001b[31;1mError\u001b[0m Could not access {}: Permission denied", path)) }
			(ErrFBIG) =>		{ panic(format("\u001b[31;1mError\u001b[0m Could not access {}: File too big", path)) }
			(ErrNAMETOOLONG) =>	{ panic(format("\u001b[31;1mError\u001b[0m Could not access {}: Name too long", path)) }
			else => {
				panic("Incurred unrecognized error while trying to open file")
			}
		}
	}

	return result
}

fn gatherLineSpans(anon source: [u8]) throws -> [Span] {
	mut index: usize = 0
	mut start = index
	mut result: [Span] = []

	while index < source.size() {
		if source[index] == b'\n' {
			result.push(Span(start, end: index))
			start = index + 1
		}

		index++
	}

	if start < index {
		result.push(Span(start, end: index))
	}

	return result
}

fn printError(anon message: String, anon span: Span, anon file: FileInfo) throws {
	if span.start == 0 and span.end == 0 {
		eprintln("{}", message)
	} else {
		mut start_line: usize = 0
		mut end_line: usize = 0

		for index in 0..file.lines.size() {
			let current = file.lines[index]

			if current.start <= span.start and current.end >= span.start {
				start_line = index
			}

			if current.start <= span.end and current.end >= span.end {
				end_line = index + 1
				break
			}
		}

		let column = span.start - file.lines[start_line].start + 1

		eprintln("{} at {}:{}:{}", message, file.path, start_line + 1, column)

		// if possible also show 1 line before and after the error
		if start_line > 0 {
			start_line -= 1
		}
		if end_line < file.lines.size() - 1 {
			end_line += 1
		}

		let max_line_number_width = format("{}", end_line).length()

		for line_index in start_line..end_line {
			let current_line_number_width = format("{}", line_index + 1).length();
			let line_number_padding = max_line_number_width - current_line_number_width
			printSourceLine(file: file, line_span: file.lines[line_index], error_span: span, line_number: line_index + 1, line_number_padding)
		}
	}
}

fn printSourceLine(file: FileInfo, line_span: Span, error_span: Span, line_number: usize, line_number_padding: usize) throws {
	eprint(" {}", line_number)
	for _ in 0..line_number_padding {
		eprint(" ")
	}
	eprint(" | ")

	if error_span.start <= line_span.start and error_span.end > line_span.start {
		eprint("\u001b[31m")
	}

	for index in line_span.start..line_span.end {
		if (index == error_span.start) {
			eprint("\u001b[31m")
		}
		if (index == error_span.end) {
			eprint("\u001b[0m")
		}

		eprint("{:c}", file.source[index])
	}

	eprintln("\u001b[0m")
}

fn setToOrderedList(set: {u64}) throws -> [u64] {
	mut result: [u64] = []

	for v in set {
		mut inserted = false
		for i in 0..result.size() {
			if result[i] > v {
				result.insert(before_index: i, value: v)
				inserted = true
				break
			}
		}

		if not inserted {
			result.push(v)
		}
	}

	return result
}

fn join(anon args: [String], separator: String) throws -> String {
	mut result = ""
	for i in 0..args.size() {
		if i != 0 {
			result += separator
		}
		result += args[i]
	}
	return result
}

fn null<T>() -> raw T {
	unsafe {
		cpp {
			"return nullptr;"
		}
	}
	abort()
}

fn allocate<T>(count: usize) -> raw T {
	let alloc_impl = fn[count](anon ptr: &mut raw T) -> void {
		unsafe {
			cpp {
				"ptr = static_cast<RemoveReference<decltype(ptr)>>(calloc(count, sizeof(*ptr)));"
			}
		}
	}

	mut ptr = null<T>()
	alloc_impl(&mut ptr)
	return ptr
}
