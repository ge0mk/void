import utility { Span, cloneList, printError, panic }
import ast

enum Type {
	id: u64

	Base
	ConstRef
	VarRef

	fn equals(this, other: Type) -> bool {
		return this.id == other.id and match this {
			Base => other is Base
			ConstRef => other is ConstRef
			VarRef => other is VarRef
		}
	}

	fn base(this) => Type::Base(id: .id)
	fn constRef(this) => Type::ConstRef(id: .id)
	fn varRef(this) => Type::VarRef(id: .id)

	fn hasSameKind(this, other: Type) -> bool => match this {
		Base => other is Base
		ConstRef => other is ConstRef
		VarRef => other is VarRef
	}

	fn withId(this, other: Type) -> Type => match this {
		Base => Type::Base(id: other.id)
		ConstRef => Type::ConstRef(id: other.id)
		VarRef => Type::VarRef(id: other.id)
	}
}

struct Function {
	id: u64
}

struct Variable {
	id: u64
}

class Program {
	public modules: [Module]
	public types: [TypeDecl]
	public functions: [FunctionDecl]

	public root_module: Module? = None
	public main: Function? = None

	public void_type: Type = Type::Base(id: 0)
	public never_type: Type = Type::Base(id: 0)
	public bool_type: Type = Type::Base(id: 0)
	public byte_type: Type = Type::Base(id: 0)
	public int_type: Type = Type::Base(id: 0)
	public uint_type: Type = Type::Base(id: 0)
	public cptr_type: Type = Type::Base(id: 0)
	public vptr_type: Type = Type::Base(id: 0)

	public fn dump(this, indent: String) throws -> String {
		mut result = format("{}program\n", indent)

		for module in .modules {
			result += module.dump(indent: indent + "  ")
		}

		return result
	}

	public fn createModule(mut this, parsed_module: ParsedModule) throws -> Module {
		mut namespaces = parsed_module.name.split(c'/')

		let module = Module(
			id: .modules.size() as! u64,
			name: parsed_module.name,
			parsed_module,
			program: this,
			has_errors: false,
			imports: {},
			types: [],
			functions: []
			unchecked_types: [],
			unchecked_functions: []
			namespaces
		)
		.modules.push(module)
		return module
	}

	public fn containsUncheckedTypes(this) -> bool {
		for module in .modules {
			if not module.unchecked_types.is_empty() {
				return true
			}
		}

		return false
	}

	public fn containsUncheckedFunctions(this) -> bool {
		for module in .modules {
			if not module.unchecked_functions.is_empty() {
				return true
			}
		}

		return false
	}

	public fn hasErrors(this) -> bool {
		for module in .modules {
			if module.has_errors {
				return true
			}
		}

		return false
	}

	public fn isPrimitive(this, anon type: Type) throws -> bool {
		if type is ConstRef or type is VarRef {
			return true
		}

		return match .types[type.id].kind {
			Empty => false
			Unchecked => false
			Struct => false
			Enum => true
			Variant(cases) => false
			Alias(target) => .isPrimitive(target)
			Builtin(builtin) => match builtin {
				Void => true
				Bool => true
				Byte => true
				ISize => true
				USize => true
				SInt => true
				UInt => true
				Float => true
				OpaquePointer => true
				Pointer => true
				Array => false
			}
		}
	}

	public fn getNamespacesForMemberFunction(this, type: Type) throws -> [String] {
		let decl = .types[type.id]

		let type_name = decl.name
		mut namespaces = cloneList<String>(decl.namespaces)

		namespaces.push(type_name + .formatTemplateParameters(decl.template_parameters))
		return namespaces
	}

	public fn formatTemplateParameters(this, anon parameters: [TemplateParameter]) throws -> String {
		if parameters.is_empty() {
			return ""
		}

		mut result = ""
		mut separator = ""

		for param in parameters {
			result += separator + param.name
			separator = ", "

			match param {
				Type(value) => {
					if value.has_value() {
						result += " = " + .formatTypeSignature(type: value!)
					} else {
						result += ": type"
					}
				}
				IntLiteral(value) => {
					if value.has_value() {
						result += " = " + format("{}", value!)
					} else {
						result += ": i64"
					}
				}
			}
		}

		return "!<" + result + ">"
	}

	public fn formatTypeSignature(this, type: Type) throws -> String {
		let decl = .types[type.id]
		let type_name = decl.name
		mut namespaces = ""
		for ns in decl.namespaces {
			namespaces += ns + "::"
		}

		let full_name = namespaces + type_name + .formatTemplateParameters(decl.template_parameters)

		return match type {
			Base => full_name
			ConstRef => "&" + full_name
			VarRef => "&&" + full_name
		}
	}

	public fn formatFunctionParameterTypes(this, param_types: [Type]) throws -> String {
		mut result = "("
		mut separator = ""

		for type in param_types {
			result += separator
			result += .formatTypeSignature(type)
			separator = ", "
		}
		result += ")"

		return result
	}

	public fn formatFunctionSignature(this, func: Function) throws -> String {
		let decl = .functions[func.id]


		let return_type = .formatTypeSignature(type: decl.type.return_type)

		mut namespaces = ""
		for ns in decl.namespaces {
			namespaces += ns + "::"
		}

		let func_name = decl.name
		let full_name = namespaces + func_name + .formatTemplateParameters(decl.template_parameters)
		let param_types = .formatFunctionParameterTypes(param_types: decl.type.param_types)

		return full_name + param_types + " -> " + return_type
	}

	public fn typeContainsOther(this, type: Type, other: Type) throws -> bool {
		let children = .types[type.id].contained_types
		if children.contains(other.id) {
			return true
		}

		for c in children {
			if .typeContainsOther(type: Type::Base(id: c), other) {
				return true
			}
		}

		return false
	}

	public fn getTypeIds(this) throws -> {u64} {
		mut result: {u64} = {}

		for id in 0u64..(.types.size() as! u64) {
			result.add(id)
		}

		return result
	}

	public fn getFunctionIds(this) throws -> [u64] {
		mut result: [u64] = []

		for module in .modules {
			result.push_values(other: &module.functions)
		}

		return result
	}

	public fn isIntType(this, type: Type) throws -> bool => match .types[type.id].kind {
		Enum => true
		Builtin(builtin) => match builtin {
			Bool | Byte
			| ISize | USize
			| SInt | UInt => true
			else => false
		}
		else => false
	}

	public fn isFloatType(this, type: Type) throws -> bool => match .types[type.id].kind {
		Enum => true
		Builtin(builtin) => match builtin {
			Float => true
			else => false
		}
		else => false
	}

	public fn isPtrType(this, type: Type) -> bool => match .types[type.id].kind {
		Builtin(builtin) => match builtin {
			OpaquePointer | Pointer => true
			else => false
		}
		else => false
	}

	public fn isSigned(this, type: Type) -> bool => match .types[type.id].kind {
		Builtin(builtin) => match builtin {
			ISize | SInt | Float => true
			else => false
		}
		else => false
	}

	public fn getEnumCase(this, type: Type, name: String) -> EnumCaseDecl? {
		guard .types[type.id].kind is Enum(cases) else {
			return None
		}

		for c in cases {
			if c.name == name {
				return c
			}
		}

		return None
	}

	public fn getVariantCase(this, type: Type, name: String) -> VariantCaseDecl? {
		guard .types[type.id].kind is Variant(cases) else {
			return None
		}

		for c in cases {
			if c.name == name {
				return c
			}
		}

		return None
	}
}

class Module {
	public id: u64
	public name: String
	public parsed_module: ParsedModule
	public program: weak Program
	public has_errors: bool

	public imports: {u64}
	public types: [u64]
	public functions: [u64]

	public unchecked_types: [u64]
	public unchecked_functions: [u64]

	public namespaces: [String]

	public fn error(mut this, anon message: String, anon span: Span) throws {
		printError(message, span, .parsed_module.file)
		.has_errors = true
	}

	public fn dump(this, indent: String) throws -> String {
		mut result = format("{}module {} - {} ({})\n", indent, .id, .parsed_module.name, .parsed_module.file.path)

		result += format("{}imports: {}\n", indent + "  ", .imports)
		result += format("{}namespaces: {}\n", indent + "  ", .namespaces)

		return result
	}

	public fn createType(mut this, name: String, template_parameters: [TemplateParameter]) throws -> Type {
		let type = TypeDecl(
			id: .program!.types.size() as! u64,
			program: .program,
			module: this,
			name,
			namespaces: .namespaces,
			template_parameters,
			is_packed: false,
			contained_types: {},
			member_functions: [],
			member_variables: [],
			kind: TypeDeclKind::Empty,
			additional_member_functions: [],
			template_instances: []
		)

		.program!.types.push(type)
		.types.push(type.id)
		return Type::Base(id: type.id)
	}

	public fn createBuiltinType(mut this, name: String, base: BuiltinType, template_parameters: [TemplateParameter]) throws -> Type {
		let type = .createType(name, template_parameters)
		.program!.types[type.id].kind = TypeDeclKind::Builtin(
			builtin: base,
		)
		return type
	}

	public fn createFunction(mut this, name: String, template_parameters: [TemplateParameter], parent_type: Type?) throws -> Function {
		let func = FunctionDecl(
			id: .program!.functions.size() as! u64,
			program: .program,
			module: this,
			span: Span::empty(),
			name: name
			namespaces: match parent_type.has_value() {
				true => .program!.getNamespacesForMemberFunction(type: parent_type!)
				else => .namespaces,
			},
			template_parameters,
			parent_type,
			type: FunctionType(param_types: [], return_type: .program!.void_type),
			extern_name: None,
			kind: FunctionDeclKind::Empty,
			template_instances: []
		)

		.program!.functions.push(func)
		.functions.push(func.id)

		if parent_type.has_value() {
			mut parentTypeDecl = .program!.types[parent_type!.id]
			parentTypeDecl.member_functions.push(func.id)
		}

		return Function(id: func.id)
	}

	public fn setFunctionType(mut this, func: Function, type: FunctionType) throws {
		.program!.functions[func.id].type = type
	}

	public fn createFunction(mut this, name: String, template_parameters: [TemplateParameter], parent_type: Type?, type: FunctionType) throws -> Function {
		let func = .createFunction(name, template_parameters, parent_type)
		.setFunctionType(func, type)
		return func
	}

	public fn createBuiltinFunction2(mut this, anon parent_type: Type?, anon name: String, anon param_types: [Type], anon return_type: Type, anon body: InlineBuiltinFunction, template_parameters: [TemplateParameter]) throws -> Function {
		let func = .createFunction(name, template_parameters, parent_type, type: FunctionType(
			param_types,
			return_type,
		))
		.program!.functions[func.id].kind = FunctionDeclKind::InlineBuiltin(body)
		return func
	}

	public fn createBuiltinFunction2(mut this, anon parent_type: Type?, anon name: String, anon param_types: [Type], anon return_type: Type, anon body: BuiltinFunction, template_parameters: [TemplateParameter]) throws -> Function {
		let func = .createFunction(name, template_parameters, parent_type, type: FunctionType(
			param_types,
			return_type,
		))
		.program!.functions[func.id].kind = FunctionDeclKind::Builtin(body)
		return func
	}

	public fn createBuiltinFunction(mut this, anon parent_type: Type?, anon name: String, anon param_types: [Type], anon return_type: Type, anon body: InlineBuiltinFunction, template_parameters: [TemplateParameter]) throws {
		let _ = .createBuiltinFunction2(parent_type, name, param_types, return_type, body, template_parameters)
	}

	public fn createBuiltinFunction(mut this, anon parent_type: Type?, anon name: String, anon param_types: [Type], anon return_type: Type, anon body: BuiltinFunction, template_parameters: [TemplateParameter]) throws {
		let _ = .createBuiltinFunction2(parent_type, name, param_types, return_type, body, template_parameters)
	}

	public fn createBuiltinFunction(mut this, anon parent_type: Type?, anon name: String, anon param_types: [Type], anon return_type: Type, anon body: InlineBuiltinFunction) throws {
		let _ = .createBuiltinFunction2(parent_type, name, param_types, return_type, body, template_parameters: [])
	}

	public fn createBuiltinFunction(mut this, anon parent_type: Type?, anon name: String, anon param_types: [Type], anon return_type: Type, anon body: BuiltinFunction) throws {
		let _ = .createBuiltinFunction2(parent_type, name, param_types, return_type, body, template_parameters: [])
	}

	public fn createExternFunction(mut this, anon parent_type: Type?, anon name: String, anon param_types: [Type], anon return_type: Type, anon extern_name: String) throws {
		let func = .createFunction(name, template_parameters: [], parent_type, type: FunctionType(
			param_types,
			return_type,
		))
		if not extern_name.is_empty() {
			.program!.functions[func.id].extern_name = extern_name
		}
		.program!.functions[func.id].kind = FunctionDeclKind::Extern
	}

	public fn getMatchingTypes(this, namespaces: [String], name: String, template_parameters_to_search: [TemplateParameter]) throws -> [Type] {
		mut matching_types: [Type] = []

		if namespaces.is_empty() {
			for param in template_parameters_to_search {
				if param.name == name and param is Type(value) {
					matching_types.push(value!)
				}
			}
		}

		for id in .types {
			if .program!.types[id].matches(namespaces, name) {
				matching_types.push(Type::Base(id))
			}
		}

		for imported_module in .imports {
			for id in .program!.modules[imported_module].types {
				if .program!.types[id].matches(namespaces, name) {
					matching_types.push(Type::Base(id))
				}
			}
		}

		return matching_types
	}

	public fn getMatchingFunctions(this, namespaces: [String], name: String, parent_type: Type?, is_comparison: bool) throws -> {u64} {
		mut matching_functions: {u64} = {}

		for id in .functions {
			if .program!.functions[id].matches(namespaces, name, is_comparison) {
				matching_functions.add(id)
			}
		}

		for imported_module in .imports {
			for id in .program!.modules[imported_module].functions {
				if .program!.functions[id].matches(namespaces, name, is_comparison) {
					matching_functions.add(id)
				}
			}
		}

		if parent_type.has_value() {
			let type_decl = .program!.types[parent_type!.id]

			for id in type_decl.member_functions {
				if .program!.functions[id].matches(namespaces: [], name, is_comparison) {
					matching_functions.add(id)
				}
			}

			let unwrapped = .program!.types[parent_type!.id].unwrapped
			if unwrapped.has_value() {
				let type_decl = .program!.types[unwrapped!.id]
				for id in type_decl.member_functions {
					if .program!.functions[id].matches(namespaces: [], name, is_comparison) {
						matching_functions.add(id)
					}
				}
			}
		}

		return matching_functions
	}

	public fn existsType(this, namespaces: [String], name: String, span: Span, template_parameters_to_search: [TemplateParameter]) throws -> bool {
		mut matching_types = .getMatchingTypes(namespaces, name, template_parameters_to_search)
		return matching_types.size() > 0
	}

	public fn getTypeDecl(this, name: String, template_parameters: [TemplateParameter]) -> Type? {
		for id in .types {
			if .program!.types[id].isSame(name, template_parameters) {
				return Type::Base(id)
			}
		}

		return None
	}
}

enum TemplateParameter {
	span: Span
	name: String

	Type(value: Type?)
	IntLiteral(value: i64?)

	fn equals(this, anon other: TemplateParameter) -> bool => match this {
		Type(value: thisValue) => {
			if other is Type(value: otherValue) {
				if thisValue.has_value() and otherValue.has_value() {
					return thisValue!.equals(other: otherValue!)
				} else if (not thisValue.has_value()) and (not otherValue.has_value()) {
					return true
				} else {
					return false
				}
			}
			yield false
		}
		IntLiteral(value: thisValue) => {
			if other is IntLiteral(value: otherValue) {
				if thisValue.has_value() and otherValue.has_value() {
					return (thisValue!) == (otherValue!)
				} else if (not thisValue.has_value()) and (not otherValue.has_value()) {
					return true
				} else {
					return false
				}
			}
			yield false
		}
	}

	fn canBeMappedTo(this, anon target: TemplateParameter) -> bool => match target {
		Type(value: targetValue) => {
			if targetValue.has_value() {
				guard this is Type(value) else {
					return false
				}

				return targetValue!.equals(other: value!)
			}
			yield true
		}
		IntLiteral(value: targetValue) => {
			if targetValue.has_value() {
				guard this is IntLiteral(value) else {
					return false
				}

				return targetValue! == value!
			}
			yield true
		}
	}

	fn isSpecified(this) => match this {
		Type(value) => value.has_value()
		IntLiteral(value) => value.has_value()
	}
}

class TypeDecl {
	public id: u64
	public program: weak Program
	public module: weak Module

	public name: String
	public namespaces: [String]
	public template_parameters: [TemplateParameter]
	public is_packed: bool
	public contained_types: {u64}
	public member_functions: [u64]
	public member_variables: [MemberVar]
	public kind: TypeDeclKind
	public additional_member_functions: [ParsedFunctionDecl]
	public template_instances: [Type]
	public unwrapped: Type? = None
	public is_finalized: bool = false

	public fn dump(this, indent: String) throws -> String {
		return format("{}type {} : {} - {}\n", indent, .id, .name)
	}

	public fn isIncompleteTemplate(this) -> bool {
		for param in .template_parameters {
			match param {
				Type(value) => {
					if not value.has_value() {
						return true
					}
				}
				IntLiteral(value) => {
					if not value.has_value() {
						return true
					}
				}
			}
		}
		return false
	}

	public fn matches(this, namespaces: [String], name: String) -> bool {
		if .name != name {
			return false
		}

		if .namespaces.size() < namespaces.size() {
			return false
		}

		for i in 0..namespaces.size() {
			if namespaces[namespaces.size() - i - 1] != .namespaces[.namespaces.size() - i - 1] {
				return false
			}
		}

		return true
	}

	public fn canBeMappedTo(this, anon targetParameters: [TemplateParameter]) -> bool {
		guard .template_parameters.size() == targetParameters.size() else {
			return false
		}

		for i in 0..targetParameters.size() {
			if not targetParameters[i].canBeMappedTo(.template_parameters[i]) {
				return false
			}
		}

		return true
	}

	public fn getMatchingTemplateParameterCount(this, anon targetParameters: [TemplateParameter]) -> u64 {
		guard .template_parameters.size() == targetParameters.size() else {
			return 0
		}

		mut count = 0u64
		for i in 0..targetParameters.size() {
			if targetParameters[i].equals(.template_parameters[i]) {
				count += 1
			}
		}

		return count
	}

	public fn isSame(this, name: String, template_parameters: [TemplateParameter]) -> bool {
		guard .name == name else {
			return false
		}

		guard .template_parameters.size() == template_parameters.size() else {
			return false
		}

		for i in 0..template_parameters.size() {
			if not .template_parameters[i].equals(template_parameters[i]) {
				return false
			}
		}

		return true
	}
}

enum TypeDeclKind {
	Empty
	Builtin(builtin: BuiltinType)
	Struct
	Enum(id_type: Type, cases: [EnumCaseDecl])
	Variant(id_type: Type, cases: [VariantCaseDecl])
	Alias(target: Type)
	Unchecked(ParsedTypeDecl)
}

enum BuiltinType {
	Void
	Bool
	Byte
	ISize
	USize
	SInt(size: u64?)
	UInt(size: u64?)
	Float(size: u64)
	OpaquePointer(is_const: bool)
	Pointer(element_type: Type?, is_const: bool)
	Array(element_type: Type?, size: u64?)
}

class MemberVar {
	public span: Span
	public id: u64
	public name: String
	public type: Type
	public initializer: [Expr]
	public type_default_constructor: Function? = None
	public type_copy_constructor: Function? = None
	public type_destructor: Function? = None
	public type_op_assign: Function? = None
	public type_op_equal: Function? = None
	public type_op_unwrap: Function? = None
}

class EnumCaseDecl {
	public span: Span
	public id: i64
	public name: String
}

class VariantCaseDecl {
	public span: Span
	public id: i64
	public name: String
	public type: Type
	public type_copy_constructor: Function? = None
	public type_destructor: Function? = None
	public type_op_equal: Function? = None
	public type_op_unwrap: Function? = None
}

class FunctionDecl {
	public id: u64
	public program: weak Program
	public module: weak Module

	public span: Span
	public name: String
	public namespaces: [String]
	public template_parameters: [TemplateParameter]
	public parent_type: Type?
	public type: FunctionType
	public extern_name: String?
	public kind: FunctionDeclKind
	public template_instances: [Function]

	public fn dump(this, indent: String) throws -> String {
		return format("{}func {} : {}\n", indent, .id, .type)
	}

	public fn isIncompleteTemplate(this) -> bool {
		for param in .template_parameters {
			match param {
				Type(value) => {
					if not value.has_value() {
						return true
					}
				}
				IntLiteral(value) => {
					if not value.has_value() {
						return true
					}
				}
			}
		}

		if .parent_type.has_value() {
			return .module!.program!.types[.parent_type!.id].isIncompleteTemplate()
		} else {
			return false
		}
	}

	public fn matches(this, namespaces: [String], name: String, is_comparison: bool) throws -> bool {
		if namespaces.is_empty() and is_comparison {
			if .name == "operator <=>" {
				return true
			} else if name == "operator ==" and .name == "operator !=" {
				return true
			} else if name == "operator !=" and .name == "operator ==" {
				return true
			}
		}

		if .name != name {
			return false
		}

		if .namespaces.size() < namespaces.size() {
			return false
		}

		for i in 0..namespaces.size() {
			if namespaces[namespaces.size() - i - 1] != .namespaces[.namespaces.size() - i - 1] {
				return false
			}
		}

		return true
	}

	public fn canBeMappedTo(this, anon targetParameters: [TemplateParameter]) -> bool {
		guard .template_parameters.size() == targetParameters.size() else {
			return false
		}

		for i in 0..targetParameters.size() {
			if not targetParameters[i].canBeMappedTo(.template_parameters[i]) {
				return false
			}
		}

		return true
	}

	public fn getMatchingTemplateParameterCount(this, anon targetParameters: [TemplateParameter]) -> u64 {
		guard .template_parameters.size() == targetParameters.size() else {
			return 0
		}

		mut count = 0u64
		for i in 0..targetParameters.size() {
			if targetParameters[i].equals(.template_parameters[i]) {
				count += 1
			}
		}

		return count
	}

	public fn getSpecialzedTemplateParameterCount(this) -> u64 {
		mut count: u64 = 0

		for param in .template_parameters {
			if param.isSpecified() {
				count++
			}
		}

		return count
	}

	public fn getSiblingIds(this) throws -> [u64] {
		mut siblings: [u64] = []

		for id in match .parent_type.has_value() {
			true => .program!.types[.parent_type!.id].member_functions
			false => .module!.functions
		} {
			if id != .id {
				siblings.push(id)
			}
		}

		return siblings
	}
}

struct FunctionType {
	param_types: [Type]
	return_type: Type
}

enum FunctionDeclKind {
	Empty
	Extern
	InlineBuiltin(InlineBuiltinFunction)
	Builtin(BuiltinFunction)
	Code(FunctionDeclBody)
	Unchecked(ParsedFunctionDecl)
}

class FunctionDeclBody {
	public span: Span
	public variables: [VarDecl]
	public body: CompoundStmt

	public fn createParameter(mut this, span: Span, name: String, type: Type, init: Expr?) throws -> Variable {
		mut var = VarDecl(
			span,
			id: .variables.size() as! u64,
			is_const: not type is VarRef, is_param: true,
			name, type, init,
			unused: false
		)

		.variables.push(var)
		return Variable(id: var.id)
	}

	public fn createVariable(mut this, span: Span, is_const: bool, name: String, type: Type, init: Expr?) throws -> Variable {
		mut var = VarDecl(
			span,
			id: .variables.size() as! u64,
			is_const, is_param: false,
			name, type, init,
			unused: false
		)

		.variables.push(var)
		return Variable(id: var.id)
	}
}

enum InlineBuiltinFunction {
	PrimitiveNullConstructor(Type)
	PrimitiveCopyConstructor(Type)
	PrimitiveOpAssign(Type)
	PrimitiveDestructor

	BitOpEQ(Type)
	BitOpNE(Type)

	BitOpAnd(Type)
	BitOpOr(Type)
	BitOpXOr(Type)
	BitOpNot(Type)
	BitOpShl(Type)
	BitOpLShr(Type)
	BitOpAShr(Type)
	BitOpAndAssign(Type)
	BitOpOrAssign(Type)
	BitOpXOrAssign(Type)
	BitOpShlAssign(Type)
	BitOpLShrAssign(Type)
	BitOpAShrAssign(Type)

	SIntOpEQ(Type)
	SIntOpNE(Type)
	SIntOpLT(Type)
	SIntOpLE(Type)
	SIntOpGT(Type)
	SIntOpGE(Type)
	SIntOpCmp(Type)

	SIntOpAdd(Type)
	SIntOpSub(Type)
	SIntOpMul(Type)
	SIntOpDiv(Type)
	SIntOpMod(Type)
	SIntOpNeg(Type)
	SIntOpInc(Type)
	SIntOpDec(Type)

	SIntOpAddAssign(Type)
	SIntOpSubAssign(Type)
	SIntOpMulAssign(Type)
	SIntOpDivAssign(Type)
	SIntOpModAssign(Type)

	UIntOpEQ(Type)
	UIntOpNE(Type)
	UIntOpLT(Type)
	UIntOpLE(Type)
	UIntOpGT(Type)
	UIntOpGE(Type)
	UIntOpCmp(Type)

	UIntOpAdd(Type)
	UIntOpSub(Type)
	UIntOpMul(Type)
	UIntOpDiv(Type)
	UIntOpMod(Type)
	UIntOpInc(Type)
	UIntOpDec(Type)

	UIntOpAddAssign(Type)
	UIntOpSubAssign(Type)
	UIntOpMulAssign(Type)
	UIntOpDivAssign(Type)
	UIntOpModAssign(Type)

	FloatOpEQ(Type)
	FloatOpNE(Type)
	FloatOpLT(Type)
	FloatOpLE(Type)
	FloatOpGT(Type)
	FloatOpGE(Type)
	FloatOpCmp(Type)

	FloatOpAdd(Type)
	FloatOpSub(Type)
	FloatOpMul(Type)
	FloatOpDiv(Type)
	FloatOpMod(Type)
	FloatOpNeg(Type)

	FloatOpAddAssign(Type)
	FloatOpSubAssign(Type)
	FloatOpMulAssign(Type)
	FloatOpDivAssign(Type)
	FloatOpModAssign(Type)

	PointerOpEQ
	PointerOpNE
	PointerOpLT
	PointerOpLE
	PointerOpGT
	PointerOpGE
	PointerOpCmp

	PointerGetNull
	PointerToRef
	RefToPointer
	PointerCast
	PointerDiff(element_type: Type)
	PointerOffset(element_type: Type)
	PointerOpIndex(element_type: Type)

	IntCast(target: Type?, source: Type?)
	FloatCast(target: Type?, source: Type?)
	IntToFloat(target: Type?, source: Type?)
	FloatToInt(target: Type?, source: Type?)

	SizeOf(Type?)
	AlignmentOf(Type?)
	ReferenceKindOf(Type?)

	Memset(Type?)
	Memcpy(Type?)
	Memmove(Type?)

	VariantOpIs(type: Type, id: i64)
	VariantOpUnsafeAs(type: Type, id: i64)

	ArrayGetSize(instance: Type, element_type: Type, size: u64)
	ArrayGetDataPointer(instance: Type, element_type: Type, size: u64)
}

enum BuiltinFunction {
	StructDefaultConstructor(type: Type)
	StructCopyConstructor(type: Type)
	StructDestructor(type: Type)
	StructOpAssign(type: Type)
	StructOpEqual(type: Type)

	VariantCaseConstructor(type: Type, id: i64)
	VariantCopyConstructor(type: Type)
	VariantOpAssign(type: Type)
	VariantDestructor(type: Type)
	VariantOpSafeAs(type: Type, id: i64, optional_type: Type, some_constructor: Function, none_constructor: Function)
	VariantOpEqual(type: Type)

	ArrayDefaultConstructor(instance: Type, element_type: Type, size: u64, element_default_constructor: Function)
	ArrayCopyConstructor(instance: Type, element_type: Type, size: u64, element_copy_constructor: Function)
	ArrayValueConstructor(instance: Type, element_type: Type, size: u64, element_copy_constructor: Function)
	ArrayOpAssign(instance: Type, element_type: Type, size: u64, element_op_assign: Function)
	ArrayDestructor(instance: Type, element_type: Type, size: u64, element_destructor: Function)
}

class VarDecl {
	public span: Span
	public id: u64
	public is_const: bool
	public is_param: bool
	public name: String
	public type: Type
	public init: Expr? = None
	public unused: bool = false
	public constructor_call: Expr? = None
	public destructor_call: Expr? = None
}

class CompoundStmt {
	public span: Span
	public children: [Stmt]
	public cleanup_list: [Expr]

	public fn containsGarbage(this) -> bool {
		for child in .children {
			if child.containsGarbage() {
				return true
			}
		}

		return false
	}

	public fn doesReturn(this, never_type: Type) -> bool {
		for child in .children {
			if child.doesReturn(never_type) {
				return true
			}
		}

		return false
	}

	public fn isTerminator(this, never_type: Type) -> bool {
		for child in .children {
			if child.isTerminator(never_type) {
				return true
			}
		}

		return false
	}
}

boxed enum Stmt {
	span: Span

	Empty
	Compound(CompoundStmt)
	VarDecl(var: Variable)
	If(condition: Expr, then_branch: CompoundStmt, else_branch: Stmt?)
	IfVar(temp_var: Expr, has_value_call: Expr, body: CompoundStmt, var: Variable)
	VarElse(temp_var: Expr, has_value_call: Expr, error_var: Variable?, body: CompoundStmt, ok_var: Variable)
	While(condition: Expr, body: CompoundStmt, continue_expr: Expr?)
	DoWhile(body: CompoundStmt, condition: Expr)
	Match(value: Expr, cases: [CaseStmt], else_branch: Stmt?, is_complete: bool)
	Continue(cleanup_list: [Expr])
	Break(cleanup_list: [Expr])
	Return(value: Expr?, cleanup_list: [Expr])
	Discard(Expr)
	Expr(Expr)
	Garbage

	fn containsGarbage(this) -> bool {
		return match this {
			Empty => false
			Compound(c) => c.containsGarbage()
			VarDecl => false
			If(condition, then_branch, else_branch) => {
				mut result = condition.containsGarbage()
				result |= then_branch.containsGarbage()
				if else_branch.has_value() {
					result |= else_branch!.containsGarbage()
				}
				yield result
			}
			IfVar(temp_var, has_value_call, body) => {
				mut result = temp_var.containsGarbage()
				result |= has_value_call.containsGarbage()
				result |= body.containsGarbage()
				yield result
			}
			VarElse(temp_var, has_value_call, body) => {
				mut result = temp_var.containsGarbage()
				result |= has_value_call.containsGarbage()
				result |= body.containsGarbage()
				yield result
			}
			While(condition, body, continue_expr) => {
				mut result = condition.containsGarbage() or body.containsGarbage()
				if continue_expr.has_value() {
					result |= continue_expr!.containsGarbage()
				}
				yield result
			}
			DoWhile(condition, body) => condition.containsGarbage() or body.containsGarbage()
			Match(value, cases, else_branch) => {
				mut result = value.containsGarbage()
				for c in cases {
					result |= c.containsGarbage()
				}
				if else_branch.has_value() {
					result |= else_branch!.containsGarbage()
				}
				yield result
			}
			Break => false
			Continue => false
			Return(value) => {
				mut result = false
				if value.has_value() {
					result |= value!.containsGarbage()
				}
				return result
			}
			Discard(value) => value.containsGarbage()
			Expr(expr) => expr.containsGarbage()
			Garbage => true
		}
	}

	fn doesReturn(this, never_type: Type) -> bool => match this {
		Compound(compoundStmt) => compoundStmt.doesReturn(never_type)
		If(then_branch, else_branch) => {
			yield match else_branch.has_value() {
				true => then_branch.doesReturn(never_type) and else_branch!.doesReturn(never_type)
				else => false
			}
		}
		Match(cases, else_branch, is_complete) => {
			for c in cases {
				if not c.doesReturn(never_type) {
					return false
				}
			}

			if else_branch.has_value() {
				return else_branch!.doesReturn(never_type)
			} else {
				return is_complete
			}
		}
		While => false
		DoWhile(body) => body.doesReturn(never_type)
		Continue => false
		Break => false
		Return => true
		Expr(value) => value.type.id == never_type.id
		else => false
	}

	fn isTerminator(this, never_type: Type) -> bool => match this {
		Compound(compoundStmt) => compoundStmt.isTerminator(never_type)
		If(then_branch, else_branch) => {
			yield match else_branch.has_value() {
				true => then_branch.isTerminator(never_type) and else_branch!.isTerminator(never_type)
				else => false
			}
		}
		Match(cases, else_branch, is_complete) => {
			for c in cases {
				if not c.isTerminator(never_type) {
					return false
				}
			}

			if else_branch.has_value() {
				return else_branch!.isTerminator(never_type)
			} else {
				return is_complete
			}
		}
		While => false
		DoWhile(body) => body.isTerminator(never_type)
		Continue => true
		Break => true
		Return => true
		Expr(value) => value.type.id == never_type.id
		else => false
	}
}

struct CaseStmt {
	span: Span
	patterns: [Expr]
	body: Stmt

	fn containsGarbage(this) -> bool {
		for pattern in .patterns {
			if pattern.containsGarbage() {
				return true
			}
		}
		return .body.containsGarbage()
	}

	fn doesReturn(this, never_type) -> bool {
		return .body.doesReturn(never_type)
	}

	fn isTerminator(this, never_type: Type) -> bool {
		return .body.isTerminator(never_type)
	}
}

enum ValidationKind {
	Try
	Must
}

boxed enum Expr {
	span: Span
	type: Type

	IntLiteral(value: i64, isSigned: bool)
	FloatLiteral(value: f64)
	StringLiteral(value: String)
	ArrayLiteral(values: [Expr])
	Call(func: Function, args: [Expr], cleanup: (Variable, Expr)?)
	MemberAccess(object: Expr, var: Variable)
	Dereference(value: Expr)
	VarInvoke(var: Variable)
	ReferenceVarInit(var: Variable, value: Expr)
	ReferenceVarInvoke(var: Variable)
	ReferenceMemberInit(object: Expr, member: Variable, value: Expr)
	ReferenceMemberInvoke(object: Expr, member: Variable)
	Validate(var: Expr, check_call: Expr, value_call: Expr, error_body: CompoundStmt, kind: ValidationKind)

	// temporary / unnamed variable. destructor is called immediatly after use
	TempVariable(constructor_call: Expr, var: Variable, destructor_call: Expr?)

	// initializes a variable with a fn result directly without calling the copy constructor
	ShallowCopyInit(var: Variable, value: Expr)

	InlineIf(true_value: Expr, condition: Expr, false_value: Expr, result_var: Variable, cleanup_call: Expr)

	Garbage

	fn containsGarbage(this) -> bool => match this {
		IntLiteral => false
		FloatLiteral => false
		StringLiteral => false
		ArrayLiteral(values) => {
			for val in values {
				if val.containsGarbage() {
					return true
				}
			}
			return false
		}
		Call(args) => {
			for arg in args {
				if arg.containsGarbage() {
					return true
				}
			}
			return false
		}
		MemberAccess(object) => object.containsGarbage()
		Dereference(value) => value.containsGarbage()
		VarInvoke => false
		ReferenceVarInit(value) => value.containsGarbage()
		ReferenceVarInvoke => false
		ReferenceMemberInit(object, value) => object.containsGarbage() or value.containsGarbage()
		ReferenceMemberInvoke(object) => object.containsGarbage()
		Validate(var, check_call, value_call, error_body) =>
			var.containsGarbage()
			or check_call.containsGarbage()
			or value_call.containsGarbage()
			or error_body.containsGarbage()
		TempVariable(constructor_call) => constructor_call.containsGarbage()
		ShallowCopyInit(value) => value.containsGarbage()
		InlineIf(true_value, condition, false_value) => true_value.containsGarbage() or condition.containsGarbage() or false_value.containsGarbage()
		Garbage => true
	}

	fn isTemporary(this) -> bool => match this {
		IntLiteral => false
		FloatLiteral => false
		StringLiteral => false
		ArrayLiteral(values) => {
			for val in values {
				if val.isTemporary() {
					return true
				}
			}
			return false
		}
		Call => true
		MemberAccess(object) => object.isTemporary()
		Dereference(value) => value.isTemporary()
		VarInvoke => false
		ReferenceVarInit => false
		ReferenceVarInvoke => false
		ReferenceMemberInit => false
		ReferenceMemberInvoke(object) => object.isTemporary()
		TempVariable(constructor_call) => true
		Validate => true
		ShallowCopyInit(value) => false
		InlineIf => true
		Garbage => false
	}

	fn toBool(this) throws -> bool => match this {
		IntLiteral(value) => match value {
			0 => false
			1 => true
			else => { panic("invalid bool-literal expr") }
		}
		else => { panic("expression can't be converted to bool") }
	}

	fn toInt(this) throws -> i64 => match this {
		IntLiteral(value) => value
		else => { panic("expression can't be converted to int") }
	}
}

fn removeDereference(anon expr: Expr) -> Expr {
	let result = match expr {
		Dereference(value) => value
		else => expr
	}
	return result
}

enum ScopeType {
	Function
	Compound
	Loop
}

struct Scope {
	type: ScopeType
	variables: [Variable]
}

class FunctionContext {
	public decl: FunctionDecl
	public body: FunctionDeclBody
	public return_type: Type
	public scopes: [Scope]
	public template_parameters_to_search: [TemplateParameter]
	public this_parameter_type: Type?
	public is_constructor: bool
	public is_destructor: bool
	public initialized_members: {u64}
	public deinitialized_members: {u64}

	public fn pushScope(mut this, type: ScopeType) throws {
		.scopes.push(Scope(type, variables: []))
	}

	public fn popScope(mut this) throws {
		let _ = .scopes.pop()
	}

	public fn addVariable(mut this, var: Variable) throws {
		.scopes.last()!.variables.push(var)
	}

	public fn findVariable(this, name: String) throws -> Variable? {
		for index in .scopes.size()..0 {
			for var in .scopes[index - 1].variables {
				if .body.variables[var.id].name == name {
					return var
				}
			}
		}

		return None
	}

	public fn isCurrentScopeInsideLoop(this) throws -> bool {
		for index in .scopes.size()..0 {
			if .scopes[index - 1].type is Loop {
				return true
			}
		}

		return false
	}
}
