import std/core;
import std/list;
import std/io;
import std/map;
import std/range;
import std/shared_list;
import std/string;

import std/libc/stdlib;

import error;
import options;
import program;
import span;

struct StackFrame {
	var variables: Map!<SharedHandle!<VarDecl>, Expr>;
	var return_variable: SharedHandle!<VarDecl>;

	func constructor(this: &&StackFrame) -> void = default;
	func constructor(this: &&StackFrame, other: StackFrame) -> void = default;
	func destructor(this: &&StackFrame) -> void = default;

	operator ==(this: StackFrame, other: StackFrame) -> bool = default;
}

enum ControlFlow {
	case Continue;
	case Break;
	case Yield;
	case Return;
}

struct Interpreter {
	var program: &&Program;
	var stack: List!<StackFrame>;

	func constructor(this: &&Interpreter, program: &&Program) -> void {
		this.program := &&program;
	}

	func destructor(this: &&Interpreter) -> void = default;

	func error(this: &Interpreter, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Error, ErrorStage::Interpreter, span));
	}

	func todo(this: &Interpreter, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Todo, ErrorStage::Interpreter, span));
	}

	func pushStackFrame(this: &&Interpreter) -> void {
		this.stack.append(StackFrame());
	}

	func popStackFrame(this: &&Interpreter) -> Expr {
		const last_stack_frame = this.stack.last() else {
			return Expr::Undefined(Span(), Type::unknown());
		}

		this.stack.removeLast();
		return last_stack_frame.variables.get(last_stack_frame.return_variable) ?? Expr::Void(Span(), this.program.void_type);
	}

	func setVariable(this: &&Interpreter, variable: SharedHandle!<VarDecl>, value: &Expr) -> void {
		if variable.is_comptime {
			variable.value = value;
		} else {
			this.stack[this.stack.size() - 1].variables[variable] = value;
		}
	}

	func getVariable(this: &&Interpreter, variable: SharedHandle!<VarDecl>) -> Expr {
		if variable.is_comptime {
			return variable.value;
		} else {
			return this.stack[this.stack.size() - 1].variables[variable];
		}
	}

	func interpret(this: &&Interpreter, stmt: &Stmt) -> Result!<void, ControlFlow> {
		match stmt {
			case Empty -> return Ok;
			case Compound: compound_stmt -> return this.interpret(compound_stmt);
			case Expr: expr -> {
				discard try this.interpret(expr);
				return Ok;
			}
			case If: if_stmt -> {
				const condition = try this.interpret(if_stmt.condition);
				if condition is Undefined {
					return Ok;
				}

				if condition.toBool() {
					return this.interpret(if_stmt.then_branch);
				} else {
					return this.interpret(if_stmt.else_branch);
				}
			}
			case While: while_stmt -> {
				if while_stmt.kind == While {
					var condition = try this.interpret(while_stmt.condition);

					while condition.toBool() {
						if const control_flow = this.interpret(while_stmt.body) as Error {
							match control_flow {
								case Break -> break;
								case Continue -> {}
								else -> throw control_flow;
							}
						}

						condition = try this.interpret(while_stmt.condition);
					}
				} else if while_stmt.kind == DoWhile {
					var condition = Expr::Undefined(Span(), Type::unknown());

					do {
						if const control_flow = this.interpret(while_stmt.body) as Error {
							match control_flow {
								case Break -> break;
								case Continue -> {}
								else -> throw control_flow;
							}
						}

						condition = try this.interpret(while_stmt.condition);
					} while condition.toBool();
				}

				return Ok;
			}
			case Case | ElseCase -> panic("case stmts should be handled by interpret(Expr)");
			case Break -> throw ControlFlow::Break;
			case Continue -> throw ControlFlow::Continue;
			case Yield -> throw ControlFlow::Yield;
			case Return: value -> {
				this.setVariable(this.stack[this.stack.size() - 1].return_variable, try this.interpret(value));
				throw ControlFlow::Return;
			}
			case LifeTimeStart: variable -> {
				discard try this.interpret(variable.constructor_call);
				return Ok;
			}
			case LifeTimeEnd: variable -> {
				discard try this.interpret(variable.destructor_call);
				return Ok;
			}
		}
	}

	func interpret(this: &&Interpreter, stmt: &CompoundStmt) -> Result!<void, ControlFlow> {
		for child in stmt.children {
			try this.interpret(child);
		}

		return Ok;
	}

	func interpret(this: &&Interpreter, expr: &Expr) -> Result!<Expr, ControlFlow> {
		var result = Expr::Undefined(expr.span, Type::unknown());

		match expr {
			case Undefined | Void | Integer | Float | String | ConstAggregate | VarInvoke | TypeRef | FunctionRef -> return Ok(expr);
			case Call: call -> {
				var parameters: List!<Expr>;
				var has_errors = false;
				for param in call.parameters {
					const value = try this.interpret(param);
					if value is Undefined {
						has_errors = true;
					}
					parameters.append(value);
				}

				if !has_errors {
					result = this.interpret(call.function, parameters, expr.span);
				}
			}
			case Dereference: base -> match try this.interpret(base) {
				case VarInvoke: variable -> result = this.getVariable(variable);
				else -> {}
			}
			else -> {}
		}

		if result is Undefined {
			result = this.compileAndRun(expr, List!<Stmt>());
		}

		return Ok(result);
	}

	func interpret(this: &&Interpreter, function: SharedHandle!<FunctionDecl>, args: &List!<Expr>, error_span: Span) -> Expr {
		match function.body {
			case Extern -> {
				this.todo("interpret calls to extern functions", error_span);
				return Expr::Undefined(Span(), Type::unknown());
			}
			case Builtin: builtin_funcion -> return this.interpret(builtin_funcion, function.return_type, args, error_span);
			case Stmt: stmt -> {
				this.pushStackFrame();

				for i in 0u..args.size() {
					this.setVariable(function.variables[i], args[i]);
				}

				discard this.interpret(stmt);

				return this.popStackFrame();
			}
			else -> {
				this.error("function can't be interpreted: " + function.signature(), error_span);
				return Expr::Undefined(Span(), Type::unknown());
			}
		}
	}

	func interpret(this: &&Interpreter, function: BuiltinFunction, return_type: Type, args: &List!<Expr>, span: Span) -> Expr {
		match function {
			case PrimitiveOp: op -> return this.interpret(op, function.base_type, args, span);
			// casts
			case IntCast: target_type -> return Expr::Integer(args[0u].toInt(), span, target_type);
			case FloatCast: target_type -> return Expr::Float(args[0u].toFloat(), span, target_type);
			case IntToFloat: target_type -> return Expr::Float(args[0u].toInt() as f64, span, target_type);
			case FloatToInt: target_type -> return Expr::Integer(args[0u].toFloat() as int, span, target_type);
			// reflection functions
			case ReferenceKindOf -> return Expr::Integer(function.base_type.reference_kind as int, span, return_type);
			else -> {
				this.todo("finish interpretation of builtin functions", span);
				return Expr::Undefined(Span(), Type::unknown());
			}
		}
	}

	func interpret(this: &&Interpreter, op: PrimitiveOp, type: Type, args: &List!<Expr>, span: Span) -> Expr {
		var lhs = args[0u];
		if op.isAssignment() && op.getOp() > Copy {
			const variable = args[0u] as VarInvoke else {
				return Expr::Undefined(span, Type::unknown());
			}

			lhs = this.getVariable(variable);
		}

		const lhs_int = lhs.toInt();
		const lhs_uint = lhs.toUInt();
		const lhs_float = lhs.toFloat();

		const rhs = args.at(1u) ?? Expr::Undefined(span, Type::unknown());

		const rhs_int = rhs.toInt();
		const rhs_uint = rhs.toUInt();
		const rhs_float = rhs.toFloat();

		const result = match op.getOp() {
			case NoOp -> yield Expr::Undefined(span, Type::unknown());
			case ConstNull -> {
				if type.decl.body is Float {
					yield Expr::Float(0.0, span, type);
				} else {
					yield Expr::Integer(0, span, type);
				}
			}
			case Copy -> yield rhs;
			case BitwiseEQ -> yield Expr::Integer((lhs_int == rhs_int) as int, span, this.program.bool_type);
			case BitwiseNE -> yield Expr::Integer((lhs_int != rhs_int) as int, span, this.program.bool_type);
			case BitwiseAnd -> yield Expr::Integer(lhs_int & rhs_int, span, type);
			case BitwiseOr -> yield Expr::Integer(lhs_int | rhs_int, span, type);
			case BitwiseXOr -> yield Expr::Integer(lhs_int ^ rhs_int, span, type);
			case BitwiseNot -> yield Expr::Integer(~lhs_int, span, type);
			case BitwiseShl -> yield Expr::Integer(lhs_int << rhs_int, span, type);
			case BitwiseLShr -> yield Expr::Integer((lhs_uint >> rhs_uint) as int, span, type);
			case BitwiseAShr -> yield Expr::Integer(lhs_int >> rhs_int, span, type);
			case IntAdd -> yield Expr::Integer(lhs_int + rhs_int, span, type);
			case IntSub -> yield Expr::Integer(lhs_int - rhs_int, span, type);
			case IntMul -> yield Expr::Integer(lhs_int * rhs_int, span, type);
			case IntNeg -> yield Expr::Integer(-lhs_int, span, type);
			case IntInc -> yield Expr::Integer(lhs_int + 1, span, type);
			case IntDec -> yield Expr::Integer(lhs_int - 1, span, type);
			case SIntLT -> yield Expr::Integer((lhs_int < rhs_int) as int, span, this.program.bool_type);
			case SIntLE -> yield Expr::Integer((lhs_int <= rhs_int) as int, span, this.program.bool_type);
			case SIntGT -> yield Expr::Integer((lhs_int > rhs_int) as int, span, this.program.bool_type);
			case SIntGE -> yield Expr::Integer((lhs_int >= rhs_int) as int, span, this.program.bool_type);
			case SIntCmp -> yield Expr::Integer(lhs_int <=> rhs_int, span, this.program.int_type);
			case SIntDiv -> yield Expr::Integer(lhs_int / rhs_int, span, type);
			case SIntMod -> yield Expr::Integer(lhs_int % rhs_int, span, type);
			case UIntLT -> yield Expr::Integer((lhs_uint < rhs_uint) as int, span, this.program.bool_type);
			case UIntLE -> yield Expr::Integer((lhs_uint <= rhs_uint) as int, span, this.program.bool_type);
			case UIntGT -> yield Expr::Integer((lhs_uint > rhs_uint) as int, span, this.program.bool_type);
			case UIntGE -> yield Expr::Integer((lhs_uint >= rhs_uint) as int, span, this.program.bool_type);
			case UIntCmp -> yield Expr::Integer(lhs_uint <=> rhs_uint, span, this.program.int_type);
			case UIntDiv -> yield Expr::Integer((lhs_uint / rhs_uint) as int, span, type);
			case UIntMod -> yield Expr::Integer((lhs_uint % rhs_uint) as int, span, type);
			case FloatEQ -> yield Expr::Integer((lhs_float == rhs_float) as int, span, this.program.bool_type);
			case FloatNE -> yield Expr::Integer((lhs_float != rhs_float) as int, span, this.program.bool_type);
			case FloatLT -> yield Expr::Integer((lhs_float < rhs_float) as int, span, this.program.bool_type);
			case FloatLE -> yield Expr::Integer((lhs_float <= rhs_float) as int, span, this.program.bool_type);
			case FloatGT -> yield Expr::Integer((lhs_float > rhs_float) as int, span, this.program.bool_type);
			case FloatGE -> yield Expr::Integer((lhs_float >= rhs_float) as int, span, this.program.bool_type);
			case FloatCmp -> yield Expr::Integer(lhs_float <=> rhs_float, span, this.program.int_type);
			case FloatAdd -> yield Expr::Float(lhs_float + rhs_float, span, type);
			case FloatSub -> yield Expr::Float(lhs_float - rhs_float, span, type);
			case FloatMul -> yield Expr::Float(lhs_float * rhs_float, span, type);
			case FloatDiv -> yield Expr::Float(lhs_float / rhs_float, span, type);
			case FloatMod -> yield Expr::Float(lhs_float % rhs_float, span, type);
			case FloatNeg -> yield Expr::Float(-lhs_float, span, type)
			case Assign -> yield Expr::Undefined(span, Type::unknown());
		}

		if op.isAssignment() {
			const variable = args[0u] as VarInvoke else {
				return Expr::Undefined(span, Type::unknown());
			}
			this.setVariable(variable, result);

			return Expr::Void(Span(), this.program.void_type);
		} else {
			return result;
		}
	}

	func compileAndRun(this: &&Interpreter, expr: &Expr, cleanup: &List!<Stmt>) -> Expr {
		var result = Expr::Undefined(expr.span, expr.type);

		this.todo("finish interpretation of expressions using llvm", expr.span);

		return result;
	}
}
