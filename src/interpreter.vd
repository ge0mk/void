import std/core;
import std/list;
import std/io;
import std/map;
import std/range;
import std/shared_list;
import std/string;

import std/libc/stdlib;

import error;
import options;
import program;
import span;

struct StackFrame {
	var variables: Map!<SharedHandle!<VarDecl>, Expr>;
	var return_variable: SharedHandle!<VarDecl>;

	func constructor(this: &&StackFrame) -> void = default;
	func constructor(this: &&StackFrame, other: StackFrame) -> void = default;
	func destructor(this: &&StackFrame) -> void = default;

	operator ==(this: StackFrame, other: StackFrame) -> bool = default;
}

enum ControlFlow {
	case Continue;
	case Break;
	case Yield;
	case Return;
}

struct Interpreter {
	var program: &&Program;
	var stack: List!<StackFrame>;

	func constructor(this: &&Interpreter, program: &&Program) -> void {
		this.program := &&program;
	}

	func destructor(this: &&Interpreter) -> void = default;

	func error(this: &Interpreter, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Error, ErrorStage::Interpreter, span));
	}

	func todo(this: &Interpreter, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Todo, ErrorStage::Interpreter, span));
	}

	func pushStackFrame(this: &&Interpreter) -> void {
		this.stack.append(StackFrame());
	}

	func popStackFrame(this: &&Interpreter) -> Expr {
		const last_stack_frame = this.stack.last() else {
			return Expr::Undefined(Span(), Type::unknown());
		}

		this.stack.removeLast();
		return last_stack_frame.variables.get(last_stack_frame.return_variable) ?? Expr::Void(Span(), this.program.void_type);
	}

	func setVariable(this: &&Interpreter, variable: SharedHandle!<VarDecl>, value: &Expr) -> void {
		if variable.is_comptime {
			variable.value = value;
		} else {
			this.stack[this.stack.size() - 1].variables[variable] = value;
		}
	}

	func getVariable(this: &&Interpreter, variable: SharedHandle!<VarDecl>) -> Expr {
		if variable.is_comptime {
			return variable.value;
		} else {
			return this.stack[this.stack.size() - 1].variables[variable];
		}
	}

	func interpret(this: &&Interpreter, stmt: &Stmt) -> Result!<void, ControlFlow> {
		match stmt {
			case Empty -> return Ok;
			case Compound: compound_stmt -> return this.interpret(compound_stmt);
			case Expr: expr -> {
				discard try this.interpret(expr);
				return Ok;
			}
			case If: if_stmt -> {
				const condition = try this.interpret(if_stmt.condition);
				if condition is Undefined {
					return Ok;
				}

				if condition.toBool() {
					return this.interpret(if_stmt.then_branch);
				} else {
					return this.interpret(if_stmt.else_branch);
				}
			}
			case While: while_stmt -> {
				if while_stmt.kind == While {
					var condition = try this.interpret(while_stmt.condition);

					while condition.toBool() {
						if const control_flow = this.interpret(while_stmt.body) as Error {
							match control_flow {
								case Break -> break;
								case Continue -> {}
								else -> throw control_flow;
							}
						}

						condition = try this.interpret(while_stmt.condition);
					}
				} else if while_stmt.kind == DoWhile {
					var condition = Expr::Undefined(Span(), Type::unknown());

					do {
						if const control_flow = this.interpret(while_stmt.body) as Error {
							match control_flow {
								case Break -> break;
								case Continue -> {}
								else -> throw control_flow;
							}
						}

						condition = try this.interpret(while_stmt.condition);
					} while condition.toBool();
				}

				return Ok;
			}
			case Case | ElseCase -> panic("case stmts should be handled by interpret(Expr)");
			case Break -> throw ControlFlow::Break;
			case Continue -> throw ControlFlow::Continue;
			case Yield -> throw ControlFlow::Yield;
			case Return: value -> {
				this.setVariable(this.stack[this.stack.size() - 1].return_variable, try this.interpret(value));
				throw ControlFlow::Return;
			}
			case LifeTimeStart: variable -> {
				discard try this.interpret(variable.constructor_call);
				return Ok;
			}
			case LifeTimeEnd: variable -> {
				discard try this.interpret(variable.destructor_call);
				return Ok;
			}
		}
	}

	func interpret(this: &&Interpreter, stmt: &CompoundStmt) -> Result!<void, ControlFlow> {
		for child in stmt.children {
			try this.interpret(child);
		}

		return Ok;
	}

	func interpret(this: &&Interpreter, expr: &Expr) -> Result!<Expr, ControlFlow> {
		var result = Expr::Undefined(expr.span, Type::unknown());

		match expr {
			case Undefined | Void | Integer | Float | String | ConstAggregate | VarInvoke | TypeRef | FunctionRef -> return Ok(expr);
			case Call: call -> {
				var parameters: List!<Expr>;
				var has_errors = false;
				for param in call.parameters {
					const value = try this.interpret(param);
					if value is Undefined {
						has_errors = true;
					}
					parameters.append(value);
				}

				if !has_errors {
					result = this.interpret(call.function, parameters, expr.span);
				}
			}
			case Dereference: base -> match try this.interpret(base) {
				case VarInvoke: variable -> result = this.getVariable(variable);
				else -> {}
			}
			else -> {}
		}

		if result is Undefined {
			result = this.compileAndRun(expr, List!<Stmt>());
		}

		return Ok(result);
	}

	func interpret(this: &&Interpreter, function: SharedHandle!<FunctionDecl>, args: &List!<Expr>, error_span: Span) -> Expr {
		match function.body {
			case Extern -> {
				this.todo("interpret calls to extern functions", error_span);
				return Expr::Undefined(Span(), Type::unknown());
			}
			case InlineBuiltin: builtin_funcion -> return this.interpret(builtin_funcion, function.return_type, args, error_span);
			case Builtin: builtin_funcion -> return this.interpret(builtin_funcion, function.return_type, args, error_span);
			case Stmt: stmt -> {
				this.pushStackFrame();

				for i in 0u..args.size() {
					this.setVariable(function.variables[i], args[i]);
				}

				discard this.interpret(stmt);

				return this.popStackFrame();
			}
			else -> {
				this.error("function can't be interpreted: " + function.signature(), error_span);
				return Expr::Undefined(Span(), Type::unknown());
			}
		}
	}

	func interpret(this: &&Interpreter, function: InlineBuiltinFunction, return_type: Type, args: &List!<Expr>, span: Span) -> Expr {
		match function {
			case NoOp -> {}
			case BitStoreNull -> {
				var variable = args[0u] as VarInvoke else { return Expr::Undefined(span, Type::unknown()); }
				this.setVariable(variable, Expr::Integer(0, span, function.base_type));
			}
			case BitStoreValue -> {
				var variable = args[0u] as VarInvoke else { return Expr::Undefined(span, Type::unknown()); }
				this.setVariable(variable, args[1u]);
			}
			// bitwise comparison
			case BitOpEQ -> return Expr::Integer((args[0u].toUInt() == args[1u].toUInt()) as int, span, return_type);
			case BitOpNE -> return Expr::Integer((args[0u].toUInt() != args[1u].toUInt()) as int, span, return_type);
			// bitwise arithmetic operators
			case BitOpAnd -> return Expr::Integer((args[0u].toUInt() & args[1u].toUInt()) as int, span, function.base_type);
			case BitOpOr -> return Expr::Integer((args[0u].toUInt() | args[1u].toUInt()) as int, span, function.base_type);
			case BitOpXOr -> return Expr::Integer((args[0u].toUInt() ^ args[1u].toUInt()) as int, span, function.base_type);
			case BitOpNot -> return Expr::Integer((~args[0u].toUInt()) as int, span, function.base_type);
			case BitOpShl -> return Expr::Integer((args[0u].toUInt() << args[1u].toUInt()) as int, span, function.base_type);
			case BitOpLShr -> return Expr::Integer((args[0u].toUInt() >> args[1u].toUInt()) as int, span, function.base_type);
			case BitOpAShr -> return Expr::Integer((args[0u].toUInt() >> args[1u].toUInt()) as int, span, function.base_type);
			// bitwise arithmetic assignment operators
			case BitOpAndAssign -> {
				const variable = args[0u] as VarInvoke else { return Expr::Undefined(Span(), Type::unknown()); }
				this.setVariable(variable, Expr::Integer(this.getVariable(variable).toInt() & args[1u].toInt(), span, function.base_type));
			}
			case BitOpOrAssign -> {
				const variable = args[0u] as VarInvoke else { return Expr::Undefined(Span(), Type::unknown()); }
				this.setVariable(variable, Expr::Integer(this.getVariable(variable).toInt() | args[1u].toInt(), span, function.base_type));
			}
			case BitOpXOrAssign -> {
				const variable = args[0u] as VarInvoke else { return Expr::Undefined(Span(), Type::unknown()); }
				this.setVariable(variable, Expr::Integer(this.getVariable(variable).toInt() ^ args[1u].toInt(), span, function.base_type));
			}
			case BitOpShlAssign -> {
				const variable = args[0u] as VarInvoke else { return Expr::Undefined(Span(), Type::unknown()); }
				this.setVariable(variable, Expr::Integer(this.getVariable(variable).toInt() << args[1u].toInt(), span, function.base_type));
			}
			case BitOpLShrAssign -> {
				const variable = args[0u] as VarInvoke else { return Expr::Undefined(Span(), Type::unknown()); }
				this.setVariable(variable, Expr::Integer((this.getVariable(variable).toUInt() >> args[1u].toUInt()) as int, span, function.base_type));
			}
			case BitOpAShrAssign -> {
				const variable = args[0u] as VarInvoke else { return Expr::Undefined(Span(), Type::unknown()); }
				this.setVariable(variable, Expr::Integer(this.getVariable(variable).toInt() >> args[1u].toInt(), span, function.base_type));
			}
			// sign-independent integer arithmetic operators
			case IntOpAdd -> return Expr::Integer(args[0u].toInt() + args[1u].toInt(), span, return_type);
			case IntOpSub -> return Expr::Integer(args[0u].toInt() - args[1u].toInt(), span, return_type);
			case IntOpMul -> return Expr::Integer(args[0u].toInt() * args[1u].toInt(), span, return_type);
			case IntOpNeg -> return Expr::Integer(-args[0u].toInt(), span, return_type);
			// sign-independent integer arithmetic assignment operators
			case IntOpInc -> {
				const variable = args[0u] as VarInvoke else { return Expr::Undefined(span, Type::unknown()); }
				this.setVariable(variable, Expr::Integer(this.getVariable(variable).toInt() + 1, span, function.base_type));
			}
			case IntOpDec -> {
				const variable = args[0u] as VarInvoke else { return Expr::Undefined(span, Type::unknown()); }
				this.setVariable(variable, Expr::Integer(this.getVariable(variable).toInt() - 1, span, function.base_type));
			}
			case IntOpAddAssign -> {
				const variable = args[0u] as VarInvoke else { return Expr::Undefined(span, Type::unknown()); }
				this.setVariable(variable, Expr::Integer(this.getVariable(variable).toInt() + args[1u].toInt(), span, function.base_type));
			}
			case IntOpSubAssign -> {
				const variable = args[0u] as VarInvoke else { return Expr::Undefined(span, Type::unknown()); }
				this.setVariable(variable, Expr::Integer(this.getVariable(variable).toInt() - args[1u].toInt(), span, function.base_type));
			}
			case IntOpMulAssign -> {
				const variable = args[0u] as VarInvoke else { return Expr::Undefined(span, Type::unknown()); }
				this.setVariable(variable, Expr::Integer(this.getVariable(variable).toInt() * args[1u].toInt(), span, function.base_type));
			}
			// signed int comparison
			case SIntOpLT -> return Expr::Integer((args[0u].toInt() < args[1u].toInt()) as int, span, return_type);
			case SIntOpLE -> return Expr::Integer((args[0u].toInt() <= args[1u].toInt()) as int, span, return_type);
			case SIntOpGT -> return Expr::Integer((args[0u].toInt() > args[1u].toInt()) as int, span, return_type);
			case SIntOpGE -> return Expr::Integer((args[0u].toInt() >= args[1u].toInt()) as int, span, return_type);
			// signed int arithmetic operators
			case SIntOpDiv -> return Expr::Integer(args[0u].toInt() / args[1u].toInt(), span, return_type);
			case SIntOpMod -> return Expr::Integer(args[0u].toInt() % args[1u].toInt(), span, return_type);
			// signed int arithmetic assignment operators
			case SIntOpDivAssign -> {
				const variable = args[0u] as VarInvoke else { return Expr::Undefined(span, Type::unknown()); }
				this.setVariable(variable, Expr::Integer(this.getVariable(variable).toInt() / args[1u].toInt(), span, function.base_type));
			}
			case SIntOpModAssign -> {
				const variable = args[0u] as VarInvoke else { return Expr::Undefined(span, Type::unknown()); }
				this.setVariable(variable, Expr::Integer(this.getVariable(variable).toInt() % args[1u].toInt(), span, function.base_type));
			}
			// unsigned int comparison
			case UIntOpLT -> return Expr::Integer((args[0u].toUInt() < args[1u].toUInt()) as int, span, return_type);
			case UIntOpLE -> return Expr::Integer((args[0u].toUInt() <= args[1u].toUInt()) as int, span, return_type);
			case UIntOpGT -> return Expr::Integer((args[0u].toUInt() > args[1u].toUInt()) as int, span, return_type);
			case UIntOpGE -> return Expr::Integer((args[0u].toUInt() >= args[1u].toUInt()) as int, span, return_type);
			// unsigned int arithmetic operators
			case UIntOpDiv -> return Expr::Integer((args[0u].toUInt() / args[1u].toUInt()) as int, span, return_type);
			case UIntOpMod -> return Expr::Integer((args[0u].toUInt() % args[1u].toUInt()) as int, span, return_type);
			// unsigned int arithmetic assignment operators
			case UIntOpDivAssign -> {
				const variable = args[0u] as VarInvoke else { return Expr::Undefined(span, Type::unknown()); }
				this.setVariable(variable, Expr::Integer((this.getVariable(variable).toUInt() / args[1u].toUInt()) as int, span, function.base_type));
			}
			case UIntOpModAssign -> {
				const variable = args[0u] as VarInvoke else { return Expr::Undefined(span, Type::unknown()); }
				this.setVariable(variable, Expr::Integer((this.getVariable(variable).toUInt() % args[1u].toUInt()) as int, span, function.base_type));
			}
			// float comparisons
			case FloatOpEQ -> return Expr::Integer((args[0u].toFloat() == args[1u].toFloat()) as int, span, return_type);
			case FloatOpNE -> return Expr::Integer((args[0u].toFloat() != args[1u].toFloat()) as int, span, return_type);
			case FloatOpLT -> return Expr::Integer((args[0u].toFloat() < args[1u].toFloat()) as int, span, return_type);
			case FloatOpLE -> return Expr::Integer((args[0u].toFloat() <= args[1u].toFloat()) as int, span, return_type);
			case FloatOpGT -> return Expr::Integer((args[0u].toFloat() > args[1u].toFloat()) as int, span, return_type);
			case FloatOpGE -> return Expr::Integer((args[0u].toFloat() >= args[1u].toFloat()) as int, span, return_type);
			case FloatOpCmp -> return Expr::Integer(args[0u].toFloat() <=> args[1u].toFloat(), span, return_type);
			// float arithmetic operators
			case FloatOpAdd -> return Expr::Float(args[0u].toFloat() + args[1u].toFloat(), span, return_type);
			case FloatOpSub -> return Expr::Float(args[0u].toFloat() - args[1u].toFloat(), span, return_type);
			case FloatOpMul -> return Expr::Float(args[0u].toFloat() * args[1u].toFloat(), span, return_type);
			case FloatOpDiv -> return Expr::Float(args[0u].toFloat() / args[1u].toFloat(), span, return_type);
			case FloatOpMod -> return Expr::Float(args[0u].toFloat() % args[1u].toFloat(), span, return_type);
			case FloatOpNeg -> return Expr::Float(-args[0u].toFloat(), span, return_type);
			// float arithmetic assignment operators
			case FloatOpAddAssign -> {
				const variable = args[0u] as VarInvoke else { return Expr::Undefined(span, Type::unknown()); }
				this.setVariable(variable, Expr::Float(this.getVariable(variable).toFloat() + args[1u].toFloat(), span, function.base_type));
			}
			case FloatOpSubAssign -> {
				const variable = args[0u] as VarInvoke else { return Expr::Undefined(span, Type::unknown()); }
				this.setVariable(variable, Expr::Float(this.getVariable(variable).toFloat() - args[1u].toFloat(), span, function.base_type));
			}
			case FloatOpMulAssign -> {
				const variable = args[0u] as VarInvoke else { return Expr::Undefined(span, Type::unknown()); }
				this.setVariable(variable, Expr::Float(this.getVariable(variable).toFloat() * args[1u].toFloat(), span, function.base_type));
			}
			case FloatOpDivAssign -> {
				const variable = args[0u] as VarInvoke else { return Expr::Undefined(span, Type::unknown()); }
				this.setVariable(variable, Expr::Float(this.getVariable(variable).toFloat() / args[1u].toFloat(), span, function.base_type));
			}
			case FloatOpModAssign -> {
				const variable = args[0u] as VarInvoke else { return Expr::Undefined(span, Type::unknown()); }
				this.setVariable(variable, Expr::Float(this.getVariable(variable).toFloat() % args[1u].toFloat(), span, function.base_type));
			}
			// casts
			case IntCast -> return args[0u];
			case FloatCast -> return args[0u];
			case IntToFloat -> return Expr::Float(args[0u].toInt() as f64, span, return_type);
			case FloatToInt -> return Expr::Integer(args[0u].toFloat() as int, span, return_type);
			// reflection functions
			case ReferenceKindOf -> return Expr::Integer(function.base_type.reference_kind as int, span, return_type);
			else -> {
				this.todo("finish interpretation of inline builtin functions", span);
				return Expr::Undefined(Span(), Type::unknown());
			}
		}

		return Expr::Void(Span(), this.program.void_type);
	}

	func interpret(this: &&Interpreter, function: BuiltinFunction, return_type: Type, args: &List!<Expr>, error_span: Span) -> Expr {
		match function {
			else -> {
				this.todo("finish interpretation of builtin functions", error_span);
				return Expr::Undefined(Span(), Type::unknown());
			}
		}
	}

	func compileAndRun(this: &&Interpreter, expr: &Expr, cleanup: &List!<Stmt>) -> Expr {
		var result = Expr::Undefined(expr.span, expr.type);

		this.todo("finish interpretation of expressions using llvm", expr.span);

		return result;
	}
}
