import std/core;
import std/box;
import std/file;
import std/format;
import std/io;
import std/libc/math;
import std/list;
import std/map;
import std/math;
import std/set;
import std/shared_list;
import std/string;

import builtins;
import error;
import interpreter;
import lexer;
import llvm_c;
import llvm_codegen;
import llvm_util;
import operators;
import options;
import parser;
import optimizations;
import program;
import span;

enum CallKind {
	case Static;
	case MemberCall;
	case Operator;
	case TempVar;
}

variant CaseDecl {
	var parent_type: SharedHandle!<TypeDecl>;

	case EnumCase: uint;
	case VariantCase: uint;
}

enum ScopeKind {
	case Function;
	case Compound;
	case Loop;
	case Match;
	case Expr;
}

struct Scope {
	var kind: ScopeKind;
	var variables: List!<SharedHandle!<VarDecl>>;
	var variables_by_name: Map!<String, SharedHandle!<VarDecl>>;
	var cleanup: List!<uint>;

	func constructor(this: &&Scope, kind: ScopeKind) -> void {
		this.kind := kind;
	}

	func constructor(this: &&Scope, other: Scope) -> void = default;
	func destructor(this: &&Scope) -> void = default;

	operator =(this: &&Scope, other: Scope) -> void = default;

	operator ==(this: Scope, other: Scope) -> bool = default;
}

struct TCContext {
	alias PragmaCallback = (&&TCContext, &&Program, SharedHandle!<Namespace>, Span) -> void;

	var program: &&Program;
	var interpreter: Interpreter;
	var cg_context: CGContext;

	var modules_by_import_name: Map!<String, List!<SharedHandle!<Namespace>>>;
	var pragmas: List!<(name: String, callback: PragmaCallback)>;

	var current_target_state: NamespaceState;
	var current_namespace: SharedHandle!<Namespace>;
	var current_function: SharedHandle!<FunctionDecl>;

	var scope_stack: List!<Scope>;
	var current_return_type: Type;
	var active_member_variables: Set!<uint>; // used to track (de-)initialized member variables in con/de-structors
	var return_variable: SharedHandle!<VarDecl>;

	// context for checking match expressions
	var match_value: uint;
	var match_type: Type;
	var yield_type: Type;
	var yield_var: SharedHandle!<VarDecl>;

	func constructor(this: &&TCContext, program: &&Program) -> void {
		this.program := &&program;
		this.interpreter := (&&program);
		this.cg_context := (&&program);
		this.current_target_state := Unchecked;
	}

	func destructor(this: &&TCContext) -> void = default;

	func registerPragma(this: &&TCContext, name: String, callback: PragmaCallback) -> void {
		this.pragmas.append((name: name, callback: callback));
	}

	func error(this: &TCContext, msg: String, span: Span) -> void {
		this.program.printError(CompilationError(msg, ErrorType::Error, ErrorStage::Typechecker, span));

		if this.current_function.isAlive() {
			for p in this.current_function.template_parameters {
				this.info("    with " + p.signature(), Span());
			}
		}

		if this.current_namespace.isAlive() {
			for p in this.current_namespace.template_parameters {
				this.info("    with " + p.signature(), Span());
			}
		}

		if this.current_function.isAlive() {
			this.current_function.has_errors = true;
		} else if this.current_namespace.isAlive() {
			this.current_namespace.has_errors = true;
		}
	}

	func info(this: &TCContext, msg: String, span: Span) -> void {
		this.program.printError(CompilationError(msg, ErrorType::Info, ErrorStage::Typechecker, span));
	}

	func hint(this: &TCContext, msg: String, span: Span) -> void {
		this.program.printError(CompilationError(msg, ErrorType::Hint, ErrorStage::Typechecker, span));
	}

	func todo(this: &TCContext, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Todo, ErrorStage::Typechecker, span));

		if this.current_function.isAlive() {
			this.current_function.has_errors = true;
		} else if this.current_namespace.isAlive() {
			this.current_namespace.has_errors = true;
		}
	}

	func interpret(this: &&TCContext, id: uint) -> Value {
		return this.interpret(this.current_namespace.file.nodes[id]);
	}

	func interpret(this: &&TCContext, stmt_list: &List!<uint>) -> void {
		for id in stmt_list {
			discard this.interpret(this.current_namespace.file.nodes[id]);
		}
	}

	func interpret(this: &&TCContext, node: &Node) -> Value {
		const prev_namespace = this.interpreter.current_namespace;
		this.interpreter.current_namespace = this.current_namespace;
		defer this.interpreter.current_namespace = prev_namespace;

		match this.interpreter.interpret(node) {
			case Ok: value -> return value;
			else -> {
				this.error("unexpected control flow in comptime expression", node.span);
				return Value::Undefined;
			}
		}
	}

	func pushScope(this: &&TCContext, kind: ScopeKind) -> void {
		this.scope_stack.append(Scope(kind));
	}

	func popScope(this: &&TCContext) -> void {
		this.scope_stack.removeLast();
	}

	func getASTNode(this: &TCContext, id: uint) -> &Node {
		return &this.current_namespace.file.getASTNode(id);
	}

	func getEmptyNode(this: &TCContext) -> uint {
		return this.current_namespace.file.getEmptyNode();
	}

	func getGarbageNode(this: &TCContext) -> uint {
		return this.current_namespace.file.getGarbageNode();
	}

	func isASTNodeTerminator(this: &TCContext, id: uint, yield_is_terminator: bool) -> bool {
		return this.current_namespace.file.isTerminator(id, this.program.never_type, yield_is_terminator)
	}

	func getASTNodeSpan(this: &TCContext, id: uint) -> Span {
		return this.current_namespace.file.nodes[id].span;
	}

	func getASTNodeType(this: &TCContext, id: uint) -> Type {
		return this.current_namespace.file.nodes[id].type;
	}

	func removeDereference(this: &&TCContext, id: uint) -> uint {
		return this.current_namespace.file.removeDereference(id);
	}

	func addASTNode(this: &&TCContext, node: &Node) -> uint {
		return this.current_namespace.file.addASTNode(node);
	}

	func setASTNodeType(this: &&TCContext, id: uint, type: Type) -> void {
		this.current_namespace.file.nodes[id].type = type;
	}

	func replaceASTNode(this: &&TCContext, id: uint, new: &Node) -> void {
		this.current_namespace.file.nodes[id] = new;
	}

	func addChildToFrontOfCompoundStmt(this: &&TCContext, id: uint, additional_child: uint) -> void {
		match this.current_namespace.file.nodes[id] {
			case CompoundStmt: &&children -> children.insert(0u, additional_child);
			else -> panic(Error::EINVAL);
		}
	}

	func addChildrenToCompoundStmt(this: &&TCContext, id: uint, additional_children: &List!<uint>) -> void {
		match this.current_namespace.file.nodes[id] {
			case CompoundStmt: &&children -> children.append(additional_children);
			else -> panic(Error::EINVAL);
		}
	}

	func addVariableToCurrentScope(this: &&TCContext, variable: SharedHandle!<VarDecl>) -> void {
		this.scope_stack[this.scope_stack.size() - 1].variables.append(variable);
		this.scope_stack[this.scope_stack.size() - 1].cleanup.insert(0u, this.addASTNode(Node::LifeTimeEnd(variable, Span(), Type::unknown(), false)));

		if variable.name != ""{
			this.scope_stack[this.scope_stack.size() - 1].variables_by_name[variable.name] = variable;
		}
	}

	func isCurrentScopeInsideLoop(this: &TCContext) -> bool {
		for i in 0u..this.scope_stack.size() {
			if this.scope_stack[this.scope_stack.size() - i - 1].kind == Loop {
				return true;
			}
		}

		return false;
	}

	func isCurrentScopeInsideMatch(this: &TCContext) -> bool {
		for i in 0u..this.scope_stack.size() {
			if this.scope_stack[this.scope_stack.size() - i - 1].kind == Match {
				return true;
			}
		}

		return false;
	}

	func getVariableByName(this: &&TCContext, name: String) -> Optional!<SharedHandle!<VarDecl>> {
		for i in 0u..this.scope_stack.size() {
			const tmp = this.scope_stack[this.scope_stack.size() - i - 1].variables_by_name.get(name);
			if tmp is Some {
				return tmp;
			}
		}

		return None;
	}

	func collectCleanupCalls(this: &&TCContext, until: ScopeKind) -> List!<uint> {
		var result: List!<uint>;

		for i in 0u..this.scope_stack.size() {
			result.append(this.scope_stack[this.scope_stack.size() - i - 1].cleanup);
			if this.scope_stack[this.scope_stack.size() - i - 1].kind == until {
				break;
			}
		}

		return result;
	}

	func getCleanupCallsForCurrentScope(this: &&TCContext) -> &List!<uint> {
		return &this.scope_stack[this.scope_stack.size() - 1].cleanup;
	}

	func loadFile(this: &&TCContext, imported_module: ImportedModule) -> Result!<SharedHandle!<CompilationUnit>> {
		var file = try File::open(imported_module.path, OpenMode::read);
		const source = try file.readAll();

		const file_id = this.program.files.size();

		// collect line spans
		var line_spans = List!<Span>();
		var line = 0u;
		var line_start = 0u;

		var index = 0u;
		while index < source.size() {
			if source.at(index) ?? '\0'b == '\n'b {
				const span = Span(line_start, index, line as u32, 0u16, file_id as u16);
				line_spans.append(span);

				line++;
				line_start = index + 1;
			}
			index++;
		}

		const span = Span(line_start, index, line as u32, 0u16, file_id as u16);
		line_spans.append(span);

		var source_file = CompilationUnit(this.program.files.size(), imported_module.group, imported_module.name, imported_module.path, source, line_spans);

		if this.program.options.generate_debug_info {
			var segments = source_file.path.split('/'b);
			const filename = segments.last().value();
			segments.removeLast();
			const directory = "/".join(segments);

			source_file.llvm_di_file = LLVMDIBuilderCreateFile(this.program.di_builder, filename, directory);
			source_file.llvm_di_module = LLVMDIBuilderCreateModule(
				this.program.di_builder,
				this.program.di_compile_unit,
				source_file.name,
				"",		// config macros
				"",		// include path
				"", 	// api notes file
			);
		}

		return Ok(this.program.files.append(source_file));
	}

	func loadModule(this: &&TCContext, imported_module: ImportedModule) -> Result!<SharedHandle!<Namespace>> {
		const file = try this.loadFile(imported_module);
		var module = this.program.createModule(file);

		// lex
		var tokens: List!<Token>;
		var strings: List!<String>;
		var numbers: List!<ParsedNumber>;

		var lexer = Lexer(&&tokens, &&strings, &&numbers, file.source, file.id as u16);
		while !lexer.eof() {
			lexer.next();
		}

		if this.program.options.dump_tokens {
			print(tokens.dump());
		}

		// parse
		var parser = Parser(&&this.program, file, &tokens, &strings, &numbers);
		while !parser.eof() {
			file.top_level_nodes.append(parser.parseStmt(true));
		}

		if this.program.options.dump_ast {
			print(file.dump());
		}

		return Ok(module);
	}

	func checkImport(this: &&TCContext, import_name: String, span: Span) -> void {
		var modules: List!<SharedHandle!<Namespace>>;

		if this.modules_by_import_name.contains(import_name) {
			modules = this.modules_by_import_name[import_name];
		} else {
			const imported_modules = this.program.options.getImportPaths(import_name);
			if imported_modules.isEmpty() {
				this.error("no matching module found", span);
				return;
			}

			for imported_module in imported_modules {
				if const module = this.program.getModule(imported_module.path) {
					modules.append(module);
					continue;
				}

				match this.loadModule(imported_module) {
					case Ok: module -> {
						modules.append(module);
						this.checkTopLevelStatements(module);
						discard this.check(module, NamespaceState::UncheckedFunctionBodies);
					}
					case Error: error -> {
						this.error("couldn't load module " + imported_module.path + ": " + String::fromErrorCode(error), span);
						continue;
					}
				}
			}

			this.modules_by_import_name[import_name] = modules;
		}

		for module in modules {
			this.current_namespace.addImportedNamespace(module);
		}
	}

	func checkTopLevelStatements(this: &&TCContext, namespace_to_check: SharedHandle!<Namespace>) -> void {
		const prev_namespace = this.current_namespace;
		const prev_function = this.current_function;

		this.current_namespace = namespace_to_check;
		this.current_function = SharedHandle!<FunctionDecl>();

		for child in namespace_to_check.file.top_level_nodes {
			discard this.interpret(this.checkStmt(child));
		}

		this.current_namespace = prev_namespace;
		this.current_function = prev_function;
	}

	func check(this: &&TCContext, namespace_to_check: SharedHandle!<Namespace>, max_state: NamespaceState) -> bool {
		if namespace_to_check.state == IncompleteTemplate || namespace_to_check.state >= max_state {
			return false;
		}

		const prev_namespace = this.current_namespace;
		const prev_target_state = this.current_target_state;
		const prev_function = this.current_function;

		this.current_namespace = namespace_to_check;
		this.current_function = SharedHandle!<FunctionDecl>();

		while namespace_to_check.state < max_state {
			this.current_target_state = namespace_to_check.state + 1u;

			var changes = false;
			do {
				changes = false;
				for imported_namespace in namespace_to_check.imported_namespaces {
					changes |= this.check(imported_namespace, NamespaceState::UncheckedFunctionBodies);
				}

				var i = 0u;
				while i < namespace_to_check.children.size() {
					changes |= this.check(namespace_to_check.children[i], this.current_target_state);
					i++;
				}
			} while changes;

			if namespace_to_check.linked_type.isAlive() {
				for contained_type in namespace_to_check.linked_type.contained_types {
					discard this.check(contained_type.linked_namespace, namespace_to_check.state);
				}
			}

			match namespace_to_check.state {
				case IncompleteTemplate -> {}
				case Unchecked -> this.checkCurrentNamespaceBodies();
				case UncheckedTypeBodies -> this.checkTypeBodies();
				case UncheckedFunctionSignatures -> this.checkFunctionSignatures();
				case UncheckedFunctionBodies -> this.checkFunctionBodies();
				case Done -> {}
			}
		}

		this.current_namespace = prev_namespace;
		this.current_target_state = prev_target_state;
		this.current_function = prev_function;

		return true;
	}

	func checkCurrentNamespaceBodies(this: &&TCContext) -> void {
		while !this.current_namespace.unchecked_bodies.isEmpty() {
			const bodies = this.current_namespace.unchecked_bodies;
			this.current_namespace.unchecked_bodies.clear();

			for parsed_namespace in bodies {
				for child in (this.getASTNode(parsed_namespace.body) as CompoundStmt).value() {
					discard this.interpret(this.checkStmt(child));
				}
			}
		}

		if this.current_namespace.state == Unchecked {
			this.current_namespace.updateState(NamespaceState::UncheckedTypeBodies);
		}
	}

	func checkTypeBodies(this: &&TCContext) -> void {
		var next = this.current_namespace.unchecked_types.last();
		while next.hasValue() && this.current_namespace.state == UncheckedTypeBodies {
			this.current_namespace.unchecked_types.removeLast();
			this.checkTypeBody(next.value());
			next = this.current_namespace.unchecked_types.last();
		}

		if this.current_namespace.state == UncheckedTypeBodies {
			this.current_namespace.updateState(NamespaceState::UncheckedFunctionSignatures);
		}
	}

	func checkFunctionSignatures(this: &&TCContext) -> void {
		var next = this.current_namespace.unchecked_functions.last();
		while next.hasValue() && this.current_namespace.state == UncheckedFunctionSignatures {
			this.current_namespace.unchecked_functions.removeLast();
			this.checkFunctionSignature(next.value());
			next = this.current_namespace.unchecked_functions.last();
		}

		if this.current_namespace.state == UncheckedFunctionSignatures {
			this.current_namespace.updateState(NamespaceState::UncheckedFunctionBodies);
		}
	}

	func checkFunctionBodies(this: &&TCContext) -> void {
		var next = this.current_namespace.unchecked_function_bodies.last();
		while next.hasValue() && this.current_namespace.state == UncheckedFunctionBodies {
			this.current_namespace.unchecked_function_bodies.removeLast();
			this.checkFunctionBody(next.value());
			next = this.current_namespace.unchecked_function_bodies.last();
		}

		if this.current_namespace.state == UncheckedFunctionBodies {
			this.current_namespace.updateState(NamespaceState::Done);
		}
	}

	func checkStmt(this: &&TCContext, id: uint) -> uint {
		id = this.checkNode(id, Type::unknown(), false);
		if id > 1 && this.getASTNodeType(id) != this.program.void_type && this.getASTNodeType(id) != this.program.never_type {
			this.error("unused value", this.getASTNodeSpan(id));
		}

		if this.getASTNode(id).is_comptime {
			this.replaceASTNode(id, this.comptimeValueToASTNode(this.interpret(id), this.getASTNodeSpan(id)));
		}

		return id;
	}

	func checkNode(this: &&TCContext, id: uint, expected_type: Type, inside_comptime_region: bool) -> uint {
		const span = this.getASTNodeSpan(id);
		const is_comptime = this.getASTNode(id).is_comptime;

		match this.getASTNode(id) {
			case Empty -> {
				this.setASTNodeType(id, this.program.void_type);
				return id;
			}
			case Garbage -> return id;
			case ExternFunctionBody | DefaultFunctionBody -> panic("unreachable"); // should be handled by checkFunctionBody()
			case Pragma: name -> {
				for p in this.pragmas {
					if p.name == name {
						p.callback(&&this, &&this.program, this.current_namespace, span);
						return this.getEmptyNode();
					}
				}

				this.error("unknown pragma '" + name + "'", span);
				return this.getEmptyNode();
			}
			case Import: name -> {
				if this.current_function.isAlive() {
					this.error("imports are only allowed at root scope", span);
				} else {
					this.checkImport(name, span);
				}
				return this.getEmptyNode();
			}

			// decls
			case NamespaceDecl: parsed_decl -> {
				if this.current_function.isAlive() {
					this.error("namespaces & types must be declared outside of functions", parsed_decl.name_span);
				}
				discard this.checkNamespaceDecl(parsed_decl, span);
				return this.getEmptyNode();
			}
			case TypeDecl: parsed_decl -> {
				if this.current_function.isAlive() {
					this.error("namespaces & types must be declared outside of functions", parsed_decl.name_span);
				}
				discard this.checkTypeDecl(parsed_decl, this.checkTemplateParameterDecl(parsed_decl.template_parameters), span, true, false);
				return this.getEmptyNode();
			}
			case FunctionDecl: parsed_decl -> {
				discard this.checkFunctionDecl(parsed_decl, this.checkTemplateParameterDecl(parsed_decl.template_parameters), true, false);
				return this.getEmptyNode();
			}
			case AliasDecl: parsed_alias -> {
				const target = this.checkTypeUsage(parsed_alias.type, false);
				if target.reference_kind != None {
					this.error("aliases to reference types aren't allowed", span);
				} else if !target.isUnknown() {
					this.current_namespace.aliases[parsed_alias.name] = target.decl.linked_namespace;
				}
				return this.getEmptyNode();
			}
			case VarDecl: parsed_var_decl -> {
				if is_comptime {
					discard this.interpret(this.checkVarDecl(id, parsed_var_decl, true, span));
				} else if this.current_function.isAlive() {
					return this.checkVarDecl(id, parsed_var_decl, false, span);
				} else if this.current_namespace.linked_type.isAlive() {
					this.checkMemberVarDecl(parsed_var_decl, span);
				} else {
					this.error("non comptime variable declared outside of type / function", span);
				}
				return this.getEmptyNode();
			}
			case CaseDecl: parsed_case_decl -> {
				if this.current_namespace.linked_type.isAlive() {
					this.checkCaseDecl(parsed_case_decl, span);
				} else {
					this.error("case decls must be inside a enum or variant type", span);
				}
				return this.getEmptyNode();
			}

			// stmts
			case CompoundStmt: children -> return this.checkCompoundStmt(id, children, is_comptime, span);
			case IfStmt: if_stmt -> return this.checkIfStmt(id, if_stmt, is_comptime, span);
			case IfVarStmt: if_var_stmt -> return this.checkIfVarStmt(id, if_var_stmt, is_comptime, span);
			case VarElseStmt: var_else_stmt -> return this.checkVarElseStmt(id, var_else_stmt, is_comptime, span);
			case WhileStmt: while_stmt -> return this.checkWhileStmt(id, while_stmt, is_comptime, span);
			case ParsedForStmt: for_stmt -> return this.checkForStmt(id, for_stmt, is_comptime, span);
			case BreakStmt | ContinueStmt -> {
				this.setASTNodeType(id, this.program.void_type);

				if !this.isCurrentScopeInsideLoop() {
					this.error("continue & break statements must be inside of a loop", span);
					return id;
				}

				return this.addASTNode(Node::CompoundStmt(
					this.collectCleanupCalls(ScopeKind::Loop) + id,
					span, this.program.void_type, false
				));
			}
			case CaseStmt: case_stmt -> return this.checkCaseStmt(id, case_stmt, span);
			case ElseCaseStmt: body -> return this.checkElseCaseStmt(id, body, span);
			case DeferStmt: body -> return this.checkDeferStmt(id, body, span);
			case ThrowStmt: value -> return this.checkThrowStmt(id, value, span);
			case ReturnStmt: value -> return this.checkReturnStmt(id, value, span);
			case YieldStmt: value -> return this.checkYieldStmt(id, value, span);
			case DiscardStmt: value -> return this.checkDiscardStmt(id, value, span, is_comptime);

			// exprs
			case BoolLiteralExpr: value -> {
				this.replaceASTNode(id, Node::IntegerLiteralExpr(value as int, span, this.program.bool_type, false));
				return id;
			}
			case NumberLiteralExpr: literal -> return this.checkNumberLiteralExpr(id, literal.value, literal.postfix, expected_type, span);
			case CharLiteralExpr: literal -> return this.checkCharLiteralExpr(id, literal.value, literal.postfix, span);
			case StringLiteralExpr -> {
				this.setASTNodeType(id, this.getType(Name("String"), span));
				return id;
			}
			case Name -> return this.checkNameExpr(id, expected_type, is_comptime || inside_comptime_region, span);
			case UnaryOperatorExpr: operator_expr -> return this.checkUnaryOperatorExpr(id, operator_expr, expected_type, is_comptime || inside_comptime_region, span);
			case BinaryOperatorExpr: operator_expr -> return this.checkBinaryOperatorExpr(id, operator_expr, expected_type, is_comptime || inside_comptime_region, span);
			case CallExpr: call_expr -> return this.checkCallExpr(id, call_expr, expected_type, is_comptime || inside_comptime_region, span);
			case IndexExpr: operands -> return this.checkIndexExpr(id, operands, expected_type, is_comptime || inside_comptime_region, span);
			case InlineIfExpr: expr -> return this.checkInlineIfExpr(id, expr, expected_type, is_comptime || inside_comptime_region, span);
			case ArrayExpr: elements -> return this.checkArrayExpr(id, elements, expected_type, is_comptime || inside_comptime_region, span);
			case TupleExpr: elements -> return this.checkTupleExpr(id, elements, expected_type, is_comptime || inside_comptime_region, span);
			case DictExpr: elements -> return this.checkDictExpr(id, elements, expected_type, is_comptime || inside_comptime_region, span);
			case MatchExpr: match_expr -> return this.checkMatchExpr(id,match_expr, expected_type, is_comptime || inside_comptime_region, span);
			case ParsedFunctionRefExpr: expr -> {
				const checked_name = this.checkName(expr.name);
				var parameter_types: List!<Type>;
				for t in expr.parameter_types {
					parameter_types.append(this.checkTypeUsage(t, false));
				}

				const candidates = this.lookupFunction(checked_name, SharedHandle!<TypeDecl>(), parameter_types, false, false, span);
				if this.validateFunctionCanditates(candidates, checked_name, parameter_types, span) {
					this.replaceASTNode(id, Node::FunctionRefExpr(candidates[0u], span, this.getFunctionType(parameter_types, candidates[0u].return_type, span), is_comptime));
				}
				return id;
			}
			case AnonymousFunctionExpr: id -> {
				const function = this.checkFunctionDecl((this.getASTNode(id) as FunctionDecl).value(), List!<TemplateParameterDecl>(), false, false);
				this.checkFunctionSignature(function);
				this.replaceASTNode(id, Node::FunctionRefExpr(function, span, this.getFunctionType(function.parameter_types, function.return_type, span), is_comptime));
				return id;
			}
			else -> {
				this.error("invalid unchecked node '" + this.getASTNode(id).name() + "'", span);
				return this.getGarbageNode();
			}
		}
	}

	// decl typechecking functions
	func checkNamespaceDecl(this: &&TCContext, parsed_decl: &ParsedNamespaceDecl, span: Span) -> SharedHandle!<Namespace> {
		const template_parameters = this.checkTemplateParameterDecl(parsed_decl.template_parameters);
		var namespace_decl = this.program.getOrCreateChildNamespace(parsed_decl.name, template_parameters, this.current_namespace, this.current_namespace.file);
		namespace_decl.addUncheckedBody(parsed_decl);
		return namespace_decl;
	}

	func checkTypeDecl(this: &&TCContext, parsed_decl: ParsedTypeDecl, template_parameters: &List!<TemplateParameterDecl>, span: Span, add_to_unchecked_list: bool, copy_ast: bool) -> SharedHandle!<TypeDecl> {
		for sibling in this.current_namespace.types_by_name[parsed_decl.name] {
			if sibling.template_parameters == template_parameters {
				this.error("type redeclared with identical template parameters", parsed_decl.name_span);
				this.info("previously declared here: ", sibling.name_span);
				return sibling;
			}
		}

		if copy_ast {
			const offset = this.current_namespace.file.duplicateNodes(parsed_decl.first_node_id, parsed_decl.last_node_id + 1);
			parsed_decl = (this.current_namespace.file.nodes[parsed_decl.last_node_id + offset] as TypeDecl).value();
		}

		var type = this.program.createType(this.current_namespace, parsed_decl.name, template_parameters, TypeBody::Unchecked(parsed_decl));

		type.span = span;
		type.name_span = parsed_decl.name_span;

		if add_to_unchecked_list {
			this.current_namespace.addUncheckedType(type);
		}

		return type;
	}

	func checkTypeBody(this: &&TCContext, type: SharedHandle!<TypeDecl>) -> void {
		if type.isIncompleteTemplate() {
			return;
		}

		const parsed_type = type.body as Unchecked else {
			return;
		}

		const prev_namespace = this.current_namespace;
		const prev_target_state = this.current_target_state;
		const prev_function = this.current_function;

		this.current_namespace = type.linked_namespace;
		this.current_target_state = NamespaceState::UncheckedFunctionSignatures;
		this.current_function = SharedHandle!<FunctionDecl>();

		match parsed_type.kind {
			case Struct -> type.body = Struct;
			case Enum -> type.body = Enum;
			case Variant -> type.body = Variant;
		}

		for annotation in parsed_type.annotations {
			if annotation.name == "packed" {
				match annotation {
					case Flag -> type.is_packed = true;
					else -> this.error("invalid annotation", annotation.span);
				}
			} else {
				this.error("invalid annotation name '" + annotation.name + "'", annotation.span);
			}
		}

		this.program.createDefaultFunctions(Type(type, ReferenceKind::None));
		if type.body is Enum || type.body is Variant {
			type.id_type = this.checkTypeUsage(parsed_type.id_type, false);
			if type.id_type.isUnknown() {
				type.id_type = this.program.int_type;
			}

			type.addContainedType(type.id_type);
		}

		for child in (this.getASTNode(parsed_type.body) as CompoundStmt).value() {
			discard this.interpret(this.checkStmt(child));
		}

		discard this.check(type.linked_namespace, NamespaceState::UncheckedFunctionSignatures);

		for c in type.variant_cases {
			this.program.createVariantCaseConstructor(type, c.id, c.type);
			this.program.createVariantOpIs(type, c.id);

			if c.type != this.program.void_type {
				this.program.createVariantOpUnsafeAs(type, ReferenceKind::Const, c.id);
				this.program.createVariantOpUnsafeAs(type, ReferenceKind::Var, c.id);
			}
		}

		this.current_namespace = prev_namespace;
		this.current_target_state = prev_target_state;
		this.current_function = prev_function;
	}

	func checkFunctionDecl(this: &&TCContext, parsed_decl: ParsedFunctionDecl, template_parameters: &List!<TemplateParameterDecl>, add_to_unchecked_list: bool, copy_ast: bool) -> SharedHandle!<FunctionDecl> {
		if !template_parameters.isEmpty() {
			for sibling in this.current_namespace.functions_by_name[parsed_decl.signature.name] {
				if sibling.template_parameters == template_parameters {
					this.error("function redeclared with identical template parameters", parsed_decl.signature.span);
					this.info("previously declared here: ", sibling.signature_span);
					return sibling;
				}
			}
		}

		if copy_ast {
			const offset = this.current_namespace.file.duplicateNodes(parsed_decl.first_node_id, parsed_decl.last_node_id + 1);
			parsed_decl = (this.current_namespace.file.nodes[parsed_decl.last_node_id + offset] as FunctionDecl).value();
		}

		const function = this.program.createFunction(this.current_namespace, parsed_decl.signature.name, template_parameters, FunctionBody::Unchecked(parsed_decl));
		function.span = parsed_decl.span;
		function.signature_span = parsed_decl.signature.span;

		if add_to_unchecked_list {
			this.current_namespace.addUncheckedFunction(function);
		}

		for annotation in parsed_decl.annotations {
			if annotation.name == "extern_name" {
				match annotation {
					case String: value -> function.extern_name = value;
					else -> this.error("invalid annotation", annotation.span);
				}
			} else {
				this.error("invalid annotation name '" + annotation.name + "'", annotation.span);
			}
		}

		return function;
	}

	func checkFunctionSignature(this: &&TCContext, function: SharedHandle!<FunctionDecl>) -> void {
		if function.isIncompleteTemplate() {
			return;
		}

		if function.body is Builtin {
			function.parent_namespace.addUncheckedFunctionBody(function);
			if this.program.options.codegen_asap {
				if function.body is Builtin || this.program.options.codegen_inline_builtin_functions {
					this.cg_context.codegenFunctionDecl(function);
				}
			}

			return;
		}

		const signature = match function.body {
			case Unchecked: &parsed_body -> yield parsed_body.signature;
			else -> return;
		}

		const prev_namespace = this.current_namespace;
		const prev_function = this.current_function;

		this.current_namespace = function.parent_namespace;
		this.current_function = function;

		function.return_type = this.checkTypeUsage(signature.return_type, false);
		for id in signature.parameters {
			const parameter_decl = this.getASTNode(id) as VarDecl else {
				continue;
			}

			const parameter_type = this.checkTypeUsage(parameter_decl.type, false);
			function.parameter_types.append(parameter_type);
			function.createParameter(this.getASTNodeSpan(id), parameter_decl.name, parameter_type);

			for annotation in parameter_decl.annotations {
				match annotation {
					case Flag -> {
						if annotation.name == "shallow" {
							function.parameters[function.parameters.size() - 1].is_shallow_parameter = true;
						} else {
							this.error("invalid function parameter annotation", annotation.span);
						}
					}
					else -> {
						this.error("invalid function parameter annotation", annotation.span);
					}
				}
			}
		}

		this.current_namespace.addUncheckedFunctionBody(function);

		for sibling in this.current_namespace.functions_by_name[function.name] {
			if sibling == function {
				continue;
			}

			if sibling.template_parameters != function.template_parameters {
				continue;
			}

			if sibling.parameter_types == function.parameter_types {
				this.error("function redeclared with identical parameter types", function.signature_span);
				this.info("previously declared here: ", sibling.signature_span);
			}
		}

		if function.name == "main" {
			if !function.return_type.isUnknown() && function.return_type != this.program.int_type && function.return_type != this.program.void_type {
				this.error("invalid return type for main, expected " + this.program.int_type.signature() + " or " + this.program.void_type.signature(), function.signature_span);
			}

			// TODO: validate parameter types

			if this.program.main_function.isEmpty() {
				this.program.main_function = function;
			} else {
				this.error("re-declaration of the main function", function.signature_span);
				this.hint("main was already declared here:", this.program.main_function.signature_span);
			}
		}

		if this.current_namespace.linked_type.isAlive() {
			var parent_type = this.current_namespace.linked_type;
			const type = Type(parent_type);

			if function.name == "constructor" && function.parameter_types.size() == 1 {
				if function.parameter_types[0u] == type.varRef() {
					parent_type.default_constructor = function;
				}
			} else if function.name == "constructor" && function.parameter_types.size() == 2 {
				if function.parameter_types[0u] == type.varRef() && function.parameter_types[1u] == type {
					parent_type.copy_constructor = function;
					function.is_copy_constructor = true;

					// the "other" parameter in copy a constructor can't be deep copied (would result in recursion),
					// but it can safely be shallow copied because no other parameters can reference the same object
					function.parameters[1u].is_shallow_parameter = true;
				}
			} else if function.name == "destructor" && function.parameter_types.size() == 1 {
				if function.parameter_types[0u] == type.varRef() {
					parent_type.destructor = function;
				}
			} else if function.name == "operator =" && function.parameter_types.size() == 2 {
				if function.parameter_types[0u] == type.varRef() && function.parameter_types[1u] == type {
					parent_type.op_assign = function;
				}
			} else if function.name == "operator ==" && function.parameter_types.size() == 2 {
				if function.parameter_types[0u] == type && function.parameter_types[1u] == type {
					parent_type.op_equal = function;
				}
			} else if function.name == "operator <=>" && function.parameter_types.size() == 2 {
				if function.parameter_types[0u] == type && function.parameter_types[1u] == type {
					parent_type.op_compare = function;
				}
			} else if function.name == "operator unwrap" && function.parameter_types.size() == 1 {
				if parent_type.unwrapped_type.isEmpty() {
					parent_type.unwrapped_type = function.return_type.decl;
				} else if parent_type.unwrapped_type != function.return_type.decl {
					this.error("operator unwrap redeclared with different return type", function.signature_span);
				}

				if function.return_type.reference_kind < function.parameter_types[0u].reference_kind {
					this.error("invalid operator unwrap declaration", function.signature_span);
				}
			}
		}

		if const parsed_function = function.body as Unchecked {
			if this.getASTNode(parsed_function.body) is ExternFunctionBody && function.extern_name == "" {
				function.extern_name = function.name;
			}
		}

		if this.program.options.codegen_asap {
			this.cg_context.codegenFunctionDecl(function);
		}

		this.current_namespace = prev_namespace;
		this.current_function = prev_function;
	}

	func checkFunctionBody(this: &&TCContext, function: SharedHandle!<FunctionDecl>) -> void {
		const prev_namespace = this.current_namespace;
		const prev_function = this.current_function;

		this.current_namespace = function.parent_namespace;
		this.current_function = function;

		match function.body {
			case Empty | Extern -> {}
			case Builtin: builtin_function -> this.validateBuiltinFunctionDecl(function, builtin_function);
			case Stmt -> this.error("function body is already checked", function.span);
			case Unchecked: &parsed_function -> match this.getASTNode(parsed_function.body) {
				case ExternFunctionBody -> function.body = FunctionBody::Extern;
				case DefaultFunctionBody -> {
					const builtin_function = function.getDefaultFunctionBody();
					if builtin_function is Empty {
						this.error("cannot generate default function body for this function", function.signature_span);
					} else {
						function.body = FunctionBody::Builtin(builtin_function);
						this.validateBuiltinFunctionDecl(function, builtin_function);
					}
				}
				else -> this.checkFunctionBody(&&function.operator unwrap(), parsed_function.body);
			}
		}

		if this.program.options.codegen_asap {
			match function.body {
				case Builtin: builtin_function -> {
					if !builtin_function.isInlineable() || this.program.options.codegen_inline_builtin_functions {
						this.cg_context.codegenFunctionBody(function);
					}
				}
				else -> this.cg_context.codegenFunctionBody(function);
			}
		}

		this.current_namespace = prev_namespace;
		this.current_function = prev_function;
	}

	func validateBuiltinFunctionDecl(this: &&TCContext, function: SharedHandle!<FunctionDecl>, body: BuiltinFunction) -> void {
		if body.isInlineable() || body.base_type.isUnknown() { // inlineable builtin functions don't call any other functions and thus are always valid
			return;
		}

		const parent_type = body.base_type.decl;

		for v in parent_type.member_variables {
			if v.type.isUnknown() || v.type.reference_kind != None {
				continue;
			}

			const t = v.type.decl;

			match body {
				case StructDefaultConstructor | ArrayDefaultConstructor -> {
					if t.default_constructor.isEmpty() {
						this.error(t.signature() + " is missing a default constructor", t.name_span);
						this.info("required by " + function.signature(), function.signature_span);
					}
				}
				case StructValueConstructor | StructCopyConstructor | VariantCaseConstructor | VariantCopyConstructor | ArrayCopyConstructor -> {
					if t.copy_constructor.isEmpty() {
						this.error(t.signature() + " is missing a copy constructor", t.name_span);
						this.info("required by " + function.signature(), function.signature_span);
					}
				}
				case StructDestructor | VariantDestructor | ArrayDestructor -> {
					if t.destructor.isEmpty() {
						this.error(t.signature() + " is missing a destructor", t.name_span);
						this.info("required by " + function.signature(), function.signature_span);
					}
				}
				case StructOpAssign | VariantOpAssign | ArrayOpAssign -> {
					if t.op_assign.isEmpty() {
						this.error(t.signature() + " is missing an assignment operator", t.name_span);
						this.info("required by " + function.signature(), function.signature_span);
					}
				}
				case StructOpEqual | VariantOpEqual | ArrayOpEqual -> {
					if t.op_equal.isEmpty() {
						this.error(t.signature() + " is missing an equal operator", t.name_span);
						this.info("required by " + function.signature(), function.signature_span);
					}
				}
				case StructOpCmp -> {
					if t.op_compare.isEmpty() {
						this.error(t.signature() + " is missing a compare operator", t.name_span);
						this.info("required by " + function.signature(), function.signature_span);
					}
				}
				else -> {}
			}
		}

		for c in parent_type.variant_cases {
			if c.type == this.program.void_type || c.type == this.program.never_type || c.type.isUnknown() || c.type.reference_kind != None {
				continue;
			}

			const t = c.type.decl;

			match body {
				case VariantCaseConstructor: id -> {
					if id == c.id && t.copy_constructor.isEmpty() {
						this.error(t.signature() + " is missing a copy constructor", t.name_span);
						this.info("required by " + function.signature(), function.signature_span);
					}
				}
				case VariantCopyConstructor -> {
					if t.copy_constructor.isEmpty() {
						this.error(t.signature() + " is missing a copy constructor", t.name_span);
						this.info("required by " + function.signature(), function.signature_span);
					}
				}
				case VariantDestructor -> {
					if t.destructor.isEmpty() {
						this.error(t.signature() + " is missing a destructor", t.name_span);
						this.info("required by " + function.signature(), function.signature_span);
					}
				}
				case VariantOpAssign -> {
					if t.copy_constructor.isEmpty() {
						this.error(t.signature() + " is missing a copy constructor", t.name_span);
						this.info("required by " + function.signature(), function.signature_span);
					}

					if t.destructor.isEmpty() {
						this.error(t.signature() + " is missing a destructor", t.name_span);
						this.info("required by " + function.signature(), function.signature_span);
					}
				}
				case VariantOpEqual -> {
					if t.op_equal.isEmpty() {
						this.error(t.signature() + " is missing an equal operator", t.name_span);
						this.info("required by " + function.signature(), function.signature_span);
					}
				}
				else -> {}
			}
		}
	}

	func checkFunctionBody(this: &&TCContext, decl: &&FunctionDecl, body_id: uint) -> void {
		var prev_scope_stack = this.scope_stack;
		var prev_current_return_type = this.current_return_type;
		var prev_active_member_variables = this.active_member_variables;
		var prev_return_variable = this.return_variable;

		this.scope_stack.clear();
		this.current_return_type = decl.return_type;
		this.active_member_variables.clear();
		this.return_variable = SharedHandle!<VarDecl>();

		this.pushScope(ScopeKind::Function);

		var required_member_variables: Set!<uint>;
		if this.current_namespace.linked_type.isAlive() {
			const parent_type = this.current_namespace.linked_type;

			if decl.name == "constructor" {
				for member_variable in parent_type.member_variables {
					required_member_variables.add(member_variable.id);
				}
			} else {
				for member_variable in parent_type.member_variables {
					this.active_member_variables.add(member_variable.id);
				}
			}
		}

		var checked_body: List!<uint>;
		for parameter in decl.parameters {
			// create a local copy of all parameters passed by value
			if parameter.type.reference_kind == None {
				var copy = decl.createVariable(decl.signature_span, parameter.name, parameter.type, false, false);
				const parameter_expr = this.addASTNode(Node::VarInvokeExpr(parameter, decl.signature_span, parameter.type, false));

				if parameter.is_shallow_parameter {
					copy.constructor_call = this.addASTNode(Node::ShallowCopyExpr(ShallowCopyExpr(
						this.addASTNode(Node::VarInvokeExpr(copy, decl.signature_span, copy.type.varRef(), false)),
						parameter_expr,
					), decl.signature_span, this.program.void_type, false));
					copy.is_const = true;
				} else {
					this.createConstructorCall(copy, List!<uint>(1u, parameter_expr));
					this.createDestructorCall(copy);
				}

				this.addVariableToCurrentScope(copy);
				checked_body.append(this.addASTNode(Node::LifeTimeStart(copy, decl.signature_span, Type::unknown(), false)));
			} else {
				this.addVariableToCurrentScope(parameter);
			}
		}

		if !decl.return_type.isUnknown(){
			if decl.return_type != this.program.void_type && decl.return_type != this.program.never_type {
				this.return_variable = decl.createVariable(decl.signature_span, "#return_var", decl.return_type, false, false);
			}
		}

		checked_body.append(this.checkStmt(body_id));

		if this.active_member_variables != required_member_variables {
			if this.isASTNodeTerminator(body_id, false) {
				if decl.name == "constructor" {
					this.error("not all member variables initialized", decl.signature_span);
				} else if decl.name == "destructor" {
					this.error("not all member variables de-initialized", decl.signature_span);
				}
			} else {
				const parent_type = this.current_namespace.linked_type;
				var unhandled_member_variables: List!<uint>;
				if decl.name == "constructor" {
					for id in required_member_variables - this.active_member_variables {
						if parent_type.member_variables[id].type.reference_kind == None {
							unhandled_member_variables.append(id);
						} else {
							this.error("uninitialized reference member variable", decl.signature_span);
						}
					}
				} else if decl.name == "destructor" {
					for id in this.active_member_variables {
						if parent_type.member_variables[id].type.reference_kind == None {
							unhandled_member_variables.insert(0u, id);
						}
					}
				}

				const this_var_invoke_expr = this.addASTNode(Node::VarInvokeExpr(decl.variables[0u], decl.signature_span, decl.variables[0u].type, false));
				for id in unhandled_member_variables {
					const member_access_expr = this.addASTNode(Node::MemberVarInvokeExpr(
						MemberVarInvokeExpr(this_var_invoke_expr, id),
						decl.signature_span,
						parent_type.member_variables[id].type.varRef(),
						false
					));

					var parameters = List!<uint>(1u, member_access_expr);
					const initializer = parent_type.member_variables[id].initializer;
					if decl.name == "constructor" && initializer > 1 {
						parameters.append(initializer);
					}

					const call = this.addASTNode(this.checkCall(Name(decl.name), parameters, false, false, CallKind::MemberCall, false, decl.signature_span));

					checked_body.append(call);
				}
			}
		}

		if !this.isASTNodeTerminator(body_id, false) {
			checked_body.append(this.getCleanupCallsForCurrentScope());

			if this.current_return_type == this.program.void_type {
				checked_body.append(this.addASTNode(Node::ReturnStmt(this.getEmptyNode(), Span(), Type::unknown(), false)));
			} else {
				checked_body.append(this.addASTNode(Node::ReturnStmt(this.getGarbageNode(), Span(), Type::unknown(), false)));
				if !this.current_return_type.isUnknown() {
					this.error("non-void function doesn't return a value in all paths", decl.signature_span);
				}
			}
		}

		decl.body = FunctionBody::Stmt(this.addASTNode(Node::CompoundStmt(checked_body, this.getASTNodeSpan(body_id), this.program.void_type, false)));

		this.popScope();

		this.scope_stack = prev_scope_stack;
		this.current_return_type = prev_current_return_type;
		this.active_member_variables = prev_active_member_variables;
		this.return_variable = prev_return_variable;
	}

	func checkTemplateParameterDecl(this: &&TCContext, unchecked_parameters: &List!<ParsedTemplateParameterDecl>) -> List!<TemplateParameterDecl> {
		var result: List!<TemplateParameterDecl>;

		for parameter in unchecked_parameters {
			const name = parameter.name;
			const concept = this.program.getConcept(parameter.concept) else {
				this.error("concept '" + parameter.concept + "' not found", parameter.span);
				continue;
			}

			var checked_parameter = TemplateParameterDecl(name, concept, false);
			checked_parameter.value = this.checkTemplateParameter(parameter.value);

			result.append(checked_parameter);
		}

		return result;
	}

	func checkMemberVarDecl(this: &&TCContext, parsed_decl: &ParsedVarDecl, span: Span) -> void {
		var type_decl = this.current_namespace.linked_type;

		if !(type_decl.body is Struct) && !(type_decl.body is Variant) {
			this.error("member variables are only allowed inside struct or variant types", span);
			return;
		}

		if this.getASTNode(parsed_decl.type) is Empty {
			this.error("member variables must have a type specified", span);
			return;
		}

		const type = this.checkTypeUsage(parsed_decl.type, false);
		const initializer = this.checkNode(parsed_decl.initializer, type, false);
		type_decl.createMemberVariable(span, parsed_decl.name, type, initializer);
	}

	func checkCaseDecl(this: &&TCContext, parsed_decl: &ParsedCaseDecl, span: Span) -> void {
		if !this.current_namespace.linked_type.isAlive() {
			this.error("case declarations are only allowed inside enum or variant types", span);
		}

		var type_decl = this.current_namespace.linked_type;
		if !(type_decl.body is Enum) && !(type_decl.body is Variant) {
			this.error("case declarations are only allowed inside enum or variant types", span);
			return;
		}

		if parsed_decl.payload > 0 && type_decl.body is Enum {
			this.error("only variant cases are allowed to have a payload attached", span);
		}

		var id = 0;
		if this.getASTNode(parsed_decl.id) is Empty {
			id = type_decl.getNextCaseId();
		} else {
			id = this.interpret(this.checkNode(parsed_decl.id, type_decl.id_type, true)).toInt();
		}

		var payload_type = this.program.void_type;
		if !(this.getASTNode(parsed_decl.payload) is Empty) {
			payload_type = this.checkTypeUsage(parsed_decl.payload, false);
		}

		if type_decl.body is Enum {
			type_decl.createEnumCase(span, id, parsed_decl.name);
		} else {
			type_decl.createVariantCase(span, id, parsed_decl.name, payload_type);
		}
	}

	func checkVarDecl(this: &&TCContext, id: uint, parsed_stmt: &ParsedVarDecl, is_comptime: bool, span: Span) -> uint {
		var type = this.checkTypeUsage(parsed_stmt.type, false);

		var initializer: List!<uint>;
		this.pushScope(ScopeKind::Expr);
		if !type.isUnknown() && this.getASTNode(parsed_stmt.initializer).isAnonymousTuple() {
			const elements = (this.getASTNode(parsed_stmt.initializer) as TupleExpr).value();
			for &element in elements {
				initializer.append(this.checkNode(element.value, Type::unknown(), is_comptime));
			}
		} else if parsed_stmt.initializer > 1 {
			initializer.append(this.checkNode(parsed_stmt.initializer, type, is_comptime));
			if type.isUnknown() {
				type = this.getASTNodeType(initializer[initializer.size() - 1]);
			}
		}

		const initializer_cleanup = this.getCleanupCallsForCurrentScope();
		this.popScope();

		const var_decl = this.createVarDecl(parsed_stmt.name, type, parsed_stmt.is_const, initializer, initializer_cleanup, is_comptime, span);

		if var_decl is Garbage {
			return this.getGarbageNode();
		} else {
			this.replaceASTNode(id, var_decl);
			return id;
		}
	}

	func createVarDecl(this: &&TCContext, name: String, type: Type, is_const: bool, initializer: &List!<uint>, initializer_cleanup: &List!<uint>, is_comptime: bool, span: Span) -> Node {
		if is_const && initializer.isEmpty() {
			this.error("constants must be initialized", span);
		}

		if !is_const && type.reference_kind == Const {
			this.error("cannot store const reference in non-const variable", span);
		}

		if !name.startsWith("#") {
			if const other = this.getVariableByName(name) {
				this.error("redefinition of variable '" + name + "'", span);
				this.info("previously declared here:", other.span);
			}
		}

		var variable: SharedHandle!<VarDecl>;
		if this.current_function.isAlive() {
			variable = this.current_function.createVariable(span, name, type, is_const, is_comptime);
		} else {
			variable = this.current_namespace.createComptimeVariable(span, name, type, is_const);
		}

		this.createConstructorCall(variable, initializer);
		this.createDestructorCall(variable);

		if this.current_function.isAlive() {
			this.addVariableToCurrentScope(variable);
		}

		var result: List!<uint>;
		result.append(this.addASTNode(Node::LifeTimeStart(variable, span, this.program.void_type, is_comptime)));
		result.append(initializer_cleanup);
		return Node::CompoundStmt(result, span, this.program.void_type, is_comptime);
	}

	func createConstructorCall(this: &&TCContext, variable: SharedHandle!<VarDecl>, initializer: List!<uint>) -> void {
		if variable.type.isUnknown() {
			return;
		}

		if variable.type.reference_kind == None {
			initializer.insert(0u, this.addASTNode(Node::VarInvokeExpr(variable, variable.span, variable.type.varRef(), false)));
			variable.constructor_call = this.addASTNode(this.checkCall(Name("constructor"), initializer, false, true, CallKind::MemberCall, variable.is_comptime, variable.span));
		} else {
			if initializer.size() != 1 {
				this.error("reference variables must be initialized with a single value", variable.span);
				return;
			}

			const initializer_type = this.getASTNodeType(initializer[0u]);
			if initializer_type.base() != variable.type.base() || initializer_type.reference_kind < variable.type.reference_kind {
				this.error("initializer has invalid type: expected " + variable.type.signature() + " but got " + initializer_type.signature(), variable.span);
				return;
			}

			variable.constructor_call = this.addASTNode(Node::ShallowCopyExpr(ShallowCopyExpr(
				this.addASTNode(Node::VarInvokeExpr(variable, variable.span, variable.type, false)), initializer[0u]
			), variable.span, this.program.void_type, false));
		}
	}

	func createDestructorCall(this: &&TCContext, variable: SharedHandle!<VarDecl>) -> void {
		if variable.type.isUnknown() {
			return;
		}

		if variable.type.reference_kind == None {
			variable.destructor_call = this.addASTNode(this.checkCall(
				Name("destructor"),
				List!<uint>(1u, this.addASTNode(
					Node::VarInvokeExpr(variable, variable.span, variable.type.varRef(), false)
				)),
				false, false, CallKind::MemberCall,
				variable.is_comptime,
				variable.span
			));
		}
	}

	// stmt typechecking functions
	func checkCompoundStmt(this: &&TCContext, id: uint, children: List!<uint>, is_comptime: bool, span: Span) -> uint {
		this.pushScope(ScopeKind::Compound);
		var is_terminator = false;
		for &&child in children {
			if is_terminator {
				this.error("unreachable code", this.getASTNodeSpan(child));
			}

			child = this.checkStmt(child);
			if this.isASTNodeTerminator(child, this.isCurrentScopeInsideMatch()) {
				is_terminator = true;
			}
		}

		if !is_terminator {
			children.append(this.getCleanupCallsForCurrentScope());
		}

		this.popScope();
		this.replaceASTNode(id, Node::CompoundStmt(children, span, this.program.void_type, false));
		return id;
	}

	func checkIfStmt(this: &&TCContext, id: uint, if_stmt: IfStmt, is_comptime: bool, span: Span) -> uint {
		this.pushScope(ScopeKind::Expr);
		if_stmt.condition = this.checkNode(if_stmt.condition, this.program.bool_type, is_comptime);
		if_stmt.condition_cleanup = this.getCleanupCallsForCurrentScope();
		this.popScope();

		const condition_type = this.getASTNodeType(if_stmt.condition);
		if condition_type != this.program.bool_type && !condition_type.isUnknown() {
			this.error("invalid condition type: expected " + this.program.bool_type.signature() + " but got " + condition_type.signature(), this.getASTNodeSpan(if_stmt.condition));
			return this.getGarbageNode();
		}

		if is_comptime {
			const condition_value = this.interpret(this.getASTNode(if_stmt.condition));
			for node in if_stmt.condition_cleanup {
				discard this.interpret(this.getASTNode(node));
			}

			if condition_value is Undefined {
				return this.getGarbageNode();
			}

			if condition_value.toBool() {
				return this.checkStmt(if_stmt.then_branch);
			} else {
				return this.checkStmt(if_stmt.else_branch);
			}
		} else {
			const prev_active_member_variables = this.active_member_variables;

			if_stmt.then_branch = this.checkStmt(if_stmt.then_branch);
			const then_branch_active_member_variables = this.active_member_variables;

			this.active_member_variables = prev_active_member_variables;
			if_stmt.else_branch = this.checkStmt(if_stmt.else_branch);

			if then_branch_active_member_variables != this.active_member_variables {
				this.error("if & then branch (de)initialize different member variables", span);
			}

			this.replaceASTNode(id, Node::IfStmt(if_stmt, span, this.program.void_type, false));
			return id;
		}
	}

	func checkIfVarStmt(this: &&TCContext, id: uint, parsed_stmt: &IfVarStmt, is_comptime: bool, span: Span) -> uint {
		// if var x = y { ... }
		// ->
		// match y {
		//    Ok | Some: #value -> { var x = #value; ... }
		//    else -> {}
		// }

		var var_decl_node = this.getASTNode(parsed_stmt.var_decl);
		match var_decl_node {
			case VarDecl: &&var_decl -> {
				this.pushScope(ScopeKind::Expr);
				defer this.popScope();
				const value = this.checkNode(var_decl.initializer, Type::unknown(), is_comptime);
				if value <= 1 {
					return this.getGarbageNode();
				}

				const value_type = this.getASTNodeType(value);
				const value_span = this.getASTNodeSpan(value);

				var ok_case_name = "";
				if value_type.decl.getVariantCase("Ok").hasValue() {
					ok_case_name = "Ok";
				} else if value_type.decl.getVariantCase("Some").hasValue() {
					ok_case_name = "Some";
				} else {
					this.error("invalid value type for if var: expected Result or Optional", span);
					return this.getGarbageNode();
				}

				var_decl.initializer = this.addASTNode(Node::Name(ParsedName("#value", List!<uint>()), var_decl_node.span, Type::unknown(), false));
				if value_type.reference_kind == Var {
					var_decl.initializer = this.addASTNode(Node::UnaryOperatorExpr(UnaryOperatorExpr(Operator::VarRef, var_decl.initializer), var_decl_node.span, Type::unknown(), false));
				} else if value_type.reference_kind == Const {
					var_decl.initializer = this.addASTNode(Node::UnaryOperatorExpr(UnaryOperatorExpr(Operator::ConstRef, var_decl.initializer), var_decl_node.span, Type::unknown(), false));
				}
				this.replaceASTNode(parsed_stmt.var_decl, var_decl_node);
				this.addChildToFrontOfCompoundStmt(parsed_stmt.body, parsed_stmt.var_decl);

				var cases: List!<uint>;

				// Ok | Some: #val -> { var x = #val; ... }
				cases.append(this.addASTNode(Node::CaseStmt(CaseStmt(
					List!<uint>(1u, this.addASTNode(Node::Name(ParsedName(ok_case_name, List!<uint>()), value_span, Type::unknown(), false))),
					"#value", value_type.reference_kind,
					parsed_stmt.body
				), value_span, Type::unknown(), false)));

				// else -> {}
				cases.append(this.addASTNode(Node::ElseCaseStmt(
					this.addASTNode(Node::CompoundStmt(List!<uint>(), value_span, Type::unknown(), false)),
					value_span, Type::unknown(), false
				)));

				const match_expr = this.createMatchExpr(value, this.addASTNode(Node::CompoundStmt(cases, span, Type::unknown(), false)), Type::unknown(), is_comptime, span);
				if match_expr is Garbage {
					return this.getGarbageNode();
				}

				var result: List!<uint>;
				result.append(this.addASTNode(match_expr));
				result.append(this.getCleanupCallsForCurrentScope());
				this.replaceASTNode(id, Node::CompoundStmt(result, span, this.program.void_type, false));
				return id;
			}
			else -> panic("invalid if var stmt");
		};
	}

	func checkVarElseStmt(this: &&TCContext, id: uint, parsed_stmt: &VarElseStmt, is_comptime: bool, span: Span) -> uint {
		// var bar = foo else: (&&)error { ... }
		// ->
		// var bar = match foo {
		//     Ok | Some: val -> yield val;
		//     Error | None: (&&)error -> { ... }
		// }

		const parsed_var_decl_node = this.getASTNode(parsed_stmt.var_decl);
		const parsed_var_decl = (parsed_var_decl_node as VarDecl).value();
		const var_decl_span = parsed_var_decl_node.span;

		const value = this.checkNode(parsed_var_decl.initializer, Type::unknown(), is_comptime);
		if value <= 1 {
			return this.getGarbageNode();
		}

		const value_type = this.getASTNodeType(value);

		var ok_case_name = "";
		var error_case_name = "";
		var capture = false;
		if value_type.decl.getVariantCase("Ok").hasValue() {
			ok_case_name = "Ok";
			error_case_name = "Error";

			if !parsed_stmt.capture_name.isEmpty() {
				capture = true;
			}
		} else if value_type.decl.getVariantCase("Some").hasValue() {
			ok_case_name = "Some";
			error_case_name = "None";

			if !parsed_stmt.capture_name.isEmpty() {
				this.error("can't capure error on this value type", span);
			}
		} else {
			this.error("invalid value type for if var: expected Result or Optional", span);
			return this.getGarbageNode();
		}

		var value_invoke_expr = this.addASTNode(Node::Name(ParsedName("#value", List!<uint>()), var_decl_span, Type::unknown(), false));
		match value_type.reference_kind {
			case Var -> value_invoke_expr = this.addASTNode(Node::UnaryOperatorExpr(UnaryOperatorExpr(Operator::VarRef, value_invoke_expr), var_decl_span, Type::unknown(), false));
			case Const -> value_invoke_expr = this.addASTNode(Node::UnaryOperatorExpr(UnaryOperatorExpr(Operator::ConstRef, value_invoke_expr), var_decl_span, Type::unknown(), false));
			else -> {}
		}

		var cases: List!<uint>;

		// case Ok: val -> yield val
		cases.append(this.addASTNode(Node::CaseStmt(CaseStmt(
			List!<uint>(1u, this.addASTNode(Node::Name(ParsedName(ok_case_name, List!<uint>()), var_decl_span, Type::unknown(), false))),
			"#value", value_type.reference_kind,
			this.addASTNode(Node::YieldStmt(value_invoke_expr, var_decl_span, Type::unknown(), false))
		), var_decl_span, Type::unknown(), false)));

		// case Error: (&&err) -> { ... }
		cases.append(this.addASTNode(Node::CaseStmt(CaseStmt(
			List!<uint>(1u, this.addASTNode(Node::Name(ParsedName(error_case_name, List!<uint>()), var_decl_span, Type::unknown(), false))),
			parsed_stmt.capture_name, parsed_stmt.capture_kind, parsed_stmt.body
		), var_decl_span, Type::unknown(), false)));

		this.pushScope(ScopeKind::Expr);
		const initializer = this.createMatchExpr(value, this.addASTNode(Node::CompoundStmt(cases, span, Type::unknown(), false)), Type::unknown(), is_comptime, span);
		const initializer_cleanup = this.getCleanupCallsForCurrentScope();
		this.popScope();

		if initializer is Garbage {
			return this.getGarbageNode();
		}

		const var_decl = this.createVarDecl(
			parsed_var_decl.name,
			initializer.type,
			parsed_var_decl.is_const,
			List!<uint>(1u, this.addASTNode(initializer)),
			initializer_cleanup,
			is_comptime,
			var_decl_span
		);

		if var_decl is Garbage {
			return this.getGarbageNode();
		} else {
			this.replaceASTNode(id, var_decl);
			return id;
		}
	}

	func checkWhileStmt(this: &&TCContext, id: uint, while_stmt: WhileStmt, is_comptime: bool, span: Span) -> uint {
		this.pushScope(ScopeKind::Expr);
		while_stmt.condition = this.checkNode(while_stmt.condition, this.program.bool_type, is_comptime);
		while_stmt.condition_cleanup = this.getCleanupCallsForCurrentScope();
		this.popScope();

		const condition_type = this.getASTNodeType(while_stmt.condition);
		if condition_type != this.program.bool_type && !condition_type.isUnknown() {
			this.error("invalid condition type: expected " + this.program.bool_type.signature() + " but got " + condition_type.signature(), this.getASTNodeSpan(while_stmt.condition));
			return this.getGarbageNode();
		}

		this.pushScope(ScopeKind::Loop);
		defer this.popScope();

		if !is_comptime {
			while_stmt.body = this.checkStmt(while_stmt.body);
			this.replaceASTNode(id, Node::WhileStmt(while_stmt, span, this.program.void_type, false));
			return id;
		}

		var result: List!<uint>;
		if while_stmt.kind == While {
			var condition_value = this.interpret(while_stmt.condition);
			this.interpret(while_stmt.condition_cleanup);

			while condition_value.toBool() {
				const offset = this.current_namespace.file.duplicateNodes(while_stmt.body_start, while_stmt.body_end);
				result.append(this.checkStmt(while_stmt.body + offset));
				condition_value = this.interpret(while_stmt.condition);
				this.interpret(while_stmt.condition_cleanup);
			}
		} else if while_stmt.kind == DoWhile {
			var condition_value = Value::Undefined;

			do {
				const offset = this.current_namespace.file.duplicateNodes(while_stmt.body_start, while_stmt.body_end);
				result.append(this.checkStmt(while_stmt.body + offset));
				condition_value = this.interpret(while_stmt.condition);
				this.interpret(while_stmt.condition_cleanup);
			} while condition_value.toBool();
		}

		this.replaceASTNode(id, Node::CompoundStmt(result, span, this.program.void_type, false));
		return id;
	}

	func checkForStmt(this: &&TCContext, id: uint, parsed_stmt: &ParsedForStmt, is_comptime: bool, span: Span) -> uint {
		this.pushScope(ScopeKind::Expr);
		const range = this.checkNode(parsed_stmt.range, Type::unknown(), is_comptime);
		if range <= 1 {
			return this.getGarbageNode();
		}

		const iterator = this.checkCall(Name("iterator"), List!<uint>(1u, range), true, false, CallKind::MemberCall, is_comptime, this.getASTNodeSpan(range));
		if iterator is Garbage {
			return this.getGarbageNode();
		}

		const iterator_cleanup = this.getCleanupCallsForCurrentScope();
		this.popScope();

		const iterator_type = iterator.type.decl;
		if this.program.options.optimization_level > 0 {
			if iterator_type.body is RangeIterator || iterator_type.body is NumericIterator {
				if iterator_type.body is NumericIterator && parsed_stmt.capture_kind != None {
					this.error("for loops over numeric ranges don't support capturing by reference", span);
					return this.getGarbageNode();
				}

				this.pushScope(ScopeKind::Loop);

				var enumerator_type = (iterator_type.template_parameters[0u].value as Type).value();
				if iterator_type.body is RangeIterator {
					const is_var_range = (iterator_type.template_parameters[1u].value as Boolean).value();
					if !is_var_range && parsed_stmt.capture_kind == Var {
						this.error("cannot take mutable reference to const range", this.getASTNodeSpan(range));
						return this.getGarbageNode();
					}

					enumerator_type = Type(enumerator_type.decl, parsed_stmt.capture_kind);
				}

				const enumerator_var = this.current_function.createVariable(span, parsed_stmt.capture_name, enumerator_type, enumerator_type.reference_kind == Const, is_comptime);
				this.createDestructorCall(enumerator_var);
				this.addVariableToCurrentScope(enumerator_var);

				const body = this.checkStmt(parsed_stmt.body);
				if !this.isASTNodeTerminator(body, this.isCurrentScopeInsideMatch()) {
					this.addChildrenToCompoundStmt(body, this.getCleanupCallsForCurrentScope());
				}
				this.popScope();

				const kind = ForStmtKind::Range if iterator_type.body is RangeIterator else ForStmtKind::Count;

				var result: List!<uint>;
				result.append(this.addASTNode(Node::ForStmt(ForStmt(this.addASTNode(iterator), enumerator_var, body, kind), span, this.program.void_type, false)));
				result.append(iterator_cleanup);
				this.replaceASTNode(id, Node::CompoundStmt(result, span, this.program.void_type, false));
				return id;
			}
		}

		const for_stmt = this.createGenericForStmt(id, iterator, iterator_cleanup, parsed_stmt, is_comptime, span);
		if for_stmt is Garbage {
			return this.getGarbageNode();
		}

		this.replaceASTNode(id, for_stmt);
		return id;
	}

	func createGenericForStmt(this: &&TCContext, id: uint, iterator_call: Node, iterator_cleanup: &List!<uint>, parsed_stmt: &ParsedForStmt, is_comptime: bool, span: Span) -> Node {
		var iterator_var: SharedHandle!<VarDecl>;

		match iterator_call {
			case DereferenceExpr: base -> match this.getASTNode(base) {
				case CallExpr: &call_expr -> iterator_var = call_expr.result_var;
				else -> return Node::Garbage(Span(), Type::unknown(), false);
			}
			case CallExpr: &call_expr -> iterator_var = call_expr.result_var;
			else -> return Node::Garbage(Span(), Type::unknown(), false);
		};

		const iterator_var_expr = this.addASTNode(Node::DereferenceExpr(
			this.addASTNode(Node::VarInvokeExpr(iterator_var, iterator_call.span, iterator_var.type.varRef(), false)),
			iterator_call.span, iterator_var.type, false
		));

		this.pushScope(ScopeKind::Expr);
		const condition = this.addASTNode(this.checkCall(Name("hasNext"), List!<uint>(1u, iterator_var_expr), false, false, CallKind::MemberCall, is_comptime, iterator_call.span));
		const condition_cleanup = this.getCleanupCallsForCurrentScope();
		this.popScope();

		const condition_type = this.getASTNodeType(condition);
		if condition_type.isUnknown() {
			return Node::Garbage(Span(), Type::unknown(), false);
		}

		if condition_type != this.program.bool_type {
			this.error("invalid condition type: expected " + this.program.bool_type.signature() + " but got " + condition_type.signature(), this.getASTNodeSpan(condition));
			return Node::Garbage(Span(), Type::unknown(), false);
		}

		this.pushScope(ScopeKind::Loop);

		var initializer: List!<uint>;
		var next_value = this.addASTNode(this.checkCall(Name("getNext"), List!<uint>(1u, iterator_var_expr), false, false, CallKind::MemberCall, is_comptime, parsed_stmt.capture_span));
		if next_value <= 1 {
			return Node::Garbage(Span(), Type::unknown(), false);
		}

		if parsed_stmt.capture_kind != None {
			next_value = this.removeDereference(next_value);
			var next_value_type = this.getASTNodeType(next_value);
			if next_value_type.reference_kind == None {
				this.error("can't take reference of constant", this.getASTNodeSpan(next_value));
				return Node::Garbage(Span(), Type::unknown(), false);
			} else if next_value_type.reference_kind == Const && parsed_stmt.capture_kind == Var {
				this.error("can't take var reference of const object", this.getASTNodeSpan(next_value));
				return Node::Garbage(Span(), Type::unknown(), false);
			}
			next_value_type.reference_kind = parsed_stmt.capture_kind;
			this.setASTNodeType(next_value, next_value_type);
		}

		initializer.append(next_value);
		const next_value_type = this.getASTNodeType(next_value);
		const variable = this.current_function.createVariable(parsed_stmt.capture_span, parsed_stmt.capture_name, next_value_type, next_value_type.reference_kind == Const, is_comptime);

		this.createConstructorCall(variable, initializer);
		this.createDestructorCall(variable);

		this.addVariableToCurrentScope(variable);

		var body: List!<uint>;
		body.append(this.addASTNode(Node::LifeTimeStart(variable, parsed_stmt.capture_span, this.program.void_type, false)));
		body.append(this.checkStmt(parsed_stmt.body));

		if !this.isASTNodeTerminator(body[body.size() - 1], this.isCurrentScopeInsideMatch()) {
			body.append(this.getCleanupCallsForCurrentScope());
		}

		this.popScope();

		var result: List!<uint>;
		result.append(this.addASTNode(iterator_call));
		result.append(this.addASTNode(Node::WhileStmt(WhileStmt(
			condition, condition_cleanup,
			this.addASTNode(Node::CompoundStmt(body, this.getASTNodeSpan(parsed_stmt.body), this.program.void_type, false)),
			0u, 0u, WhileStmtKind::While
		), span, this.program.void_type, false)));
		result.append(iterator_cleanup);

		return Node::CompoundStmt(result, span, this.program.void_type, false);
	}

	func checkCaseStmt(this: &&TCContext, id: uint, stmt: CaseStmt, span: Span) -> uint {
		if this.match_type.isUnknown() {
			this.error("case statement outside of a match statement", span);
			return this.getGarbageNode();
		}

		const match_type_decl = this.match_type.decl;

		for &&id in stmt.patterns {
			if match_type_decl.body is Variant {
				var case_name = "";
				const name = this.checkName(id);
				if name.segments.size() != 1 {
					this.error("invalid variant case as match patter", this.getASTNodeSpan(id));
				} else if !name.segments[0u].template_parameters.isEmpty() {
					this.error("invalid variant case as match patter", this.getASTNodeSpan(id));
				} else {
					case_name = name.segments[0u].name;
				}

				const pattern = match_type_decl.getVariantCase(case_name) else {
					this.error("unknown variant case", this.getASTNodeSpan(id));
					continue;
				}

				this.replaceASTNode(id, Node::IntegerLiteralExpr(pattern.id, pattern.span, match_type_decl.id_type, false));
			} else {
				id = this.checkNode(id, this.match_type, false);
				if id > 1 && this.getASTNodeType(id) != this.match_type {
					this.error("pattern has invalid type: expected '" + this.match_type.signature() + "' but got '" + this.getASTNodeType(id).signature() + "'", this.getASTNodeSpan(id));
					continue;
				}
			}
		}

		this.pushScope(ScopeKind::Compound);
		defer this.popScope();
		var result: List!<uint>;

		if !stmt.capture_name.isEmpty() {
			if stmt.patterns.size() != 1 {
				this.error("capturing case statements must have exactly 1 pattern", span);
				return this.getGarbageNode();
			}

			if !(match_type_decl.body is Variant) {
				this.error("capturing works only on variant types", span);
				return this.getGarbageNode();
			}

			const case_id = (this.getASTNode(stmt.patterns[0u]) as IntegerLiteralExpr).value();
			const case_decl = match_type_decl.getVariantCase(case_id).value();

			var capture_init_template_parameters: List!<TemplateParameter>;
			capture_init_template_parameters.append(TemplateParameter::Integer(case_id));

			var capture_init = this.addASTNode(this.checkCall(
				Name("operator unsafe as", capture_init_template_parameters),
				List!<uint>(1u, this.match_value),
				false, false, CallKind::MemberCall, false, span
			));

			var capture_type = this.getASTNodeType(capture_init);
			capture_type.reference_kind = stmt.capture_kind;
			if stmt.capture_kind != None {
				capture_init = this.removeDereference(capture_init);
			}

			const variable = this.current_function.createVariable(span, stmt.capture_name, capture_type, capture_type.reference_kind != Var, false);

			this.createConstructorCall(variable, List!<uint>(1u, capture_init));
			this.createDestructorCall(variable);

			this.addVariableToCurrentScope(variable);

			result.append(this.addASTNode(Node::LifeTimeStart(variable, span, this.program.void_type, false)));
		}

		stmt.body = this.checkStmt(stmt.body);
		result.append(stmt.body);
		if !this.isASTNodeTerminator(stmt.body, true) {
			result.append(this.getCleanupCallsForCurrentScope());
		}

		stmt.body = this.addASTNode(Node::CompoundStmt(result, span, this.program.void_type, false));

		this.replaceASTNode(id, Node::CaseStmt(stmt, span, this.program.void_type, false));
		return id;
	}

	func checkElseCaseStmt(this: &&TCContext, id: uint, body: uint, span: Span) -> uint {
		this.pushScope(ScopeKind::Compound);
		defer this.popScope();

		body = this.checkStmt(body);
		if body <= 1 {
			return this.getGarbageNode();
		}

		var result: List!<uint>;
		result.append(body);
		if !this.isASTNodeTerminator(body, true) {
			result.append(this.getCleanupCallsForCurrentScope());
		}

		body = this.addASTNode(Node::CompoundStmt(result, span, this.program.void_type, false));
		this.replaceASTNode(id, Node::ElseCaseStmt(body, span, this.program.void_type, false));
		return id;
	}

	func checkDeferStmt(this: &&TCContext, id: uint, body: uint, span: Span) -> uint {
		this.pushScope(ScopeKind::Compound);

		body = this.checkStmt(body);
		if body == 1 {
			this.popScope();
			return this.getGarbageNode();
		}

		var result: List!<uint>;
		result.append(body);
		result.append(this.getCleanupCallsForCurrentScope());
		this.replaceASTNode(id, Node::CompoundStmt(result, span, this.program.void_type, false))

		this.popScope();
		this.scope_stack[this.scope_stack.size() - 1].cleanup.insert(0u, id);
		return this.getEmptyNode();
	}

	func checkThrowStmt(this: &&TCContext, id: uint, value: uint, span: Span) -> uint {
		const return_type_decl = this.current_return_type.decl;
		const c = return_type_decl.getVariantCase("Error") else {
			this.error("invalid return type for throw: expected std::core::Result or similar, but got " + this.current_return_type.signature(), span);
			return this.getGarbageNode();
		}

		this.pushScope(ScopeKind::Expr);
		value = this.addASTNode(this.createTemporaryVariable(
			this.current_return_type,
			List!<TemplateParameter>(1u, TemplateParameter::Integer(c.id)),
			List!<uint>(1u, this.checkNode(value, c.type, false)),
			false,
			span
		));
		const value_cleanup = this.getCleanupCallsForCurrentScope();
		this.popScope();

		this.replaceASTNode(id, this.createReturnStmt(value, value_cleanup, span));
		return id;
	}

	func checkReturnStmt(this: &&TCContext, id: uint, value: uint, span: Span) -> uint {
		this.pushScope(ScopeKind::Expr);
		value = this.checkNode(value, this.current_return_type, false);

		const value_type = this.getASTNodeType(value);
		if value_type.decl.isAlive() {
			const type_decl = value_type.decl;
			if value_type != this.current_return_type && type_decl.unwrapped_type == this.current_return_type.decl && value_type.reference_kind == this.current_return_type.reference_kind {
				value = this.addASTNode(this.checkCall(Name("operator unwrap"), List!<uint>(1u, value), false, false, CallKind::MemberCall, false, span));
				if this.current_return_type.reference_kind != None {
					value = this.removeDereference(value);
					this.setASTNodeType(value, this.current_return_type);
				}
			}
		}

		const value_cleanup = this.getCleanupCallsForCurrentScope();
		this.popScope();

		this.replaceASTNode(id, this.createReturnStmt(value, value_cleanup, span));
		return id;
	}

	func createReturnStmt(this: &&TCContext, value: uint, value_cleanup: &List!<uint>, span: Span) -> Node {
		if this.getASTNode(value) is Garbage || this.current_return_type.isUnknown() {
			return Node::ReturnStmt(value, span, this.program.void_type, false);
		}

		const value_type = this.getASTNodeType(value);
		if value_type != this.current_return_type {
			this.error("invalid return type: expected " + this.current_return_type.signature() + ", but got " + value_type.signature(), this.getASTNodeSpan(value));
			return Node::ReturnStmt(this.getGarbageNode(), span, this.program.void_type, false);
		}

		var result: List!<uint>;
		if value_type == this.program.void_type || value_type == this.program.void_type {
			result.append(value);
			result.append(value_cleanup);
			result.append(this.collectCleanupCalls(ScopeKind::Function));
			result.append(this.addASTNode(Node::ReturnStmt(this.getEmptyNode(), span, this.program.void_type, false)));
			return Node::CompoundStmt(result, span, this.program.void_type, false);
		}

		var parameters: List!<uint>;
		parameters.append(this.addASTNode(Node::VarInvokeExpr(this.return_variable, span, this.current_return_type.varRef(), false)));
		parameters.append(value);

		if this.current_return_type.reference_kind == None {
			result.append(this.addASTNode(this.checkCall(Name("constructor"), parameters, false, false, CallKind::MemberCall, false, span)));
		} else {
			result.append(this.addASTNode(Node::ShallowCopyExpr(ShallowCopyExpr(parameters[0u], parameters[1u]), span, this.program.void_type, false)));
		}

		value = this.addASTNode(Node::VarInvokeExpr(this.return_variable, span, this.current_return_type.varRef(), false));

		if this.current_return_type.reference_kind == None {
			value = this.addASTNode(Node::DereferenceExpr(value, span, this.current_return_type, false));
			this.setASTNodeType(value, this.current_return_type);
		}

		result.append(value_cleanup);
		result.append(this.collectCleanupCalls(ScopeKind::Function));
		result.append(this.addASTNode(Node::ReturnStmt(value, span, this.program.void_type, false)));

		return Node::CompoundStmt(result, span, this.program.void_type, false);
	}

	func checkYieldStmt(this: &&TCContext, id: uint, value: uint, span: Span) -> uint {
		this.pushScope(ScopeKind::Expr);
		value = this.checkNode(value, this.yield_type, false);
		const value_cleanup = this.getCleanupCallsForCurrentScope();
		this.popScope();

		if value <= 1 {
			return this.getGarbageNode();
		}

		const value_type = this.getASTNodeType(value);
		if this.yield_type.isUnknown() {
			this.yield_type = value_type;
		} else if value_type != this.yield_type {
			this.error("invalid yield type: expected " + this.yield_type.signature() + " but got " + value_type.signature(), span);
			return this.getGarbageNode();
		}

		var result: List!<uint>;
		if value_type == this.program.void_type {
			result.append(value);
		} else {
			if !this.yield_var.isAlive() {
				this.yield_var = this.current_function.createVariable(Span(), "#yield_var", value_type, value_type.reference_kind != Var, false);
				this.createDestructorCall(this.yield_var);
			}

			if this.yield_type.reference_kind == None {
				var constructor_args: List!<uint>;
				constructor_args.append(this.addASTNode(Node::VarInvokeExpr(this.yield_var, span, this.yield_type.varRef(), false)));
				constructor_args.append(value);

				const constructor_call = this.checkCall(Name("constructor"), constructor_args, false, false, CallKind::MemberCall, false, span);
				if constructor_call is Garbage {
					return this.getGarbageNode();
				}
				result.append(this.addASTNode(constructor_call));
			} else {
				result.append(this.addASTNode(Node::ShallowCopyExpr(
					ShallowCopyExpr(this.addASTNode(Node::VarInvokeExpr(this.yield_var, span, this.yield_type.varRef(), false)), value),
					span, this.program.void_type, false
				)));
			}
		}

		result.append(value_cleanup);
		result.append(this.collectCleanupCalls(ScopeKind::Match));
		result.append(this.addASTNode(Node::YieldStmt(this.getEmptyNode(), span, this.program.void_type, false)));
		this.replaceASTNode(id, Node::CompoundStmt(result, span, this.program.void_type, false));
		return id;
	}

	func checkDiscardStmt(this: &&TCContext, id: uint, expr: uint, span: Span, is_comptime: bool) -> uint {
		this.pushScope(ScopeKind::Expr);
		expr = this.checkNode(expr, Type::unknown(), is_comptime);
		defer this.popScope();

		if expr <= 1 {
			return this.getGarbageNode();
		}

		var result: List!<uint>;
		result.append(expr);
		if !this.isASTNodeTerminator(expr, this.isCurrentScopeInsideMatch()) {
			result.append(this.getCleanupCallsForCurrentScope());
		}

		this.replaceASTNode(id, Node::CompoundStmt(result, span, this.program.void_type, false));
		return id;
	}

	func checkExprList(this: &&TCContext, expressions: &&List!<uint>, is_comptime: bool) -> bool {
		var has_errors = false;
		for &&id in expressions {
			const prev_id = id;
			id = this.checkNode(id, Type::unknown(), is_comptime);
			if id <= 1 {
				has_errors = true;
			}
		}
		return !has_errors;
	}

	func checkNumberLiteralExpr(this: &&TCContext, id: uint, number_literal: ParsedNumber, postfix: String, expected_type: Type, span: Span) -> uint {
		if postfix == "" {
			if expected_type.isIntType() {
				this.replaceASTNode(id, Node::IntegerLiteralExpr(number_literal.toInt(), span, expected_type, false));
			} else if expected_type.isFloatType() {
				this.replaceASTNode(id, Node::FloatLiteralExpr(number_literal.toFloat(), span, expected_type, false));
			} else if number_literal.isInteger() && !number_literal.contains_decimal_point {
				this.replaceASTNode(id, Node::IntegerLiteralExpr(number_literal.toInt(), span, this.program.int_type, false));
			} else {
				this.replaceASTNode(id, Node::FloatLiteralExpr(number_literal.toFloat(), span, this.getType(Name("f64"), span), false));
			}
		} else if postfix == "i" {
			this.replaceASTNode(id, Node::IntegerLiteralExpr(number_literal.toInt(), span, this.program.int_type, false));
		} else if postfix == "u" {
			this.replaceASTNode(id, Node::IntegerLiteralExpr(number_literal.toInt(), span, this.program.uint_type, false));
		} else if postfix == "b" {
			this.replaceASTNode(id, Node::IntegerLiteralExpr(number_literal.toInt(), span, this.program.byte_type, false));
		} else if postfix == "f" {
			this.replaceASTNode(id, Node::FloatLiteralExpr(number_literal.toFloat(), span, this.getType(Name("f64"), span), false));
		} else {
			const bits = getNumericTypeBits(postfix) else {
				this.error("invalid number literal", span);
				return this.getGarbageNode();
			}

			const name = match postfix[0u] {
				case 'i'b -> yield "int";
				case 'u'b -> yield "uint";
				case 'f'b -> yield "float";
				else -> {
					this.error("invalid number literal postfix", span);
					return this.getGarbageNode();
				}
			}

			var template_parameters: List!<TemplateParameter>;
			template_parameters.append(TemplateParameter::Integer(bits as int));
			this.replaceASTNode(id, Node::IntegerLiteralExpr(number_literal.toInt(), span, this.getType(Name(name, template_parameters), span), false));
		}

		return id;
	}

	func checkCharLiteralExpr(this: &&TCContext, id: uint, char_literal: byte, postfix: String, span: Span) -> uint {
		if postfix == "b" {
			this.replaceASTNode(id, Node::IntegerLiteralExpr(char_literal as int, span, this.program.byte_type, false));
		} else {
			const bits = getNumericTypeBits(postfix) else {
				this.error("invalid char literal", span);
				return this.getGarbageNode();
			}

			const name = match postfix[0u] {
				case 'i'b -> yield "int";
				case 'u'b -> yield "uint";
				else -> {
					this.error("invalid char literal postfix", span);
					return this.getGarbageNode();
				}
			}

			const template_parameters = List!<TemplateParameter>(1u, TemplateParameter::Integer(bits as int));
			this.replaceASTNode(id, Node::IntegerLiteralExpr(char_literal as int, span, this.getType(Name(name, template_parameters), span), false));
		}

		return id;
	}

	func createVarInvokeExpr(this: &&TCContext, variable: SharedHandle!<VarDecl>, span: Span) -> Node {
		if variable.type.isUnknown() {
			return Node::Garbage(span, Type::unknown(), false);
		}

		var type = variable.type;
		if type.reference_kind == None {
			if variable.is_const {
				type = variable.type.constRef();
			} else {
				type = variable.type.varRef();
			}
		}

		return Node::DereferenceExpr(this.addASTNode(Node::VarInvokeExpr(variable, span, type, false)), span, variable.type.base(), false);
	}

	func checkArrayExpr(this: &&TCContext, id: uint, elements: List!<uint>, expected_type: Type, is_comptime: bool, span: Span) -> uint {
		var expected_element_type = Type::unknown();
		if !expected_type.isUnknown() {
			const type_decl = expected_type.decl;
			if const array_type = type_decl.body as Array {
				expected_element_type = array_type.element_type;
			}
		}

		for &&id in elements {
			id = this.checkNode(id, expected_element_type, is_comptime);
			if expected_element_type.isUnknown() {
				expected_element_type = this.getASTNodeType(id);
			} else if expected_element_type != this.getASTNodeType(id) {
				this.error("array element has invalid type: expected " + expected_element_type.signature() + ", but got " + this.getASTNodeType(id).signature(), this.getASTNodeSpan(id));
			}
		}

		var template_parameters: List!<TemplateParameter>;
		template_parameters.append(TemplateParameter::Type(expected_element_type));
		template_parameters.append(TemplateParameter::Integer(elements.size() as int));
		const result_type = this.getType(Name("Array", template_parameters), span);

		const temporary_variable = this.createTemporaryVariable(
			result_type,
			List!<TemplateParameter>(),
			List!<uint>(1u, this.addASTNode(Node::ConstAggregateExpr(elements, span, result_type, false))),
			is_comptime,
			span
		);

		if temporary_variable is Garbage {
			return this.getGarbageNode();
		}

		this.replaceASTNode(id, temporary_variable);
		return id;
	}

	func checkTupleExpr(this: &&TCContext, id: uint, parsed_expr: &List!<TupleElement>, expected_type: Type, is_comptime: bool, span: Span) -> uint {
		var names: List!<String>;
		var elements: List!<uint>;
		var element_types: List!<Type>;

		var is_named = false;
		for parsed_element in parsed_expr {
			if parsed_element.name == "" {
				names.append(String(1u, ('a'b as uint + names.size()) as byte));
			} else {
				is_named = true;
				names.append(parsed_element.name);
			}

			const value = this.checkNode(parsed_element.value, Type::unknown(), is_comptime);
			elements.append(value);
			element_types.append(this.getASTNodeType(value));
		}

		if !is_named && elements.size() == 1 {
			// single expression wrapped in parenthesis
			return elements[0u];
		}

		var template_parameters: List!<TemplateParameter>;
		template_parameters.append(TemplateParameter::String(",".join(names)));
		for t in element_types {
			template_parameters.append(TemplateParameter::Type(t));
		}

		const temporary_variable = this.createTemporaryVariable(
			this.getType(Name("Tuple", template_parameters), span),
			List!<TemplateParameter>(), elements, is_comptime, span
		);

		if temporary_variable is Garbage {
			return this.getGarbageNode();
		}

		this.replaceASTNode(id, temporary_variable);
		return id;
	}

	func checkDictExpr(this: &&TCContext, id: uint, parsed_expr: &List!<DictElement>, expected_type: Type, is_comptime: bool, span: Span) -> uint {
		this.todo("implement typechecking of dict expressions", span);
		return this.getGarbageNode();
	}

	func checkMatchExpr(this: &&TCContext, id: uint, expr: &MatchExpr, expected_type: Type, is_comptime: bool, span: Span) -> uint {
		const match_expr = this.createMatchExpr(this.checkNode(expr.value, Type::unknown(), is_comptime), expr.body, expected_type, is_comptime, span);
		if match_expr is Garbage {
			return this.getGarbageNode();
		}
		this.replaceASTNode(id, match_expr);
		return id;
	}

	func addCasesToMatchExpr(this: &&TCContext, match_expr: &&MatchExpr, stmt: uint) -> void {
		match this.getASTNode(stmt) {
			case Empty | Garbage -> {}
			case CompoundStmt: &children -> {
				for child in children {
					this.addCasesToMatchExpr(&&match_expr, child);
				}
			}
			case CaseStmt -> match_expr.cases.append(stmt);
			case ElseCaseStmt: body -> {
				if match_expr.else_case == 0 {
					match_expr.else_case = body;
				} else {
					this.error("mutiple definitions of an else case in the same match expr", this.getASTNodeSpan(stmt));
					this.info("else case first declared here:", this.getASTNodeSpan(match_expr.else_case));
				}
			}
			else -> {
				this.error("expected case statement but got '" + this.getASTNode(stmt).name() + "'", this.getASTNodeSpan(stmt));
				this.info("", this.getASTNodeSpan(this.match_value));
			}
		}
	}

	func createMatchExpr(this: &&TCContext, value: uint, body: uint, expected_type: Type, is_comptime: bool, span: Span) -> Node {
		if value <= 1 {
			return Node::Garbage(span, Type::unknown(), false);
		}

		const prev_match_value = this.match_value;
		const prev_match_type = this.match_type;
		const prev_yield_type = this.yield_type;
		const prev_yield_var = this.yield_var;

		const value_type_decl = this.getASTNodeType(value).decl;
		if !((value_type_decl.body is Variant) || this.getASTNodeType(value).isIntType()) {
			this.error("value in match statement has invalid type: expected integral type or variant but got '" + this.getASTNodeType(value).signature() + "'", this.getASTNodeSpan(value));
		}

		var match_value_var = SharedHandle!<VarDecl>();
		if value_type_decl.body is Variant {
			value = this.removeDereference(value);

			match this.getASTNode(value) {
				case CallExpr: &call_expr -> match_value_var = call_expr.result_var;
				case MatchExpr: &match_expr -> match_value_var = match_expr.yield_var;
				else -> {}
			}

			if !match_value_var.isAlive() && !(this.getASTNode(value) is VarInvokeExpr) {
				const temporary_variable = this.createTemporaryVariable(
					this.getASTNodeType(value),
					List!<TemplateParameter>(),
					List!<uint>(1u, value),
					is_comptime,
					this.getASTNodeSpan(value)
				);

				match temporary_variable {
					case DereferenceExpr: base -> value = base;
					else -> value = this.addASTNode(temporary_variable);
				}

				match this.getASTNode(value) {
					case CallExpr: &call_expr -> match_value_var = call_expr.result_var;
					case ShallowCopyExpr: &shallow_copy_expr -> match this.getASTNode(shallow_copy_expr.destination) {
						case VarInvokeExpr: variable -> match_value_var = variable;
						else -> panic("invalid temporary variable");
					}
					case Garbage -> return Node::Garbage(span, Type::unknown(), false);
					else -> panic("invalid temporary variable");
				}
			}
		}

		if match_value_var.isAlive() {
			const var_invoke_expr = this.createVarInvokeExpr(match_value_var, this.getASTNodeSpan(this.match_value));
			match var_invoke_expr {
				case DereferenceExpr: base -> this.match_value = base;
				else -> this.match_value = this.addASTNode(var_invoke_expr);
			}
		} else {
			this.match_value = value;
		}

		this.match_type = this.getASTNodeType(this.match_value);
		this.yield_type = expected_type;
		this.yield_var = SharedHandle!<VarDecl>();

		this.pushScope(ScopeKind::Match);
		var match_expr = MatchExpr(value, this.getEmptyNode(), List!<uint>(), this.getEmptyNode(), SharedHandle!<VarDecl>());
		this.addCasesToMatchExpr(&&match_expr, this.checkStmt(body));
		this.popScope();

		var result_type = this.program.void_type;
		var does_yield = false;
		if this.yield_var.isAlive() {
			this.addVariableToCurrentScope(this.yield_var);
			result_type = this.yield_var.type.constRef();
			does_yield = true;
		}

		var all_cases_are_terminators = true;
		for case_stmt in match_expr.cases {
			all_cases_are_terminators &= this.isASTNodeTerminator((this.getASTNode(case_stmt) as CaseStmt).value().body, false);
		}

		if match_expr.else_case > 1 {
			all_cases_are_terminators &= this.isASTNodeTerminator(match_expr.else_case, false);
		}

		if all_cases_are_terminators && !does_yield {
			result_type = this.program.never_type;
		}

		var covered_cases: Set!<int>;
		for case_stmt in match_expr.cases {
			for pattern in (this.getASTNode(case_stmt) as CaseStmt).value().patterns {
				match this.getASTNode(pattern) {
					case IntegerLiteralExpr: value -> {
						if covered_cases.contains(value) {
							this.error("duplicated match pattern", this.getASTNodeSpan(pattern));
						} else {
							covered_cases.add(value);
						}
					}
					else -> {
						this.todo("check match completeness for non-int expressions (" + this.getASTNodeType(pattern).signature() + ")", this.getASTNodeSpan(pattern));
					}
				}
			}
		}

		var number_of_possible_cases = 0u;
		match value_type_decl.body {
			case Bool -> number_of_possible_cases = 2;
			case Byte -> number_of_possible_cases = 256;
			case Int: size -> {
				if size == 0 {
					number_of_possible_cases = -1 as uint; // ptr sized max int
				} else {
					number_of_possible_cases = pow(2.0, size as f64) as uint;
				}
			}
			case UInt: size -> {
				if size == 0 {
					number_of_possible_cases = -1 as uint; // ptr sized max int
				} else {
					number_of_possible_cases = pow(2.0, size as f64) as uint;
				}
			}
			case Enum -> number_of_possible_cases = value_type_decl.enum_cases.size();
			case Variant -> number_of_possible_cases = value_type_decl.variant_cases.size();
			else -> {}
		}

		if covered_cases.size() < number_of_possible_cases && match_expr.else_case == 0 {
			this.error("match stmt doesn't cover all possible cases", this.getASTNodeSpan(value));
		} else if covered_cases.size() == number_of_possible_cases && match_expr.else_case > 1 {
			this.error("else branch is unreachable", this.getASTNodeSpan(match_expr.else_case));
		}

		match_expr.yield_var = this.yield_var;
		const result = Node::MatchExpr(match_expr, span, result_type, false);

		this.match_value = prev_match_value;
		this.match_type = prev_match_type;
		this.yield_type = prev_yield_type;
		this.yield_var = prev_yield_var;

		if result_type.reference_kind == None {
			return result;
		} else {
			return Node::DereferenceExpr(this.addASTNode(result), result.span, result_type.base(), false);
		}
	}

	func checkNameExpr(this: &&TCContext, id: uint, expected_type: Type, is_comptime: bool, span: Span) -> uint {
		const name = this.checkName(id);

		var result_candidates: List!<Node>;
		for variable in this.lookupVariable(name, span) {
			result_candidates.append(this.createVarInvokeExpr(variable, span));
		}

		for case_decl in this.lookupCaseDecl(name, expected_type.decl, span) {
			match case_decl {
				case EnumCase: index -> result_candidates.append(
					Node::IntegerLiteralExpr(case_decl.parent_type.enum_cases[index].id, span, Type(case_decl.parent_type), false)
				);
				case VariantCase: index -> {
					var template_parameters: List!<TemplateParameter>;
					template_parameters.append(TemplateParameter::Integer(
						case_decl.parent_type.variant_cases[index].id
					));

					result_candidates.append(this.createTemporaryVariable(
						Type(case_decl.parent_type),
						template_parameters,
						List!<uint>(),
						is_comptime,
						span
					));
				}
			}
		}

		const last_segment = name.segments[name.segments.size() - 1];
		if name.segments.size() == 1 && last_segment.template_parameters.isEmpty() {
			for template_parameter in this.lookupTemplateParameter(last_segment.name) {
				match template_parameter {
					case Boolean: value -> result_candidates.append(Node::IntegerLiteralExpr(value as int, span, this.program.bool_type, false));
					case Integer: value -> {
						if expected_type.isIntType() {
							result_candidates.append(Node::IntegerLiteralExpr(value, span, expected_type, false));
						} else {
							result_candidates.append(Node::IntegerLiteralExpr(value, span, this.program.int_type, false));
						}
					}
					else -> {}
				}
			}
		}

		if result_candidates.isEmpty() {
			const type = this.getType(name, this.getASTNodeSpan(id), true);
			if !type.isUnknown() {
				result_candidates.append(Node::TypeRefExpr(type, span, this.program.typeref_type, false));
			}
		}

		if result_candidates.isEmpty() {
			this.error("no matching symbol found for '" + format(name) + "'", name.span);
			return this.getGarbageNode();
		} else if result_candidates.size() > 1 {
			this.error("too many matching symbols found", span);
			return this.getGarbageNode();
		} else if result_candidates[0u] is Garbage {
			return this.getGarbageNode();
		}

		this.replaceASTNode(id, result_candidates[0u]);
		return id;
	}

	func checkUnaryOperatorExpr(this: &&TCContext, id: uint, parsed_expr: &UnaryOperatorExpr, expected_type: Type, is_comptime: bool, span: Span) -> uint {
		match parsed_expr.op {
			case ConstRef | VarRef -> {
				var base = this.removeDereference(this.checkNode(parsed_expr.operand, Type::unknown(), is_comptime));
				if base <= 1 {
					return this.getGarbageNode();
				}

				var base_type = this.getASTNodeType(base);
				if base_type.reference_kind == None {
					this.error("object can't be referenced", this.getASTNodeSpan(base));
					return this.getGarbageNode();
				} else if base_type.reference_kind == Const && parsed_expr.op is VarRef {
					this.error("can't take var reference to const object", this.getASTNodeSpan(base));
					return this.getGarbageNode();
				}

				base_type.reference_kind = Const if parsed_expr.op is ConstRef else Var;
				this.setASTNodeType(base, base_type);
				return base;
			}
			case Try | Must -> return this.checkValidateExpr(id, parsed_expr.operand, parsed_expr.op, is_comptime, span);
			else -> {
				this.replaceASTNode(id, this.checkCall(
					Name("operator " + format(parsed_expr.op)),
					List!<uint>(1u, this.checkNode(parsed_expr.operand, Type::unknown(), is_comptime)),
					true, true, CallKind::Operator, is_comptime, span
				));
				return id;
			}
		}
	}

	func checkBinaryOperatorExpr(this: &&TCContext, id: uint, expr: &BinaryOperatorExpr, expected_type: Type, is_comptime: bool, span: Span) -> uint {
		match expr.op {
			case Namespace -> return this.checkNameExpr(id, expected_type, is_comptime, span);
			case Initialize -> {
				var lhs = this.removeDereference(this.checkNode(expr.lhs, Type::unknown(), is_comptime));
				if lhs <= 1 {
					return this.getGarbageNode();
				}

				const member_access_expr = this.getASTNode(lhs) as MemberVarInvokeExpr else {
					this.error("invalid initialize expr: object must be a member var invoke expr", span);
					return this.getGarbageNode();
				}

				const type_decl = this.getASTNodeType(member_access_expr.object).decl;

				const member_variable = type_decl.member_variables[member_access_expr.id];
				if member_variable.type.reference_kind == None {
					var arguments: List!<uint>;
					arguments.append(lhs);

					if this.getASTNode(expr.rhs).isAnonymousTuple() {
						const elements = (this.getASTNode(expr.rhs) as TupleExpr).value();
						for &element in elements {
							arguments.append(this.checkNode(element.value, Type::unknown(), is_comptime));
						}
					} else if expr.rhs >= 1 {
						arguments.append(this.checkNode(expr.rhs, member_variable.type, is_comptime));
					}

					this.replaceASTNode(id, this.checkCall(Name("constructor"), arguments, false, false, CallKind::MemberCall, is_comptime, span));
				} else {
					if this.active_member_variables.contains(member_access_expr.id) {
						this.error("double initialization of member variable", span);
						return this.getGarbageNode();
					}

					this.active_member_variables.add(member_access_expr.id);

					const rhs = this.checkNode(expr.rhs, member_variable.type, is_comptime);
					if this.getASTNodeType(rhs) != member_variable.type {
						this.error("initializer has invalid type: expected " + member_variable.type.signature() + " but got " + this.getASTNodeType(rhs).signature(), span);
					}

					this.replaceASTNode(id, Node::ShallowCopyExpr(ShallowCopyExpr(lhs, rhs), span, this.program.void_type, false));
				}
			}
			case Is -> return this.checkOperatorIsExpr(id, expr.lhs, expr.rhs, is_comptime, span);
			case As -> return this.checkOperatorAsExpr(id, expr.lhs, expr.rhs, is_comptime, span);
			case MemberAccess -> {
				const object = this.checkNode(expr.lhs, Type::unknown(), is_comptime);

				const parsed_member_name = this.getASTNode(expr.rhs) as Name else {
					this.error("expected member name", span);
					return this.getGarbageNode();
				}

				if !parsed_member_name.template_parameters.isEmpty() {
					this.error("invalid member name", span);
					return this.getGarbageNode();
				}

				const member_access_expr = this.createMemberAccessExpr(object, parsed_member_name.name, is_comptime, span);
				if member_access_expr is Garbage {
					return this.getGarbageNode();
				}

				this.replaceASTNode(id, member_access_expr);
			}
			else -> {
				var arguments: List!<uint>;
				arguments.grow(2u);
				arguments.append(this.checkNode(expr.lhs, Type::unknown(), is_comptime));
				arguments.append(this.checkNode(expr.rhs, this.getASTNodeType(arguments[0u]), is_comptime));

				const call_expr = this.checkCall(
					Name("operator " + format(expr.op)),
					arguments, true, true, CallKind::Operator, is_comptime, span
				);

				if call_expr is Garbage {
					return this.getGarbageNode();
				}

				this.replaceASTNode(id, call_expr);
			}
		}

		return id;
	}

	func checkCallExpr(this: &&TCContext, id: uint, call_expr: &CallExpr, expected_type: Type, is_comptime: bool, span: Span) -> uint {
		var arguments = call_expr.parameters;
		if !this.checkExprList(&&arguments, is_comptime) {
			return this.getGarbageNode();
		}

		var result = Node::Empty(span, Type::unknown(), false);

		const function_name = this.checkName(call_expr.callee);
		if function_name.segments.size() > 0 {
			const argument_types = this.getArgumentTypes(arguments, false);
			const matching_functions = this.lookupFunction(function_name, SharedHandle!<TypeDecl>(), argument_types, true, true, span);

			if matching_functions.isEmpty() {
				const matching_types = this.lookupType(function_name, span);
				const matching_variables = this.lookupVariable(function_name, span);
				const matching_case_decls = this.lookupCaseDecl(function_name, expected_type.decl, span);

				if matching_types.size() + matching_variables.size() + matching_case_decls.size() > 1 {
					this.error("too many matching symbols found", span);
					return this.getGarbageNode();
				}

				if matching_types.size() == 1 {
					result = this.createTemporaryVariable(matching_types[0u], List!<TemplateParameter>(), arguments, is_comptime, span);
				} else if matching_variables.size() == 1 {
					arguments.insert(0u, this.checkNode(call_expr.callee, Type::unknown(), is_comptime));
					result = this.checkCall(Name("operator ()"), arguments, true, true, CallKind::MemberCall, is_comptime, span);
				} else if matching_case_decls.size() == 1 {
					if const index = matching_case_decls[0u] as VariantCase {
						const parent_type = matching_case_decls[0u].parent_type;
						var template_parameters: List!<TemplateParameter>;
						template_parameters.append(TemplateParameter::Integer(parent_type.variant_cases[index].id));
						result = this.createTemporaryVariable(Type(parent_type), template_parameters, arguments, is_comptime, span);
					}
				}
			}

			if result is Empty {
				if !this.validateFunctionCanditates(matching_functions, function_name, argument_types, span) {
					return this.getGarbageNode();
				}

				result = this.createCall(matching_functions[0u], arguments, CallKind::Static, is_comptime, span);
			}
		} else if const operator_expr = this.getASTNode(call_expr.callee) as BinaryOperatorExpr {
			if operator_expr.op == MemberAccess {
				const name = this.checkName(operator_expr.rhs);
				if name.segments.size() > 0 {
					const object = this.checkNode(operator_expr.lhs, Type::unknown(), is_comptime);
					if object <= 1 {
						return this.getGarbageNode();
					}
					arguments.insert(0u, object);

					const parent_type = this.getASTNodeType(object).decl;
					const candidates = this.lookupFunction(name, parent_type, this.getArgumentTypes(arguments, true), true, true, span);

					if candidates.isEmpty() && name.segments.size() == 1 {
						if name.segments[0u].template_parameters.isEmpty() && parent_type.member_variables_by_name.contains(name.segments[0u].name) {
							const member_access_expr = this.createMemberAccessExpr(object, name.segments[0u].name, is_comptime, span);
							if member_access_expr is Garbage {
								return this.getGarbageNode();
							}

							arguments[0u] = this.addASTNode(member_access_expr);
							result = this.checkCall(Name("operator ()"), arguments, true, true, CallKind::MemberCall, is_comptime, span);
						}
					}

					if result is Empty {
						if !this.validateFunctionCanditates(candidates, name, this.getArgumentTypes(arguments, true), span) {
							return this.getGarbageNode();
						}

						result = this.createCall(candidates[0u], arguments, CallKind::MemberCall, is_comptime, span);
					}
				}
			}
		}

		if result is Empty {
			arguments.insert(0u, this.checkNode(call_expr.callee, Type::unknown(), is_comptime));
			result = this.checkCall(Name("operator ()"), arguments, true, true, CallKind::MemberCall, is_comptime, span);
		}

		if result is Garbage {
			return this.getGarbageNode();
		}

		this.replaceASTNode(id, result);
		return id;
	}

	func checkIndexExpr(this: &&TCContext, id: uint, operands: List!<uint>, expected_type: Type, is_comptime: bool, span: Span) -> uint {
		if !this.checkExprList(&&operands, is_comptime) {
			return this.getGarbageNode();
		}

		const call = this.checkCall(Name("operator []"), operands, true, true, CallKind::MemberCall, is_comptime, span);
		if call is Garbage {
			return this.getGarbageNode();
		}

		this.replaceASTNode(id, call);
		return id;
	}

	func createMemberAccessExpr(this: &&TCContext, object: uint, member_name: String, is_comptime: bool, span: Span) -> Node {
		object = this.removeDereference(object);
		if object <= 1 {
			return Node::Garbage(span, Type::unknown(), false);
		}

		var type_decl = this.getASTNodeType(object).decl;
		if type_decl.getMemberVariable(member_name) is None && !type_decl.unwrapped_type.isEmpty() {
			if type_decl.unwrapped_type.getMemberVariable(member_name) is Some {
				const unwrap_call = this.checkCall(
					Name("operator unwrap"), List!<uint>(1u, object),
					false, false, CallKind::MemberCall, is_comptime, span
				);

				match unwrap_call {
					case DereferenceExpr: base -> object = base;
					else -> object = this.addASTNode(unwrap_call);
				}

				type_decl = type_decl.unwrapped_type;
			}
		}

		const object_type = this.getASTNodeType(object);
		const member_variable = type_decl.getMemberVariable(member_name) else {
			this.error("no member variable with name '" + member_name + "' on type " + object_type.base().signature(), span);
			return Node::Garbage(span, Type::unknown(), false);
		}

		var result_type = member_variable.type;
		if result_type.reference_kind == None {
			result_type.reference_kind = object_type.reference_kind;
		}

		return Node::DereferenceExpr(
			this.addASTNode(Node::MemberVarInvokeExpr(MemberVarInvokeExpr(object, member_variable.id), span, result_type, false)),
			span, result_type.base(), false
		);
	}

	func checkValidateExpr(this: &&TCContext, id: uint, value: uint, op: Operator, is_comptime: bool, span: Span) -> uint {
		// try foo()
		// ->
		// match foo() {
		//     Ok: val -> yield val;
		//     Error: err -> throw err;
		// }

		// must foo()
		// ->
		// match foo() {
		//     Ok: val -> yield val;
		//     Error: err -> panic(err);
		// }

		value = this.checkNode(value, Type::unknown(), is_comptime);
		if value <= 1 {
			return this.getGarbageNode();
		}

		const value_type = this.getASTNodeType(value);

		const ok_case_decl = value_type.decl.getVariantCase("Ok") else {
			this.error("value has invalid type: expected std::core::Result or similar, but got " + value_type.signature(), span);
			return this.getGarbageNode();
		}

		const error_case_decl = value_type.decl.getVariantCase("Error") else {
			this.error("value has invalid type: expected std::core::Result or similar, but got " + value_type.signature(), span);
			return this.getGarbageNode();
		}

		var cases: List!<uint>;

		var yield_type = ok_case_decl.type;
		if yield_type == this.program.void_type {
			// case Ok -> yield
			cases.append(this.addASTNode(Node::CaseStmt(CaseStmt(
				List!<uint>(1u, this.addASTNode(Node::Name(ParsedName("Ok", List!<uint>()), span, Type::unknown(), false))),
				"", ok_case_decl.type.reference_kind,
				this.addASTNode(Node::YieldStmt(this.current_namespace.file.getEmptyNode(), span, Type::unknown(), false))
			), span, Type::unknown(), false)));
		} else {
			// case Ok: val -> yield val
			var value_invoke_expr = this.addASTNode(Node::Name(ParsedName("#value", List!<uint>()), span, Type::unknown(), false));
			match ok_case_decl.type.reference_kind {
				case Var -> value_invoke_expr = this.addASTNode(Node::UnaryOperatorExpr(UnaryOperatorExpr(Operator::VarRef, value_invoke_expr), span, Type::unknown(), false));
				case Const -> value_invoke_expr = this.addASTNode(Node::UnaryOperatorExpr(UnaryOperatorExpr(Operator::ConstRef, value_invoke_expr), span, Type::unknown(), false));
				else -> {}
			}

			cases.append(this.addASTNode(Node::CaseStmt(CaseStmt(
				List!<uint>(1u, this.addASTNode(Node::Name(ParsedName("Ok", List!<uint>()), span, Type::unknown(), false))),
				"#value", ok_case_decl.type.reference_kind,
				this.addASTNode(Node::YieldStmt(value_invoke_expr, span, Type::unknown(), false))
			), span, Type::unknown(), false)));
		}

		var error_invoke_expr = this.addASTNode(Node::Name(ParsedName("#error", List!<uint>()), span, Type::unknown(), false));
		match error_case_decl.type.reference_kind {
			case Var -> error_invoke_expr = this.addASTNode(Node::UnaryOperatorExpr(UnaryOperatorExpr(Operator::VarRef, error_invoke_expr), span, Type::unknown(), false));
			case Const -> error_invoke_expr = this.addASTNode(Node::UnaryOperatorExpr(UnaryOperatorExpr(Operator::ConstRef, error_invoke_expr), span, Type::unknown(), false));
			else -> {}
		}

		if op == Try {
			// case Error: error -> throw error
			cases.append(this.addASTNode(Node::CaseStmt(CaseStmt(
				List!<uint>(1u, this.addASTNode(Node::Name(ParsedName("Error", List!<uint>()), span, Type::unknown(), false))),
				"#error", error_case_decl.type.reference_kind,
				this.addASTNode(Node::ThrowStmt(error_invoke_expr, span, Type::unknown(), false))
			), span, Type::unknown(), false)));
		} else if op == Must {
			// case Error: error -> panic(error)
			const panic_function = this.addASTNode(Node::Name(ParsedName("panic", List!<uint>()), span, Type::unknown(), false));
			cases.append(this.addASTNode(Node::CaseStmt(CaseStmt(
				List!<uint>(1u, this.addASTNode(Node::Name(ParsedName("Error", List!<uint>()), span, Type::unknown(), false))),
				"#error", error_case_decl.type.reference_kind,
				this.addASTNode(Node::CallExpr(CallExpr(panic_function, List!<uint>(1u, error_invoke_expr), SharedHandle!<VarDecl>(), ReturnKind::None, SharedHandle!<FunctionDecl>()), span, Type::unknown(), false))
			), span, Type::unknown(), false)));
		} else {
			this.error("invalid operator for validate expr: must be try or must", span);
			abort();
		}

		const match_expr = this.createMatchExpr(value, this.addASTNode(Node::CompoundStmt(cases, span, Type::unknown(), false)), yield_type, is_comptime, span);

		if match_expr is Garbage {
			return this.getGarbageNode();
		} else {
			this.replaceASTNode(id, match_expr);
			return id;
		}
	}

	func checkInlineIfExpr(this: &&TCContext, id: uint, expr: &InlineIfExpr, expected_type: Type, is_comptime: bool, span: Span) -> uint {
		// x if y else z
		// ->
		// match y {
		//     true -> yield x;
		//     false -> yield z;
		// }

		var cases = List!<uint>();
		const then_value_span = this.getASTNodeSpan(expr.then_value);
		cases.append(this.addASTNode(Node::CaseStmt(CaseStmt(
			List!<uint>(1u, this.addASTNode(Node::BoolLiteralExpr(true, then_value_span, Type::unknown(), false))),
			"", ReferenceKind::None,
			this.addASTNode(Node::YieldStmt(expr.then_value, then_value_span, Type::unknown(), false))
		), then_value_span, Type::unknown(), false)));

		const else_value_span = this.getASTNodeSpan(expr.else_value);
		cases.append(this.addASTNode(Node::CaseStmt(CaseStmt(
			List!<uint>(1u, this.addASTNode(Node::BoolLiteralExpr(false, else_value_span, Type::unknown(), false))),
			"", ReferenceKind::None,
			this.addASTNode(Node::YieldStmt(expr.else_value, else_value_span, Type::unknown(), false))
		), else_value_span, Type::unknown(), false)));

		const condition = this.checkNode(expr.condition, this.program.bool_type, is_comptime);
		const match_expr = this.createMatchExpr(condition, this.addASTNode(Node::CompoundStmt(cases, span, Type::unknown(), false)), expected_type, is_comptime, span);

		if match_expr is Garbage {
			return this.getGarbageNode();
		} else {
			this.replaceASTNode(id, match_expr);
			return id;
		}
	}

	func checkOperatorIsExpr(this: &&TCContext, id: uint, lhs: uint, rhs: uint, is_comptime: bool, span: Span) -> uint {
		lhs = this.checkNode(lhs, Type::unknown(), is_comptime);
		if lhs <= 1 {
			return this.getGarbageNode();
		}

		const lhs_type_decl = this.getASTNodeType(lhs).decl;

		if lhs_type_decl.body is Enum {
			rhs = this.checkNode(rhs, Type(lhs_type_decl), is_comptime);
			if this.getASTNodeType(rhs) != Type(lhs_type_decl) {
				this.error("invalid rhs for 'operator is'", span);
				return this.getGarbageNode();
			}

			var arguments: List!<uint>;
			arguments.append(lhs);
			arguments.append(rhs);

			this.replaceASTNode(id, this.checkCall(Name("operator =="), arguments, false, false, CallKind::MemberCall, is_comptime, span));
			return id;
		} else if lhs_type_decl.body is Variant {
			var arguments: List!<uint>;
			arguments.append(lhs);

			const case_name = this.getASTNode(rhs) as Name else {
				this.error("invalid rhs for 'operator is'", span);
				return this.getGarbageNode();
			}

			if !case_name.template_parameters.isEmpty() {
				this.error("invalid rhs for 'operator is'", span);
				return this.getGarbageNode();
			}

			const case_decl = lhs_type_decl.getVariantCase(case_name.name) else {
				this.error("unknown variant case", span);
				return this.getGarbageNode();
			}

			var template_parameters: List!<TemplateParameter>;
			template_parameters.append(TemplateParameter::Integer(case_decl.id));

			this.replaceASTNode(id, this.checkCall(Name("operator is", template_parameters), arguments, false, false, CallKind::MemberCall, is_comptime, span));
			return id;
		} else {
			this.error("'operator is' requires lhs to be an enum or a variant instance", span);
			return this.getGarbageNode();
		}
	}

	func checkOperatorAsExpr(this: &&TCContext, id: uint, lhs: uint, rhs: uint, is_comptime: bool, span: Span) -> uint {
		lhs = this.checkNode(lhs, Type::unknown(), is_comptime);
		if lhs <= 1 {
			return this.getGarbageNode();
		}

		const source_type = this.getASTNodeType(lhs);
		if source_type.decl.body is Variant && this.getASTNode(rhs) is Name {
			const parsed_name = (this.getASTNode(rhs) as Name).value();
			if parsed_name.template_parameters.isEmpty() {
				if source_type.decl.getVariantCase(parsed_name.name).hasValue() {
					const cast = this.createSafeVariantCastExpr(lhs, parsed_name.name, is_comptime, span);
					if cast is Garbage {
						return this.getGarbageNode();
					} else {
						this.replaceASTNode(id, cast);
						return id;
					}
				}
			}
		}

		const target_type = this.checkTypeUsage(rhs, false);
		if target_type.isUnknown() {
			this.error("invalid target type for cast", this.getASTNodeSpan(rhs));
			return this.getGarbageNode();
		}

		var cast_name = "";
		if source_type.isIntType() && target_type.isIntType() {
			cast_name = "intCast";
		} else if source_type.isIntType() && target_type.isFloatType() {
			cast_name = "intToFloat";
		} else if source_type.isFloatType() && target_type.isIntType() {
			cast_name = "floatToInt";
		} else if source_type.isFloatType() && target_type.isFloatType() {
			cast_name = "floatCast";
		} else if source_type.isPtrType() && target_type.isPtrType() {
			cast_name = "pointerCast";
		}

		var cast_template_parameters: List!<TemplateParameter>;

		var call = Node::Garbage(Span(), Type::unknown(), false);
		if cast_name == "" { // lhs.operator as!<target_type>()
			cast_template_parameters.append(TemplateParameter::Type(target_type));
			call = this.checkCall(
				Name("operator as", cast_template_parameters),
				List!<uint>(1u, lhs),
				false, false, CallKind::MemberCall, is_comptime, span
			);
		} else {
			cast_template_parameters.append(TemplateParameter::Type(source_type));
			cast_template_parameters.append(TemplateParameter::Type(target_type));
			call = this.checkCall(
				Name(cast_name, cast_template_parameters),
				List!<uint>(1u, lhs),
				false, false, CallKind::Static, is_comptime, span
			);
		}

		if call is Garbage {
			return this.getGarbageNode();
		}
		this.replaceASTNode(id, call);
		return id;
	}

	func createSafeVariantCastExpr(this: &&TCContext, value: uint, case_name: String, is_comptime: bool, span: Span) -> Node {
		// x as Foo
		// ->
		// match x {
		//     case Foo: val -> yield Some(val);
		//     else -> yield None;
		// }

		const type_decl = this.getASTNodeType(value).decl;
		const case_decl = type_decl.getVariantCase(case_name).value();

		if case_decl.type == this.program.void_type {
			this.error("invalid variant cast: no type attached to this case", span);
			return Node::Garbage(Span(), Type::unknown(), false);
		}

		const yield_type = this.getType(Name("Optional", List!<TemplateParameter>(1u, TemplateParameter::Type(case_decl.type))), span);

		var value_invoke_expr = this.addASTNode(Node::Name(ParsedName("#value", List!<uint>()), span, Type::unknown(), false));
		match case_decl.type.reference_kind {
			case Var -> value_invoke_expr = this.addASTNode(Node::UnaryOperatorExpr(UnaryOperatorExpr(Operator::VarRef, value_invoke_expr), span, Type::unknown(), false));
			case Const -> value_invoke_expr = this.addASTNode(Node::UnaryOperatorExpr(UnaryOperatorExpr(Operator::ConstRef, value_invoke_expr), span, Type::unknown(), false));
			else -> {}
		}

		var cases: List!<uint>;

		// case Foo: val -> yield Some(val)
		const some_name = this.addASTNode(Node::Name(ParsedName("Some", List!<uint>()), span, Type::unknown(), false));
		cases.append(this.addASTNode(Node::CaseStmt(CaseStmt(
			List!<uint>(1u, this.addASTNode(Node::Name(ParsedName(case_name, List!<uint>()), span, Type::unknown(), false))),
			"#value", case_decl.type.reference_kind,
			this.addASTNode(Node::YieldStmt(
				this.addASTNode(Node::CallExpr(CallExpr(some_name, List!<uint>(1u, value_invoke_expr), SharedHandle!<VarDecl>(), ReturnKind::None, SharedHandle!<FunctionDecl>()), span, Type::unknown(), false)),
				span, Type::unknown(), false
			))
		), span, Type::unknown(), false)));

		// else -> yield None
		cases.append(this.addASTNode(Node::ElseCaseStmt(
			this.addASTNode(Node::YieldStmt(
				this.addASTNode(Node::Name(ParsedName("None", List!<uint>()), span, Type::unknown(), false)),
				span, Type::unknown(), false
			)),
			span, Type::unknown(), false
		)));

		return this.createMatchExpr(value, this.addASTNode(Node::CompoundStmt(cases, span, Type::unknown(), is_comptime)), yield_type, is_comptime, span);
	}

	func checkName(this: &&TCContext, id: uint) -> Name {
		match this.getASTNode(id) {
			case Name: name -> {
				var template_parameters: List!<TemplateParameter>;
				template_parameters.grow(name.template_parameters.size());
				for parameter in name.template_parameters {
					template_parameters.append(this.checkTemplateParameter(parameter));
				}

				return Name(this.getASTNodeSpan(id), name.name, template_parameters);
			}
			case BinaryOperatorExpr: operator_expr -> {
				if operator_expr.op == Namespace {
					return this.checkName(operator_expr.lhs)..this.checkName(operator_expr.rhs);
				}
			}
			else -> {}
		}

		return Name(this.getASTNodeSpan(id));
	}

	func checkTemplateParameter(this: &&TCContext, id: uint) -> TemplateParameter {
		if id <= 1 {
			return None;
		}

		const type = this.checkTypeUsage(id, true);
		if !type.isUnknown() {
			return TemplateParameter::Type(type);
		}

		id = this.checkNode(id, Type::unknown(), true);
		const result = this.interpret(this.getASTNode(id));
		match result {
			case Integer: val -> {
				if result.type == this.program.bool_type {
					return TemplateParameter::Boolean(val != 0);
				} else {
					return TemplateParameter::Integer(val);
				}
			}
			case String: val -> return TemplateParameter::String(val);
			case Type: type -> return TemplateParameter::Type(type);
			else -> this.error("invalid template parameter", this.getASTNodeSpan(id));
		}

		return TemplateParameter::Garbage;
	}

	func checkTypeUsage(this: &&TCContext, id: uint, quiet: bool) -> Type {
		match this.getASTNode(id) {
			case Empty -> return Type::unknown();
			case Name | BinaryOperatorExpr -> {
				const name = this.checkName(id);
				if !name.segments.isEmpty() {
					return this.getType(name, this.getASTNodeSpan(id), quiet);
				}
			}
			case UnaryOperatorExpr: operator_expr -> match operator_expr.op {
				case ConstRef | VarRef -> {
					const checked_base = this.checkTypeUsage(operator_expr.operand, quiet);
					if checked_base.reference_kind != None {
						if !quiet {
							this.error("double reference types aren't allowed", this.getASTNodeSpan(id));
						}

						return Type::unknown();
					}
					return checked_base.constRef() if operator_expr.op is ConstRef else checked_base.varRef();
				}
				else -> {}
			}
			case TupleExpr: &elements -> {
				var names: List!<String>;
				var types: List!<Type>;

				for &e in elements {
					const element_type = this.checkTypeUsage(e.value, quiet);
					if element_type.isUnknown() {
						return Type::unknown();
					}

					types.append(element_type);
					if e.name == "" {
						names.append(String(1u, ('a'b as uint + names.size()) as byte));
					} else {
						names.append(e.name);
					}
				}

				var template_parameters: List!<TemplateParameter>;
				template_parameters.append(TemplateParameter::String(",".join(names)));
				for t in types {
					template_parameters.append(TemplateParameter::Type(t));
				}

				return this.getType(Name("Tuple", template_parameters), this.getASTNodeSpan(id));
			}
			case FunctionType: &function_type -> {
				var parameter_types: List!<Type>;
				for t in function_type.parameter_types {
					parameter_types.append(this.checkTypeUsage(t, quiet));
				}

				const return_type = this.checkTypeUsage(function_type.return_type, quiet);
				return this.getFunctionType(parameter_types, return_type, this.getASTNodeSpan(id));
			}
			else -> {}
		}

		if !quiet {
			this.error("invalid type", this.getASTNodeSpan(id));
		}

		return Type::unknown();
	}

	func checkCall(this: &&TCContext, name: &Name, arguments: &List!<uint>, allow_unwrapping_this: bool, allow_unwrapping: bool, kind: CallKind, is_comptime: bool, span: Span) -> Node {
		for arg in arguments {
			if arg <= 1 {
				return Node::Garbage(span, Type::unknown(), false);
			}
		}

		const argument_types = this.getArgumentTypes(arguments, kind == MemberCall || kind == Operator);

		var parent_type = SharedHandle!<TypeDecl>();
		if kind == MemberCall || kind == Operator {
			parent_type = this.getASTNodeType(arguments[0u]).decl;
		}

		var candidates = this.lookupFunction(name, parent_type, argument_types, allow_unwrapping_this, allow_unwrapping, span);

		var negate_result = false;
		var compare_result_zero = false;
		const name_str = format(name);
		if candidates.isEmpty() && kind == Operator {
			if name_str == "operator ==" {
				candidates = this.lookupFunction(Name("operator !="), parent_type, argument_types, allow_unwrapping_this, allow_unwrapping, span);
				negate_result = true;
			} else if name_str == "operator !=" {
				candidates = this.lookupFunction(Name("operator =="), parent_type, argument_types, allow_unwrapping_this, allow_unwrapping, span);
				negate_result = true;
			}

			if candidates.isEmpty() && isComparisonOperator(name_str) {
				candidates = this.lookupFunction(Name("operator <=>"), parent_type, argument_types, allow_unwrapping_this, allow_unwrapping, span);
				compare_result_zero = true;
			}
		}

		if !this.validateFunctionCanditates(candidates, name, argument_types, span) {
			return Node::Garbage(span, Type::unknown(), false);
		}

		const result = this.createCall(candidates[0u], arguments, kind, is_comptime, span);
		if result is Garbage {
			return Node::Garbage(span, Type::unknown(), false);
		}

		if compare_result_zero {
			var cmp_arguments: List!<uint>;
			cmp_arguments.append(this.addASTNode(result));
			cmp_arguments.append(this.addASTNode(Node::IntegerLiteralExpr(0, span, result.type, false)));
			return this.checkCall(Name(name_str), cmp_arguments, false, false, CallKind::Operator, is_comptime, span);
		} else if negate_result {
			const not_arguments = List!<uint>(1u, this.addASTNode(result));
			return this.checkCall(Name("operator !"), not_arguments, false, false, CallKind::Operator, is_comptime, span);
		} else {
			return result;
		}
	}

	func isComparisonOperator(name: String) -> bool {
		return name == "operator ==" || name == "operator !="
			|| name == "operator <" || name == "operator <="
			|| name == "operator >" || name == "operator >=";
	}

	func unwrapArguments(this: &&TCContext, arguments: &&List!<uint>, required_parameter_types: &List!<Type>, is_comptime: bool) -> void {
		for i in 0u..arguments.size() {
			if this.getASTNodeType(arguments[i]).decl != required_parameter_types[i].decl {
				arguments[i] = this.addASTNode(this.checkCall(
					Name("operator unwrap"),
					List!<uint>(1u, arguments[i]),
					false, false,
					CallKind::MemberCall,
					is_comptime,
					this.getASTNodeSpan(arguments[i])
				));
			}

			if required_parameter_types[i].reference_kind != None {
				arguments[i] = this.removeDereference(arguments[i]);
			}

			if const base = this.getASTNode(arguments[i]) as DereferenceExpr {
				if const variable = this.getASTNode(base) as VarInvokeExpr {
					if !is_comptime && variable.is_comptime {
						arguments[i] = this.addASTNode(this.comptimeValueToASTNode(this.interpret(arguments[i]), this.getASTNodeSpan(arguments[i])));
					}
				}
			}
		}
	}

	func validateArgumentTypes(this: &&TCContext, arguments: &List!<uint>, required_parameter_types: &List!<Type>, span: Span) -> bool {
		for i in 0u..arguments.size() {
			const type = this.getASTNodeType(arguments[i]);
			if type == required_parameter_types[i] {
				continue;
			}

			if type.reference_kind == Var && required_parameter_types[i].reference_kind == Const {
				continue;
			}

			this.error("invalid parameter type for call", span);
			return false;
		}

		return true;
	}

	func createCall(this: &&TCContext, function: SharedHandle!<FunctionDecl>, arguments: List!<uint>, call_kind: CallKind, is_comptime: bool, span: Span) -> Node {
		this.unwrapArguments(&&arguments, function.parameter_types, is_comptime);
		if !this.validateArgumentTypes(arguments, function.parameter_types, span) {
			return Node::Garbage(span, Type::unknown(), is_comptime);
		}

		var return_kind = ReturnKind::None;
		var result_type = function.return_type;

		if call_kind == TempVar {
			return_kind = Parameter;
			result_type = function.parameter_types[0u].constRef();
		} else if !function.return_type.isPrimitive() {
			return_kind = Variable;
			result_type = function.return_type.constRef();
		} else if function.return_type == this.program.void_type || function.return_type == this.program.never_type {
			return_kind = None;
		} else {
			return_kind = Value;
		}

		if result_type.isUnknown() {
			this.error("function '" + function.signature() + "' has unknown return type", function.signature_span);
			return Node::Garbage(span, Type::unknown(), is_comptime);
		}

		var result_var: SharedHandle!<VarDecl>;
		if return_kind == Variable {
			if !this.current_function.isAlive() {
				this.todo("implement comptime calls, that return a non-primitive value", span);
				return Node::Garbage(span, Type::unknown(), is_comptime);
			}

			result_var = this.current_function.createVariable(span, "#result", result_type.base(), true, is_comptime);
			// no constructor call needed, the callee does that
			this.createDestructorCall(result_var);
			this.addVariableToCurrentScope(result_var);
		}

		this.checkActiveMembersForCall(arguments, function.name, span);

		var should_be_comptime = false;
		for i in 0u..arguments.size() {
			if const variable = this.getASTNode(arguments[i]) as VarInvokeExpr {
				if variable.is_comptime {
					should_be_comptime = true;
					break;
				}
			}
		}

		var call_expr = CallExpr(
			this.getEmptyNode(),
			arguments,
			result_var,
			return_kind,
			function
		);

		this.optimizeCallExpr(&&call_expr);

		var result = Node::CallExpr(call_expr, span, result_type, false);
		if should_be_comptime && !is_comptime {
			result = this.comptimeValueToASTNode(this.interpret(result), span);
		}

		if result.type.reference_kind != None {
			return Node::DereferenceExpr(this.addASTNode(result), span, result.type.base(), false);
		} else {
			return result;
		}
	}

	func createTemporaryVariable(this: &&TCContext, type: Type, template_parameters: &List!<TemplateParameter>, arguments: List!<uint>, is_comptime: bool, span: Span) -> Node {
		if type.isUnknown() {
			return Node::Garbage(span, Type::unknown(), false);
		}

		for &&arg in arguments {
			if arg <= 1 {
				return Node::Garbage(span, Type::unknown(), false);
			}
		}

		const variable = this.current_function.createVariable(span, "#tmp", type, true, is_comptime);

		this.createDestructorCall(variable);
		this.addVariableToCurrentScope(variable);

		if type.reference_kind == None {
			arguments.insert(0u, this.addASTNode(Node::VarInvokeExpr(variable, span, type.varRef(), false)));
			const argument_types = this.getArgumentTypes(arguments, true);

			const candidates = this.lookupFunction(Name("constructor", template_parameters), type.decl, argument_types, false, true, span);
			if !this.validateFunctionCanditates(candidates, Name("constructor", template_parameters), argument_types, span) {
				return Node::Garbage(span, Type::unknown(), false);
			}

			const constructor_decl = candidates[0u];
			this.unwrapArguments(&&arguments, constructor_decl.parameter_types, is_comptime);
			if !this.validateArgumentTypes(arguments, constructor_decl.parameter_types, span) {
				return Node::Garbage(span, Type::unknown(), false);
			}

			var constructor_call = CallExpr(this.getEmptyNode(), arguments, variable, ReturnKind::Parameter, candidates[0u]);
			this.optimizeCallExpr(&&constructor_call);

			return Node::DereferenceExpr(this.addASTNode(
				Node::CallExpr(constructor_call, span, type.varRef(), false)
			), span, type.base(), false);
		} else {
			if arguments.size() != 1 {
				this.error("invalid arguments for temporary variable of reference type", span);
				return Node::Garbage(span, Type::unknown(), false);
			}

			return Node::DereferenceExpr(this.addASTNode(
				Node::ShallowCopyExpr(ShallowCopyExpr(
					this.addASTNode(Node::VarInvokeExpr(variable, span, type, false)), arguments[0u]
				), span, type, false)
			), span, type.base(), false);
		}
	}

	func checkActiveMembersForCall(this: &&TCContext, arguments: &List!<uint>, function_name: String, span: Span) -> void {
		if !this.current_function.isAlive() {
			return;
		}

		if arguments.isEmpty() || this.current_function.parameter_types.isEmpty() {
			return;
		}

		if this.current_function.parameter_types[0u].decl != this.current_namespace.linked_type {
			return;
		}

		match this.getASTNode(arguments[0u]) {
			case MemberVarInvokeExpr: member_access_expr -> {
				const object = this.getASTNode(member_access_expr.object) as VarInvokeExpr else {
					return;
				}

				if object.id != 0 { // this parameter
					return;
				}

				if function_name == "constructor" {
					if this.active_member_variables.contains(member_access_expr.id) {
						this.error("double initialization of member variable", span);
					}

					this.active_member_variables.add(member_access_expr.id);
				} else if function_name == "destructor" {
					if !this.active_member_variables.contains(member_access_expr.id) {
						this.error("double de-initialization of member variable", span);
					}

					this.active_member_variables.remove(member_access_expr.id);
				}
			}
			case VarInvokeExpr: variable -> {
				if variable.id != 0 { // this parameter
					return;
				}

				const object_type_decl = variable.type.decl;
				if function_name == "constructor" {
					for variable in object_type_decl.member_variables {
						if this.active_member_variables.contains(variable.id) {
							this.error("double initialization of member variable '" + variable.name + "'", span);
						}

						this.active_member_variables.add(variable.id);
					}
				} else if function_name == "destructor" {
					for variable in object_type_decl.member_variables {
						if !this.active_member_variables.contains(variable.id) {
							this.error("double de-initialization of member variable '" + variable.name + "'", span);
						}

						this.active_member_variables.remove(variable.id);
					}
				}
			}
			else -> {}
		}
	}

	func optimizeCallExpr(this: &&TCContext, call_expr: &&CallExpr) -> void {
		if this.program.options.optimization_level == 0 {
			return;
		}

		eliminateCallResultCopies(&&call_expr, this.current_namespace.file);
	}

	func getArgumentTypes(this: &TCContext, arguments: &List!<uint>, is_member_call: bool) -> List!<Type> {
		var types: List!<Type>;
		types.grow(arguments.size());

		for i in 0u..arguments.size() {
			match this.getASTNode(arguments[i]) {
				case DereferenceExpr: base -> {
					const base_type = this.getASTNodeType(base);
					if is_member_call && i == 0 {
						types.append(base_type);
					} else {
						types.append(Type(base_type.decl, ReferenceKind::Const));
					}
				}
				else -> types.append(this.getASTNodeType(arguments[i]));
			}
		}

		return types;
	}

	// symbol lookup functions
	func lookupNamespace(this: &&TCContext, namespaces_to_search: &Set!<SharedHandle!<Namespace>>, name: &NameSegment, span: Span) -> Set!<SharedHandle!<Namespace>> {
		var result: Set!<SharedHandle!<Namespace>>;

		for n in namespaces_to_search {
			var most_matching_template_parameters = 0;
			var matching_children: List!<SharedHandle!<Namespace>>;

			for child in n.children_by_name.getOrDefault(name.name) {
				const matching_template_parameters = this.getMatchingTemplateParameterCount(child.template_parameters, name.template_parameters);
				if matching_template_parameters > most_matching_template_parameters {
					matching_children.clear();
					matching_children.append(child);
					most_matching_template_parameters = matching_template_parameters;
				} else if matching_template_parameters == most_matching_template_parameters {
					matching_children.append(child);
				}
			}

			result.grow(result.size() + matching_children.size());
			for child in matching_children {
				if child.isIncompleteTemplate() {
					result.add(this.createTemplateInstance(child, name.template_parameters, span));
				} else {
					result.add(child);
				}
			}

			if name.template_parameters.isEmpty() {
				if const target = n.aliases.get(name.name) {
					result.add(target);
				}
			}
		}

		return result;
	}

	func getNamespacesToSearch(this: &&TCContext, name: &Name, parent_type: SharedHandle!<TypeDecl>, span: Span) -> Set!<SharedHandle!<Namespace>> {
		var namespaces_to_search: Set!<SharedHandle!<Namespace>>;
		namespaces_to_search.grow(8u);

		if name.segments.size() == 1 {
			namespaces_to_search = this.current_namespace.visible_namespaces;
			if parent_type.isAlive() {
				namespaces_to_search.add(parent_type.linked_namespace);

				if parent_type.unwrapped_type.isAlive() {
					namespaces_to_search.add(parent_type.unwrapped_type.linked_namespace);
				}
			}
		} else {
			const name_segments: List!<NameSegment> = name.segments[0u..(name.segments.size() - 1)];
			for n in this.current_namespace.visible_namespaces {
				var matching_namespaces: Set!<SharedHandle!<Namespace>>;
				matching_namespaces.add(n);

				const intersecting_segments = n.full_name.intersection(name_segments);
				for i in intersecting_segments..name_segments.size() {
					matching_namespaces = this.lookupNamespace(matching_namespaces, name_segments[i], span);
				}

				namespaces_to_search.add(matching_namespaces);
			}
		}

		return namespaces_to_search;
	}

	func lookupTemplateParameter(this: &&TCContext, name: String) -> List!<TemplateParameter> {
		var result: List!<TemplateParameter>;

		if this.current_function.isAlive() {
			for template_parameter in this.current_function.template_parameters {
				if template_parameter.name == name && !(template_parameter.value is None) {
					result.append(template_parameter.value);
				}
			}
		}

		var current_namespace = this.current_namespace;
		while current_namespace.isAlive() {
			for template_parameter in current_namespace.template_parameters {
				if template_parameter.name == name && !(template_parameter.value is None) {
					result.append(template_parameter.value);
				}
			}

			current_namespace = current_namespace.parent;
		}

		return result;
	}

	func lookupType(this: &&TCContext, name: &Name, span: Span) -> List!<Type> {
		const namespaces_to_search = this.getNamespacesToSearch(name, SharedHandle!<TypeDecl>(), span);

		const last_segment = name.segments[name.segments.size() - 1];
		const is_templated_name = last_segment.template_parameters.size() > 0;
		const is_namespaced_name = name.segments.size() > 1;

		var result: List!<Type>;
		for n in this.lookupNamespace(namespaces_to_search, last_segment, span) {
			if n.linked_type.isAlive() {
				result.append(Type(n.linked_type));
			}
		}

		if !is_namespaced_name && !is_templated_name && namespaces_to_search.contains(this.program.core_namespace) {
			if const bits = getNumericTypeBits(last_segment.name) {
				var numeric_type_template_parameters: List!<TemplateParameter>;
				numeric_type_template_parameters.append(TemplateParameter::Integer(bits as int));

				const numeric_type_name = match last_segment.name[0u] {
					case 'i'b -> yield "int";
					case 'u'b -> yield "uint";
					case 'f'b -> yield "float";
					else -> panic("invalid numeric type");
				}

				for n in this.lookupNamespace(namespaces_to_search, NameSegment(numeric_type_name, numeric_type_template_parameters), span) {
					if n.linked_type.isAlive() {
						result.append(Type(n.linked_type));
					}
				}
			}
		}

		if !is_namespaced_name && !is_templated_name {
			for template_parameter in this.lookupTemplateParameter(last_segment.name) {
				match template_parameter {
					case Type: type -> result.append(type);
					else -> {}
				}
			}
		}

		return result;
	}

	func lookupFunction(this: &&TCContext, name: &Name, parent_type: SharedHandle!<TypeDecl>, parameter_types: &List!<Type>, allow_unwrapping_this: bool, allow_unwrapping: bool, span: Span) -> List!<SharedHandle!<FunctionDecl>> {
		var candidates: List!<SharedHandle!<FunctionDecl>>;

		const last_segment = name.segments[name.segments.size() - 1];
		for n in this.getNamespacesToSearch(name, parent_type, span) {
			var most_matching_template_parameters = 0;
			var functions_with_matching_template_parameters: List!<SharedHandle!<FunctionDecl>>;
			for function in n.functions_by_name.getOrDefault(last_segment.name) {
				const matching_template_parameters = this.getMatchingTemplateParameterCount(function.template_parameters, last_segment.template_parameters);

				if matching_template_parameters > most_matching_template_parameters {
					functions_with_matching_template_parameters.clear();
					functions_with_matching_template_parameters.append(function);
					most_matching_template_parameters = matching_template_parameters;
				} else if matching_template_parameters == most_matching_template_parameters {
					functions_with_matching_template_parameters.append(function);
				}
			}

			for function in functions_with_matching_template_parameters {
				if function.isIncompleteTemplate() {
					candidates.append(this.createTemplateInstance(function, last_segment.template_parameters, span));
				} else {
					candidates.append(function);
				}
			}
		}

		return this.selectMatchingFunctions(candidates, parameter_types, allow_unwrapping_this, allow_unwrapping);
	}

	func lookupCaseDecl(this: &&TCContext, name: &Name, parent_type: SharedHandle!<TypeDecl>, span: Span) -> List!<CaseDecl> {
		const last_segment = name.segments[name.segments.size() - 1];
		const is_templated_name = last_segment.template_parameters.size() > 0;
		const is_namespaced_name = name.segments.size() > 1;

		var result: List!<CaseDecl>;

		if !is_namespaced_name && parent_type.isAlive() {
			if const index = parent_type.enum_cases_by_name.get(last_segment.name) {
				result.append(CaseDecl::EnumCase(index, parent_type));
			}

			if const index = parent_type.variant_cases_by_name.get(last_segment.name) {
				result.append(CaseDecl::VariantCase(index, parent_type));
			}
		} else if is_namespaced_name {
			for n in this.getNamespacesToSearch(name, parent_type, span) {
				if n.linked_type.isEmpty() {
					continue;
				}

				if const index = n.linked_type.enum_cases_by_name.get(last_segment.name) {
					result.append(CaseDecl::EnumCase(index, n.linked_type));
				}

				if const index = n.linked_type.variant_cases_by_name.get(last_segment.name) {
					result.append(CaseDecl::VariantCase(index, n.linked_type));
				}
			}
		}

		return result;
	}

	func lookupVariable(this: &&TCContext, name: &Name, span: Span) -> List!<SharedHandle!<VarDecl>> {
		const last_segment = name.segments[name.segments.size() - 1];
		if last_segment.template_parameters.size() > 0 {
			return List!<SharedHandle!<VarDecl>>();
		}

		var result: List!<SharedHandle!<VarDecl>>;
		for n in this.getNamespacesToSearch(name, SharedHandle!<TypeDecl>(), span) {
			if const variable = n.comptime_variables_by_name.get(last_segment.name) {
				result.append(variable);
			}
		}

		if name.segments.size() == 1 {
			if const variable = this.getVariableByName(last_segment.name) {
				result.append(variable);
			}
		}

		return result;
	}

	func getType(this: &&TCContext, name: &Name, span: Span) -> Type {
		return this.getType(name, span, false);
	}

	func getType(this: &&TCContext, name: &Name, span: Span, quiet: bool) -> Type {
		const candidates = this.lookupType(name, span);
		if candidates.isEmpty() {
			if !quiet {
				this.error("no matching type found", span);
				this.info("looking for " + format(name), Span());
			}

			return Type::unknown();
		} else if candidates.size() == 1 {
			return candidates[0u];
		} else {
			if !quiet {
				this.error("more than one matching types found", span);
				this.info("looking for " + format(name), Span());
			}

			return Type::unknown();
		}
	}

	func getFunctionType(this: &&TCContext, parameter_types: &List!<Type>, return_type: Type, span: Span) -> Type {
		var template_parameters: List!<TemplateParameter>;
		template_parameters.append(TemplateParameter::Type(return_type));
		for t in parameter_types {
			template_parameters.append(TemplateParameter::Type(t));
		}

		return this.getType(Name("function", template_parameters), span);
	}

	func getNumericTypeBits(name: String) -> Optional!<uint> {
		if name.size() <= 1 {
			return None;
		}

		if name[0u] != 'i'b && name[0u] != 'u'b && name[0u] != 'f'b {
			return None;
		}

		const number_str = name.substring(1u..name.size());
		const number = parseNumber(number_str, 0u);

		if number.length < number_str.size() {
			return None;
		}

		return Some(number.toInt() as uint);
	}

	func selectMatchingFunctions(this: &&TCContext, candidates: &List!<SharedHandle!<FunctionDecl>>, parameter_types: &List!<Type>, allow_unwrapping_this: bool, allow_unwrapping: bool) -> List!<SharedHandle!<FunctionDecl>> {
		var result: List!<SharedHandle!<FunctionDecl>>;
		result.grow(4u);

		var most_matching_parameters = 0;
		for function in candidates {
			const matching_parameters = function.getMatchingParameterCount(parameter_types, allow_unwrapping_this, allow_unwrapping);

			if matching_parameters < most_matching_parameters {
				continue;
			} else if matching_parameters == 0 {
				result.append(function);
				continue;
			} else if matching_parameters > most_matching_parameters {
				result.clear();
				result.append(function);
				most_matching_parameters = matching_parameters;
				continue;
			}

			const ref_kind = function.parameter_types[0u].reference_kind;
			var inserted = false;

			for i in 0u..result.size() {
				if result[i].parameter_types[0u].reference_kind < ref_kind {
					result.insert(i, function);
					inserted = true;
					break;
				}
			}

			if !inserted {
				result.append(function);
			}
		}

		return result;
	}

	func validateFunctionCanditates(this: &&TCContext, candidates: &List!<SharedHandle!<FunctionDecl>>, required_name: &Name, required_parameter_types: &List!<Type>, span: Span) -> bool {
		if candidates.isEmpty() {
			this.error("no matching function found", span);
			this.info("looking for " + format(required_name) + format(required_parameter_types), Span());
			return false;
		}

		var no_ref_count = 0;
		var const_ref_count = 0;
		var var_ref_count = 0;
		var no_param_count = 0;

		for f in candidates {
			if f.parameter_types.isEmpty() {
				no_param_count++;
				continue;
			}

			match f.parameter_types[0u].reference_kind {
				case None -> no_ref_count++;
				case Const -> const_ref_count++;
				case Var -> var_ref_count++;
			}
		}

		if no_ref_count > 1 || const_ref_count > 1 || var_ref_count > 1 || no_param_count > 1 {
			this.error("too many matching functions found", span);
			this.info("candidates are:", Span());
			for f in candidates {
				this.info("    " + f.signature(), Span());
			}
			return false;
		}

		return true;
	}

	func getMatchingTemplateParameterCount(this: &&TCContext, template_decls: &List!<TemplateParameterDecl>, template_parameters: &List!<TemplateParameter>) -> int {
		if template_decls.size() == 0 {
			if template_parameters.size() == 0 {
				return 0;
			} else {
				return -1;
			}
		}

		const is_variadic = template_decls[template_decls.size() - 1].is_variadic;

		if template_parameters.size() < template_decls.size() {
			if !(is_variadic && template_parameters.size() == template_decls.size() - 1) {
				return -1;
			}
		} else if template_parameters.size() > template_decls.size() && !is_variadic {
			return -1;
		}

		var count = 0;
		for i in 0u..template_parameters.size() {
			const template_parameter_decl = &template_decls[min!<uint>(i, template_decls.size() - 1)];
			if !this.doesConceptAcceptTemplateParameter(template_parameter_decl.concept, template_parameters[i]) {
				return -1;
			}

			if template_parameter_decl.value is None {
				continue;
			}

			if template_parameter_decl.value != template_parameters[i] {
				return -1;
			} else {
				count += 1;
			}
		}

		return count;
	}

	func doesConceptAcceptTemplateParameter(this: &&TCContext, concept: &Concept, parameter: &TemplateParameter) -> bool {
		match concept {
			case Boolean -> return parameter is Boolean;
			case Integer -> return parameter is Integer;
			case String -> return parameter is String;
			case Any -> return parameter is Type;
		}
	}

	func getMatchingParameterCount(function: &FunctionDecl, parameter_types: &List!<Type>, allow_unwrapping_this: bool, allow_unwrapping: bool) -> int {
		if function.parameter_types.size() != parameter_types.size() {
			return -1;
		}

		var count = 0;
		for i in 0u..parameter_types.size() {
			const required_parameter_type = parameter_types[i];
			const function_parameter_type = function.parameter_types[i];

			if function_parameter_type.reference_kind > required_parameter_type.reference_kind {
				return -1;
			}

			if required_parameter_type.decl == function_parameter_type.decl {
				count++;
			} else if !((i != 0 && allow_unwrapping) || (i == 0 && allow_unwrapping_this)) {
				return -1;
			} else if required_parameter_type.decl.unwrapped_type != function_parameter_type.decl {
				return -1;
			}
		}

		return count;
	}

	func createTemplateInstance(this: &&TCContext, base: SharedHandle!<Namespace>, template_parameters: &List!<TemplateParameter>, error_span: Span) -> SharedHandle!<Namespace> {
		const prev_namespace = this.current_namespace;
		this.current_namespace = base.parent;

		var instance: SharedHandle!<Namespace>;
		if base.linked_type.isAlive() {
			const base_type = base.linked_type;
			var type_instance: SharedHandle!<TypeDecl>;
			match base_type.body {
				case Int | UInt | Float -> {
					const bits = (template_parameters[0u] as Integer).value();
					if bits < 0 {
						this.error("only numeric types with size >= 0 are allowed", error_span);
						return SharedHandle!<Namespace>();
					}

					match base_type.body {
						case Int -> type_instance = this.program.createIntTypeInstance(base.parent, true, bits).decl;
						case UInt -> type_instance = this.program.createIntTypeInstance(base.parent, false, bits).decl;
						case Float -> type_instance = this.program.createFloatTypeInstance(base.parent, bits).decl;
						else -> panic("unreachable");
					}

					const type = Type(type_instance);
					const range_type = this.getType(Name("NumericRange", List!<TemplateParameter>(1u, TemplateParameter::Type(type))), error_span);
					discard this.program.createBinaryFunction(type_instance.linked_namespace, "operator ..", type, type, range_type, BuiltinFunction::NumericTypeRangeOperator(range_type, type));
				}
				case Pointer: pointer_type -> {
					const pointee_type = (template_parameters[0u] as Type).value();
					const is_mutable = (template_parameters[1u] as Boolean).value();
					type_instance = this.program.createPtrTypeInstance(base.parent, is_mutable, pointee_type).decl;
				}
				case Function -> {
					const return_type = (template_parameters[0u] as Type).value();
					var parameter_types: List!<Type>;
					for i in 1u..template_parameters.size() {
						parameter_types.append((template_parameters[i] as Type).value());
					}

					type_instance = this.program.createFunctionTypeInstance(base.parent, parameter_types, return_type);
				}
				case Array -> {
					const element_type = (template_parameters[0u] as Type).value();
					const size = (template_parameters[1u] as Integer).value();

					if size < 0 {
						this.error("only array types with size >= 0 are allowed", error_span);
						return SharedHandle!<Namespace>();
					}

					var element_ptr_type_template_parameters: List!<TemplateParameter>;
					element_ptr_type_template_parameters.append(TemplateParameter::Type(element_type));

					const element_cptr_type = this.getType(Name("ptr", element_ptr_type_template_parameters + TemplateParameter::Boolean(false)), Span(), false);
					const element_vptr_type = this.getType(Name("ptr", element_ptr_type_template_parameters + TemplateParameter::Boolean(true)), Span(), false);

					type_instance = this.program.createArrayTypeInstance(base.parent, element_type, size as uint, element_cptr_type, element_vptr_type);
				}
				case Tuple -> {
					const names = (template_parameters[0u] as String).value().split(",");
					var elements: List!<Type>;
					for i in 1u..template_parameters.size() {
						elements.append((template_parameters[i] as Type).value());
					}

					if names.size() != elements.size() {
						this.error("name and element count not matching for tuple type", error_span);
						return SharedHandle!<Namespace>();
					}

					type_instance = this.program.createTupleTypeInstance(base.parent, names, elements);
				}
				case Range -> {
					const element_type = (template_parameters[0u] as Type).value();
					const is_mutable = (template_parameters[1u] as Boolean).value();
					const element_ptr_type = this.getType(Name("ptr", template_parameters), error_span);
					const iterator_type = this.getType(Name("RangeIterator", template_parameters), error_span);
					var mutable_range_type = Type::unknown();
					if !is_mutable {
						var template_parameters_2 = template_parameters;
						template_parameters_2[1u] = TemplateParameter::Boolean(true);
						mutable_range_type = this.getType(Name("Range", template_parameters_2), error_span);
					}
					type_instance = this.program.createRangeTypeInstance(base.parent, element_type, is_mutable, element_ptr_type, iterator_type, mutable_range_type);
				}
				case RangeIterator -> {
					const element_type = (template_parameters[0u] as Type).value();
					const is_mutable = (template_parameters[1u] as Boolean).value();
					const element_ptr_type = this.getType(Name("ptr", template_parameters), error_span);
					type_instance = this.program.createRangeIteratorTypeInstance(base.parent, element_type, is_mutable, element_ptr_type);
				}
				case NumericRange -> {
					const numeric_type = (template_parameters[0u] as Type).value();
					if !numeric_type.isIntType() && !numeric_type.isFloatType() {
						this.error("expected numeric type", error_span);
						this.todo("this should be filtered out using concepts", error_span);
						return SharedHandle!<Namespace>();
					}

					const iterator_type = this.getType(Name("NumericIterator", template_parameters), error_span);
					type_instance = this.program.createNumericRangeTypeInstance(base.parent, numeric_type, iterator_type);
				}
				case NumericIterator -> {
					const numeric_type = (template_parameters[0u] as Type).value();
					if !numeric_type.isIntType() && !numeric_type.isFloatType() {
						this.error("expected numeric type", error_span);
						this.todo("this should be filtered out using concepts", error_span);
						return SharedHandle!<Namespace>();
					}

					type_instance = this.program.createNumericIteratorTypeInstance(base.parent, numeric_type);
				}
				case Unchecked: &parsed_type -> type_instance = this.checkTypeDecl(
					parsed_type,
					getTemplateParameterDecls(base.template_parameters, template_parameters),
					base.span,
					this.current_target_state <= UncheckedTypeBodies,
					true
				);
				else -> {
					this.error("can't create template instance of type " + base.signature(), base.name_span);
					abort();
				}
			}

			instance = type_instance.linked_namespace;
		} else {
			instance = this.program.getOrCreateChildNamespace(base.name, getTemplateParameterDecls(base.template_parameters, template_parameters), base.parent, base.parent.file);
		}

		if instance == base || instance.isEmpty() {
			panic("bad template instance: " + base.signature() + " - " + format(template_parameters));
		}

		for parsed_decl in base.unchecked_bodies {
			const offset = this.current_namespace.file.duplicateNodes(parsed_decl.first_node_id, parsed_decl.last_node_id + 1);
			parsed_decl = (this.current_namespace.file.nodes[parsed_decl.last_node_id + offset] as NamespaceDecl).value();
			instance.addUncheckedBody(parsed_decl);
		}

		base.template_instances.append(instance);

		if instance.linked_type.isAlive() && this.current_target_state > UncheckedTypeBodies {
			discard this.check(instance, NamespaceState::UncheckedTypeBodies);
			this.checkTypeBody(instance.linked_type);
		}

		discard this.check(instance, this.current_target_state);

		this.current_namespace = prev_namespace;
		return instance;
	}

	func createTemplateInstance(this: &&TCContext, base: SharedHandle!<FunctionDecl>, template_parameters: &List!<TemplateParameter>, error_span: Span) -> SharedHandle!<FunctionDecl> {
		for &parameter in template_parameters {
			if const type = parameter as Type {
				discard this.check(type.decl.linked_namespace, NamespaceState::UncheckedFunctionBodies);
			}
		}

		const prev_namespace = this.current_namespace;
		this.current_namespace = base.parent_namespace;

		var instance: SharedHandle!<FunctionDecl>;

		match base.body {
			case Builtin: builtin_function -> match builtin_function {
				case Swap -> {
					const type = (template_parameters[0u] as Type).value();
					instance = this.program.createFunction(
						base.parent_namespace,
						"swap",
						List!<TemplateParameterDecl>(1u, TemplateParameterDecl("Type", this.program.any_concept, false, TemplateParameter::Type(type))),
						List!<Type>(2u, type.varRef()),
						this.program.void_type,
						BuiltinFunction::Swap(type)
					);
				}
				case IntCast
				| FloatCast
				| IntToFloat
				| FloatToInt
				| PointerCast -> {
					const source = (template_parameters[0u] as Type).value();
					const target = (template_parameters[1u] as Type).value();

					var cast_name = "";
					match builtin_function {
						case IntCast -> cast_name = "intCast";
						case FloatCast -> cast_name = "floatCast";
						case IntToFloat -> cast_name = "intToFloat";
						case FloatToInt -> cast_name = "floatToInt";
						case PointerCast -> cast_name = "pointerCast";
						else -> panic("unreachable");
					}

					if cast_name == "pointerCast" && source.isConstPtrType() && !target.isConstPtrType() {
						this.error("invalid pointer cast, source type is const but target isn't", error_span);
					}

					instance = this.program.createPrimitiveCastInstance(base.parent_namespace, cast_name, source, target);
				}
				case SizeOf
				| AlignmentOf
				| ReferenceKindOf
				| HasDefaultConstructor
				| HasCopyConstructor -> {
					var name = "";
					var parameter_types: List!<Type>;
					var return_type: Type;
					var body = builtin_function;

					body.base_type = (template_parameters[0u] as Type).value();

					match builtin_function {
						case SizeOf -> name = "sizeOf";
						case AlignmentOf -> name = "alignmentOf";
						case ReferenceKindOf -> name = "referenceKindOf";
						case HasDefaultConstructor -> name = "hasDefaultConstructor";
						case HasCopyConstructor -> name = "hasCopyConstructor";
						else -> panic(Error::EINVAL);
					}

					match builtin_function {
						case SizeOf
						| AlignmentOf -> return_type = this.program.uint_type;
						case ReferenceKindOf -> return_type = this.getType(Name("ReferenceKind"), error_span);
						case HasDefaultConstructor
						| HasCopyConstructor -> return_type = this.program.bool_type;
						else -> panic(Error::EINVAL);
					}

					instance = this.program.createFunction(base.parent_namespace, name, parameter_types, return_type, FunctionBody::Builtin(body));
					instance.template_parameters.append(TemplateParameterDecl("Type", this.program.any_concept, false, template_parameters[0u]));
				}
				else -> this.error("cannot create template instance of builtin function " + base.signature(), base.signature_span);
			}
			case Unchecked: parsed_function -> {
				if this.current_target_state > UncheckedFunctionSignatures {
					instance = this.checkFunctionDecl(parsed_function, getTemplateParameterDecls(base.template_parameters, template_parameters), false, true);
					this.checkFunctionSignature(instance);
				} else {
					instance = this.checkFunctionDecl(parsed_function, getTemplateParameterDecls(base.template_parameters, template_parameters), true, true);
				}
			}
			else -> this.error("cannot create template instance of this function", base.signature_span);
		}

		this.current_namespace = prev_namespace;
		return instance;
	}

	func getTemplateParameterDecls(base_decls: &List!<TemplateParameterDecl>, values: &List!<TemplateParameter>) -> List!<TemplateParameterDecl> {
		var result = base_decls;

		for i in 0u..values.size() {
			if result.size() <= i {
				result.append(result[i - 1]);
			}

			result[i].value = values[i];
		}

		return result;
	}

	func comptimeValueToASTNode(this: &&TCContext, value: &Value, span: Span) -> Node {
		match value {
			case Undefined -> return Node::Garbage(span, value.type, false);
			case Void -> return Node::Empty(span, value.type, false);
			case Integer: v -> return Node::IntegerLiteralExpr(v, span, value.type, false);
			case Float: v -> return Node::FloatLiteralExpr(v, span, value.type, false);
			case String: v -> return Node::StringLiteralExpr(StringLiteralExpr(v, ""), span, value.type, false);
			case Pointer -> {
				this.error("comptime pointers can't be added to the ast", span);
				return Node::Garbage(span, value.type, false);
			}
			case Aggregate: &children -> {
				var converted_children: List!<uint>;
				for &c in children {
					converted_children.append(this.addASTNode(this.comptimeValueToASTNode(c, span)));
				}
				return Node::ConstAggregateExpr(converted_children, span, value.type, false);
			}
			case Type: type -> return Node::TypeRefExpr(type, span, value.type, false);
			case Function: function -> return Node::FunctionRefExpr(function, span, value.type, false);
			case Variable -> {
				this.error("comptime variables can't be added to the ast", span);
				return Node::Garbage(span, value.type, false);
			}
		}
	}
}
