import std/core;
import std/libc/math;
import std/box;
import std/file;
import std/format;
import std/io;
import std/list;
import std/map;
import std/set;
import std/shared;
import std/shared_list;
import std/string;

import builtins;
import error;
import interpreter;
import lexer;
import llvm_c;
import llvm_codegen;
import llvm_util;
import operators;
import options;
import parser;
import optimizations;
import program;
import span;
import syntax_tree;

enum CallKind {
	case Static;
	case MemberCall;
	case Operator;
	case TempVar;
}

enum SymbolLookupFilter {
	case None = 0;
	case Namespaces = 1;
	case Types = 2;
	case Functions = 4;
	case MemberVariables = 8;
	case CaseDecls = 16;
	case TemplateParameters = 32;
	case Variables = 64;
	case Any = 127;

	operator &(this: SymbolLookupFilter, other: SymbolLookupFilter) -> SymbolLookupFilter = default;
	operator |(this: SymbolLookupFilter, other: SymbolLookupFilter) -> SymbolLookupFilter = default;
}

variant Symbol {
	var parent_namespace: SharedHandle!<Namespace>;

	case Namespace: SharedHandle!<Namespace>;
	case Type: SharedHandle!<TypeDecl>;
	case Function: SharedHandle!<FunctionDecl>;
	case MemberVariable: uint;
	case EnumCase: uint;
	case VariantCase: uint;
	case TemplateParameter: TemplateParameter;
	case Variable: SharedHandle!<VarDecl>;
}

func format(symbol: &Symbol) -> String {
	match symbol {
		case Namespace: value -> return "namespace " + value.signature();
		case Type: value -> return "type " + value.signature();
		case Function: value -> return "function " + value.signature();
		case MemberVariable: value -> return "member variable";
		case EnumCase: value -> return "enum case";
		case VariantCase: value -> return "variant case";
		case TemplateParameter: value -> return "template parameter " + format(value);
		case Variable: value -> return "variable " + value.signature();
	}
}

enum ScopeKind {
	case Function;
	case Compound;
	case Loop;
	case Match;
	case Expr;
}

struct Scope {
	var kind: ScopeKind;
	var variables: List!<SharedHandle!<VarDecl>>;
	var variables_by_name: Map!<String, SharedHandle!<VarDecl>>;

	func constructor(this: &&Scope, kind: ScopeKind) -> void {
		this.kind := kind;
	}

	func constructor(this: &&Scope, other: Scope) -> void = default;
	func destructor(this: &&Scope) -> void = default;

	operator =(this: &&Scope, other: Scope) -> void = default;

	operator ==(this: Scope, other: Scope) -> bool = default;
}

func typecheck(program: &&Program) -> void {
	var context: TCContext = (&&program);

	const root_module_desc = ImportedModule(1u, program.options.root_module_path, program.options.program_name);
	if const error = context.loadModule(root_module_desc) as Error {
		context.error("couldn't load module " + root_module_desc.path + ": " + String::fromErrorCode(error), Span());
		return;
	}

	do {
		var changes = false;
		for ns in program.top_level_namespaces {
			changes |= context.check(ns, NamespaceState::Done);
		}
	} while changes;

	if program.options.mode == Check {
		return;
	}

	if program.main_function.isEmpty() {
		context.error("no main function specified", Span());
	}

	if program.has_errors {
		return;
	}

	if program.options.codegen_lazy {
		context.cg_context.codegenFunctionDecl(program.main_function);
		context.cg_context.codegenFunctionBody(program.main_function);
	}

	match program.llvm_context.loadModuleFromFile(program.options.install_path + "/rt.ll") {
		case Some: rt_module -> discard LLVMLinkModules2(program.llvm_module, rt_module);
		else -> program.has_errors = true;
	}

	program.finalizeDI();

	if const error = verifyModule(program.llvm_module, LLVMVerifierFailureAction::LLVMReturnStatusAction) as Error {
		eprintln(error);
		program.has_errors = true;
	}
}

struct TCContext {
	var program: &&Program;
	var interpreter: Interpreter;
	var cg_context: CGContext;

	var current_target_state: NamespaceState;
	var current_namespace: SharedHandle!<Namespace>;
	var current_function: SharedHandle!<FunctionDecl>;

	var scope_stack: List!<Scope>;
	var current_return_type: Type;
	var active_member_variables: Set!<uint>; // used to track (de-)initialized member variables in con/de-structors
	var return_variable: SharedHandle!<VarDecl>;

	// context for checking match expressions
	var match_value: Expr;
	var match_type: Type;
	var yield_type: Type;
	var yield_var: SharedHandle!<VarDecl>;

	func constructor(this: &&TCContext, program: &&Program) -> void {
		this.program := &&program;
		this.interpreter := (&&program);
		this.cg_context := (&&program);
		this.current_target_state := Unchecked;
		this.match_value := Expr::Undefined(Span(), Type::unknown());
	}

	func destructor(this: &&TCContext) -> void = default;

	func error(this: &TCContext, msg: String, span: Span) -> void {
		this.program.printError(CompilationError(msg, ErrorType::Error, ErrorStage::Typechecker, span));

		if this.current_function.isAlive() {
			this.current_function.has_errors = true;
		} else if this.current_namespace.isAlive() {
			this.current_namespace.has_errors = true;
		}
	}

	func info(this: &TCContext, msg: String, span: Span) -> void {
		this.program.printError(CompilationError(msg, ErrorType::Info, ErrorStage::Typechecker, span));
	}

	func hint(this: &TCContext, msg: String, span: Span) -> void {
		this.program.printError(CompilationError(msg, ErrorType::Hint, ErrorStage::Typechecker, span));
	}

	func todo(this: &TCContext, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Todo, ErrorStage::Typechecker, span));

		if this.current_function.isAlive() {
			this.current_function.has_errors = true;
		} else if this.current_namespace.isAlive() {
			this.current_namespace.has_errors = true;
		}
	}

	func interpret(this: &&TCContext, expr: &Expr) -> Expr {
		match this.interpreter.interpret(expr) {
			case Ok: value -> return value;
			else -> {
				this.error("unexpected control flow in comptime expression", expr.span);
				return Expr::Undefined(expr.span, Type::unknown());
			}
		}
	}

	func interpret(this: &&TCContext, stmt: &Stmt) -> void {
		if this.interpreter.interpret(stmt) is Error {
			this.error("unexpected control flow in comptime statement", stmt.span);
		}
	}

	func interpret(this: &&TCContext, stmts: &List!<Stmt>) -> void {
		for stmt in stmts {
			this.interpret(stmt);
		}
	}

	func pushScope(this: &&TCContext, kind: ScopeKind) -> void {
		this.scope_stack.append(Scope(kind));
	}

	func popScope(this: &&TCContext) -> void {
		this.scope_stack.removeLast();
	}

	func addVariableToCurrentScope(this: &&TCContext, variable: SharedHandle!<VarDecl>) -> void {
		this.scope_stack[this.scope_stack.size() - 1].variables.append(variable);

		if variable.name != ""{
			this.scope_stack[this.scope_stack.size() - 1].variables_by_name[variable.name] = variable;
		}
	}

	func isCurrentScopeInsideLoop(this: &TCContext) -> bool {
		for i in 0u..this.scope_stack.size() {
			if this.scope_stack[this.scope_stack.size() - i - 1].kind == Loop {
				return true;
			}
		}

		return false;
	}

	func isCurrentScopeInsideMatch(this: &TCContext) -> bool {
		for i in 0u..this.scope_stack.size() {
			if this.scope_stack[this.scope_stack.size() - i - 1].kind == Match {
				return true;
			}
		}

		return false;
	}

	func getVariableByName(this: &&TCContext, name: String) -> Optional!<SharedHandle!<VarDecl>> {
		for i in 0u..this.scope_stack.size() {
			const tmp = this.scope_stack[this.scope_stack.size() - i - 1].variables_by_name.get(name);
			if tmp is Some {
				return tmp;
			}
		}

		return None;
	}

	func collectCleanupCalls(this: &&TCContext, until: ScopeKind) -> List!<Stmt> {
		var result: List!<Stmt>;

		for i in 0u..this.scope_stack.size() {
			const variables = this.scope_stack[this.scope_stack.size() - i - 1].variables;

			for k in 0u..variables.size() {
				const variable = variables[variables.size() - k - 1];
				result.append(Stmt::LifeTimeEnd(variable, Span()));
			}

			if this.scope_stack[this.scope_stack.size() - i - 1].kind == until {
				break;
			}
		}

		return result;
	}

	func collectCleanupCallsForCurrentScope(this: &&TCContext) -> List!<Stmt> {
		var result: List!<Stmt>;

		const variables = this.scope_stack[this.scope_stack.size() - 1].variables;
		for i in 0u..variables.size() {
			const variable = variables[variables.size() - i - 1];
			if variable.type.reference_kind == None {
				result.append(Stmt::LifeTimeEnd(variable, Span()));
			}
		}

		return result;
	}

	func loadFile(this: &&TCContext, imported_module: ImportedModule) -> Result!<uint> {
		var file = try File::open(imported_module.path, OpenMode::read);
		const source = try file.readAll();

		const file_id = this.program.files.size();

		// collect line spans
		var line_spans = List!<Span>();
		var line = 0u;
		var line_start = 0u;

		var index = 0u;
		while index < source.size() {
			if source.at(index) ?? '\0'b == '\n'b {
				const span = Span(line_start, index, line as u32, 0u16, file_id as u16);
				line_spans.append(span);

				line++;
				line_start = index + 1;
			}
			index++;
		}

		const span = Span(line_start, index, line as u32, 0u16, file_id as u16);
		line_spans.append(span);

		var source_file = SourceFile(imported_module.name, imported_module.path, source, line_spans);

		if this.program.options.generate_debug_info {
			var segments = source_file.path.split('/'b);
			const filename = segments.last().value();
			segments.removeLast();
			const directory = "/".join(segments);

			source_file.llvm_di_file = LLVMDIBuilderCreateFile(this.program.di_builder, filename, directory);
			source_file.llvm_di_module = LLVMDIBuilderCreateModule(
				this.program.di_builder,
				this.program.di_compile_unit,
				source_file.name,
				"",		// config macros
				"",		// include path
				"", 	// api notes file
			);
		}

		this.program.files.append(source_file);

		return Ok(file_id);
	}

	func loadModule(this: &&TCContext, imported_module: ImportedModule) -> Result!<SharedHandle!<Namespace>> {
		const file_id = try this.loadFile(imported_module);
		var module = this.program.createModule(imported_module);

		// lex
		const tokens = Lexer::lex(this.program.files[file_id].source, file_id as u16);
		if this.program.options.dump_tokens {
			print(tokens.dump());
		}

		// parse
		var parser = Parser(&&this.program, &tokens);
		while !parser.eof() {
			module.unchecked_children.append(parser.parseStmt());
		}

		if this.program.options.dump_ast {
			print(dumpModule(&module.unchecked_children));
		}

		return Ok(module);
	}

	func checkImport(this: &&TCContext, import_name: String, span: Span) -> void {
		const imported_modules = this.program.options.getImportPaths(import_name);

		if imported_modules.isEmpty() {
			this.error("no matching module found", span);
			return;
		}

		for imported_module in imported_modules {
			if const module = this.program.getModule(imported_module.path) {
				this.current_namespace.imported_namespaces.append(module);
				continue;
			}

			const module = this.loadModule(imported_module) else: error {
				this.error("couldn't load module " + imported_module.path + ": " + String::fromErrorCode(error), span);
				continue;
			}

			this.current_namespace.imported_namespaces.append(module);
			discard this.check(module, this.current_target_state);
		}
	}

	func check(this: &&TCContext, namespace_to_check: SharedHandle!<Namespace>, max_state: NamespaceState) -> bool {
		if namespace_to_check.state == IncompleteTemplate || namespace_to_check.state >= max_state {
			return false;
		}

		const prev_namespace = this.current_namespace;
		const prev_target_state = this.current_target_state;
		const prev_function = this.current_function;

		this.current_namespace = namespace_to_check;
		this.current_function = SharedHandle!<FunctionDecl>();

		while namespace_to_check.state < max_state {
			this.current_target_state = namespace_to_check.state + 1u;

			do {
				var changes = false;
				for imported_namespace in namespace_to_check.imported_namespaces {
					changes |= this.check(imported_namespace, this.current_target_state);
				}

				var i = 0u;
				while i < namespace_to_check.children.size() {
					changes |= this.check(namespace_to_check.children[i], this.current_target_state);
					i++;
				}
			} while changes;

			if namespace_to_check.linked_type.isAlive() {
				for contained_type in namespace_to_check.linked_type.contained_types {
					discard this.check(contained_type.linked_namespace, namespace_to_check.state);
				}
			}

			match namespace_to_check.state {
				case IncompleteTemplate -> {}
				case Unchecked -> this.checkTopLevelStatements();
				case UncheckedTypeBodies -> this.checkTypeBodies();
				case UncheckedFunctionSignatures -> this.checkFunctionSignatures();
				case UncheckedFunctionBodies -> this.checkFunctionBodies();
				case Done -> {}
			}
		}

		this.current_namespace = prev_namespace;
		this.current_target_state = prev_target_state;
		this.current_function = prev_function;

		return true;
	}

	func checkTopLevelStatements(this: &&TCContext) -> void {
		while !this.current_namespace.unchecked_children.isEmpty() {
			const stmts = this.current_namespace.unchecked_children;
			this.current_namespace.unchecked_children.clear();

			for parsed_stmt in stmts {
				const stmt = this.checkStmt(parsed_stmt);
				if stmt is Empty {
					continue;
				}

				discard this.interpret(stmt);
			}
		}

		if this.current_namespace.state == Unchecked {
			this.current_namespace.updateState(NamespaceState::UncheckedTypeBodies);
		}
	}

	func checkTypeBodies(this: &&TCContext) -> void {
		var next = this.current_namespace.unchecked_types.last();
		while next.hasValue() && this.current_namespace.state == UncheckedTypeBodies {
			this.current_namespace.unchecked_types.removeLast();
			this.checkTypeBody(next.value());
			next = this.current_namespace.unchecked_types.last();
		}

		if this.current_namespace.state == UncheckedTypeBodies {
			this.current_namespace.updateState(NamespaceState::UncheckedFunctionSignatures);
		}
	}

	func checkFunctionSignatures(this: &&TCContext) -> void {
		var next = this.current_namespace.unchecked_functions.last();
		while next.hasValue() && this.current_namespace.state == UncheckedFunctionSignatures {
			this.current_namespace.unchecked_functions.removeLast();
			this.checkFunctionSignature(next.value());
			next = this.current_namespace.unchecked_functions.last();
		}

		if this.current_namespace.state == UncheckedFunctionSignatures {
			this.current_namespace.updateState(NamespaceState::UncheckedFunctionBodies);
		}
	}

	func checkFunctionBodies(this: &&TCContext) -> void {
		var next = this.current_namespace.unchecked_function_bodies.last();
		while next.hasValue() && this.current_namespace.state == UncheckedFunctionBodies {
			this.current_namespace.unchecked_function_bodies.removeLast();
			this.checkFunctionBody(next.value());
			next = this.current_namespace.unchecked_function_bodies.last();
		}

		if this.current_namespace.state == UncheckedFunctionBodies {
			this.current_namespace.updateState(NamespaceState::Done);
		}
	}

	func checkNamespaceDecl(this: &&TCContext, parsed_decl: &ParsedNamespace) -> SharedHandle!<Namespace> {
		const template_parameters = this.checkTemplateParameterDecl(parsed_decl.template_parameters);

		if var namespace_decl = this.current_namespace.aliases.get(parsed_decl.name) {
			namespace_decl.addUncheckedChildren(parsed_decl.children);
			return namespace_decl;
		}

		var namespace_decl = this.program.getOrCreateChildNamespace(this.current_namespace, parsed_decl.name, template_parameters, false);
		namespace_decl.addUncheckedChildren(parsed_decl.children);
		return namespace_decl;
	}

	func checkTypeDecl(this: &&TCContext, parsed_decl: &ParsedTypeDecl) -> SharedHandle!<TypeDecl> {
		const body = match parsed_decl.kind {
			case Struct -> yield TypeBody::Struct;
			case Enum -> yield TypeBody::Enum;
			case Variant -> yield TypeBody::Variant;
			case Garbage -> yield TypeBody::Empty;
		}

		const type = this.checkTypeDecl(
			parsed_decl.name,
			this.checkTemplateParameterDecl(parsed_decl.template_parameters),
			body,
			parsed_decl.span,
			parsed_decl.name_span,
			parsed_decl.annotations,
			true
		);

		type.parsed_id_type = parsed_decl.id_type;
		type.parsed_annotations = parsed_decl.annotations;
		type.linked_namespace.addUncheckedChildren(parsed_decl.children);

		return type;
	}

	func checkTypeDecl(this: &&TCContext, name: String, template_parameters: &List!<TemplateParameterDecl>, body: TypeBody, span: Span, name_span: Span, parsed_annotations: &List!<ParsedAnnotation>, add_to_unchecked_list: bool) -> SharedHandle!<TypeDecl> {
		var type = this.program.createType(this.current_namespace, name, template_parameters, body);
		type.span = span;
		type.name_span = name_span;

		if add_to_unchecked_list {
			this.current_namespace.addUncheckedType(type);
		}

		for sibling in this.current_namespace.types_by_name[name] {
			if sibling == type {
				continue;
			}

			if template_parameters.isEmpty() {
				continue;
			}

			if sibling.template_parameters == template_parameters {
				this.error("type redeclared with identical template parameters", name_span);
				this.info("previously declared here: ", sibling.name_span);
			}
		}

		for annotation in parsed_annotations {
			if annotation.name == "packed" {
				match annotation {
					case Flag -> type.is_packed = true;
					else -> this.error("invalid annotation", annotation.span);
				}
			} else {
				this.error("invalid annotation name '" + annotation.name + "'", annotation.span);
			}
		}

		return type;
	}

	func checkTypeBody(this: &&TCContext, type: SharedHandle!<TypeDecl>) -> void {
		if type.isIncompleteTemplate() {
			return;
		}

		this.program.createDefaultFunctions(Type(type, ReferenceKind::None));
		if type.body is Enum || type.body is Variant {
			type.id_type = this.checkTypeUsage(type.parsed_id_type, false);
			if type.id_type.isUnknown() {
				type.id_type = this.program.int_type;
			}

			type.addContainedType(type.id_type);
		}

		discard this.check(type.linked_namespace, NamespaceState::UncheckedFunctionSignatures);

		for c in type.variant_cases {
			this.program.createVariantCaseConstructor(type, c.id, c.type);
			this.program.createVariantOpIs(type, c.id);

			if c.type != this.program.void_type {
				this.program.createVariantOpUnsafeAs(type, ReferenceKind::Const, c.id);
				this.program.createVariantOpUnsafeAs(type, ReferenceKind::Var, c.id);
			}
		}
	}

	func checkFunctionDecl(this: &&TCContext, parsed_decl: &ParsedFunctionDecl) -> SharedHandle!<FunctionDecl> {
		return this.checkFunctionDecl(parsed_decl, this.checkTemplateParameterDecl(parsed_decl.template_parameters), true);
	}

	func checkFunctionDecl(this: &&TCContext, parsed_decl: &ParsedFunctionDecl, template_parameters: &List!<TemplateParameterDecl>, add_to_unchecked_list: bool) -> SharedHandle!<FunctionDecl> {
		const function = this.program.createFunction(this.current_namespace, parsed_decl.signature.name, template_parameters, FunctionBody::Unchecked(parsed_decl));
		function.span = parsed_decl.span;
		function.signature_span = parsed_decl.signature.span;

		if add_to_unchecked_list {
			this.current_namespace.addUncheckedFunction(function);
		}

		for sibling in this.current_namespace.functions_by_name[parsed_decl.signature.name] {
			if sibling == function {
				continue;
			}

			if template_parameters.isEmpty() {
				continue;
			}

			if sibling.template_parameters == template_parameters {
				this.error("function redeclared with identical template parameters", parsed_decl.signature.span);
				this.info("previously declared here: ", sibling.signature_span);
			}
		}

		for annotation in parsed_decl.annotations {
			if annotation.name == "extern_name" {
				match annotation {
					case String: value -> function.extern_name = value;
					else -> this.error("invalid annotation", annotation.span);
				}
			} else {
				this.error("invalid annotation name '" + annotation.name + "'", annotation.span);
			}
		}

		return function;
	}

	func checkFunctionSignature(this: &&TCContext, function: SharedHandle!<FunctionDecl>) -> void {
		if function.isIncompleteTemplate() {
			return;
		}

		if function.body is Builtin || function.body is InlineBuiltin {
			function.parent_namespace.addUncheckedFunctionBody(function);
			if this.program.options.codegen_asap {
				if function.body is Builtin || this.program.options.codegen_inline_builtin_functions {
					this.cg_context.codegenFunctionDecl(function);
				}
			}

			return;
		}

		const signature = match function.body {
			case Unchecked: &parsed_body -> yield parsed_body.signature;
			else -> return;
		}

		const prev_namespace = this.current_namespace;
		const prev_function = this.current_function;

		this.current_namespace = function.parent_namespace;
		this.current_function = function;

		function.return_type = this.checkTypeUsage(signature.return_type, false);
		for parameter in signature.parameters {
			const parameter_type = this.checkTypeUsage(parameter.type, false);
			function.parameter_types.append(parameter_type);
			function.createParameter(parameter.span, parameter.name, parameter_type);

			for annotation in parameter.annotations {
				match annotation {
					case Flag -> {
						if annotation.name == "shallow" {
							function.parameters[function.parameters.size() - 1].is_shallow_parameter = true;
						} else {
							this.error("invalid function parameter annotation", annotation.span);
						}
					}
					else -> {
						this.error("invalid function parameter annotation", annotation.span);
					}
				}
			}
		}

		this.current_namespace.addUncheckedFunctionBody(function);

		for sibling in this.current_namespace.functions_by_name[function.name] {
			if sibling == function {
				continue;
			}

			if sibling.template_parameters != function.template_parameters {
				continue;
			}

			if sibling.parameter_types == function.parameter_types {
				this.error("function redeclared with identical parameter types", function.signature_span);
				this.info("previously declared here: ", sibling.signature_span);
			}
		}

		if function.name == "main" {
			if !function.return_type.isUnknown() && function.return_type != this.program.int_type && function.return_type != this.program.void_type {
				this.error("invalid return type for main, expected " + this.program.int_type.signature() + " or " + this.program.void_type.signature(), function.signature_span);
			}

			// TODO: validate parameter types

			if this.program.main_function.isEmpty() {
				this.program.main_function = function;
			} else {
				this.error("re-declaration of the main function", function.signature_span);
				this.hint("main was already declared here:", this.program.main_function.signature_span);
			}
		}

		if this.current_namespace.linked_type.isAlive() {
			var parent_type = this.current_namespace.linked_type;
			const type = Type(parent_type);

			if function.name == "constructor" && function.parameter_types.size() == 1 {
				if function.parameter_types[0u] == type.varRef() {
					parent_type.default_constructor = function;
				}
			} else if function.name == "constructor" && function.parameter_types.size() == 2 {
				if function.parameter_types[0u] == type.varRef() && function.parameter_types[1u] == type {
					parent_type.copy_constructor = function;
					function.is_copy_constructor = true;

					// the "other" parameter in copy a constructor can't be deep copied (would result in recursion),
					// but it can safely be shallow copied because no other parameters can reference the same object
					function.parameters[1u].is_shallow_parameter = true;
				}
			} else if function.name == "destructor" && function.parameter_types.size() == 1 {
				if function.parameter_types[0u] == type.varRef() {
					parent_type.destructor = function;
				}
			} else if function.name == "operator =" && function.parameter_types.size() == 2 {
				if function.parameter_types[0u] == type.varRef() && function.parameter_types[1u] == type {
					parent_type.op_assign = function;
				}
			} else if function.name == "operator ==" && function.parameter_types.size() == 2 {
				if function.parameter_types[0u] == type && function.parameter_types[1u] == type {
					parent_type.op_equal = function;
				}
			} else if function.name == "operator <=>" && function.parameter_types.size() == 2 {
				if function.parameter_types[0u] == type && function.parameter_types[1u] == type {
					parent_type.op_compare = function;
				}
			} else if function.name == "operator unwrap" && function.parameter_types.size() == 1 {
				if parent_type.unwrapped_type.isEmpty() {
					parent_type.unwrapped_type = function.return_type.decl;
				} else if parent_type.unwrapped_type != function.return_type.decl {
					this.error("operator unwrap redeclared with different return type", function.signature_span);
				}

				if function.return_type.reference_kind < function.parameter_types[0u].reference_kind {
					this.error("invalid operator unwrap declaration", function.signature_span);
				}
			}
		}

		if const parsed_function = function.body as Unchecked {
			if parsed_function.body is ExternFunctionBody && function.extern_name == "" {
				function.extern_name = function.name;
			}
		}

		if this.program.options.codegen_asap {
			this.cg_context.codegenFunctionDecl(function);
		}

		this.current_namespace = prev_namespace;
		this.current_function = prev_function;
	}

	func checkFunctionBody(this: &&TCContext, function: SharedHandle!<FunctionDecl>) -> void {
		const prev_namespace = this.current_namespace;
		const prev_function = this.current_function;

		this.current_namespace = function.parent_namespace;
		this.current_function = function;

		match function.body {
			case Empty | Extern | InlineBuiltin -> {}
			case Builtin: builtin_function -> this.validateBuiltinFunctionDecl(builtin_function, function.signature(), function.signature_span);
			case Stmt -> this.error("function body is already checked", function.span);
			case Unchecked: &parsed_function -> match parsed_function.body {
				case ExternFunctionBody -> function.body = FunctionBody::Extern;
				case DefaultFunctionBody -> {
					function.body = function.getDefaultFunctionBody();
					match function.body {
						case Builtin: builtin_function -> this.validateBuiltinFunctionDecl(builtin_function, function.signature(), function.signature_span);
						else -> {}
					}
				}
				case Compound: &compound_stmt -> this.checkFunctionBody(&&function.operator unwrap(), compound_stmt);
				else -> {}
			}
		}

		if this.program.options.codegen_asap {
			if !(function.body is InlineBuiltin) || this.program.options.codegen_inline_builtin_functions {
				this.cg_context.codegenFunctionBody(function);
			}
		}

		this.current_namespace = prev_namespace;
		this.current_function = prev_function;
	}

	func validateBuiltinFunctionDecl(this: &&TCContext, body: BuiltinFunction, caller_signature: String, caller_span: Span) -> void {
		const parent_type = body.base_type.decl;

		for v in parent_type.member_variables {
			if v.type.isUnknown() || v.type.reference_kind != None {
				continue;
			}

			const t = v.type.decl;

			match body {
				case StructDefaultConstructor | ArrayDefaultConstructor -> {
					if t.default_constructor.isEmpty() {
						this.error(t.signature() + " is missing a default constructor", t.name_span);
						this.info("required by " + caller_signature, caller_span);
					}
				}
				case StructValueConstructor | StructCopyConstructor | VariantCaseConstructor | VariantCopyConstructor | ArrayCopyConstructor -> {
					if t.copy_constructor.isEmpty() {
						this.error(t.signature() + " is missing a copy constructor", t.name_span);
						this.info("required by " + caller_signature, caller_span);
					}
				}
				case StructDestructor | VariantDestructor | ArrayDestructor -> {
					if t.destructor.isEmpty() {
						this.error(t.signature() + " is missing a destructor", t.name_span);
						this.info("required by " + caller_signature, caller_span);
					}
				}
				case StructOpAssign | VariantOpAssign | ArrayOpAssign -> {
					if t.op_assign.isEmpty() {
						this.error(t.signature() + " is missing an assignment operator", t.name_span);
						this.info("required by " + caller_signature, caller_span);
					}
				}
				case StructOpEqual | VariantOpEqual | ArrayOpEqual -> {
					if t.op_equal.isEmpty() {
						this.error(t.signature() + " is missing an equal operator", t.name_span);
						this.info("required by " + caller_signature, caller_span);
					}
				}
				case StructOpCmp -> {
					if t.op_compare.isEmpty() {
						this.error(t.signature() + " is missing a compare operator", t.name_span);
						this.info("required by " + caller_signature, caller_span);
					}
				}
			}
		}

		for c in parent_type.variant_cases {
			if c.type == this.program.void_type || c.type == this.program.never_type || c.type.isUnknown() || c.type.reference_kind != None {
				continue;
			}

			const t = c.type.decl;

			match body {
				case VariantCaseConstructor: id -> {
					if id == c.id && t.copy_constructor.isEmpty() {
						this.error(t.signature() + " is missing a copy constructor", t.name_span);
						this.info("required by " + caller_signature, caller_span);
					}
				}
				case VariantCopyConstructor -> {
					if t.copy_constructor.isEmpty() {
						this.error(t.signature() + " is missing a copy constructor", t.name_span);
						this.info("required by " + caller_signature, caller_span);
					}
				}
				case VariantDestructor -> {
					if t.destructor.isEmpty() {
						this.error(t.signature() + " is missing a destructor", t.name_span);
						this.info("required by " + caller_signature, caller_span);
					}
				}
				case VariantOpAssign -> {
					if t.copy_constructor.isEmpty() {
						this.error(t.signature() + " is missing a copy constructor", t.name_span);
						this.info("required by " + caller_signature, caller_span);
					}

					if t.destructor.isEmpty() {
						this.error(t.signature() + " is missing a destructor", t.name_span);
						this.info("required by " + caller_signature, caller_span);
					}
				}
				case VariantOpEqual -> {
					if t.op_equal.isEmpty() {
						this.error(t.signature() + " is missing an equal operator", t.name_span);
						this.info("required by " + caller_signature, caller_span);
					}
				}
				else -> {}
			}
		}
	}

	func checkFunctionBody(this: &&TCContext, decl: &&FunctionDecl, parsed_body: &ParsedCompoundStmt) -> void {
		var prev_scope_stack = this.scope_stack;
		var prev_current_return_type = this.current_return_type;
		var prev_active_member_variables = this.active_member_variables;
		var prev_return_variable = this.return_variable;

		this.scope_stack.clear();
		this.current_return_type = decl.return_type;
		this.active_member_variables.clear();
		this.return_variable = SharedHandle!<VarDecl>();

		this.pushScope(ScopeKind::Function);

		var required_member_variables: Set!<uint>;
		if this.current_namespace.linked_type.isAlive() {
			const parent_type = this.current_namespace.linked_type;

			if decl.name == "constructor" {
				for member_variable in parent_type.member_variables {
					required_member_variables.add(member_variable.id);
				}
			} else {
				for member_variable in parent_type.member_variables {
					this.active_member_variables.add(member_variable.id);
				}
			}
		}

		var body = CompoundStmt(parsed_body.span);

		for parameter in decl.parameters {
			// create a local copy of all parameters passed by value
			if parameter.type.reference_kind == None {
				var copy = decl.createVariable(decl.signature_span, parameter.name, parameter.type, false, false);
				const parameter_expr = Expr::VarInvoke(parameter, decl.signature_span, parameter.type);

				if parameter.is_shallow_parameter {
					copy.constructor_call = Expr::ShallowCopy(ShallowCopyExpr(
						Expr::VarInvoke(copy, decl.signature_span, copy.type.varRef()),
						parameter_expr,
					), decl.signature_span, this.program.void_type);

					copy.is_const = true;
				} else {
					this.createConstructorCall(copy, List!<Expr>(1u, parameter_expr));
					this.createDestructorCall(copy);
				}

				this.addVariableToCurrentScope(copy);
				body.children.append(Stmt::LifeTimeStart(copy, decl.signature_span));
			} else {
				this.addVariableToCurrentScope(parameter);
			}
		}

		if !decl.return_type.isUnknown(){
			if decl.return_type != this.program.void_type && decl.return_type != this.program.never_type {
				this.return_variable = decl.createVariable(decl.signature_span, "#return_var", decl.return_type, false, false);
			}
		}

		this.checkStmtList(parsed_body.children, &&body.children.operator unwrap());

		if this.active_member_variables != required_member_variables {
			if body.isTerminator(this.program.never_type, false) {
				if decl.name == "constructor" {
					this.error("not all member variables initialized", decl.signature_span);
				} else if decl.name == "destructor" {
					this.error("not all member variables de-initialized", decl.signature_span);
				}
			} else {
				const parent_type = this.current_namespace.linked_type;
				var unhandled_member_variables: List!<uint>;
				if decl.name == "constructor" {
					for id in required_member_variables - this.active_member_variables {
						if parent_type.member_variables[id].type.reference_kind == None {
							unhandled_member_variables.append(id);
						} else {
							this.error("uninitialized reference member variable", decl.signature_span);
						}
					}
				} else if decl.name == "destructor" {
					for id in this.active_member_variables {
						if parent_type.member_variables[id].type.reference_kind == None {
							unhandled_member_variables.insert(0u, id);
						}
					}
				}

				const this_var_invoke_expr = Expr::VarInvoke(
					decl.variables[0u],
					decl.signature_span,
					decl.variables[0u].type
				);

				for id in unhandled_member_variables {
					const member_access_expr = Expr::MemberVarInvoke(
						Box!<MemberVarInvokeExpr>(MemberVarInvokeExpr(this_var_invoke_expr, id)),
						decl.signature_span,
						parent_type.member_variables[id].type.varRef()
					);

					var parameters = List!<Expr>(1u, member_access_expr);
					const initializer = parent_type.member_variables[id].initializer;
					if decl.name == "constructor" && !(initializer is Undefined || initializer is Void) {
						parameters.append(initializer);
					}

					const call = this.checkCall(
						Name(decl.name),
						parameters,
						false, false, CallKind::MemberCall,
						false,
						decl.signature_span
					);

					body.children.append(Stmt::Expr(call, decl.signature_span));
				}
			}
		}

		if !body.isTerminator(this.program.never_type, false) {
			body.children.append(this.collectCleanupCallsForCurrentScope());

			if this.current_return_type == this.program.void_type {
				body.children.append(Stmt::Return(Expr::Void(Span(), this.program.void_type), Span()));
			} else {
				body.children.append(Stmt::Return(Expr::Undefined(Span(), this.current_return_type), Span()));
				if !this.current_return_type.isUnknown() {
					this.error("non-void function doesn't return a value in all paths", decl.signature_span);
				}
			}
		}

		decl.body = FunctionBody::Stmt(Stmt::Compound(body, body.span));

		this.popScope();

		this.scope_stack = prev_scope_stack;
		this.current_return_type = prev_current_return_type;
		this.active_member_variables = prev_active_member_variables;
		this.return_variable = prev_return_variable;
	}

	func checkTemplateParameterDecl(this: &&TCContext, unchecked_parameters: &List!<ParsedTemplateParameterDecl>) -> List!<TemplateParameterDecl> {
		var result: List!<TemplateParameterDecl>;

		for parameter in unchecked_parameters {
			const name = parameter.name;
			const concept = this.program.getConcept(parameter.concept) else {
				this.error("concept '" + parameter.concept + "' not found", parameter.span);
				continue;
			}

			var checked_parameter = TemplateParameterDecl(name, concept, false);
			if !(parameter.value is Empty) {
				checked_parameter.value = this.checkTemplateParameter(parameter.value);
			}

			result.append(checked_parameter);
		}

		return result;
	}

	// stmt typechecking functions
	func checkStmt(this: &&TCContext, parsed_stmt: &ParsedStmt) -> Stmt {
		var result: List!<Stmt>;

		match parsed_stmt {
			case Empty -> {}
			case ExternFunctionBody
			| DefaultFunctionBody -> panic("unreachable"); // should be handled by checkFunctionBody()
			case Pragma: value -> {
				if this.current_function.isAlive() {
					this.error("invalid pragma", parsed_stmt.span);
				} else {
					if value == "generate_std_core_builtins" {
						this.program.createCoreDecls(this.current_namespace);
					} else if value == "generate_std_array_builtins" {
						this.program.createArrayTypeTemplate(this.current_namespace);
					} else {
						this.error("invalid pragma", parsed_stmt.span);
					}
				}
			}
			case Import: name -> {
				if this.current_function.isAlive() {
					this.error("imports are only allowed at root scope", parsed_stmt.span);
				} else {
					this.checkImport(name, parsed_stmt.span);
				}
			}
			case Namespace: &parsed_namespace -> {
				if this.current_function.isAlive() {
					this.error("namespaces & types must be declared outside of functions", parsed_namespace.name_span);
				}
				discard this.checkNamespaceDecl(parsed_namespace);
			}
			case TypeDecl: &parsed_type_decl -> {
				if this.current_function.isAlive() {
					this.error("namespaces & types must be declared outside of functions", parsed_type_decl.name_span);
				}
				discard this.checkTypeDecl(parsed_type_decl);
			}
			case FunctionDecl: &parsed_function_decl -> {
				discard this.checkFunctionDecl(parsed_function_decl);
			}
			case Alias: &parsed_alias -> {
				const target = this.checkTypeUsage(parsed_alias.type, false);
				if target.reference_kind != None {
					this.error("aliases to reference types aren't allowed", parsed_stmt.span);
				} else if !target.isUnknown() {
					this.current_namespace.aliases[parsed_alias.name] = target.decl.linked_namespace;
				}
			}
			case VarDecl: &parsed_var_decl -> {
				if parsed_stmt.is_comptime {
					for stmt in this.checkVarDecl(parsed_var_decl, true) {
						discard this.interpret(stmt);
					}
				} else if this.current_function.isAlive() {
					result = this.checkVarDecl(parsed_var_decl, false);
				} else if this.current_namespace.linked_type.isAlive() {
					this.checkMemberVarDecl(parsed_var_decl);
				} else {
					this.error("non comptime variable declared outside of type / function", parsed_stmt.span);
				}
			}
			case CaseDecl: &parsed_case_decl -> {
				if this.current_namespace.linked_type.isAlive() {
					this.checkCaseDecl(parsed_case_decl);
				} else {
					this.error("case decls must be inside a enum or variant type", parsed_case_decl.span);
				}
			}
			case Compound: &compound_stmt -> result.append(this.checkCompoundStmt(compound_stmt, true));
			case If: &if_stmt -> result.append(this.checkIfStmt(if_stmt, parsed_stmt.is_comptime, parsed_stmt.span));
			case IfVar: &if_var_stmt -> result.append(this.checkIfVarStmt(if_var_stmt, parsed_stmt.is_comptime, parsed_stmt.span));
			case VarElse: &var_else_stmt -> result.append(this.checkVarElseStmt(var_else_stmt, parsed_stmt.is_comptime, parsed_stmt.span));
			case While: &while_stmt -> result.append(this.checkWhileStmt(while_stmt, parsed_stmt.is_comptime, parsed_stmt.span));
			case DoWhile: &do_while_stmt -> result.append(this.checkDoWhileStmt(do_while_stmt, parsed_stmt.is_comptime, parsed_stmt.span));
			case For: &for_stmt -> result.append(this.checkForStmt(for_stmt, parsed_stmt.is_comptime, parsed_stmt.span));
			case Case: &case_stmt -> result.append(this.checkCaseStmt(case_stmt, parsed_stmt.span));
			case ElseCase: &body -> result.append(this.checkElseCaseStmt(body, parsed_stmt.span));
			case Break -> result.append(this.checkBreakStmt(parsed_stmt.span));
			case Continue -> result.append(this.checkContinueStmt(parsed_stmt.span));
			case Throw: &value -> result.append(this.checkThrowStmt(value, parsed_stmt.span));
			case Return: &value -> result.append(this.checkReturnStmt(value, parsed_stmt.span));
			case Yield: &value -> result.append(this.checkYieldStmt(value, parsed_stmt.span));
			case Discard: &value -> result.append(this.checkExprStmt(value, true, parsed_stmt.is_comptime, parsed_stmt.span));
			case Expr: &parsed_expr -> result.append(this.checkExprStmt(parsed_expr, false, parsed_stmt.is_comptime, parsed_stmt.span));
			case Garbage -> {}
		}

		if result.isEmpty() {
			return Stmt::Empty(parsed_stmt.span);
		} else if result.size() == 1 {
			return result[0u];
		} else {
			var tmp = CompoundStmt(parsed_stmt.span);
			tmp.children = result;
			return Stmt::Compound(tmp, parsed_stmt.span);
		}
	}

	func checkMemberVarDecl(this: &&TCContext, parsed_decl: &ParsedVarDecl) -> void {
		var type_decl = this.current_namespace.linked_type;

		if !(type_decl.body is Struct) && !(type_decl.body is Variant) {
			this.error("member variables are only allowed inside struct or variant types", parsed_decl.span);
			return;
		}

		if parsed_decl.type is Empty {
			this.error("member variables must have a type specified", parsed_decl.span);
			return;
		}

		const name = parsed_decl.name;
		const type = this.checkTypeUsage(parsed_decl.type, false);
		const initializer = this.checkExpr(parsed_decl.initializer, type, false);
		type_decl.createMemberVariable(parsed_decl.span, name, type, initializer);
	}

	func checkCaseDecl(this: &&TCContext, parsed_decl: &ParsedCaseDecl) -> void {
		if !this.current_namespace.linked_type.isAlive() {
			this.error("case declarations are only allowed inside enum or variant types", parsed_decl.span);
		}

		var type_decl = this.current_namespace.linked_type;
		if !(type_decl.body is Enum) && !(type_decl.body is Variant) {
			this.error("case declarations are only allowed inside enum or variant types", parsed_decl.span);
			return;
		}

		if !(parsed_decl.payload is Empty) && type_decl.body is Enum {
			this.error("only variant cases are allowed to have a payload attached", parsed_decl.span);
		}

		const name = parsed_decl.name;
		var id = 0;
		if parsed_decl.id is Empty {
			id = type_decl.getNextCaseId();
		} else {
			const id_expr = this.checkExpr(parsed_decl.id, type_decl.id_type, true);
			id = this.interpret(id_expr).toInt();
		}

		var payload_type = this.program.void_type;
		if !(parsed_decl.payload is Empty) {
			payload_type = this.checkTypeUsage(parsed_decl.payload, false);
		}

		if type_decl.body is Enum {
			type_decl.createEnumCase(parsed_decl.span, id, name);
		} else {
			type_decl.createVariantCase(parsed_decl.span, id, name, payload_type);
		}
	}

	func checkVarDecl(this: &&TCContext, parsed_stmt: &ParsedVarDecl, is_comptime: bool) -> List!<Stmt> {
		var type = this.checkTypeUsage(parsed_stmt.type, false);

		var initializer: List!<Expr>;
		this.pushScope(ScopeKind::Expr);
		if !(parsed_stmt.initializer is Empty) {
			if parsed_stmt.initializer.isAnonymousTuple() && !type.isUnknown() {
				for &element in (parsed_stmt.initializer as Tuple).value() {
					initializer.append(this.checkExpr(element.value, Type::unknown(), is_comptime));
				}
			} else  {
				initializer.append(this.checkExpr(parsed_stmt.initializer, type, is_comptime));
				if type.isUnknown() {
					type = initializer[0u].type;
				}
			}
		}

		const initializer_cleanup = this.collectCleanupCallsForCurrentScope();
		this.popScope();

		return this.checkVarDecl(parsed_stmt.name, type, parsed_stmt.is_const, initializer, initializer_cleanup, is_comptime, parsed_stmt.span);
	}

	func checkVarDecl(this: &&TCContext, name: String, type: Type, is_const: bool, initializer: &List!<Expr>, initializer_cleanup: &List!<Stmt>, is_comptime: bool, span: Span) -> List!<Stmt> {
		if is_const && initializer.isEmpty() {
			this.error("constants must be initialized", span);
		}

		if !is_const && type.reference_kind == Const {
			this.error("cannot store const reference in non-const variable", span);
		}

		if !name.startsWith("#") {
			if const other = this.getVariableByName(name) {
				this.error("redefinition of variable '" + name + "'", span);
				this.info("previously declared here:", other.span);
			}
		}

		var variable: SharedHandle!<VarDecl>;
		if this.current_function.isAlive() {
			variable = this.current_function.createVariable(span, name, type, is_const, is_comptime);
			this.addVariableToCurrentScope(variable);
		} else {
			variable = this.current_namespace.createComptimeVariable(span, name, type, is_const);
		}

		this.createConstructorCall(variable, initializer);
		this.createDestructorCall(variable);

		var result: List!<Stmt>;

		result.append(Stmt::LifeTimeStart(variable, span));
		result.append(initializer_cleanup);

		return result;
	}

	func createConstructorCall(this: &&TCContext, variable: SharedHandle!<VarDecl>, initializer: &List!<Expr>) -> void {
		if variable.type.isUnknown() {
			return;
		}

		if variable.type.reference_kind == None {
			var parameters: List!<Expr>;
			parameters.append(Expr::VarInvoke(variable, variable.span, variable.type.varRef()));
			parameters.append(initializer);

			variable.constructor_call = this.checkCall(Name("constructor"), parameters, false, true, CallKind::MemberCall, variable.is_comptime, variable.span);
		} else {
			if initializer.size() != 1 {
				this.error("reference variables must be initialized with a single value", variable.span);
				return;
			}

			if initializer[0u].type.base() != variable.type.base() || initializer[0u].type.reference_kind < variable.type.reference_kind {
				this.error("initializer has invalid type: expected " + variable.type.signature() + " but got " + initializer[0u].type.signature(), variable.span);
				return;
			}

			const object = Expr::VarInvoke(variable, variable.span, variable.type);
			variable.constructor_call = Expr::ShallowCopy(
				ShallowCopyExpr(object, initializer[0u]),
				variable.span, this.program.void_type
			);
		}
	}

	func createDestructorCall(this: &&TCContext, variable: SharedHandle!<VarDecl>) -> void {
		if variable.type.isUnknown() {
			return;
		}

		if variable.type.reference_kind == None {
			var parameters: List!<Expr>;
			parameters.append(Expr::VarInvoke(variable, variable.span, variable.type.varRef()));

			variable.destructor_call = this.checkCall(Name("destructor"), parameters, false, false, CallKind::MemberCall, variable.is_comptime, variable.span);
		} else {
			variable.destructor_call = Expr::Void(variable.span, this.program.void_type);
		}
	}

	func checkCompoundStmt(this: &&TCContext, parsed_stmt: &ParsedCompoundStmt, create_scope: bool) -> Stmt {
		var result = CompoundStmt(parsed_stmt.span);
		if create_scope {
			this.pushScope(ScopeKind::Compound);
		}

		this.checkStmtList(parsed_stmt.children, &&result.children.operator unwrap());

		if !result.isTerminator(this.program.never_type, this.isCurrentScopeInsideMatch()) {
			result.children.append(this.collectCleanupCallsForCurrentScope());
		}

		if create_scope {
			this.popScope();
		}

		return Stmt::Compound(result, parsed_stmt.span);
	}

	func checkStmtList(this: &&TCContext, input: &List!<ParsedStmt>, output: &&List!<Stmt>) -> void {
		for &stmt in input {
			if const previous = output.last() {
				if previous.isTerminator(this.program.never_type, this.isCurrentScopeInsideMatch()) {
					this.error("unreachable code", stmt.span);
				}
			}

			const checked_stmt = this.checkStmt(stmt);
			match checked_stmt {
				case Empty -> continue;
				case Compound: &compound_stmt -> output.append(compound_stmt.children);
				else -> output.append(checked_stmt);
			}
		}
	}

	func checkIfStmt(this: &&TCContext, if_stmt: &ParsedIfStmt, is_comptime: bool, span: Span) -> Stmt {
		this.pushScope(ScopeKind::Expr);
		const condition = this.checkExpr(if_stmt.condition, this.program.bool_type, is_comptime);
		const condition_cleanup = this.collectCleanupCallsForCurrentScope();
		this.popScope();

		if condition.type != this.program.bool_type && !(condition is Undefined) {
			this.error("invalid condition type: expected " + this.program.bool_type.signature() + " but got " + condition.type.signature(), condition.span);
			return Stmt::Empty(span);
		}

		if is_comptime {
			const condition_value = this.interpret(condition);
			this.interpret(condition_cleanup);

			if condition_value is Undefined {
				return Stmt::Empty(span);
			}

			if condition_value.toInt() != 0 {
				return this.checkStmt(if_stmt.then_branch);
			} else {
				return this.checkStmt(if_stmt.else_branch);
			}
		} else {
			const prev_active_member_variables = this.active_member_variables;

			const then_branch = this.checkStmt(if_stmt.then_branch);
			const then_branch_active_member_variables = this.active_member_variables;

			this.active_member_variables = prev_active_member_variables;
			const else_branch = this.checkStmt(if_stmt.else_branch);

			if then_branch_active_member_variables != this.active_member_variables {
				this.error("if & then branch (de)initialize different member variables", span);
			}

			if condition is Undefined {
				return Stmt::Empty(span);
			}

			return Stmt::If(Box!<IfStmt>(
				IfStmt(condition, condition_cleanup, then_branch, else_branch)
			), span);
		}
	}

	func checkIfVarStmt(this: &&TCContext, parsed_stmt: &ParsedIfVarStmt, is_comptime: bool, span: Span) -> List!<Stmt> {
		// if var x = y { ... }
		// ->
		// match y {
		//    Ok | Some: #value -> { var x = #value; ... }
		//    else -> {}
		// }

		const parsed_var_decl = parsed_stmt.var_decl;
		var result: List!<Stmt>;

		this.pushScope(ScopeKind::Expr);
		const value = this.checkExpr(parsed_var_decl.initializer, Type::unknown(), is_comptime);

		if value is Undefined {
			this.popScope();
			return result;
		}

		const value_type_decl = value.type.decl;

		var ok_case_name = "";
		if value_type_decl.getVariantCase("Ok").hasValue() {
			ok_case_name = "Ok";
		} else if value_type_decl.getVariantCase("Some").hasValue() {
			ok_case_name = "Some";
		} else {
			this.error("invalid value type for if var: expected Result or Optional", span);
			this.popScope();
			return result;
		}

		var body = parsed_stmt.body;
		var capture_invoke_expr = ParsedExpr::Name(makeParsedName(parsed_var_decl.span, "#value"), parsed_var_decl.span);
		if value.type.reference_kind == Var {
			capture_invoke_expr = makeParsedOperatorExpr(Operator::VarRef, capture_invoke_expr, capture_invoke_expr.span);
		} else if value.type.reference_kind == Const {
			capture_invoke_expr = makeParsedOperatorExpr(Operator::ConstRef, capture_invoke_expr, capture_invoke_expr.span);
		}

		body.children.insert(0u, ParsedStmt::VarDecl(ParsedVarDecl(
			parsed_var_decl.span,
			parsed_var_decl.name,
			parsed_var_decl.is_const,
			ParsedType::Empty(Span()),
			capture_invoke_expr
		), parsed_stmt.var_decl.span, false));

		var cases: List!<ParsedStmt>;

		// Ok | Some: #val -> { var x = #val; ... }
		cases.append(ParsedStmt::Case(Box!<ParsedCaseStmt>(ParsedCaseStmt(
			List!<ParsedExpr>(1u, ParsedExpr::Name(makeParsedName(value.span, ok_case_name), value.span)),
			"#value", value.type.reference_kind,
			ParsedStmt::Compound(body, body.span, false)
		)), value.span, false));

		// else -> {}
		cases.append(ParsedStmt::ElseCase(Box!<ParsedStmt>(
			ParsedStmt::Compound(ParsedCompoundStmt(value.span, SharedPtr!<List!<ParsedStmt>>(List!<ParsedStmt>())), value.span, false)
		), value.span, false));

		result.append(Stmt::Expr(this.checkMatchExpr(value, cases, Type::unknown(), is_comptime, span), span));
		result.append(this.collectCleanupCallsForCurrentScope());
		this.popScope();

		return result;
	}

	func checkVarElseStmt(this: &&TCContext, parsed_stmt: &ParsedVarElseStmt, is_comptime: bool, span: Span) -> List!<Stmt> {
		// var bar = foo else: (&&)error { ... }
		// ->
		// var bar = match foo {
		//     Ok | Some: val -> yield val;
		//     Error | None: (&&)error -> { ... }
		// }

		const parsed_var_decl = parsed_stmt.var_decl;
		const value = this.checkExpr(parsed_var_decl.initializer, Type::unknown(), is_comptime);
		if value is Undefined {
			return List!<Stmt>();
		}

		const value_type_decl = value.type.decl;

		var ok_case_name = "";
		var error_case_name = "";
		var capture = false;
		if value_type_decl.getVariantCase("Ok").hasValue() {
			ok_case_name = "Ok";
			error_case_name = "Error";

			if !parsed_stmt.capture_name.isEmpty() {
				capture = true;
			}
		} else if value_type_decl.getVariantCase("Some").hasValue() {
			ok_case_name = "Some";
			error_case_name = "None";

			if !parsed_stmt.capture_name.isEmpty() {
				this.error("can't capure error on this value type", span);
			}
		} else {
			this.error("invalid value type for if var: expected Result or Optional", span);
			return List!<Stmt>();
		}

		var cases: List!<ParsedStmt>;

		var value_invoke_expr = ParsedExpr::Name(makeParsedName(parsed_var_decl.span, "#value"), parsed_var_decl.span);
		match value.type.reference_kind {
			case Var -> value_invoke_expr = makeParsedOperatorExpr(Operator::VarRef, value_invoke_expr, parsed_var_decl.span);
			case Const -> value_invoke_expr = makeParsedOperatorExpr(Operator::ConstRef, value_invoke_expr, parsed_var_decl.span);
			else -> {}
		}

		// case Ok: val -> yield val
		cases.append(ParsedStmt::Case(Box!<ParsedCaseStmt>(ParsedCaseStmt(
			List!<ParsedExpr>(1u, ParsedExpr::Name(makeParsedName(parsed_var_decl.span, ok_case_name), parsed_var_decl.span)),
			"#value", value.type.reference_kind,
			ParsedStmt::Yield(value_invoke_expr, parsed_var_decl.span, false)
		)), parsed_var_decl.span, false));

		// case Error: (&&err) -> { ... }
		cases.append(ParsedStmt::Case(Box!<ParsedCaseStmt>(ParsedCaseStmt(
			List!<ParsedExpr>(1u, ParsedExpr::Name(makeParsedName(parsed_var_decl.span, error_case_name), parsed_var_decl.span)),
			parsed_stmt.capture_name, parsed_stmt.capture_kind,
			ParsedStmt::Compound(parsed_stmt.body, parsed_stmt.body.span, false)
		)), parsed_var_decl.span, false));

		this.pushScope(ScopeKind::Expr);
		const initializer = this.checkMatchExpr(value, cases, Type::unknown(), is_comptime, span);
		const initializer_cleanup = this.collectCleanupCallsForCurrentScope();
		this.popScope();

		return this.checkVarDecl(
			parsed_var_decl.name,
			initializer.type,
			parsed_var_decl.is_const,
			List!<Expr>(1u, initializer),
			initializer_cleanup,
			is_comptime,
			parsed_var_decl.span
		);
	}

	func checkWhileStmt(this: &&TCContext, parsed_stmt: &ParsedWhileStmt, is_comptime: bool, span: Span) -> List!<Stmt> {
		this.pushScope(ScopeKind::Expr);
		const condition = this.checkExpr(parsed_stmt.condition, this.program.bool_type, is_comptime);
		const condition_cleanup = this.collectCleanupCallsForCurrentScope();
		this.popScope();

		var result: List!<Stmt>;

		if condition.type != this.program.bool_type && !(condition is Undefined) {
			this.error("invalid condition type: expected " + this.program.bool_type.signature() + " but got " + condition.type.signature(), condition.span);
			return result;
		}

		this.pushScope(ScopeKind::Loop);
		if is_comptime {
			var condition_value = this.interpret(condition);
			this.interpret(condition_cleanup);

			while condition_value.toInt() != 0 {
				const child = this.checkCompoundStmt(parsed_stmt.body, false);
				if !(child is Empty) {
					result.append(child);
				}

				condition_value = this.interpret(condition);
				this.interpret(condition_cleanup);
			}
		} else {
			const body = this.checkCompoundStmt(parsed_stmt.body, false);
			result.append(Stmt::While(Box!<WhileStmt>(
				WhileStmt(condition, condition_cleanup, body, WhileStmtKind::While)
			), span));
		}
		this.popScope();

		return result;
	}

	func checkDoWhileStmt(this: &&TCContext, parsed_stmt: &ParsedDoWhileStmt, is_comptime: bool, span: Span) -> List!<Stmt> {
		var result: List!<Stmt>;

		this.pushScope(ScopeKind::Loop);
		if is_comptime {
			this.pushScope(ScopeKind::Expr);
			const condition = this.checkExpr(parsed_stmt.condition, this.program.bool_type, is_comptime);
			const condition_cleanup = this.collectCleanupCallsForCurrentScope();
			this.popScope();

			do {
				const child = this.checkCompoundStmt(parsed_stmt.body, false);
				if !(child is Empty) {
					result.append(child);
				}

				const condition_value = this.interpret(condition);
				this.interpret(condition_cleanup);
			} while condition_value.toInt() != 0;
		} else {
			const body = this.checkCompoundStmt(parsed_stmt.body, false);

			this.pushScope(ScopeKind::Expr);
			const condition = this.checkExpr(parsed_stmt.condition, this.program.bool_type, is_comptime);
			const condition_cleanup = this.collectCleanupCallsForCurrentScope();
			this.popScope();

			if condition.type != this.program.bool_type && !(condition is Undefined) {
				this.error("invalid condition type: expected " + this.program.bool_type.signature() + " but got " + condition.type.signature(), condition.span);
			}

			result.append(Stmt::While(Box!<WhileStmt>(
				WhileStmt(condition, condition_cleanup, body, WhileStmtKind::DoWhile)
			), span));
		}
		this.popScope();

		return result;
	}

	func checkForStmt(this: &&TCContext, parsed_stmt: &ParsedForStmt, is_comptime: bool, span: Span) -> Stmt {
		var result = CompoundStmt(span);

		this.pushScope(ScopeKind::Expr);
		var get_iterator_args: List!<Expr>;
		get_iterator_args.append(this.checkExpr(parsed_stmt.range, this.program.bool_type, is_comptime));
		const get_iterator_call = this.checkCall(Name("iterator"), get_iterator_args, true, false, CallKind::MemberCall, is_comptime, parsed_stmt.range.span);

		if get_iterator_call is Undefined {
			return Stmt::Empty(span);
		}

		result.children.append(Stmt::Expr(get_iterator_call, get_iterator_call.span));

		const iterator_var = (get_iterator_call.removeDereference() as Call).value().result_var;
		const iterator_var_expr = Expr::Dereference(
			Box!<Expr>(Expr::VarInvoke(iterator_var, parsed_stmt.range.span, iterator_var.type.varRef())),
			parsed_stmt.range.span, iterator_var.type
		);

		this.pushScope(ScopeKind::Expr);
		const condition = this.checkCall(Name("hasNext"), List!<Expr>(1u, iterator_var_expr), false, false, CallKind::MemberCall, is_comptime, parsed_stmt.range.span);
		const condition_cleanup = this.collectCleanupCallsForCurrentScope();
		this.popScope();

		if condition.type != this.program.bool_type && !(condition is Undefined) {
			this.error("invalid condition type: expected " + this.program.bool_type.signature() + " but got " + condition.type.signature(), condition.span);
			return Stmt::Empty(span);
		}

		var body = CompoundStmt(parsed_stmt.body.span);
		this.pushScope(ScopeKind::Loop);

		var initializer: List!<Expr>;
		var next_value = this.checkCall(Name("getNext"), List!<Expr>(1u, iterator_var_expr), false, false, CallKind::MemberCall, is_comptime, parsed_stmt.capture_span);

		if next_value is Undefined {
			return Stmt::Empty(span);
		}

		if parsed_stmt.capture_kind != None {
			next_value = next_value.removeDereference();
			if next_value.type.reference_kind == None {
				this.error("can't take reference of constant", next_value.span);
			} else if next_value.type.reference_kind == Const && parsed_stmt.capture_kind == Var {
				this.error("can't take var reference of const object", next_value.span);
			}
			next_value.type.reference_kind = parsed_stmt.capture_kind;
		}

		initializer.append(next_value);
		const variable = this.current_function.createVariable(parsed_stmt.capture_span, parsed_stmt.capture_name, next_value.type, next_value.type.reference_kind == Const, is_comptime);

		this.addVariableToCurrentScope(variable);

		this.createConstructorCall(variable, initializer);
		this.createDestructorCall(variable);

		body.children.append(Stmt::LifeTimeStart(variable, parsed_stmt.capture_span));

		this.checkStmtList(parsed_stmt.body.children, &&body.children.operator unwrap());

		if !body.isTerminator(this.program.never_type, this.isCurrentScopeInsideMatch()) {
			body.children.append(this.collectCleanupCallsForCurrentScope());
		}

		this.popScope();

		result.children.append(Stmt::While(Box!<WhileStmt>(
			WhileStmt(condition, condition_cleanup, Stmt::Compound(body, body.span), WhileStmtKind::While)
		), span));
		result.children.append(this.collectCleanupCallsForCurrentScope());
		this.popScope();

		return Stmt::Compound(result, result.span);
	}

	func checkBreakStmt(this: &&TCContext, span: Span) -> List!<Stmt> {
		if !this.isCurrentScopeInsideLoop() {
			this.error("break statements must be inside of a loop", span);
			return List!<Stmt>();
		}

		var result = this.collectCleanupCalls(ScopeKind::Loop);
		result.append(Stmt::Break(span));
		return result;
	}

	func checkContinueStmt(this: &&TCContext, span: Span) -> List!<Stmt> {
		if !this.isCurrentScopeInsideLoop() {
			this.error("continue statements must be inside of a loop", span);
			return List!<Stmt>();
		}

		var result = this.collectCleanupCalls(ScopeKind::Loop);
		result.append(Stmt::Continue(span));
		return result;
	}

	func checkCaseStmt(this: &&TCContext, parsed_stmt: &ParsedCaseStmt, span: Span) -> Stmt {
		if this.match_type.isUnknown() {
			this.error("case statement outside of a match statement", span);
			return Stmt::Empty(span);
		}

		const match_type_decl = this.match_type.decl;

		var patterns: List!<Expr>;
		for parsed_pattern in parsed_stmt.patterns {
			if match_type_decl.body is Variant {
				var case_name = "";
				match parsed_pattern {
					case Name: &parsed_name -> {
						if parsed_name.segments.size() != 1 {
							this.error("invalid variant case as match patter", parsed_pattern.span);
						} else if !parsed_name.segments[0u].template_parameters.isEmpty() {
							this.error("invalid variant case as match patter", parsed_pattern.span);
						} else {
							case_name = parsed_name.segments[0u].name;
						}
					}
					else -> this.error("expected variant case name", parsed_pattern.span);
				}

				const pattern = match_type_decl.getVariantCase(case_name) else {
					this.error("unknown variant case", parsed_pattern.span);
					continue;
				}

				patterns.append(Expr::Integer(pattern.id, pattern.span, match_type_decl.id_type));
			} else {
				const checked_pattern = this.checkExpr(parsed_pattern, this.match_type, false);
				if checked_pattern is Undefined {
					continue;
				}

				if checked_pattern.type != this.match_type {
					this.error("pattern has invalid type: expected '" + this.match_type.signature() + "' but got '" + checked_pattern.type.signature() + "'", parsed_pattern.span);
					continue;
				}

				patterns.append(checked_pattern);
			}
		}

		if patterns.isEmpty() {
			return Stmt::Empty(span);
		}

		var body = Stmt::Empty(parsed_stmt.body.span);
		if parsed_stmt.capture_name.isEmpty() {
			body = this.checkStmt(parsed_stmt.body);
		} else {
			if patterns.size() != 1 {
				this.error("capturing case statements must have exactly 1 pattern", span);
				return Stmt::Empty(span);
			}

			if !(match_type_decl.body is Variant) {
				this.error("capturing works only on variant types", span);
				return Stmt::Empty(span);
			}

			const case_id = (patterns[0u] as Integer).value();
			const case_decl = match_type_decl.getVariantCase(case_id).value();

			var compound_stmt = CompoundStmt(span);
			this.pushScope(ScopeKind::Compound);

			var capture_init_template_parameters: List!<TemplateParameter>;
			capture_init_template_parameters.append(TemplateParameter::Integer(case_id));

			var capture_init_parameters: List!<Expr>;
			capture_init_parameters.append(this.match_value);

			var capture_init = this.checkCall(
				Name("operator unsafe as", capture_init_template_parameters),
				capture_init_parameters,
				false, false, CallKind::MemberCall, false, span
			);

			var capture_type = capture_init.type;
			capture_type.reference_kind = parsed_stmt.capture_kind;
			if parsed_stmt.capture_kind != None {
				capture_init = capture_init.removeDereference();
			}

			const variable = this.current_function.createVariable(span, parsed_stmt.capture_name, capture_type, capture_type.reference_kind != Var, false);

			this.addVariableToCurrentScope(variable);

			var initializer: List!<Expr>;
			initializer.append(capture_init);
			this.createConstructorCall(variable, initializer);
			this.createDestructorCall(variable);

			compound_stmt.children.append(Stmt::LifeTimeStart(variable, span));

			const checked_body = this.checkStmt(parsed_stmt.body);
			compound_stmt.children.append(checked_body);
			if !checked_body.isTerminator(this.program.never_type, true) {
				compound_stmt.children.append(this.collectCleanupCallsForCurrentScope());
			}

			this.popScope();
			body = Stmt::Compound(compound_stmt, span);
		}

		return Stmt::Case(Box!<CaseStmt>(CaseStmt(span, patterns, body)), span);
	}

	func checkElseCaseStmt(this: &&TCContext, parsed_body: &ParsedStmt, span: Span) -> Stmt {
		const body = this.checkStmt(parsed_body);
		if body is Empty {
			return Stmt::Empty(span);
		} else {
			return Stmt::ElseCase(Box!<Stmt>(body), span);
		}
	}

	func checkThrowStmt(this: &&TCContext, parsed_value: &ParsedExpr, span: Span) -> List!<Stmt> {
		const return_type_decl = this.current_return_type.decl;
		const c = return_type_decl.getVariantCase("Error") else {
			this.error("invalid return type for throw: expected std::core::Result or similar, but got " + this.current_return_type.signature(), span);
			return List!<Stmt>();
		}

		this.pushScope(ScopeKind::Expr);
		const value = this.createTemporaryVariable(
			this.current_return_type,
			List!<TemplateParameter>(1u, TemplateParameter::Integer(c.id)),
			List!<Expr>(1u, this.checkExpr(parsed_value, c.type, false)),
			false,
			span
		);
		const value_cleanup = this.collectCleanupCallsForCurrentScope();
		this.popScope();

		return this.checkReturnStmt(value, value_cleanup, span);
	}

	func checkReturnStmt(this: &&TCContext, parsed_value: ParsedExpr, span: Span) -> List!<Stmt> {
		this.pushScope(ScopeKind::Expr);
		var value = this.checkExpr(parsed_value, this.current_return_type, false);

		if value.type.decl.isAlive() {
			const type_decl = value.type.decl;
			if value.type != this.current_return_type && type_decl.unwrapped_type == this.current_return_type.decl && value.type.reference_kind == this.current_return_type.reference_kind {
				value = this.checkCall(
					Name("operator unwrap"),
					List!<Expr>(1u, value), false, false, CallKind::MemberCall, false, span
				);

				if this.current_return_type.reference_kind != None {
					value = value.removeDereference();
					value.type.reference_kind = this.current_return_type.reference_kind;
				}
			}
		}

		const value_cleanup = this.collectCleanupCallsForCurrentScope();
		this.popScope();

		return this.checkReturnStmt(value, value_cleanup, span);
	}

	func checkReturnStmt(this: &&TCContext, checked_value: &Expr, value_cleanup: &List!<Stmt>, span: Span) -> List!<Stmt> {
		var value = checked_value;
		var result: List!<Stmt>;

		if value is Undefined || this.current_return_type.isUnknown() {
			result.append(Stmt::Return(value, span));
			return result;
		}

		if value.type != this.current_return_type {
			this.error("invalid return type: expected " + this.current_return_type.signature() + ", but got " + value.type.signature(), value.span);
			result.append(Stmt::Return(Expr::Undefined(value.span, Type::unknown()), span));
			return result;
		}

		if value.type == this.program.void_type || value.type == this.program.never_type {
			result.append(Stmt::Expr(value, value.span));
			result.append(value_cleanup);
			result.append(this.collectCleanupCalls(ScopeKind::Function));
			result.append(Stmt::Return(Expr::Void(span, this.program.void_type), span));
			return result;
		}

		var parameters: List!<Expr>;
		parameters.append(Expr::VarInvoke(this.return_variable, span, this.current_return_type.varRef()));
		parameters.append(value);

		var return_variable_init = Expr::Undefined(span, Type::unknown());

		if this.current_return_type.reference_kind == None {
			return_variable_init = this.checkCall(
				Name("constructor"),
				parameters, false, false, CallKind::MemberCall, false, span
			);
		} else {
			return_variable_init = Expr::ShallowCopy(
				ShallowCopyExpr(parameters[0u], parameters[1u]),
				span, this.program.void_type
			);
		}

		result.append(Stmt::Expr(return_variable_init, span));

		value = Expr::VarInvoke(this.return_variable, span, this.current_return_type.varRef());

		if this.current_return_type.reference_kind == None {
			value = Expr::Dereference(Box!<Expr>(value), span, this.current_return_type);
		} else {
			value.type.reference_kind = this.current_return_type.reference_kind;
		}

		result.append(value_cleanup);
		result.append(this.collectCleanupCalls(ScopeKind::Function));
		result.append(Stmt::Return(value, span));

		return result;
	}

	func checkYieldStmt(this: &&TCContext, parsed_value: ParsedExpr, span: Span) -> List!<Stmt> {
		var result: List!<Stmt>;

		this.pushScope(ScopeKind::Expr);
		const checked_value = this.checkExpr(parsed_value, this.yield_type, false);
		const value_cleanup = this.collectCleanupCallsForCurrentScope();
		this.popScope();

		if checked_value is Undefined {
			return result;
		}

		if this.yield_type.isUnknown() {
			this.yield_type = checked_value.type;
		} else if checked_value.type != this.yield_type {
			this.error("invalid yield type: expected " + this.yield_type.signature() + " but got " + checked_value.type.signature(), span);
			return result;
		}

		if checked_value.type == this.program.void_type {
			result.append(Stmt::Expr(checked_value, checked_value.span));
		} else {
			if !this.yield_var.isAlive() {
				this.yield_var = this.current_function.createVariable(Span(), "#yield_var", checked_value.type, checked_value.type.reference_kind != Var, false);
				this.createDestructorCall(this.yield_var);
			}

			if this.yield_type.reference_kind == None {
				var constructor_args: List!<Expr>;
				constructor_args.append(Expr::VarInvoke(this.yield_var, span, this.yield_type.varRef()));
				constructor_args.append(checked_value);

				const constructor_call = this.checkCall(Name("constructor"), constructor_args, false, false, CallKind::MemberCall, false, span);
				result.append(Stmt::Expr(constructor_call, span));
			} else {
				result.append(Stmt::Expr(Expr::ShallowCopy(
					ShallowCopyExpr(Expr::VarInvoke(this.yield_var, span, this.yield_type.varRef()), checked_value),
					span,
					this.program.void_type
				), span));
			}
		}

		result.append(value_cleanup);
		result.append(this.collectCleanupCalls(ScopeKind::Match));
		result.append(Stmt::Yield(span));
		return result;
	}

	func checkExprStmt(this: &&TCContext, parsed_expr: &ParsedExpr, is_discard_stmt: bool, is_comptime: bool, span: Span) -> List!<Stmt> {
		this.pushScope(ScopeKind::Expr);
		const expr = this.checkExpr(parsed_expr, Type::unknown(), is_comptime);
		const cleanup = this.collectCleanupCallsForCurrentScope();
		this.popScope();

		var result: List!<Stmt>;

		if expr is Undefined {
			return result;
		}

		if !(expr is Void) {
			const expr_stmt = Stmt::Expr(expr, span);
			result.append(expr_stmt);
			if !expr_stmt.isTerminator(this.program.never_type, this.isCurrentScopeInsideMatch()) {
				result.append(cleanup);
			}
		}

		if !is_discard_stmt {
			if expr.type != this.program.void_type && expr.type != this.program.never_type {
				this.error("unused value", parsed_expr.span);
			}
		}

		return result;
	}

	// expr typechecking functions
	func checkExpr(this: &&TCContext, parsed_expr: &ParsedExpr, expected_type: Type, is_comptime: bool) -> Expr {
		match parsed_expr {
			case Empty -> return Expr::Void(parsed_expr.span, this.program.void_type)
			case Char: &char_literal -> return this.checkCharLiteralExpr(char_literal, parsed_expr.span);
			case String: &string_literal -> return this.checkStringLiteralExpr(string_literal, parsed_expr.span);
			case Number: &number_literal -> return this.checkNumberLiteralExpr(number_literal, expected_type, parsed_expr.span);
			case Bool: &value -> return Expr::Integer(value as int, parsed_expr.span, this.program.bool_type);
			case Name: &parsed_name -> return this.checkNameExpr(parsed_name, expected_type, is_comptime, parsed_expr.span);
			case Operator: &parsed_operator -> return this.checkOperatorExpr(parsed_operator, expected_type, is_comptime, parsed_expr.span);
			case Paren: &child -> return this.checkExpr(child, expected_type, is_comptime);
			case Array: &elements -> return this.checkArrayExpr(elements, expected_type, is_comptime, parsed_expr.span);
			case Tuple: &elements -> return this.checkTupleExpr(elements, expected_type, is_comptime, parsed_expr.span);
			case Dict: &elements -> return this.checkDictExpr(elements, expected_type, is_comptime, parsed_expr.span);
			case Match: &match_expr -> return this.checkMatchExpr(match_expr, expected_type, is_comptime, parsed_expr.span);
			case FunctionRef: &data -> return this.checkFunctionRefExpr(data.name, data.parameter_types, parsed_expr.span);
			case Type: &parsed_type -> return Expr::TypeRef(this.checkTypeUsage(parsed_type, false), parsed_expr.span, Type::unknown());
			case AnonymousFunction: &parsed_function_decl -> return this.checkAnonymousFunctionExpr(parsed_function_decl);
			case Garbage -> return Expr::Undefined(parsed_expr.span, Type::unknown());
		}
	}

	func checkExprList(this: &&TCContext, parsed_exprs: &List!<ParsedExpr>, is_comptime: bool) -> List!<Expr> {
		var result: List!<Expr>;
		result.grow(parsed_exprs.size());
		for &e in parsed_exprs {
			result.append(this.checkExpr(e, Type::unknown(), is_comptime));
		}
		return result;
	}

	func checkCharLiteralExpr(this: &&TCContext, char_literal: CharLiteral, span: Span) -> Expr {
		if char_literal.postfix == "b" {
			return Expr::Integer(char_literal.value as int, span, this.program.byte_type);
		} else if const bits = getNumericTypeBits(char_literal.postfix) {
			var name = "";
			match char_literal.postfix[0u] {
				case 'i'b -> name = "int";
				case 'u'b -> name = "uint";
				else -> {
					this.error("invalid char literal postfix", span);
					return Expr::Undefined(span, Type::unknown());
				}
			}

			var template_parameters: List!<TemplateParameter>;
			template_parameters.append(TemplateParameter::Integer(bits as int));

			return Expr::Integer(char_literal.value as int, span, this.getType(Name(name, template_parameters), span));
		}

		this.error("invalid char literal", span);
		return Expr::Undefined(span, Type::unknown());
	}

	func checkStringLiteralExpr(this: &&TCContext, string_literal: StringLiteral, span: Span) -> Expr {
		if string_literal.postfix == "" {
			return Expr::String(string_literal.value, span, this.getType(Name("String"), span));
		} else {
			this.error("invalid string literal", span);
			return Expr::Undefined(span, Type::unknown());
		}
	}

	func checkNumberLiteralExpr(this: &&TCContext, number_literal: NumberLiteral, expected_type: Type, span: Span) -> Expr {
		if number_literal.postfix == "" {
			if expected_type.isIntType() {
				return Expr::Integer(number_literal.value.toInt(), span, expected_type);
			} else if expected_type.isFloatType() {
				return Expr::Float(number_literal.value.toFloat(), span, expected_type);
			} else if number_literal.value.isInteger() && !number_literal.value.contains_decimal_point {
				return Expr::Integer(number_literal.value.toInt(), span, this.program.int_type);
			} else {
				return Expr::Float(number_literal.value.toFloat(), span, this.getType(Name("f64"), span));
			}
		} else if number_literal.postfix == "i" {
			return Expr::Integer(number_literal.value.toInt(), span, this.program.int_type);
		} else if number_literal.postfix == "u" {
			return Expr::Integer(number_literal.value.toInt(), span, this.program.uint_type);
		} else if number_literal.postfix == "b" {
			return Expr::Integer(number_literal.value.toInt(), span, this.program.byte_type);
		} else if number_literal.postfix == "f" {
			return Expr::Float(number_literal.value.toFloat(), span, this.getType(Name("f64"), span));
		} else if const bits = getNumericTypeBits(number_literal.postfix) {
			var name = "";
			match number_literal.postfix[0u] {
				case 'i'b -> name = "int";
				case 'u'b -> name = "uint";
				case 'f'b -> name = "float";
				else -> {
					this.error("invalid number literal postfix", span);
					return Expr::Undefined(span, Type::unknown());
				}
			}

			var template_parameters: List!<TemplateParameter>;
			template_parameters.append(TemplateParameter::Integer(bits as int));

			return Expr::Integer(number_literal.value.toInt(), span, this.getType(Name(name, template_parameters), span));
		}

		this.error("invalid number literal", span);
		return Expr::Undefined(span, Type::unknown());
	}

	func createVarInvokeExpr(this: &&TCContext, variable: SharedHandle!<VarDecl>, span: Span) -> Expr {
		var result = Expr::Undefined(Span(), Type::unknown());
		if variable.type.isUnknown() {
			return result;
		}

		match variable.type.reference_kind {
			case Const | Var -> result = Expr::VarInvoke(variable, span, variable.type);
			else -> match variable.is_const {
				case true -> result = Expr::VarInvoke(variable, span, variable.type.constRef());
				case false -> result = Expr::VarInvoke(variable, span, variable.type.varRef());
			}
		}

		return Expr::Dereference(Box!<Expr>(result), span, variable.type.base());
	}

	func checkArrayExpr(this: &&TCContext, parsed_elements: &List!<ParsedExpr>, expected_type: Type, is_comptime: bool, span: Span) -> Expr {
		var expected_element_type = Type::unknown();
		if !expected_type.isUnknown() {
			const type_decl = expected_type.decl;
			if const array_type = type_decl.body as Array {
				expected_element_type = array_type.element_type;
			}
		}

		var elements: List!<Expr>;
		for parsed_element in parsed_elements {
			const checked_element = this.checkExpr(parsed_element, expected_element_type, is_comptime);
			elements.append(checked_element);

			if expected_element_type.isUnknown() {
				expected_element_type = checked_element.type;
			} else if expected_element_type != checked_element.type {
				this.error("array element has invalid type: expected " + expected_element_type.signature() + ", but got " + checked_element.type.signature(), checked_element.span);
			}
		}

		var template_parameters: List!<TemplateParameter>;
		template_parameters.append(TemplateParameter::Type(expected_element_type));
		template_parameters.append(TemplateParameter::Integer(elements.size() as int));

		const result_type = this.getType(Name("Array", template_parameters), span);
		return this.createTemporaryVariable(
			result_type,
			List!<TemplateParameter>(),
			List!<Expr>(1u, Expr::ConstAggregate(elements, span, result_type)),
			is_comptime,
			span
		);
	}

	func checkTupleExpr(this: &&TCContext, parsed_expr: &List!<ParsedTupleElement>, expected_type: Type, is_comptime: bool, span: Span) -> Expr {
		var names: List!<String>;
		var elements: List!<Expr>;
		var element_types: List!<Type>;

		for parsed_element in parsed_expr {
			if parsed_element.name == "" {
				names.append(String(1u, ('a'b as uint + names.size()) as byte));
			} else {
				names.append(parsed_element.name);
			}

			const value = this.checkExpr(parsed_element.value, Type::unknown(), is_comptime);
			elements.append(value);
			element_types.append(value.type);
		}

		var template_parameters: List!<TemplateParameter>;
		template_parameters.append(TemplateParameter::String(",".join(names)));
		for t in element_types {
			template_parameters.append(TemplateParameter::Type(t));
		}

		return this.createTemporaryVariable(
			this.getType(Name("Tuple", template_parameters), span),
			List!<TemplateParameter>(), elements, is_comptime, span
		);
	}

	func checkDictExpr(this: &&TCContext, parsed_expr: &List!<ParsedDictElement>, expected_type: Type, is_comptime: bool, span: Span) -> Expr {
		this.todo("implement typechecking of dict expressions", span);
		return Expr::Undefined(span, Type::unknown());
	}

	func checkMatchExpr(this: &&TCContext, parsed_expr: &ParsedMatchExpr, expected_type: Type, is_comptime: bool, span: Span) -> Expr {
		return this.checkMatchExpr(this.checkExpr(parsed_expr.value, Type::unknown(), is_comptime), parsed_expr.body.children, expected_type, is_comptime, span);
	}

	func addCasesToMatchExpr(this: &&TCContext, match_expr: &&MatchExpr, stmt: &Stmt) -> void {
		match stmt {
			case Compound: compound_stmt -> {
				for other in compound_stmt.children {
					this.addCasesToMatchExpr(&&match_expr, other);
				}
			}
			case Case: case_stmt -> match_expr.cases.append(case_stmt);
			case ElseCase: body -> {
				if match_expr.else_case is Empty {
					match_expr.else_case = body;
				} else {
					this.error("mutiple definitions of an else case in the same match expr", stmt.span);
					this.info("else case first declared here:", match_expr.else_case.span);
				}
			}
			case Empty -> {}
			else -> {
				this.error("expected case statement", stmt.span);
			}
		}
	}

	func checkMatchExpr(this: &&TCContext, checked_value: &Expr, parsed_body: &List!<ParsedStmt>, expected_type: Type, is_comptime: bool, span: Span) -> Expr {
		if checked_value is Undefined {
			return Expr::Undefined(span, Type::unknown());
		}

		const prev_match_value = this.match_value;
		const prev_match_type = this.match_type;
		const prev_yield_type = this.yield_type;
		const prev_yield_var = this.yield_var;

		this.match_value = checked_value;

		const value_type_decl = this.match_value.type.decl;
		if !((value_type_decl.body is Variant) || this.match_value.type.isIntType()) {
			this.error("value in match statement has invalid type: expected integral type or variant but got '" + this.match_value.type.signature() + "'", this.match_value.span);
		}

		var match_value_var = SharedHandle!<VarDecl>();
		if value_type_decl.body is Variant {
			this.match_value = this.match_value.removeDereference();

			match this.match_value {
				case Call: call_expr -> match_value_var = call_expr.result_var;
				case Match: match_expr -> match_value_var = match_expr.yield_var;
				else -> {}
			}

			if !match_value_var.isAlive() && !(this.match_value is VarInvoke) {
				this.match_value = this.createTemporaryVariable(
					this.match_value.type,
					List!<TemplateParameter>(),
					List!<Expr>(1u, this.match_value),
					is_comptime,
					this.match_value.span
				).removeDereference();

				match this.match_value {
					case Call: call_expr -> match_value_var = call_expr.result_var;
					case ShallowCopy: shallow_copy_expr -> match shallow_copy_expr.destination {
						case VarInvoke: variable -> match_value_var = variable;
						else -> panic("invalid temporary variable");
					}
					case Undefined -> return Expr::Undefined(span, Type::unknown());
					else -> panic("invalid temporary variable");
				}
			}
		}

		var match_expr = MatchExpr(this.match_value, List!<CaseStmt>(), Stmt::Empty(Span()), SharedHandle!<VarDecl>());

		if match_value_var.isAlive() {
			this.match_value = this.createVarInvokeExpr(match_value_var, this.match_value.span).removeDereference();
		}

		this.match_type = this.match_value.type;
		this.yield_type = expected_type;
		this.yield_var = SharedHandle!<VarDecl>();

		this.pushScope(ScopeKind::Match);

		for parsed_stmt in parsed_body {
			const child = this.checkStmt(parsed_stmt);
			this.addCasesToMatchExpr(&&match_expr, child);
		}

		this.popScope();

		var result_type = this.program.void_type;
		var does_yield = false;
		if this.yield_var.isAlive() {
			this.addVariableToCurrentScope(this.yield_var);
			result_type = this.yield_var.type.constRef();
			does_yield = true;
		}

		var all_cases_are_terminators = true;
		for case_stmt in match_expr.cases {
			all_cases_are_terminators &= case_stmt.body.isTerminator(this.program.never_type, false);
		}

		if !(match_expr.else_case is Empty) {
			all_cases_are_terminators &= match_expr.else_case.isTerminator(this.program.never_type, false);
		}

		if all_cases_are_terminators && !does_yield {
			result_type = this.program.never_type;
		}

		var covered_cases: Set!<int>;
		for case_stmt in match_expr.cases {
			for pattern in case_stmt.patterns {
				match pattern {
					case Integer: value -> {
						if covered_cases.contains(value) {
							this.error("duplicated match pattern", pattern.span);
						} else {
							covered_cases.add(value);
						}
					}
					else -> {
						this.todo("check match completeness for non-int expressions", pattern.span);
					}
				}
			}
		}

		var number_of_possible_cases = 0u;
		match value_type_decl.body {
			case Bool -> number_of_possible_cases = 2;
			case Byte -> number_of_possible_cases = 256;
			case Int: size -> {
				if size == 0 {
					number_of_possible_cases = -1 as uint; // ptr sized max int
				} else {
					number_of_possible_cases = pow(2.0, size as f64) as uint;
				}
			}
			case UInt: size -> {
				if size == 0 {
					number_of_possible_cases = -1 as uint; // ptr sized max int
				} else {
					number_of_possible_cases = pow(2.0, size as f64) as uint;
				}
			}
			case Enum -> {
				var unique_cases: Set!<int>;
				for c in value_type_decl.enum_cases {
					unique_cases.add(c.id);
				}
				number_of_possible_cases = unique_cases.size();
			}
			case Variant -> {
				number_of_possible_cases = value_type_decl.variant_cases.size();
			}
			else -> {}
		}

		if covered_cases.size() < number_of_possible_cases && match_expr.else_case is Empty {
			this.error("match stmt doesn't cover all possible cases", this.match_value.span);
		} else if covered_cases.size() == number_of_possible_cases && !(match_expr.else_case is Empty) {
			this.error("else branch is unreachable", match_expr.else_case.span);
		}

		match_expr.yield_var = this.yield_var;
		const result = Expr::Match(Box!<MatchExpr>(match_expr), span, result_type);

		this.match_value = prev_match_value;
		this.match_type = prev_match_type;
		this.yield_type = prev_yield_type;
		this.yield_var = prev_yield_var;

		if result_type.reference_kind == None {
			return result;
		} else {
			return Expr::Dereference(Box!<Expr>(result), result.span, result_type.base());
		}
	}

	func checkFunctionRefExpr(this: &&TCContext, parsed_name: &ParsedName, parsed_parameter_types: &List!<ParsedType>, span: Span) -> Expr {
		const checked_name = this.checkName(parsed_name);
		var parameter_types: List!<Type>;
		for t in parsed_parameter_types {
			parameter_types.append(this.checkTypeUsage(t, false));
		}

		const candidates = this.lookupFunction(
			checked_name,
			SharedHandle!<TypeDecl>(),
			parameter_types,
			false, false,
			span
		);

		if !this.validateFunctionCanditates(candidates, checked_name, parameter_types, span) {
			return Expr::Undefined(span, Type::unknown());
		}

		return Expr::FunctionRef(candidates[0u], span, this.getFunctionType(parameter_types, candidates[0u].return_type, span));
	}

	func checkAnonymousFunctionExpr(this: &&TCContext, parsed_function: &ParsedFunctionDecl) -> Expr {
		const function = this.checkFunctionDecl(parsed_function, List!<TemplateParameterDecl>(), false);
		this.checkFunctionSignature(function);

		return Expr::FunctionRef(
			function,
			parsed_function.span,
			this.getFunctionType(function.parameter_types, function.return_type, parsed_function.span)
		);
	}

	func checkNameExpr(this: &&TCContext, parsed_name: &ParsedName, expected_type: Type, is_comptime: bool, span: Span) -> Expr {
		const checked_name = this.checkName(parsed_name);
		const symbols = this.lookupSymbol(
			checked_name,
			SharedHandle!<TypeDecl>(),
			SymbolLookupFilter::Variables | TemplateParameters,
			span
		) + this.lookupSymbol(
			checked_name,
			expected_type.decl,
			SymbolLookupFilter::CaseDecls,
			span
		);

		var result_candidates: List!<Expr>;

		for s in symbols {
			match s {
				case EnumCase: index -> {
					const parent_type = symbols[0u].parent_namespace.linked_type;
					result_candidates.append(Expr::Integer(parent_type.enum_cases[index].id, span, Type(parent_type)));
				}
				case VariantCase: index -> {
					const parent_type = symbols[0u].parent_namespace.linked_type;

					var template_parameters: List!<TemplateParameter>;
					template_parameters.append(TemplateParameter::Integer(
						parent_type.variant_cases[index].id
					));

					result_candidates.append(this.createTemporaryVariable(
						Type(parent_type),
						template_parameters,
						List!<Expr>(),
						is_comptime,
						span
					));
				}
				case TemplateParameter: parameter -> match parameter {
					case Integer: value -> {
						if expected_type.isIntType() {
							result_candidates.append(Expr::Integer(value, span, expected_type));
						} else {
							result_candidates.append(Expr::Integer(value, span, this.program.int_type));
						}
					}
					else -> {}
				}
				case Variable: variable -> result_candidates.append(this.createVarInvokeExpr(variable, span));
				else -> {}
			}
		}

		if result_candidates.isEmpty() {
			this.error("no matching symbol found for '" + format(checked_name) + "'", checked_name.span);
			return Expr::Undefined(span, Type::unknown());
		} else if result_candidates.size() > 1 {
			this.error("too many matching symbols found", span);
			for s in symbols {
				this.info("   " + format(s), Span());
			}
		}

		return result_candidates[0u];
	}

	func checkOperatorExpr(this: &&TCContext, parsed_expr: &ParsedOperatorExpr, expected_type: Type, is_comptime: bool, span: Span) -> Expr {
		match parsed_expr.op {
			case Initialize -> {
				var lhs = this.checkExpr(parsed_expr.operands[0u], Type::unknown(), is_comptime).removeDereference();
				if lhs.type.isUnknown() {
					return Expr::Undefined(span, Type::unknown());
				}

				const member_access_expr = lhs as MemberVarInvoke else {
					this.error("invalid initialize expr: object must be a member var invoke expr", span);
					return Expr::Undefined(span, Type::unknown());
				}

				const type_decl = member_access_expr.object.type.decl;

				const member_variable = type_decl.member_variables[member_access_expr.id];
				if member_variable.type.reference_kind == None {
					var arguments: List!<Expr>;
					arguments.append(lhs);

					match parsed_expr.operands[1u] {
						case Tuple: &elements -> {
							for &element in elements {
								arguments.append(this.checkExpr(element.value, Type::unknown(), is_comptime));
							}
						}
						case Paren: &child -> arguments.append(this.checkExpr(child, Type::unknown(), is_comptime));
						else -> arguments.append(this.checkExpr(parsed_expr.operands[1u], member_variable.type, is_comptime));
					}

					return this.checkCall(Name("constructor"), arguments, false, false, CallKind::MemberCall, is_comptime, span);
				} else {
					if this.active_member_variables.contains(member_access_expr.id) {
						this.error("double initialization of member variable", span);
						return Expr::Undefined(span, Type::unknown());
					}

					this.active_member_variables.add(member_access_expr.id);

					const rhs = this.checkExpr(parsed_expr.operands[1u], member_variable.type, is_comptime);
					if rhs.type != member_variable.type {
						this.error("initializer has invalid type: expected " + member_variable.type.signature() + " but got " + rhs.type.signature(), span);
					}

					return Expr::ShallowCopy(ShallowCopyExpr(lhs, rhs), span, this.program.void_type);
				}
			}
			case Call -> {
				const function = parsed_expr.operands[0u];
				var arguments = this.checkExprList(List!<ParsedExpr>(parsed_expr.operands[1u..parsed_expr.operands.size()]), is_comptime);

				for &arg in arguments {
					if arg is Undefined {
						return Expr::Undefined(span, Type::unknown());
					}
				}

				match function {
					case Name: name -> {
						const checked_name = this.checkName(name);
						const argument_types = getArgumentTypes(arguments, false);
						const matching_functions = this.lookupFunction(
							checked_name,
							SharedHandle!<TypeDecl>(),
							argument_types,
							true, true,
							span
						);

						if matching_functions.isEmpty() {
							const matching_symbols = this.lookupSymbol(
								checked_name,
								expected_type.decl,
								SymbolLookupFilter::Types | CaseDecls | Variables,
								span
							);

							if matching_symbols.size() == 1 {
								match matching_symbols[0u] {
									case Type: type_decl -> return this.createTemporaryVariable(
										Type(type_decl),
										List!<TemplateParameter>(),
										arguments,
										is_comptime,
										span
									);
									case VariantCase: index -> {
										const parent_type = matching_symbols[0u].parent_namespace.linked_type;

										var template_parameters: List!<TemplateParameter>;
										template_parameters.append(TemplateParameter::Integer(
											parent_type.variant_cases[index].id
										));

										return this.createTemporaryVariable(
											Type(parent_type),
											template_parameters,
											arguments,
											is_comptime,
											span
										);
									}
									case Variable: variable -> {
										arguments.insert(0u, this.checkExpr(function, Type::unknown(), is_comptime));
										return this.checkCall(
											Name("operator ()"),
											arguments,
											true, true,
											CallKind::MemberCall,
											is_comptime,
											span
										);
									}
									else -> {}
								}
							} else if matching_symbols.size() > 1 {
								this.error("too many matching symbols found", span);
								return Expr::Undefined(span, Type::unknown());
							}
						}

						if !this.validateFunctionCanditates(matching_functions, checked_name, argument_types, span) {
							return Expr::Undefined(span, Type::unknown());
						}

						return this.createCall(matching_functions[0u], arguments, CallKind::Static, is_comptime, span);
					}
					case Operator: operator_expr -> {
						if operator_expr.op == MemberAccess {
							if const parsed_name = operator_expr.operands[1u] as Name {
								const object = this.checkExpr(operator_expr.operands[0u], Type::unknown(), is_comptime);
								if object is Undefined {
									return Expr::Undefined(span, Type::unknown());
								}

								const name = this.checkName(parsed_name);

								arguments.insert(0u, object);
								const candidates = this.lookupFunction(
									name,
									object.type.decl,
									getArgumentTypes(arguments, true),
									true, true, span
								);

								const parent_type = object.type.decl;
								if candidates.isEmpty() && name.segments.size() == 1 {
									if name.segments[0u].template_parameters.isEmpty() && parent_type.member_variables_by_name.contains(parsed_name.segments[0u].name) {
										arguments[0u] = this.checkMemberAccessExpr(object, name.segments[0u].name, is_comptime, span);
										return this.checkCall(Name("operator ()"), arguments, true, true, CallKind::MemberCall, is_comptime, span);
									}
								}

								if !this.validateFunctionCanditates(candidates, name, getArgumentTypes(arguments, true), span) {
									return Expr::Undefined(span, Type::unknown());
								}

								return this.createCall(candidates[0u], arguments, CallKind::MemberCall, is_comptime, span);
							}
						}
					}
					else -> {}
				}

				arguments.insert(0u, this.checkExpr(function, Type::unknown(), is_comptime));
				return this.checkCall(
					Name("operator ()"),
					arguments,
					true, true,
					CallKind::MemberCall,
					is_comptime,
					span
				);
			}
			case Index -> return this.checkCall(
				Name("operator []"),
				this.checkExprList(parsed_expr.operands, is_comptime),
				true, true,
				CallKind::MemberCall,
				is_comptime,
				span
			);
			case ConstRef -> {
				var base = this.checkExpr(parsed_expr.operands[0u], Type::unknown(), is_comptime).removeDereference();
				if base is Undefined {
					return Expr::Undefined(span, Type::unknown());
				}

				if base.type.reference_kind == None {
					this.error("object can't be referenced", base.span);
				}

				base.type.reference_kind = Const;
				base.span = span;
				return base;
			}
			case VarRef -> {
				var base = this.checkExpr(parsed_expr.operands[0u], Type::unknown(), is_comptime).removeDereference();
				if base is Undefined {
					return Expr::Undefined(span, Type::unknown());
				}

				if base.type.reference_kind == None {
					this.error("object can't be referenced", base.span);
				} else if base.type.reference_kind == Const {
					this.error("can't take var reference to const object", base.span);
				}

				base.type.reference_kind = Var;
				base.span = span;
				return base;
			}
			case Is -> return this.checkOperatorIsExpr(parsed_expr.operands[0u], parsed_expr.operands[1u], is_comptime, span);
			case As -> return this.checkOperatorAsExpr(parsed_expr.operands[0u], parsed_expr.operands[1u], is_comptime, span);
			case Try | Must -> return this.checkValidateExpr(parsed_expr.operands[0u], parsed_expr.op, is_comptime, span);
			case InlineIf -> return this.checkInlineIfExpr(parsed_expr.operands[0u], parsed_expr.operands[1u], parsed_expr.operands[2u], expected_type, is_comptime, span);
			case MemberAccess -> {
				const object = this.checkExpr(parsed_expr.operands[0u], Type::unknown(), is_comptime);

				const parsed_member_name = parsed_expr.operands[1u] as Name else {
					this.error("expected member name", span);
					return Expr::Undefined(span, Type::unknown());
				}

				if parsed_member_name.segments.size() != 1 || !parsed_member_name.segments[0u].template_parameters.isEmpty() {
					this.error("invalid member name", span);
					return Expr::Undefined(span, Type::unknown());
				}

				return this.checkMemberAccessExpr(object, parsed_member_name.segments[0u].name, is_comptime, span);
			}
			else -> {
				var arguments: List!<Expr>;
				arguments.grow(parsed_expr.operands.size());
				for &arg in parsed_expr.operands {
					if arguments.size() == 1 {
						arguments.append(this.checkExpr(arg, arguments[0u].type, is_comptime));
					} else {
						arguments.append(this.checkExpr(arg, Type::unknown(), is_comptime));
					}
				}

				return this.checkCall(
					Name("operator " + parsed_expr.op.toString()),
					arguments, true, true, CallKind::Operator, is_comptime, span
				);
			}
		}
	}

	func checkMemberAccessExpr(this: &&TCContext, raw_object: &Expr, member_name: String, is_comptime: bool, span: Span) -> Expr {
		var object = raw_object.removeDereference();
		if object is Undefined {
			return Expr::Undefined(span, Type::unknown());
		}

		var type_decl = object.type.decl;
		if type_decl.getMemberVariable(member_name) is None && !type_decl.unwrapped_type.isEmpty() {
			if type_decl.unwrapped_type.getMemberVariable(member_name) is Some {
				object = this.checkCall(
					Name("operator unwrap"),
					List!<Expr>(1u, object), false, false, CallKind::MemberCall, is_comptime, span
				).removeDereference();

				type_decl = type_decl.unwrapped_type;
			}
		}

		const member_variable = type_decl.getMemberVariable(member_name) else {
			this.error("no member variable with name '" + member_name + "' on type " + object.type.base().signature(), span);
			return Expr::Undefined(span, Type::unknown());
		}

		var result_type = member_variable.type;
		if result_type.reference_kind == None {
			result_type.reference_kind = object.type.reference_kind;
		}

		return Expr::MemberVarInvoke(
			Box!<MemberVarInvokeExpr>(MemberVarInvokeExpr(object, member_variable.id)),
			span, result_type
		).addDereference();
	}

	func checkValidateExpr(this: &&TCContext, parsed_value: &ParsedExpr, op: Operator, is_comptime: bool, span: Span) -> Expr {
		// try foo()
		// ->
		// match foo() {
		//     Ok: val -> yield val;
		//     Error: err -> throw err;
		// }

		// must foo()
		// ->
		// match foo() {
		//     Ok: val -> yield val;
		//     Error: err -> panic(err);
		// }

		const value = this.checkExpr(parsed_value, Type::unknown(), is_comptime);
		if value is Undefined {
			return Expr::Undefined(span, Type::unknown());
		}

		const type_decl = value.type.decl;

		const ok_case_decl = type_decl.getVariantCase("Ok") else {
			this.error("value has invalid type: expected std::core::Result or similar, but got " + value.type.signature(), span);
			return Expr::Undefined(span, Type::unknown());
		}

		const error_case_decl = type_decl.getVariantCase("Error") else {
			this.error("value has invalid type: expected std::core::Result or similar, but got " + value.type.signature(), span);
			return Expr::Undefined(span, Type::unknown());
		}

		var cases: List!<ParsedStmt>;

		var yield_type = ok_case_decl.type;
		if yield_type == this.program.void_type {
			// case Ok -> yield
			cases.append(ParsedStmt::Case(Box!<ParsedCaseStmt>(ParsedCaseStmt(
				List!<ParsedExpr>(1u, ParsedExpr::Name(makeParsedName(span, "Ok"), span)),
				"", ok_case_decl.type.reference_kind,
				ParsedStmt::Yield(ParsedExpr::Empty(span), span, false)
			)), span, false));
		} else {
			// case Ok: val -> yield val
			var value_invoke_expr = ParsedExpr::Name(makeParsedName(span, "#value"), span);
			match ok_case_decl.type.reference_kind {
				case Var -> value_invoke_expr = makeParsedOperatorExpr(Operator::VarRef, value_invoke_expr, span);
				case Const -> value_invoke_expr = makeParsedOperatorExpr(Operator::ConstRef, value_invoke_expr, span);
				else -> {}
			}

			cases.append(ParsedStmt::Case(Box!<ParsedCaseStmt>(ParsedCaseStmt(
				List!<ParsedExpr>(1u, ParsedExpr::Name(makeParsedName(span, "Ok"), span)),
				"#value", ok_case_decl.type.reference_kind,
				ParsedStmt::Yield(value_invoke_expr, span, false)
			)), span, false));
		}

		var error_invoke_expr = ParsedExpr::Name(makeParsedName(span, "#error"), span);
		match error_case_decl.type.reference_kind {
			case Var -> error_invoke_expr = makeParsedOperatorExpr(Operator::VarRef, error_invoke_expr, span);
			case Const -> error_invoke_expr = makeParsedOperatorExpr(Operator::ConstRef, error_invoke_expr, span);
			else -> {}
		}

		if op == Try {
			// case Error: error -> throw error
			cases.append(ParsedStmt::Case(Box!<ParsedCaseStmt>(ParsedCaseStmt(
				List!<ParsedExpr>(1u, ParsedExpr::Name(makeParsedName(span, "Error"), span)),
				"#error", error_case_decl.type.reference_kind,
				ParsedStmt::Throw(error_invoke_expr, span, false)
			)), span, false));
		} else if op == Must {
			// case Error: error -> panic(error)
			cases.append(ParsedStmt::Case(Box!<ParsedCaseStmt>(ParsedCaseStmt(
				List!<ParsedExpr>(1u, ParsedExpr::Name(makeParsedName(span, "Error"), span)),
				"#error", error_case_decl.type.reference_kind,
				ParsedStmt::Expr(makeParsedOperatorExpr(
					ParsedExpr::Name(makeParsedName(span, "panic"), span),
					Operator::Call,
					error_invoke_expr,
					span
				), span, false)
			)), span, false));
		} else {
			this.error("invalid operator for validate expr: must be try or must", span);
			abort();
		}

		return this.checkMatchExpr(value, cases, yield_type, is_comptime, span);
	}

	func checkInlineIfExpr(this: &&TCContext, then_value: &ParsedExpr, condition: &ParsedExpr, else_value: &ParsedExpr, expected_type: Type, is_comptime: bool, span: Span) -> Expr {
		// x if y else z
		// ->
		// match y {
		//     true -> yield x;
		//     false -> yield z;
		// }
		var children: SharedPtr!<List!<ParsedStmt>> = List!<ParsedStmt>();

		children.append(ParsedStmt::Case(Box!<ParsedCaseStmt>(ParsedCaseStmt(
			List!<ParsedExpr>(1u, ParsedExpr::Bool(true, then_value.span)),
			"", ReferenceKind::None,
			ParsedStmt::Yield(then_value, then_value.span, false)
		)), then_value.span, false));

		children.append(ParsedStmt::Case(Box!<ParsedCaseStmt>(ParsedCaseStmt(
			List!<ParsedExpr>(1u, ParsedExpr::Bool(false, else_value.span)),
			"", ReferenceKind::None,
			ParsedStmt::Yield(else_value, else_value.span, false)
		)), else_value.span, false));

		return this.checkMatchExpr(ParsedMatchExpr(condition, ParsedCompoundStmt(span, children)), expected_type, is_comptime, span);
	}

	func checkOperatorIsExpr(this: &&TCContext, parsed_lhs: &ParsedExpr, parsed_rhs: &ParsedExpr, is_comptime: bool, span: Span) -> Expr {
		var lhs = this.checkExpr(parsed_lhs, Type::unknown(), is_comptime);
		if lhs is Undefined {
			return Expr::Undefined(span, Type::unknown());
		}

		const lhs_type_decl = lhs.type.decl;

		if lhs_type_decl.body is Enum {
			const rhs = this.checkExpr(parsed_rhs, lhs.type.base(), is_comptime);
			if rhs.type != lhs.type.base() {
				this.error("invalid rhs for 'operator is'", span);
				return Expr::Undefined(span, Type::unknown());
			}

			var arguments: List!<Expr>;
			arguments.append(lhs);
			arguments.append(rhs);

			return this.checkCall(
				Name("operator =="),
				arguments, false, false, CallKind::MemberCall, is_comptime, span
			);
		} else if lhs_type_decl.body is Variant {
			var arguments: List!<Expr>;
			arguments.append(lhs);

			var case_name = "";
			match &parsed_rhs {
				case Name: &parsed_name -> case_name = parsed_name.segments[0u].name;
				else -> {
					this.error("invalid rhs for 'operator is'", span);
					return Expr::Undefined(span, Type::unknown());
				}
			}

			const case_decl = lhs_type_decl.getVariantCase(case_name) else {
				this.error("unknown variant case", span);
				return Expr::Undefined(span, Type::unknown());
			}

			var template_parameters: List!<TemplateParameter>;
			template_parameters.append(TemplateParameter::Integer(case_decl.id));

			return this.checkCall(
				Name("operator is", template_parameters),
				arguments, false, false, CallKind::MemberCall, is_comptime, span
			);
		} else {
			this.error("'operator is' requires lhs to be an enum or a variant instance", span);
			return Expr::Undefined(span, Type::unknown());
		}
	}

	func checkOperatorAsExpr(this: &&TCContext, parsed_lhs: &ParsedExpr, parsed_rhs: &ParsedExpr, is_comptime: bool, span: Span) -> Expr {
		const lhs = this.checkExpr(parsed_lhs, Type::unknown(), is_comptime);
		if lhs is Undefined {
			return Expr::Undefined(span, Type::unknown());
		}

		const lhs_type_decl = lhs.type.decl;

		if lhs_type_decl.body is Variant && parsed_rhs is Name {
			const parsed_name = (parsed_rhs as Name).value();
			if parsed_name.segments.size() == 1 {
				if  parsed_name.segments[0u].template_parameters.isEmpty() {
					if lhs_type_decl.getVariantCase(parsed_name.segments[0u].name).hasValue() {
						return this.createSafeVariantCastExpr(lhs, parsed_name.segments[0u].name, is_comptime, span);
					}
				}
			}
		}

		const source_type = lhs.type;
		const target_type = this.checkTypeUsage(parsed_rhs.toType(), false);
		if target_type.isUnknown() {
			this.error("invalid target type for cast", parsed_rhs.span);
			return Expr::Undefined(span, Type::unknown());
		}

		var cast_name = "";
		if source_type.isIntType() && target_type.isIntType() {
			cast_name = "intCast";
		} else if source_type.isIntType() && target_type.isFloatType() {
			cast_name = "intToFloat";
		} else if source_type.isFloatType() && target_type.isIntType() {
			cast_name = "floatToInt";
		} else if source_type.isFloatType() && target_type.isFloatType() {
			cast_name = "floatCast";
		} else if source_type.isPtrType() && target_type.isPtrType() {
			cast_name = "pointerCast";
		}

		var cast_template_parameters: List!<TemplateParameter>;
		var cast_arguments: List!<Expr>;
		cast_arguments.append(lhs);

		if cast_name == "" { // lhs.operator as!<target_type>()
			cast_template_parameters.append(TemplateParameter::Type(target_type));

			return this.checkCall(
				Name("operator as", cast_template_parameters),
				cast_arguments,
				false, false, CallKind::MemberCall, is_comptime, span
			);
		} else {
			cast_template_parameters.append(TemplateParameter::Type(source_type));
			cast_template_parameters.append(TemplateParameter::Type(target_type));

			return this.checkCall(
				Name(cast_name, cast_template_parameters),
				cast_arguments,
				false, false, CallKind::Static, is_comptime, span
			);
		}
	}

	func createSafeVariantCastExpr(this: &&TCContext, value: &Expr, case_name: String, is_comptime: bool, span: Span) -> Expr {
		// x as Foo
		// ->
		// match x {
		//     case Foo: val -> yield Some(val);
		//     else -> yield None;
		// }

		const type_decl = value.type.decl;
		const case_decl = type_decl.getVariantCase(case_name).value();

		if case_decl.type == this.program.void_type {
			this.error("invalid variant cast: no type attached to this case", span);
			return Expr::Undefined(span, Type::unknown());
		}

		const yield_type = this.getType(Name("Optional", List!<TemplateParameter>(1u, TemplateParameter::Type(case_decl.type))), span);

		var value_invoke_expr = ParsedExpr::Name(makeParsedName(span, "#value"), span);
		match case_decl.type.reference_kind {
			case Var -> value_invoke_expr = makeParsedOperatorExpr(Operator::VarRef, value_invoke_expr, span);
			case Const -> value_invoke_expr = makeParsedOperatorExpr(Operator::ConstRef, value_invoke_expr, span);
			else -> {}
		}

		var cases: List!<ParsedStmt>;

		// case Foo: val -> yield Some(val)
		cases.append(ParsedStmt::Case(Box!<ParsedCaseStmt>(ParsedCaseStmt(
			List!<ParsedExpr>(1u, ParsedExpr::Name(makeParsedName(span, case_name), span)),
			"#value", case_decl.type.reference_kind,
			ParsedStmt::Yield(makeParsedOperatorExpr(
				ParsedExpr::Name(makeParsedName(span, "Some"), span),
				Operator::Call,
				value_invoke_expr,
				span
			), span, false)
		)), span, false));

		// else -> yield None
		cases.append(ParsedStmt::ElseCase(Box!<ParsedStmt>(
			ParsedStmt::Yield(
				ParsedExpr::Name(makeParsedName(span, "None"), span),
				span, false
			)
		), span, false));

		return this.checkMatchExpr(value, cases, yield_type, is_comptime, span);
	}

	func lookupNamespace(this: &&TCContext, namespaces_to_search: &Set!<SharedHandle!<Namespace>>, name: &NameSegment, span: Span) -> Set!<SharedHandle!<Namespace>> {
		var result: Set!<SharedHandle!<Namespace>>;

		for n in namespaces_to_search {
			var most_matching_template_parameters = 0;
			var matching_children: List!<SharedHandle!<Namespace>>;

			for child in n.children_by_name.getOrDefault(name.name) {
				const matching_template_parameters = this.getMatchingTemplateParameterCount(child.template_parameters, name.template_parameters);
				if matching_template_parameters > most_matching_template_parameters {
					matching_children.clear();
					matching_children.append(child);
					most_matching_template_parameters = matching_template_parameters;
				} else if matching_template_parameters == most_matching_template_parameters {
					matching_children.append(child);
				}
			}

			result.grow(result.size() + matching_children.size());
			for child in matching_children {
				if child.isIncompleteTemplate() {
					result.add(this.createTemplateInstance(child, name.template_parameters, span));
				} else {
					result.add(child);
				}
			}

			if name.template_parameters.isEmpty() {
				if const target = n.aliases.get(name.name) {
					result.add(target);
				}
			}
		}

		return result;
	}

	func lookupSymbol(this: &&TCContext, name: &Name, parent_type: SharedHandle!<TypeDecl>, filter: SymbolLookupFilter, span: Span) -> List!<Symbol> {
		var result: List!<Symbol>;
		if name.segments.isEmpty() {
			return result;
		}

		var name_segments = name.segments;
		const last_segment = name_segments.last().value();
		name_segments.removeLast();

		var namespaces_to_search: Set!<SharedHandle!<Namespace>>;
		for n in this.program.getVisibleNamespaces(this.current_namespace) {
			const intersecting_segments = n.full_name.intersection(name_segments);

			var matching_namespaces: Set!<SharedHandle!<Namespace>>;
			matching_namespaces.add(n);

			for i in intersecting_segments..name_segments.size() {
				matching_namespaces = this.lookupNamespace(matching_namespaces, name_segments[i], span);
			}

			namespaces_to_search.add(matching_namespaces);
		}

		if name_segments.isEmpty() && parent_type.isAlive() {
			namespaces_to_search.add(parent_type.linked_namespace);

			if parent_type.unwrapped_type.isAlive() {
				namespaces_to_search.add(parent_type.unwrapped_type.linked_namespace);
			}
		}

		for n in this.lookupNamespace(namespaces_to_search, last_segment, span) {
			if (filter & Namespaces) != None {
				result.append(Symbol::Namespace(n, n.parent));
			}

			if (filter & Types) != None {
				if n.linked_type.isAlive() {
					result.append(Symbol::Type(n.linked_type, n.parent));
				}
			}
		}

		if (filter & Types) != None && name_segments.isEmpty() && last_segment.template_parameters.isEmpty() && this.program.core_namespace.isAlive() && namespaces_to_search.contains(this.program.core_namespace) {
			if const bits = getNumericTypeBits(last_segment.name) {
				var numeric_type_template_parameters: List!<TemplateParameter>;
				numeric_type_template_parameters.append(TemplateParameter::Integer(bits as int));

				const numeric_type_name = match last_segment.name[0u] {
					case 'i'b -> yield "int";
					case 'u'b -> yield "uint";
					case 'f'b -> yield "float";
					else -> panic("invalid numeric type");
				}

				for n in this.lookupNamespace(namespaces_to_search, NameSegment(numeric_type_name, numeric_type_template_parameters), span) {
					if n.linked_type.isAlive() {
						result.append(Symbol::Type(n.linked_type, n.parent));
					}
				}
			}
		}

		if name_segments.isEmpty() && parent_type.isAlive() {
			if (filter & MemberVariables) != None {
				if const index = parent_type.member_variables_by_name.get(last_segment.name) {
					result.append(Symbol::MemberVariable(index, parent_type.linked_namespace));
				}
			}

			if (filter & CaseDecls) != None {
				if const index = parent_type.enum_cases_by_name.get(last_segment.name) {
					result.append(Symbol::EnumCase(index, parent_type.linked_namespace));
				}

				if const index = parent_type.variant_cases_by_name.get(last_segment.name) {
					result.append(Symbol::VariantCase(index, parent_type.linked_namespace));
				}
			}
		}

		if !name_segments.isEmpty() {
			for n in namespaces_to_search {
				if n.linked_type.isEmpty() {
					continue;
				}

				if (filter & CaseDecls) != None {
					if const index = n.linked_type.enum_cases_by_name.get(last_segment.name) {
						result.append(Symbol::EnumCase(index, n));
					}

					if const index = n.linked_type.variant_cases_by_name.get(last_segment.name) {
						result.append(Symbol::VariantCase(index, n));
					}
				}
			}
		}

		if (filter & Functions) != None {
			for n in namespaces_to_search {
				var most_matching_template_parameters = 0;
				var functions_with_matching_template_parameters: List!<SharedHandle!<FunctionDecl>>;
				for function in n.functions_by_name.getOrDefault(last_segment.name) {
					const matching_template_parameters = this.getMatchingTemplateParameterCount(function.template_parameters, last_segment.template_parameters);

					if matching_template_parameters > most_matching_template_parameters {
						functions_with_matching_template_parameters.clear();
						functions_with_matching_template_parameters.append(function);
						most_matching_template_parameters = matching_template_parameters;
					} else if matching_template_parameters == most_matching_template_parameters {
						functions_with_matching_template_parameters.append(function);
					}
				}

				for function in functions_with_matching_template_parameters {
					if function.isIncompleteTemplate() {
						result.append(Symbol::Function(this.createTemplateInstance(function, last_segment.template_parameters, span), n));
					} else {
						result.append(Symbol::Function(function, n));
					}
				}
			}
		}

		if last_segment.template_parameters.isEmpty() && (filter & Variables) != None {
			for n in namespaces_to_search {
				if const variable = n.comptime_variables_by_name.get(last_segment.name) {
					result.append(Symbol::Variable(variable, n));
				}
			}
		}

		if name_segments.isEmpty() && last_segment.template_parameters.isEmpty() && (filter & Variables) != None {
			if const variable = this.getVariableByName(last_segment.name) {
				result.append(Symbol::Variable(variable, SharedHandle!<Namespace>()));
			}
		}

		if name_segments.isEmpty() && last_segment.template_parameters.isEmpty() && (filter & TemplateParameters) != None {
			if this.current_function.isAlive() {
				for template_parameter in this.current_function.template_parameters {
					if template_parameter.name != last_segment.name || template_parameter.value is None {
						continue;
					}

					result.append(Symbol::TemplateParameter(template_parameter.value, SharedHandle!<Namespace>()));
				}
			}

			var current_namespace = this.current_namespace;
			while current_namespace.isAlive() {
				for template_parameter in current_namespace.template_parameters {
					if template_parameter.name != last_segment.name || template_parameter.value is None {
						continue;
					}

					result.append(Symbol::TemplateParameter(template_parameter.value, current_namespace));
				}

				current_namespace = current_namespace.parent;
			}
		}

		return result;
	}

	func lookupType(this: &&TCContext, name: &Name, span: Span) -> List!<Type> {
		var candidates: List!<Type>;
		for s in this.lookupSymbol(name, SharedHandle!<TypeDecl>(), SymbolLookupFilter::Types | TemplateParameters, span) {
			match s {
				case Type: type -> candidates.append(Type(type));
				case TemplateParameter: template_parameter -> match template_parameter {
					case Type: type -> candidates.append(Type(type));
					else -> {}
				}
				else -> {}
			}
		}
		return candidates;
	}

	func getType(this: &&TCContext, name: &Name, span: Span) -> Type {
		return this.getType(name, span, false);
	}

	func getType(this: &&TCContext, name: &Name, span: Span, quiet: bool) -> Type {
		const candidates = this.lookupType(name, span);
		if candidates.isEmpty() {
			if !quiet {
				this.error("no matching type found", span);
				this.info("looking for " + format(name), Span());
			}

			return Type::unknown();
		} else if candidates.size() == 1 {
			return candidates[0u];
		} else {
			if !quiet {
				this.error("more than one matching types found", span);
				this.info("looking for " + format(name), Span());
			}

			return Type::unknown();
		}
	}

	func lookupFunction(this: &&TCContext, name: &Name, parent_type: SharedHandle!<TypeDecl>, parameter_types: &List!<Type>, allow_unwrapping_this: bool, allow_unwrapping: bool, span: Span) -> List!<SharedHandle!<FunctionDecl>> {
		var candidates: List!<SharedHandle!<FunctionDecl>>;
		for s in this.lookupSymbol(name, parent_type, SymbolLookupFilter::Functions, span) {
			candidates.append((s as Function).value());
		}
		return this.selectMatchingFunctions(candidates, parameter_types, allow_unwrapping_this, allow_unwrapping);
	}

	func getNumericTypeBits(name: String) -> Optional!<uint> {
		if name.size() <= 1 {
			return None;
		}

		if name[0u] != 'i'b && name[0u] != 'u'b && name[0u] != 'f'b {
			return None;
		}

		const number_str = name.substring(1u..name.size());
		const number = parseNumber(number_str, 0u);

		if number.length < number_str.size() {
			return None;
		}

		return Some(number.toInt() as uint);
	}

	func selectMatchingFunctions(this: &&TCContext, candidates: &List!<SharedHandle!<FunctionDecl>>, parameter_types: &List!<Type>, allow_unwrapping_this: bool, allow_unwrapping: bool) -> List!<SharedHandle!<FunctionDecl>> {
		var result: List!<SharedHandle!<FunctionDecl>>;
		result.grow(4u);

		var most_matching_parameters = 0;
		for function in candidates {
			const matching_parameters = function.getMatchingParameterCount(parameter_types, allow_unwrapping_this, allow_unwrapping);

			if matching_parameters < most_matching_parameters {
				continue;
			} else if matching_parameters == 0 {
				result.append(function);
				continue;
			} else if matching_parameters > most_matching_parameters {
				result.clear();
				result.append(function);
				most_matching_parameters = matching_parameters;
				continue;
			}

			const ref_kind = function.parameter_types[0u].reference_kind;
			var inserted = false;

			for i in 0u..result.size() {
				if result[i].parameter_types[0u].reference_kind < ref_kind {
					result.insert(i, function);
					inserted = true;
					break;
				}
			}

			if !inserted {
				result.append(function);
			}
		}

		return result;
	}

	func validateFunctionCanditates(this: &&TCContext, candidates: &List!<SharedHandle!<FunctionDecl>>, required_name: &Name, required_parameter_types: &List!<Type>, span: Span) -> bool {
		if candidates.isEmpty() {
			this.error("no matching function found", span);
			this.info("looking for " + format(required_name) + format(required_parameter_types), Span());
			return false;
		}

		var no_ref_count = 0;
		var const_ref_count = 0;
		var var_ref_count = 0;
		var no_param_count = 0;

		for f in candidates {
			if f.parameter_types.isEmpty() {
				no_param_count++;
				continue;
			}

			match f.parameter_types[0u].reference_kind {
				case None -> no_ref_count++;
				case Const -> const_ref_count++;
				case Var -> var_ref_count++;
			}
		}

		if no_ref_count > 1 || const_ref_count > 1 || var_ref_count > 1 || no_param_count > 1 {
			this.error("too many matching functions found", span);
			this.info("candidates are:", Span());
			for f in candidates {
				this.info("    " + f.signature(), Span());
			}
			return false;
		}

		return true;
	}

	func getMatchingTemplateParameterCount(this: &&TCContext, template_decls: &List!<TemplateParameterDecl>, template_parameters: &List!<TemplateParameter>) -> int {
		if template_decls.size() == 0 && template_parameters.size() == 0 {
			return 0;
		}

		if template_parameters.size() < template_decls.size() {
			return -1;
		}

		const is_variadic = match template_decls.last() {
			case Some: template_decl -> yield template_decl.is_variadic;
			else -> yield false;
		}

		if template_parameters.size() > template_decls.size() && !is_variadic {
			return -1;
		}

		var count = 0;
		for i in 0u..template_parameters.size() {
			const template_parameter = template_parameters[i];
			const template_parameter_decl = template_decls[uint::min(i, template_decls.size() - 1)];

			if !this.doesConceptAcceptTemplateParameter(template_parameter_decl.concept, template_parameter) {
				return -1;
			}

			if template_parameter_decl.value is None {
				continue;
			}

			if template_parameter_decl.value != template_parameter {
				return -1;
			} else {
				count += 1;
			}
		}

		return count;
	}

	func doesConceptAcceptTemplateParameter(this: &&TCContext, concept: SharedHandle!<Concept>, parameter: TemplateParameter) -> bool {
		match concept.operator unwrap() {
			case Boolean -> return parameter is Boolean;
			case Integer -> return parameter is Integer;
			case String -> return parameter is String;
			case Any -> return parameter is Type;
		}
	}

	func getMatchingParameterCount(function: &FunctionDecl, parameter_types: &List!<Type>, allow_unwrapping_this: bool, allow_unwrapping: bool) -> int {
		if function.parameter_types.size() != parameter_types.size() {
			return -1;
		}

		var count = 0;
		for i in 0u..parameter_types.size() {
			const required_parameter_type = parameter_types[i];
			const function_parameter_type = function.parameter_types[i];

			if function_parameter_type.reference_kind > required_parameter_type.reference_kind {
				return -1;
			}

			if required_parameter_type.decl == function_parameter_type.decl {
				count++;
			} else if !((i != 0 && allow_unwrapping) || (i == 0 && allow_unwrapping_this)) {
				return -1;
			} else if required_parameter_type.decl.unwrapped_type != function_parameter_type.decl {
				return -1;
			}
		}

		return count;
	}

	func createTemplateInstance(this: &&TCContext, base: SharedHandle!<Namespace>, template_parameters: &List!<TemplateParameter>, error_span: Span) -> SharedHandle!<Namespace> {
		const prev_namespace = this.current_namespace;
		this.current_namespace = base.parent;

		var instance: SharedHandle!<Namespace>;
		if base.linked_type.isAlive() {
			const base_type = base.linked_type;
			var type_instance: SharedHandle!<TypeDecl>;
			match base_type.body {
				case Int | UInt | Float -> {
					const bits = (template_parameters[0u] as Integer).value();
					if bits <= 0 {
						this.error("only numeric types with size >= 1 are allowed", error_span);
						return SharedHandle!<Namespace>();
					}

					match base_type.body {
						case Int -> type_instance = this.program.createIntTypeInstance(base.parent, true, bits).decl;
						case UInt -> type_instance = this.program.createIntTypeInstance(base.parent, false, bits).decl;
						case Float -> type_instance = this.program.createFloatTypeInstance(base.parent, bits).decl;
						else -> panic("unreachable");
					}
				}
				case Pointer: pointer_type -> {
					const pointee_type = (template_parameters[0u] as Type).value();
					if pointee_type == this.program.void_type || pointee_type == this.program.never_type {
						this.error("invalid pointer template parameter: pointee type must not be void", error_span);
						return SharedHandle!<Namespace>();
					}

					type_instance = this.program.createPtrTypeInstance(base.parent, pointer_type.is_const, pointee_type).decl;
				}
				case Function -> {
					const return_type = (template_parameters[0u] as Type).value();
					var parameter_types: List!<Type>;
					for i in 1u..template_parameters.size() {
						parameter_types.append((template_parameters[1u] as Type).value());
					}

					type_instance = this.program.createFunctionTypeInstance(base.parent, parameter_types, return_type);
				}
				case Array -> {
					const element_type = (template_parameters[0u] as Type).value();
					const size = (template_parameters[1u] as Integer).value();

					if size < 0 {
						this.error("only array types with size >= 0 are allowed", error_span);
						return SharedHandle!<Namespace>();
					}

					var element_ptr_type_template_parameters: List!<TemplateParameter>;
					element_ptr_type_template_parameters.append(TemplateParameter::Type(element_type));

					const element_cptr_type = this.getType(Name("cptr", element_ptr_type_template_parameters), Span(), false);
					const element_vptr_type = this.getType(Name("vptr", element_ptr_type_template_parameters), Span(), false);

					type_instance = this.program.createArrayTypeInstance(base.parent, element_type, size as uint, element_cptr_type, element_vptr_type);
				}
				case Tuple -> {
					const names = (template_parameters[0u] as String).value().split(",");
					var elements: List!<Type>;
					for i in 1u..template_parameters.size() {
						elements.append((template_parameters[i] as Type).value());
					}

					if names.size() != elements.size() {
						this.error("name and element count not matching for tuple type", error_span);
						return SharedHandle!<Namespace>();
					}

					type_instance = this.program.createTupleTypeInstance(base.parent, names, elements);
				}
				case Struct | Enum | Variant -> {
					type_instance = this.checkTypeDecl(
						base.name,
						getTemplateParameterDecls(base.template_parameters, template_parameters),
						base_type.body,
						base.span,
						base.name_span,
						base_type.parsed_annotations,
						this.current_target_state <= UncheckedTypeBodies
					);

					type_instance.parsed_id_type = base_type.parsed_id_type;
					type_instance.parsed_annotations = base_type.parsed_annotations;
				}
				else -> {
					this.error("can't create template instance of type " + base.signature(), base.name_span);
					abort();
				}
			}

			instance = type_instance.linked_namespace;
		} else {
			instance = this.program.getOrCreateChildNamespace(base.parent, base.name, getTemplateParameterDecls(base.template_parameters, template_parameters), false);
		}

		if instance == base || instance.isEmpty() {
			panic("bad template instance: " + base.signature() + " - " + format(template_parameters));
		}

		instance.addUncheckedChildren(base.unchecked_children);
		base.template_instances.append(instance);

		if instance.linked_type.isAlive() && this.current_target_state > UncheckedTypeBodies {
			discard this.check(instance, NamespaceState::UncheckedTypeBodies);
			this.checkTypeBody(instance.linked_type);
		}

		discard this.check(instance, this.current_target_state);

		this.current_namespace = prev_namespace;
		return instance;
	}

	func createTemplateInstance(this: &&TCContext, base: SharedHandle!<FunctionDecl>, template_parameters: &List!<TemplateParameter>, error_span: Span) -> SharedHandle!<FunctionDecl> {
		const prev_namespace = this.current_namespace;
		this.current_namespace = base.parent_namespace;

		var instance: SharedHandle!<FunctionDecl>;

		match base.body {
			case InlineBuiltin: builtin_function -> match builtin_function {
				case IntCast
				| FloatCast
				| IntToFloat
				| FloatToInt
				| PointerCast -> {
					const source = (template_parameters[0u] as Type).value();
					const target = (template_parameters[1u] as Type).value();

					var cast_name = "";
					match builtin_function {
						case IntCast -> cast_name = "intCast";
						case FloatCast -> cast_name = "floatCast";
						case IntToFloat -> cast_name = "intToFloat";
						case FloatToInt -> cast_name = "floatToInt";
						case PointerCast -> cast_name = "pointerCast";
						else -> panic("unreachable");
					}

					if cast_name == "pointerCast" && source.isConstPtrType() && !target.isConstPtrType() {
						this.error("invalid pointer cast, source type is const but target isn't", error_span);
					}

					instance = this.program.createPrimitiveCastInstance(base.parent_namespace, cast_name, source, target);
				}
				case SizeOf
				| AlignmentOf
				| ReferenceKindOf -> {
					var name = "";
					var parameter_types: List!<Type>;
					var return_type: Type;
					var body = builtin_function;

					body.base_type = (template_parameters[0u] as Type).value();

					match builtin_function {
						case SizeOf -> name = "sizeOf";
						case AlignmentOf -> name = "alignmentOf";
						case ReferenceKindOf -> name = "referenceKindOf";
						else -> panic(Error::EINVAL);
					}

					match builtin_function {
						case SizeOf
						| AlignmentOf -> return_type = this.program.uint_type;
						case ReferenceKindOf -> return_type = this.getType(Name("ReferenceKind"), error_span);
						else -> panic(Error::EINVAL);
					}

					instance = this.program.createFunction(base.parent_namespace, name, parameter_types, return_type, FunctionBody::InlineBuiltin(body));
					instance.template_parameters.append(TemplateParameterDecl("Type", this.program.any_concept, false, template_parameters[0u]));
				}
				else -> this.error("cannot create template instance of builtin function " + base.signature(), base.signature_span);
			}
			case Unchecked: parsed_function -> {
				if this.current_target_state > UncheckedFunctionSignatures {
					instance = this.checkFunctionDecl(parsed_function, getTemplateParameterDecls(base.template_parameters, template_parameters), false);
					this.checkFunctionSignature(instance);
				} else {
					instance = this.checkFunctionDecl(parsed_function, getTemplateParameterDecls(base.template_parameters, template_parameters), true);
				}
			}
			else -> this.error("cannot create template instance of this function", base.signature_span);
		}

		this.current_namespace = prev_namespace;
		return instance;
	}

	func getTemplateParameterDecls(base_decls: &List!<TemplateParameterDecl>, values: &List!<TemplateParameter>) -> List!<TemplateParameterDecl> {
		var result = base_decls;

		for i in 0u..values.size() {
			if result.size() <= i {
				result.append(result[i - 1]);
			}

			result[i].value = values[i];
		}

		return result;
	}

	func checkName(this: &&TCContext, parsed_name: &ParsedName) -> Name {
		var result = Name(parsed_name.span);

		result.segments.grow(parsed_name.segments.size());
		for segment in parsed_name.segments {
			var template_parameters: List!<TemplateParameter>;
			template_parameters.grow(segment.template_parameters.size());
			for parameter in segment.template_parameters {
				template_parameters.append(this.checkTemplateParameter(parameter));
			}

			result.segments.append(NameSegment(segment.name, template_parameters));
		}

		return result;
	}

	func checkTemplateParameter(this: &&TCContext, parameter: &ParsedExpr) -> TemplateParameter {
		const type = this.checkTypeUsage(parameter.toType(), true);
		if !type.isUnknown() {
			return TemplateParameter::Type(type);
		}

		const checked_parameter = this.checkExpr(parameter, Type::unknown(), true);
		match this.interpret(checked_parameter) {
			case Integer: val -> return TemplateParameter::Integer(val);
			case String: val -> return TemplateParameter::String(val);
			case TypeRef: type -> return TemplateParameter::Type(type);
			else -> this.error("invalid template parameter", parameter.span);
		}

		return TemplateParameter::Garbage;
	}

	func checkTypeUsage(this: &&TCContext, parsed_type: &ParsedType, quiet: bool) -> Type {
		match parsed_type {
			case Empty -> return Type::unknown();
			case Name: &name -> return this.getType(this.checkName(name), parsed_type.span, quiet);
			case ConstReference: &base -> {
				const checked_base = this.checkTypeUsage(base, quiet);
				if checked_base.reference_kind != None {
					if !quiet {
						this.error("double reference types aren't allowed", parsed_type.span);
					}

					return Type::unknown();
				}
				return checked_base.constRef();
			}
			case VarReference: &base -> {
				const checked_base = this.checkTypeUsage(base, quiet);
				if checked_base.reference_kind != None {
					if !quiet {
						this.error("double reference types aren't allowed", parsed_type.span);
					}

					return Type::unknown();
				}
				return checked_base.varRef();
			}
			case Tuple: &elements -> {
				var names: List!<String>;
				var types: List!<Type>;

				for &e in elements {
					types.append(this.checkTypeUsage(e.type, quiet));
					if e.name == "" {
						names.append(String(1u, ('a'b as uint + names.size()) as byte));
					} else {
						names.append(e.name);
					}
				}

				var template_parameters: List!<TemplateParameter>;
				template_parameters.append(TemplateParameter::String(",".join(names)));
				for t in types {
					template_parameters.append(TemplateParameter::Type(t));
				}

				return this.getType(Name("Tuple", template_parameters), parsed_type.span);
			}
			case Function: &function_type -> {
				var parameter_types: List!<Type>;
				for t in function_type.parameter_types {
					parameter_types.append(this.checkTypeUsage(t, quiet));
				}

				return this.getFunctionType(parameter_types, this.checkTypeUsage(function_type.return_type, quiet), parsed_type.span);
			}
			case Garbage -> return Type::unknown();
			else -> {
				this.todo("finish typechecking of type usages", parsed_type.span);
				return Type::unknown();
			}
		}
	}

	func getFunctionType(this: &&TCContext, parameter_types: &List!<Type>, return_type: Type, span: Span) -> Type {
		var template_parameters: List!<TemplateParameter>;
		template_parameters.append(TemplateParameter::Type(return_type));
		for t in parameter_types {
			template_parameters.append(TemplateParameter::Type(t));
		}

		return this.getType(Name("function", template_parameters), span);
	}

	func checkCall(this: &&TCContext, name: &Name, arguments: &List!<Expr>, allow_unwrapping_this: bool, allow_unwrapping: bool, kind: CallKind, is_comptime: bool, span: Span) -> Expr {
		for &arg in arguments {
			if arg is Undefined {
				return Expr::Undefined(span, Type::unknown());
			}
		}

		const argument_types = getArgumentTypes(arguments, kind == MemberCall || kind == Operator);

		var parent_type = SharedHandle!<TypeDecl>();
		if kind == MemberCall || kind == Operator {
			parent_type = arguments[0u].type.decl;
		}

		var candidates = this.lookupFunction(name, parent_type, argument_types, allow_unwrapping_this, allow_unwrapping, span);

		var negate_result = false;
		var compare_result_zero = false;
		const name_str = format(name);
		if candidates.isEmpty() && kind == Operator {
			if name_str == "operator ==" {
				candidates = this.lookupFunction(Name("operator !="), parent_type, argument_types, allow_unwrapping_this, allow_unwrapping, span);
				negate_result = true;
			} else if name_str == "operator !=" {
				candidates = this.lookupFunction(Name("operator =="), parent_type, argument_types, allow_unwrapping_this, allow_unwrapping, span);
				negate_result = true;
			}

			if candidates.isEmpty() && isComparisonOperator(name_str) {
				candidates = this.lookupFunction(Name("operator <=>"), parent_type, argument_types, allow_unwrapping_this, allow_unwrapping, span);
				compare_result_zero = true;
			}
		}

		if !this.validateFunctionCanditates(candidates, name, argument_types, span) {
			return Expr::Undefined(span, Type::unknown());
		}

		var result = this.createCall(candidates[0u], arguments, kind, is_comptime, span);
		if result is Undefined {
			return Expr::Undefined(span, Type::unknown());
		}

		if compare_result_zero {
			var cmp_arguments: List!<Expr>;
			cmp_arguments.append(result);
			cmp_arguments.append(Expr::Integer(0, span, result.type));
			result = this.checkCall(Name(name_str), cmp_arguments, false, false, CallKind::Operator, is_comptime, span);
		} else if negate_result {
			var not_arguments: List!<Expr>;
			not_arguments.append(result);
			result = this.checkCall(Name("operator !"), not_arguments, false, false, CallKind::Operator, is_comptime, span);
		}

		return result;
	}

	func isComparisonOperator(name: String) -> bool {
		return name == "operator ==" || name == "operator !="
			|| name == "operator <" || name == "operator <="
			|| name == "operator >" || name == "operator >=";
	}

	func unwrapArguments(this: &&TCContext, arguments: &List!<Expr>, required_parameter_types: &List!<Type>, is_comptime: bool) -> SharedPtr!<List!<Expr>> {
		var result: SharedPtr!<List!<Expr>> = arguments;

		for i in 0u..result.size() {
			if result[i].type.decl != required_parameter_types[i].decl {
				result[i] = this.checkCall(
					Name("operator unwrap"),
					List!<Expr>(1u, result[i]),
					false, false,
					CallKind::MemberCall,
					is_comptime,
					result[i].span
				);
			}

			if required_parameter_types[i].reference_kind != None {
				result[i] = result[i].removeDereference();
			}

			if result[i] is Dereference {
				const variable = result[i].removeDereference() as VarInvoke else {
					continue;
				}

				if !is_comptime && variable.is_comptime {
					result[i] = this.interpret(result[i]);
				}
			}
		}

		return result;
	}

	func validateArgumentTypes(this: &&TCContext, arguments: &List!<Expr>, required_parameter_types: &List!<Type>, span: Span) -> bool {
		for i in 0u..arguments.size() {
			if arguments[i].type == required_parameter_types[i] {
				continue;
			}

			if arguments[i].type.reference_kind == Var && required_parameter_types[i].reference_kind == Const {
				continue;
			}

			this.error("invalid parameter type for call", span);
			return false;
		}

		return true;
	}

	func createCall(this: &&TCContext, function: SharedHandle!<FunctionDecl>, arguments: &List!<Expr>, call_kind: CallKind, is_comptime: bool, span: Span) -> Expr {
		var unwrapped_arguments = this.unwrapArguments(arguments, function.parameter_types, is_comptime);
		if !this.validateArgumentTypes(unwrapped_arguments, function.parameter_types, span) {
			return Expr::Undefined(span, Type::unknown());
		}

		var return_kind = ReturnKind::None;
		var result_type = function.return_type;

		if call_kind == TempVar {
			return_kind = Parameter;
			result_type = function.parameter_types[0u].constRef();
		} else if !function.return_type.isPrimitive() {
			return_kind = Variable;
			result_type = function.return_type.constRef();
		} else if function.return_type == this.program.void_type || function.return_type == this.program.never_type {
			return_kind = None;
		} else {
			return_kind = Value;
		}

		if result_type.isUnknown() {
			this.error("function '" + function.signature() + "' has unknown return type", function.signature_span);
			return Expr::Undefined(span, Type::unknown());
		}

		var result_var: SharedHandle!<VarDecl>;
		if return_kind == Variable {
			if !this.current_function.isAlive() {
				this.todo("implement comptime calls, that return a non-primitive value", span);
				return Expr::Undefined(span, Type::unknown());
			}

			result_var = this.current_function.createVariable(span, "#result", result_type.base(), true, is_comptime);
			// no constructor call needed, the callee does that
			this.createDestructorCall(result_var);
			this.addVariableToCurrentScope(result_var);
		}

		this.checkActiveMembersForCall(unwrapped_arguments, function.name, span);

		var should_be_comptime = false;
		for i in 0u..unwrapped_arguments.size() {
			if const variable = unwrapped_arguments[i] as VarInvoke {
				if variable.is_comptime {
					should_be_comptime = true;
					break;
				}
			}
		}

		var result = Expr::Call(
			CallExpr(
				function,
				unwrapped_arguments,
				result_var,
				return_kind
			), span, result_type
		);

		this.optimizeCallExpr(&&result);

		if should_be_comptime && !is_comptime {
			result = this.interpret(result);
		}

		return result.addDereference();
	}

	func createTemporaryVariable(this: &&TCContext, type: Type, template_parameters: &List!<TemplateParameter>, parsed_arguments: &List!<ParsedExpr>, is_comptime: bool, span: Span) -> Expr {
		var contains_errors = false;
		var checked_arguments: List!<Expr>;
		for parsed_argument in parsed_arguments {
			checked_arguments.append(this.checkExpr(parsed_argument, Type::unknown(), is_comptime));
		}

		for &arg in checked_arguments {
			if arg is Undefined {
				return Expr::Undefined(span, Type::unknown());
			}
		}

		return this.createTemporaryVariable(type, template_parameters, checked_arguments, is_comptime, span);
	}

	func createTemporaryVariable(this: &&TCContext, type: Type, template_parameters: &List!<TemplateParameter>, checked_arguments: &List!<Expr>, is_comptime: bool, span: Span) -> Expr {
		if type.isUnknown() {
			return Expr::Undefined(span, Type::unknown());
		}

		const variable = this.current_function.createVariable(span, "#tmp", type, true, is_comptime);

		this.createDestructorCall(variable);
		this.addVariableToCurrentScope(variable);

		if type.reference_kind == None {
			var constructor_arguments: List!<Expr>;
			constructor_arguments.append(Expr::VarInvoke(variable, span, type.varRef()));
			constructor_arguments.append(checked_arguments);
			const argument_types = getArgumentTypes(constructor_arguments, true);

			const candidates = this.lookupFunction(Name("constructor", template_parameters), type.decl, argument_types, false, true, span);
			if !this.validateFunctionCanditates(candidates, Name("constructor", template_parameters), argument_types, span) {
				return Expr::Undefined(span, Type::unknown());
			}

			const constructor_decl = candidates[0u];
			const unwrapped_arguments = this.unwrapArguments(constructor_arguments, constructor_decl.parameter_types, is_comptime);
			if !this.validateArgumentTypes(unwrapped_arguments, constructor_decl.parameter_types, span) {
				return Expr::Undefined(span, Type::unknown());
			}

			var constructor_call = Expr::Call(
				CallExpr(
					candidates[0u],
					unwrapped_arguments,
					variable,
					ReturnKind::Parameter
				), span, type.constRef()
			);

			this.optimizeCallExpr(&&constructor_call);

			return constructor_call.addDereference();
		} else {
			if checked_arguments.size() != 1 {
				this.error("invalid arguments for temporary variable of reference type", span);
				return Expr::Undefined(span, Type::unknown());
			}

			return Expr::Dereference(Box!<Expr>(
				Expr::ShallowCopy(ShallowCopyExpr(Expr::VarInvoke(variable, span, type), checked_arguments[0u]), span, type)
			), span, type.base());
		}
	}

	func checkActiveMembersForCall(this: &&TCContext, arguments: &List!<Expr>, function_name: String, span: Span) -> void {
		if !this.current_function.isAlive() {
			return;
		}

		if arguments.isEmpty() || this.current_function.parameter_types.isEmpty() {
			return;
		}

		if this.current_function.parameter_types[0u].decl != this.current_namespace.linked_type {
			return;
		}

		match arguments[0u] {
			case MemberVarInvoke: member_access_expr -> {
				const object = member_access_expr.object as VarInvoke else {
					return;
				}

				if object.id != 0 { // this parameter
					return;
				}

				if function_name == "constructor" {
					if this.active_member_variables.contains(member_access_expr.id) {
						this.error("double initialization of member variable", span);
					}

					this.active_member_variables.add(member_access_expr.id);
				} else if function_name == "destructor" {
					if !this.active_member_variables.contains(member_access_expr.id) {
						this.error("double de-initialization of member variable", span);
					}

					this.active_member_variables.remove(member_access_expr.id);
				}
			}
			case VarInvoke: variable -> {
				if variable.id != 0 { // this parameter
					return;
				}

				const object_type_decl = variable.type.decl;
				if function_name == "constructor" {
					for variable in object_type_decl.member_variables {
						if this.active_member_variables.contains(variable.id) {
							this.error("double initialization of member variable '" + variable.name + "'", span);
						}

						this.active_member_variables.add(variable.id);
					}
				} else if function_name == "destructor" {
					for variable in object_type_decl.member_variables {
						if !this.active_member_variables.contains(variable.id) {
							this.error("double de-initialization of member variable '" + variable.name + "'", span);
						}

						this.active_member_variables.remove(variable.id);
					}
				}
			}
			else -> {}
		}
	}

	func optimizeCallExpr(this: &&TCContext, call_expr: &&Expr) -> void {
		if this.program.options.optimization_level == 0 {
			return;
		}

		eliminateCallResultCopies(&&call_expr);
	}

	func getArgumentTypes(arguments: &List!<Expr>, is_member_call: bool) -> List!<Type> {
		var types: List!<Type>;
		types.grow(arguments.size());

		for i in 0u..arguments.size() {
			match arguments[i] {
				case Dereference: base -> {
					if is_member_call && i == 0 {
						types.append(base.type);
					} else {
						types.append(Type(base.type.decl, ReferenceKind::Const));
					}
				}
				else -> types.append(arguments[i].type);
			}
		}

		return types;
	}
}
