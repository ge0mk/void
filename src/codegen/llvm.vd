import std/core;
import std/format;
import std/list;
import std/io;
import std/map;
import std/range;
import std/set;
import std/shared;
import std/shared_list;
import std/string;

import error;
import llvm/llvm;
import llvm/llvm_c;
import llvm/dwarf;
import options;
import program;
import span;

func codegen(program: &&Program) -> Optional!<String> {
	var result: Optional!<String>;

	match program.options.output_type {
		case Assembly -> result = codegenAssemblyToFile(&&program);
		case Bitcode -> result = codegenBitcodeToFile(&&program);
	}

	LLVMShutdown();
	return result;
}

func codegenAssemblyToFile(program: &&Program) -> Optional!<String> {
	var ctx: codegen::llvm::CGContext = (&&program);
	ctx.codegen();

	const output_path = program.options.getOutputCodePath(".ll");
	if ctx.llvm_module.printToFile(output_path) {
		return Some(output_path);
	} else {
		return None;
	}
}

func codegenBitcodeToFile(program: &&Program) -> Optional!<String> {
	var ctx: codegen::llvm::CGContext = (&&program);
	ctx.codegen();

	const output_path = program.options.getOutputCodePath(".bc");
	if ctx.llvm_module.writeBitcodeToFile(output_path) {
		return Some(output_path);
	} else {
		return None;
	}
}

func codegenToString(program: &&Program) -> String {
	var ctx: codegen::llvm::CGContext = (&&program);
	ctx.codegen();

	return ctx.llvm_module.printToString();
}

struct CGContext {
	var program: &&Program;
	var llvm_context: llvm::Context;
	var llvm_module: llvm::Module;
	var data_layout: llvm::TargetDataRef;

	var di_builder: llvm::DIBuilderRef;
	var di_compile_unit: llvm::MetaDataRef;
	var di_files: List!<llvm::MetaDataRef>;
	var di_modules: List!<llvm::MetaDataRef>;
	var di_namespaces: Map!<SharedHandle!<Namespace>, llvm::MetaDataRef>;
	var di_types: Map!<SharedHandle!<TypeDecl>, llvm::MetaDataRef>;
	var di_functions: Map!<SharedHandle!<FunctionDecl>, llvm::MetaDataRef>;
	var di_scope_stack: List!<llvm::MetaDataRef>;

	var void_type: llvm::TypeRef;
	var bool_type: llvm::TypeRef;
	var byte_type: llvm::TypeRef;
	var int_type: llvm::TypeRef;
	var ptr_type: llvm::TypeRef;

	var types: Map!<SharedHandle!<TypeDecl>, llvm::TypeRef>;
	var functions: Map!<SharedHandle!<FunctionDecl>, llvm::ValueRef>;
	var function_types: Map!<SharedHandle!<FunctionDecl>, llvm::TypeRef>;
	var finished_functions: Set!<SharedHandle!<FunctionDecl>>;
	var string_globals: Map!<String, llvm::ValueRef>;

	var builder: llvm::BuilderRef;
	var current_function: llvm::ValueRef;
	var variables: Map!<WeakPtr!<VarDecl>, llvm::ValueRef>;

	var break_target: llvm::BasicBlockRef;
	var continue_target: llvm::BasicBlockRef;
	var yield_target: llvm::BasicBlockRef;

	func constructor(this: &&CGContext, program: &&Program) -> void {
		this.program := &&program;
		this.llvm_context := ();
		this.llvm_module := this.llvm_context.createModule(program.name);
		this.llvm_module.setSourceFileName(program.options.root_module_path);
		this.llvm_module.setTargetTriple(program.options.target_triple);
		this.llvm_module.setDataLayout(program.options.target_data_layout);

		this.data_layout := this.llvm_module.getDataLayout();

		this.void_type := this.llvm_context.getVoidType();
		this.bool_type := this.llvm_context.getIntType(1u);
		this.byte_type := this.llvm_context.getIntType(8u);
		this.int_type := this.llvm_context.getIntType(this.data_layout.getPointerSize() * 8);
		this.ptr_type := this.llvm_context.getPointerType(0u);
	}

	func destructor(this: &&CGContext) -> void {
		this.llvm_module.dispose();
		this.llvm_context.dispose();
	}

	func error(this: &CGContext, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Error, ErrorStage::CodeGenerator, span));
	}

	func info(this: &CGContext, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Info, ErrorStage::CodeGenerator, span));
	}

	func todo(this: &CGContext, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Todo, ErrorStage::CodeGenerator, span));
	}

	func getType(this: &CGContext, type: SharedHandle!<TypeDecl>) -> llvm::TypeRef {
		const impl = this.types.get(type) else {
			panic("invalid codegen for type '" + type.signature() + "'");
		}
		return impl;
	}

	func getType(this: &CGContext, type: Type) -> llvm::TypeRef {
		match type.reference_kind {
			case None -> return this.getType(type.decl);
			else -> return this.ptr_type;
		}
	}

	func getDIType(this: &&CGContext, type: SharedHandle!<TypeDecl>) -> llvm::MetaDataRef {
		const base_type = this.di_types.get(type) else {
			panic("invalid debug info for type '" + type.signature() + "'");
		}
		return base_type;
	}

	func getDIType(this: &&CGContext, type: Type) -> llvm::MetaDataRef {
		const base_type = this.getDIType(type.decl);
		if type.reference_kind == None {
			return base_type;
		} else {
			return this.di_builder.createReferenceType(dwarf::Tag::Reference_type, base_type);
		}
	}

	func getVariable(this: &CGContext, variable: WeakPtr!<VarDecl>) -> llvm::ValueRef {
		const impl = this.variables.get(variable) else {
			panic("invalid codegen for variable '" + variable.forceLock().name + "'");
		}

		return impl;
	}

	func codegen(this: &&CGContext) -> void {
		if this.program.options.generate_debug_info {
			this.initDIBuilder();
		}

		this.codegenTypes();

		for function in this.program.functions {
			this.codegenFunctionDecl(function);
		}

		for function in this.program.functions {
			this.codegenFunctionImpl(function);
		}

		this.linkLLVMIRFile("rt.ll");

		if this.program.options.generate_debug_info {
			this.deinitDIBuilder();
		}

		match this.llvm_module.verify(LLVMVerifierFailureAction::LLVMReturnStatusAction) {
			case Ok -> {}
			case Error: error -> {
				println(error);
				this.program.has_errors = true;
			}
		}
	}

	func linkLLVMIRFile(this: &&CGContext, path: String) -> void {
		match this.llvm_context.loadModuleFromFile("rt.ll") {
			case Some: rt_module -> this.llvm_module.link(rt_module);
			else -> this.program.has_errors = true;
		}
	}

	func initDIBuilder(this: &&CGContext) -> void {
		this.llvm_module.addFlag(LLVMModuleFlagBehavior::LLVMModuleFlagBehaviorError, "Dwarf Version", llvm::constInt(this.int_type, 5, false).asMetadata());
		this.llvm_module.addFlag(LLVMModuleFlagBehavior::LLVMModuleFlagBehaviorWarning, "Debug Info Version", llvm::constInt(this.int_type, 3, false).asMetadata());

		this.di_builder = this.llvm_module.createDIBuilder();

		for file in this.program.files {
			const path = file.path;
			var segments = file.path.split('/'b);
			const filename = segments.last().value();
			segments.removeLast();
			const directory = "/".join(segments);

			this.di_files.append(this.di_builder.createFile(filename, directory));
		}

		this.di_compile_unit = this.di_builder.createCompileUnit(
			LLVMDWARFSourceLanguage::LLVMDWARFSourceLanguageC,
			this.di_files[0u],
			"",			// producer
			this.program.options.optimized_build,
			"",			// flags
			0u,			// runtime version
			"",			// split name
			LLVMDWARFEmissionKind::LLVMDWARFEmissionFull,
			0u,			// dwo-id
			false,		// split debug inlining
			false,		// debug info for profiling
			"",			// sys-root
			"",			// sdk
		);

		for file in this.program.files {
			this.di_modules.append(this.di_builder.createModule(
				this.di_compile_unit,
				file.name,
				"",		// config macros
				"",		// include path
				"", 	// api notes file
			));
		}

		for ns in this.program.top_level_namespaces {
			this.createDINamespaces(ns);
		}
	}

	func createDINamespaces(this: &&CGContext, current_namespace: SharedHandle!<Namespace>) -> void {
		var parent = this.di_modules[0u];
		if current_namespace.parent.isAlive() {
			parent = this.di_namespaces.get(current_namespace.parent).value();
		}

		this.di_namespaces.set(current_namespace, this.di_builder.createNameSpace(parent, current_namespace.name, true));

		for child in current_namespace.children {
			this.createDINamespaces(child);
		}
	}

	func deinitDIBuilder(this: &&CGContext) -> void {
		this.di_builder.finalize();
		this.di_builder.dispose();
	}

	func getDebugLocation(this: &&CGContext, span: Span) -> llvm::MetaDataRef {
		return this.llvm_context.createDebugLocation(span.line as uint + 1, span.column as uint + 1, this.di_scope_stack.last().value());
	}

	func setCurrentDebugLocation(this: &&CGContext, span: Span) -> void {
		if this.program.options.generate_debug_info {
			this.builder.setCurrentDebugLocation2(this.getDebugLocation(span));
		}
	}

	func codegenTypes(this: &&CGContext) -> void {
		var incomplete_types = Set!<SharedHandle!<TypeDecl>>(this.program.types.range());
		var complete_types: Set!<SharedHandle!<TypeDecl>>;

		while !incomplete_types.isEmpty() {
			var completable_types: Set!<SharedHandle!<TypeDecl>>;

			for type in incomplete_types {
				var is_completable = true;

				for other in type.contained_types {
					if !complete_types.contains(other) {
						is_completable = false;
						break;
					}
				}

				if is_completable {
					completable_types.add(type);
				}
			}

			if completable_types.isEmpty() {
				this.error("some type dependencies cannot be fullfilled", Span());
				for type in incomplete_types {
					this.info(type.signature(), Span());
				}
				abort();
			}

			for type in completable_types {
				this.codegenType(type);
				incomplete_types.remove(type);
				complete_types.add(type);
			}
		}

		if this.program.options.generate_debug_info {
			for type in this.program.types {
				this.codegenTypeDI(type, true);
			}

			for type in this.program.types {
				this.codegenTypeDI(type, false);
			}
		}
	}

	func getTypeName(this: &CGContext, type: SharedHandle!<TypeDecl>) -> String {
		var name = "";
		match this.program.options.symbol_type {
			case None -> {}
			case Name -> name = type.name;
			case Full -> name = type.signature();
		}

		return name;
	}

	func codegenType(this: &&CGContext, type: SharedHandle!<TypeDecl>) -> void {
		if type.isIncompleteTemplate() {
			return;
		}

		const name = this.getTypeName(type);

		match type.body {
			case Empty -> this.types.set(type, this.void_type);
			case Void -> this.types.set(type, this.void_type);
			case Bool -> this.types.set(type, this.bool_type);
			case Byte -> this.types.set(type, this.byte_type);
			case Int: bits -> {
				if bits == 0 {
					this.types.set(type, this.int_type);
				} else {
					this.types.set(type, this.llvm_context.getIntType(bits));
				}
			}
			case UInt: bits -> {
				if bits == 0 {
					this.types.set(type, this.int_type);
				} else {
					this.types.set(type, this.llvm_context.getIntType(bits));
				}
			}
			case Float: bits -> match bits {
				case 32 -> this.types.set(type, this.llvm_context.getFloatType());
				case 64 -> this.types.set(type, this.llvm_context.getDoubleType());
				else -> this.error("invalid size for float type: " + format(bits), type.span);
			}
			case Pointer -> this.types.set(type, this.ptr_type);
			case Array: array_type -> this.types.set(type, this.llvm_context.getArrayType(this.getType(array_type.element_type), array_type.size));
			case Struct -> {
				var element_types: List!<llvm::TypeRef>;
				for member_variable in type.member_variables {
					element_types.append(this.getType(member_variable.type));
				}

				const llvm_type = this.llvm_context.createNamedStruct(name);
				llvm_type.setStructBody(element_types, type.is_packed);
				this.types.set(type, llvm_type);
			}
			case Enum -> this.types.set(type, this.getType(type.id_type));
			case Variant -> {
				var element_types: List!<llvm::TypeRef>;
				element_types.append(this.getType(type.id_type));

				var max_size = 0u;
				var max_alignment = 1u;

				for case_decl in type.variant_cases {
					if case_decl.type == this.program.void_type {
						continue;
					}

					var case_type = this.getType(case_decl.type);

					const current_size = this.data_layout.getStoreSizeOfType(case_type);
					if current_size > max_size {
						max_size = current_size;
					}

					const current_alignment = this.data_layout.getPreferredAlignmentOfType(case_type);
					if current_alignment > max_alignment {
						max_alignment = current_alignment;
					}
				}

				const max_alignment_type = this.llvm_context.getIntType(max_alignment * 8);
				element_types.append(this.llvm_context.getArrayType(max_alignment_type, max_size / max_alignment));

				for member_variable in type.member_variables {
					element_types.append(this.getType(member_variable.type));
				}

				const llvm_type = this.llvm_context.createNamedStruct(name);
				llvm_type.setStructBody(element_types, type.is_packed);
				this.types.set(type, llvm_type);
			}
		}
	}

	// first pass: generate full di for primitive types & temporary di for composites
	// second pass: finish di for composite types & replace temporaries
	func codegenTypeDI(this: &&CGContext, type: SharedHandle!<TypeDecl>, first_pass: bool) -> void {
		if type.isIncompleteTemplate() {
			return;
		}

		const line = type.name_span.line as uint;
		const di_file = this.di_files[type.span.file as uint];
		const parent_namespace = this.di_namespaces.get(type.parent_namespace).value();

		const llvm_type = this.getType(type);
		var size_in_bits = 0u;
		if llvm_type != this.void_type {
			size_in_bits = this.data_layout.getStoreSizeOfType(llvm_type) * 8;
		}
		var alignment_in_bits = 0u;
		if llvm_type != this.void_type {
			alignment_in_bits = this.data_layout.getPreferredAlignmentOfType(llvm_type) * 8;
		}

		var di_name = type.name;
		if !type.template_parameters.isEmpty() {
			di_name += type.template_parameters.format();
		}

		var di_type: llvm::MetaDataRef;
		if first_pass {
			match type.body {
				case Empty -> di_type = this.di_builder.createUnspecifiedType(di_name);
				case Void -> di_type = this.di_builder.createBasicType(di_name, size_in_bits, 0 as dwarf::TypeEncoding, LLVMDIFlags::LLVMDIFlagZero);
				case Bool -> di_type = this.di_builder.createBasicType(di_name, size_in_bits, dwarf::TypeEncoding::Boolean, LLVMDIFlags::LLVMDIFlagZero);
				case Byte -> di_type = this.di_builder.createBasicType(di_name, size_in_bits, dwarf::TypeEncoding::Unsigned_char, LLVMDIFlags::LLVMDIFlagZero);
				case Int -> di_type = this.di_builder.createBasicType(di_name, size_in_bits, dwarf::TypeEncoding::Signed, LLVMDIFlags::LLVMDIFlagZero);
				case UInt -> di_type = this.di_builder.createBasicType(di_name, size_in_bits, dwarf::TypeEncoding::Unsigned, LLVMDIFlags::LLVMDIFlagZero);
				case Float -> di_type = this.di_builder.createBasicType(di_name, size_in_bits, dwarf::TypeEncoding::Float, LLVMDIFlags::LLVMDIFlagZero);
				else -> di_type = this.di_builder.createReplaceableCompositeType(dwarf::Tag::Unspecified_type, di_name, parent_namespace, di_file, line, 0u32, size_in_bits, alignment_in_bits, LLVMDIFlags::LLVMDIFlagZero, type.signature());
			}
		} else {
			const type_scope = this.di_namespaces.get(type.linked_namespace).value();
			match type.body {
				case Pointer: pointer_type -> {
					if pointer_type.base_type.isUnknown() {
						di_type = this.di_builder.createPointerType(this.getDIType(this.program.void_type), size_in_bits, alignment_in_bits, 0u, di_name);
					} else {
						di_type = this.di_builder.createPointerType(this.getDIType(pointer_type.base_type), size_in_bits, alignment_in_bits, 0u, di_name);
					}
				}
				case Array: array_type -> di_type = this.di_builder.createArrayType(array_type.size, alignment_in_bits, this.getDIType(array_type.element_type), List!<llvm::MetaDataRef>());
				case Struct | Variant -> {
					var members: List!<llvm::MetaDataRef>;

					if type.body is Variant {
						var cases: List!<llvm::MetaDataRef>;
						var payload_members: List!<llvm::MetaDataRef>;
						for c in type.variant_cases {
							cases.append(this.di_builder.createEnumerator(c.name, c.id, true));

							if c.type == this.program.void_type {
								continue;
							}

							payload_members.append(this.di_builder.createMemberType(
								type_scope,
								c.name,
								di_file,
								c.span.line as uint,
								this.data_layout.getStoreSizeOfType(this.getType(c.type)) * 8,
								this.data_layout.getPreferredAlignmentOfType(this.getType(c.type)) * 8,
								0u,
								LLVMDIFlags::LLVMDIFlagZero,
								this.getDIType(c.type)
							));
						}

						const id_size_in_bits = this.data_layout.getStoreSizeOfType(this.getType(type.id_type)) * 8;
						const id_alignment_in_bits = this.data_layout.getPreferredAlignmentOfType(this.getType(type.id_type)) * 8;
						const id_offset_in_bits = this.data_layout.getOffsetOfElement(llvm_type, 0u) * 8;
						const id_type = this.di_builder.createEnumerationType(parent_namespace, di_name + "::Id", di_file, line, id_size_in_bits, id_alignment_in_bits, cases, this.getDIType(type.id_type));
						members.append(this.di_builder.createMemberType(
							type_scope,
							"#id",
							di_file,
							line,
							id_size_in_bits,
							id_alignment_in_bits,
							id_offset_in_bits,
							LLVMDIFlags::LLVMDIFlagZero,
							id_type
						));

						const payload_type_impl = llvm_type.structGetTypeAtIndex(1u);
						const payload_size_in_bits = this.data_layout.getStoreSizeOfType(payload_type_impl) * 8;
						const payload_alignment_in_bits = this.data_layout.getPreferredAlignmentOfType(payload_type_impl) * 8;
						const payload_offset_in_bits = this.data_layout.getOffsetOfElement(llvm_type, 1u) * 8;
						const payload_type = this.di_builder.createUnionType(type_scope, di_name + "::Payload", di_file, line, payload_size_in_bits, payload_alignment_in_bits, LLVMDIFlags::LLVMDIFlagZero, payload_members, 0u32, type.signature() + "::Payload");
						members.append(this.di_builder.createMemberType(
							type_scope,
							"#payload",
							di_file,
							line,
							payload_size_in_bits,
							payload_alignment_in_bits,
							payload_offset_in_bits,
							LLVMDIFlags::LLVMDIFlagZero,
							payload_type
						));
					}

					for i in 0u..type.member_variables.size() {
						const member_variable = type.member_variables[i];
						const member_type = this.getType(member_variable.type);
						if member_type == this.void_type {
							continue;
						}

						const member_di_type = this.getDIType(member_variable.type);

						const member_size_in_bits = this.data_layout.getStoreSizeOfType(llvm_type) * 8;
						const member_alignment_in_bits = this.data_layout.getPreferredAlignmentOfType(llvm_type) * 8;
						const member_offset_in_bits = this.data_layout.getOffsetOfElement(llvm_type, i + (2u if type.body is Variant else 0u)) * 8;

						members.append(this.di_builder.createMemberType(
							type_scope,
							member_variable.name,
							di_file,
							member_variable.span.line as uint,
							member_size_in_bits,
							member_alignment_in_bits,
							member_offset_in_bits,
							LLVMDIFlags::LLVMDIFlagZero,
							member_di_type
						));
					}

					di_type = this.di_builder.createStructType(
						parent_namespace,
						di_name,
						di_file,
						line,
						size_in_bits,
						alignment_in_bits,
						LLVMDIFlags::LLVMDIFlagZero,
						llvm::MetaDataRef(),
						members,
						0u32,
						MetaDataRef(),
						type.signature()
					);
				}
				case Enum -> {
					var cases: List!<llvm::MetaDataRef>;
					for c in type.enum_cases {
						cases.append(this.di_builder.createEnumerator(c.name, c.id, true));
					}

					di_type = this.di_builder.createEnumerationType(parent_namespace, di_name, di_file, line, size_in_bits, alignment_in_bits, cases, this.getDIType(type.id_type));
				}
				else -> return;
			}

			const temp_di_type = this.di_types.get(type).value();
			temp_di_type.replaceAllUsesWith(di_type);
		}

		this.di_types.set(type, di_type);
	}

	func codegenFunctionDecl(this: &&CGContext, function: SharedHandle!<FunctionDecl>) -> void {
		if function.isIncompleteTemplate() {
			return;
		}

		if function.body is InlineBuiltin && this.program.options.dont_codegen_builtins {
			return;
		}

		var return_type = this.getType(function.return_type);
		var parameter_types: List!<llvm::TypeRef>;

		if function == this.program.main_function {
			parameter_types.append(this.ptr_type);
			parameter_types.append(this.int_type);
			return_type = this.int_type;
		} else {
			for type in function.parameter_types {
				parameter_types.append(this.getType(type));
			}
		}

		const function_type = this.llvm_context.getFunctionType(return_type, parameter_types, false);
		this.function_types.set(function, function_type);

		var name = "";
		match this.program.options.symbol_type {
			case None -> {}
			case Name -> name = function.name;
			case Full -> name = function.signature();
		}

		if function.extern_name != "" {
			name = function.extern_name;
		} else if function == this.program.main_function {
			name = "void_main";
		}

		this.functions.set(function, this.llvm_module.addFunction(name, function_type));
	}

	func codegenFunctionImpl(this: &&CGContext, function: SharedHandle!<FunctionDecl>) -> void {
		if function.isIncompleteTemplate() {
			return;
		}

		match function.body {
			case Empty | Extern -> return;
			case InlineBuiltin -> {
				if this.program.options.dont_codegen_builtins {
					return;
				}
			}
			case Unchecked -> {
				this.error("unchecked function: " + function.signature(), function.signature_span);
				return;
			}
			else -> {}
		}

		this.variables.clear();
		this.current_function = this.functions.get(function).value();

		// setup debug info for the function
		var di_function: llvm::MetaDataRef;
		if this.program.options.generate_debug_info {
			var di_return_and_parameter_types: List!<llvm::MetaDataRef>;

			di_return_and_parameter_types.append(this.getDIType(function.return_type));
			for parameter_type in function.parameter_types {
				di_return_and_parameter_types.append(this.getDIType(parameter_type));
			}

			const di_function_type = this.di_builder.createSubroutineType(
				this.di_files[function.span.file as uint],
				di_return_and_parameter_types,
				LLVMDIFlags::LLVMDIFlagZero
			);

			const di_namespace = this.di_namespaces.get(function.parent_namespace).value();

			var di_name = function.name;
			if !function.template_parameters.isEmpty() {
				di_name += function.template_parameters.format();
			}

			di_function = this.di_builder.createFunction(
				di_namespace,
				di_name,
				function.extern_name,
				this.di_files[function.span.file as uint],
				function.signature_span.line as uint + 1,
				di_function_type,
				false, 		// is local to unit
				true,		// is definition
				function.signature_span.line as uint + 1,
				LLVMDIFlags::LLVMDIFlagZero,
				this.program.options.optimized_build
			);

			this.di_functions.set(function, di_function);
			this.di_scope_stack.append(di_function);
			this.current_function.setSubprogram(di_function);
		}

		this.builder = this.llvm_context.createBuilder();
		const entry_block = this.llvm_context.appendBasicBlock(this.current_function, "");
		this.builder.positionAtEnd(entry_block);

		// initialize function parameters & variables
		for variable in function.variables {
			if variable.type.isUnknown() {
				this.error("variable '" + variable.name + "' has unknown type", variable.span);
				continue;
			}

			if variable.is_parameter {
				if function == this.program.main_function {
					var args = llvm::constNull(this.getType(function.parameter_types[0u]));
					args = this.builder.buildInsertValue(args, this.current_function.getParam(0u), 0u, "");
					args = this.builder.buildInsertValue(args, this.current_function.getParam(1u), 1u, "");
					this.variables.set(WeakPtr!<VarDecl>(variable), args);
				} else {
					const parameter = this.current_function.getParam(variable.id);
					this.variables.set(WeakPtr!<VarDecl>(variable), parameter);

					if this.program.options.generate_debug_info {
						const di_variable = this.di_builder.createParameterVariable(
							this.di_scope_stack.last().value(),
							variable.name,
							variable.id + 1, // ArgNo starts counting at 1
							this.di_files[function.span.file as uint],
							variable.span.line as uint,
							this.getDIType(variable.type),
							false,
							LLVMDIFlags::LLVMDIFlagZero
						);

						this.di_builder.insertDeclareAtEnd(
							parameter,
							di_variable,
							this.di_builder.createExpression(vptr!<u64>::null(), 0u),
							this.getDebugLocation(variable.span),
							entry_block
						);
					}
				}
			} else {
				this.setCurrentDebugLocation(variable.span);
				const address = this.builder.buildAlloca(this.getType(variable.type), variable.name);
				this.variables.set(WeakPtr!<VarDecl>(variable), address);

				if this.program.options.generate_debug_info {
					var alignment_in_bits = this.data_layout.getPreferredAlignmentOfType(this.getType(variable.type));

					const di_variable = this.di_builder.createAutoVariable(
						this.di_scope_stack.last().value(),
						variable.name,
						this.di_files[function.span.file as uint],
						variable.span.line as uint,
						this.getDIType(variable.type),
						false,
						LLVMDIFlags::LLVMDIFlagZero,
						alignment_in_bits
					);

					this.di_builder.insertDeclareAtEnd(
						address,
						di_variable,
						this.di_builder.createExpression(vptr!<u64>::null(), 0u),
						this.getDebugLocation(variable.span),
						entry_block
					);
				}

				this.builder.setCurrentDebugLocation2(MetaDataRef());
			}
		}

		// codegen body
		match function.body {
			case InlineBuiltin: builtin_funcion -> {
				var parameters: List!<llvm::ValueRef>;
				for i in 0u..this.current_function.countParams() {
					parameters.append(this.current_function.getParam(i));
				}

				this.builder.buildRet(this.codegenInlineBuiltinFunctionCall(builtin_funcion, parameters));
			}
			case Builtin: builtin_funcion -> this.codegenBuiltinFunction(builtin_funcion, function.signature_span);
			case Stmt: stmt -> this.codegenStmt(stmt);
			else -> panic("invalid function body for codegen");
		}

		if !this.builder.getInsertBlock().hasTerminator() {
			if function == this.program.main_function {
				this.builder.buildRet(llvm::constInt(this.int_type, 0, false));
			} else if function.return_type == this.program.void_type {
				this.builder.buildRetVoid();
			} else {
				panic("function doesn't have a terminator");
			}
		}

		if this.program.options.generate_debug_info {
			this.di_builder.finalizeSubprogram(di_function);
			this.di_scope_stack.removeLast();
		}

		this.builder.dispose();
	}

	func codegenBuiltinFunction(this: &&CGContext, function: BuiltinFunction, signature_span: Span) -> void {
		const type = this.getType(function.base_type);
		const decl = function.base_type.decl;

		const param0 = this.current_function.getParam(0u);
		const param1 = this.current_function.getParam(1u);

		match function {
			case StructDefaultConstructor -> {
				for i in 0u..decl.member_variables.size() {
					const member_ptr = this.builder.buildStructGEP2(type, param0, i, "");
					const member_type = decl.member_variables[i].type.decl;

					var parameters: List!<llvm::ValueRef>;
					parameters.append(member_ptr);

					discard this.codegenCall(member_type.default_constructor, parameters, ReturnKind::None, signature_span);
				}

				this.builder.buildRetVoid();
			}
			case StructCopyConstructor -> {
				for i in 0u..decl.member_variables.size() {
					const member_ptr = this.builder.buildStructGEP2(type, param0, i, "");
					const initializer = this.builder.buildExtractValue(param1, i, "");

					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;

						var parameters: List!<llvm::ValueRef>;
						parameters.append(member_ptr);
						parameters.append(initializer);

						discard this.codegenCall(member_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						this.builder.buildStore(initializer, member_ptr);
					}
				}

				this.builder.buildRetVoid();
			}
			case StructDestructor -> {
				for i in 0u..decl.member_variables.size() {
					if decl.member_variables[i].type.reference_kind != None {
						continue;
					}

					const member_ptr = this.builder.buildStructGEP2(type, param0, i, "");
					const member_type = decl.member_variables[i].type.decl;

					var parameters: List!<llvm::ValueRef>;
					parameters.append(member_ptr);

					discard this.codegenCall(member_type.destructor, parameters, ReturnKind::None, signature_span);
				}

				this.builder.buildRetVoid();
			}
			case StructOpAssign -> {
				for i in 0u..decl.member_variables.size() {
					const member_ptr = this.builder.buildStructGEP2(type, param0, i, "");
					const initializer = this.builder.buildExtractValue(param1, i, "");

					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;

						var parameters: List!<llvm::ValueRef>;
						parameters.append(member_ptr);
						parameters.append(initializer);

						discard this.codegenCall(member_type.op_assign, parameters, ReturnKind::None, signature_span);
					} else {
						this.builder.buildStore(initializer, member_ptr);
					}
				}

				this.builder.buildRetVoid();
			}
			case VariantCaseConstructor: case_id -> {
				const id_type = this.getType(decl.id_type);
				const id_ptr = this.builder.buildStructGEP2(type, param0, 0u, "");
				this.builder.buildStore(llvm::constInt(id_type, case_id, false), id_ptr);

				var member_var_param_offset = 1u;	// first param is this

				const case_decl = decl.getVariantCase(case_id).value();
				if case_decl.type != this.program.void_type {
					member_var_param_offset += 1;	// payload is passed before member variables

					const this_payload_ptr = this.builder.buildStructGEP2(type, param0, 1u, "");
					const initializer = param1;

					if case_decl.type.reference_kind == None {
						const case_type = case_decl.type.decl;

						var parameters: List!<llvm::ValueRef>;
						parameters.append(this_payload_ptr);
						parameters.append(initializer);

						discard this.codegenCall(case_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						this.builder.buildStore(initializer, this_payload_ptr);
					}
				}

				for i in 0u..decl.member_variables.size() {
					const this_member_ptr = this.builder.buildStructGEP2(type, param0, i + 2, "");
					const initializer = this.current_function.getParam(i + member_var_param_offset);

					if decl.member_variables[i].type.reference_kind == None {
						var parameters: List!<llvm::ValueRef>;
						parameters.append(this_member_ptr);
						parameters.append(initializer);

						const member_type = decl.member_variables[i].type.decl;

						discard this.codegenCall(member_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						this.builder.buildStore(initializer, this_member_ptr);
					}
				}

				this.builder.buildRetVoid();
			}
			case VariantCopyConstructor -> {
				const id_type = this.getType(decl.id_type);
				const id_ptr = this.builder.buildStructGEP2(type, param0, 0u, "");
				const this_payload_ptr = this.builder.buildStructGEP2(type, param0, 1u, "");

				const other_payload_ptr = this.builder.buildAlloca(type.structGetTypeAtIndex(1u), "");
				this.builder.buildStore(this.builder.buildExtractValue(param1, 1u, ""), other_payload_ptr);

				const other_id = this.builder.buildExtractValue(param1, 0u, "");
				this.builder.buildStore(other_id, id_ptr);

				const cont_block = this.llvm_context.appendBasicBlock(this.current_function, "cont");

				var case_count = 0u;
				for case_decl in decl.variant_cases {
					if case_decl.type != this.program.void_type {
						case_count++;
					}
				}

				var switch_instr = this.builder.buildSwitch(other_id, cont_block, case_count);

				for case_decl in decl.variant_cases {
					if case_decl.type == this.program.void_type {
						continue;
					}

					const case_block = this.llvm_context.appendBasicBlock(this.current_function, "case");
					switch_instr.addCase(llvm::constInt(id_type, case_decl.id, false), case_block);
					this.builder.positionAtEnd(case_block);

					const other_payload = this.builder.buildLoad2(this.getType(case_decl.type), other_payload_ptr, "");

					if case_decl.type.reference_kind == None {
						const case_type = case_decl.type.decl;
						var parameters: List!<llvm::ValueRef>;
						parameters.append(this_payload_ptr);
						parameters.append(other_payload);

						discard this.codegenCall(case_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						this.builder.buildStore(other_payload, this_payload_ptr);
					}

					this.builder.buildBr(cont_block);
				}

				this.builder.positionAtEnd(cont_block);

				for i in 0u..decl.member_variables.size() {
					const this_member_ptr = this.builder.buildStructGEP2(type, param0, i + 2, "");
					const other_member = this.builder.buildExtractValue(param1, i + 2, "");

					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;

						var parameters: List!<llvm::ValueRef>;
						parameters.append(this_member_ptr);
						parameters.append(other_member);

						discard this.codegenCall(member_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						this.builder.buildStore(other_member, this_member_ptr);
					}
				}

				this.builder.buildRetVoid();
			}
			case VariantDestructor -> {
				const id_type = this.getType(decl.id_type);
				const id_ptr = this.builder.buildStructGEP2(type, param0, 0u, "");
				const this_id = this.builder.buildLoad2(id_type, id_ptr, "");
				const this_payload_ptr = this.builder.buildStructGEP2(type, param0, 1u, "");

				var case_destructor_args: List!<llvm::ValueRef>;
				case_destructor_args.append(this_payload_ptr);

				const cont_block = this.llvm_context.appendBasicBlock(this.current_function, "cont");

				var case_count = 0u;
				for case_decl in decl.variant_cases {
					if case_decl.type != this.program.void_type && case_decl.type.reference_kind == None {
						case_count++;
					}
				}
				var switch_instr = this.builder.buildSwitch(this_id, cont_block, case_count);

				for case_decl in decl.variant_cases {
					if case_decl.type == this.program.void_type || case_decl.type.reference_kind != None {
						continue;
					}

					const case_block = this.llvm_context.appendBasicBlock(this.current_function, "case");
					switch_instr.addCase(llvm::constInt(id_type, case_decl.id, false), case_block);
					this.builder.positionAtEnd(case_block);

					const case_type = case_decl.type.decl;

					discard this.codegenCall(case_type.destructor, case_destructor_args, ReturnKind::None, signature_span);

					this.builder.buildBr(cont_block);
				}

				this.builder.positionAtEnd(cont_block);

				for i in 0u..decl.member_variables.size() {
					if decl.member_variables[i].type.reference_kind != None {
						continue;
					}

					const member_type = decl.member_variables[i].type.decl;

					var parameters: List!<llvm::ValueRef>;
					parameters.append(this.builder.buildStructGEP2(type, param0, i + 2, ""));

					discard this.codegenCall(member_type.destructor, parameters, ReturnKind::None, signature_span);
				}

				this.builder.buildRetVoid();
			}
			case VariantOpAssign -> {
				const id_type = this.getType(decl.id_type);
				const payload_type = type.structGetTypeAtIndex(1u);

				const id_ptr = this.builder.buildStructGEP2(type, param0, 0u, "");
				const this_id = this.builder.buildLoad2(id_type, id_ptr, "");
				const this_payload_ptr = this.builder.buildStructGEP2(type, param0, 1u, "");

				const other_payload_ptr = this.builder.buildAlloca(payload_type, "");
				this.builder.buildStore(this.builder.buildExtractValue(param1, 1u, ""), other_payload_ptr);
				const other_id = this.builder.buildExtractValue(param1, 0u, "");

				const payload_copy_ptr = this.builder.buildAlloca(type.structGetTypeAtIndex(1u), "");

				var copy_case_count = 0u;
				var dest_case_count = 0u;
				for case_decl in decl.variant_cases {
					if case_decl.type != this.program.void_type {
						copy_case_count++;

						if case_decl.type.reference_kind == None {
							dest_case_count++;
						}
					}
				}

				// copy payload to temporary
				const dest_block = this.llvm_context.appendBasicBlock(this.current_function, "cont");

				var copy_switch_instr = this.builder.buildSwitch(other_id, dest_block, copy_case_count);

				for case_decl in decl.variant_cases {
					if case_decl.type == this.program.void_type {
						continue;
					}

					const case_block = this.llvm_context.appendBasicBlock(this.current_function, "case");
					copy_switch_instr.addCase(llvm::constInt(id_type, case_decl.id, false), case_block);
					this.builder.positionAtEnd(case_block);

					const other_payload = this.builder.buildLoad2(this.getType(case_decl.type), other_payload_ptr, "");

					if case_decl.type.reference_kind == None {
						const case_type = case_decl.type.decl;
						var parameters: List!<llvm::ValueRef>;
						parameters.append(payload_copy_ptr);
						parameters.append(other_payload);

						discard this.codegenCall(case_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						this.builder.buildStore(other_payload, payload_copy_ptr);
					}

					this.builder.buildBr(dest_block);
				}

				this.builder.positionAtEnd(dest_block);

				// destruct old payload
				var case_destructor_args: List!<llvm::ValueRef>;
				case_destructor_args.append(this_payload_ptr);

				const cont_block = this.llvm_context.appendBasicBlock(this.current_function, "cont");

				var switch_instr = this.builder.buildSwitch(this_id, cont_block, dest_case_count);

				for case_decl in decl.variant_cases {
					if case_decl.type == this.program.void_type || case_decl.type.reference_kind != None {
						continue;
					}

					const case_type = case_decl.type.decl;

					const case_block = this.llvm_context.appendBasicBlock(this.current_function, "case");
					switch_instr.addCase(llvm::constInt(id_type, case_decl.id, false), case_block);
					this.builder.positionAtEnd(case_block);

					discard this.codegenCall(case_type.destructor, case_destructor_args, ReturnKind::None, signature_span);

					this.builder.buildBr(cont_block);
				}

				this.builder.positionAtEnd(cont_block);

				// move temporary payload to this
				this.builder.buildStore(
					this.builder.buildLoad2(payload_type, payload_copy_ptr, ""),
					this_payload_ptr
				);
				this.builder.buildStore(other_id, id_ptr);

				// assign member variables
				for i in 0u..decl.member_variables.size() {
					const member_ptr = this.builder.buildStructGEP2(type, param0, i + 2, "");
					const initializer = this.builder.buildExtractValue(param1, i + 2, "");

					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;

						var parameters: List!<llvm::ValueRef>;
						parameters.append(member_ptr);
						parameters.append(initializer);

						discard this.codegenCall(member_type.op_assign, parameters, ReturnKind::None, signature_span);
					} else {
						this.builder.buildStore(initializer, member_ptr);
					}
				}

				this.builder.buildRetVoid();
			}
			case StructOpEqual
			| VariantOpEqual -> {
				const uneq_block = this.llvm_context.appendBasicBlock(this.current_function, "uneq");

				if function is VariantOpEqual {
					const id_type = this.getType(decl.id_type);
					const data_block = this.llvm_context.appendBasicBlock(this.current_function, "data");

					// store lhs & rhs on stack to access the payload in a safe way
					const lhs_id = this.builder.buildExtractValue(param0, 0u, "");
					const lhs_data = this.builder.buildAlloca(type, "");
					this.builder.buildStore(param0, lhs_data);
					const lhs_payload_ptr = this.builder.buildStructGEP2(type, lhs_data, 1u, "");

					const rhs_id = this.builder.buildExtractValue(param1, 0u, "");
					const rhs_data = this.builder.buildAlloca(type, "");
					this.builder.buildStore(param1, rhs_data);
					const rhs_payload_ptr = this.builder.buildStructGEP2(type, rhs_data, 1u, "");

					const same_id = this.builder.buildICmp(LLVMIntPredicate::LLVMIntEQ, lhs_id, rhs_id, "");
					this.builder.buildCondBr(same_id, data_block, uneq_block);

					this.builder.positionAtEnd(data_block);

					const cont_block = this.llvm_context.appendBasicBlock(this.current_function, "cont");

					var case_count = 0u;
					for case_decl in decl.variant_cases {
						if case_decl.type != this.program.void_type {
							case_count++;
						}
					}
					var switch_instr = this.builder.buildSwitch(lhs_id, cont_block, case_count);

					for case_decl in decl.variant_cases {
						if case_decl.type == this.program.void_type {
							continue;
						}

						const case_block = this.llvm_context.appendBasicBlock(this.current_function, "case")
						switch_instr.addCase(llvm::constInt(id_type, case_decl.id, false), case_block);
						this.builder.positionAtEnd(case_block);

						const lhs = this.builder.buildLoad2(this.getType(case_decl.type), lhs_payload_ptr, "");
						const rhs = this.builder.buildLoad2(this.getType(case_decl.type), rhs_payload_ptr, "");

						var equal = llvm::ValueRef();
						if case_decl.type.reference_kind == None {
							const case_type = case_decl.type.decl;
							var parameters: List!<llvm::ValueRef>;
							parameters.append(lhs);
							parameters.append(rhs);

							equal = this.codegenCall(case_type.op_equal, parameters, ReturnKind::Value, signature_span);
						} else {
							equal = this.builder.buildICmp(LLVMIntPredicate::LLVMIntEQ, lhs, rhs, "");
						}

						this.builder.buildCondBr(equal, cont_block, uneq_block);
					}

					this.builder.positionAtEnd(cont_block);
				}

				const member_var_offset = 2u if function is VariantOpEqual else 0u;
				for i in 0u..decl.member_variables.size() {
					const lhs = this.builder.buildExtractValue(param0, i + member_var_offset, "");
					const rhs = this.builder.buildExtractValue(param1, i + member_var_offset, "");

					var equal = llvm::ValueRef();
					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;
						var parameters: List!<llvm::ValueRef>;
						parameters.append(lhs);
						parameters.append(rhs);

						equal = this.codegenCall(member_type.op_equal, parameters, ReturnKind::Value, signature_span);
					} else {
						equal = this.builder.buildICmp(LLVMIntPredicate::LLVMIntEQ, lhs, rhs, "");
					}

					const next_block = this.llvm_context.appendBasicBlock(this.current_function, "next");

					this.builder.buildCondBr(equal, next_block, uneq_block);
					this.builder.positionAtEnd(next_block);
				}

				this.builder.buildRet(llvm::constInt(this.bool_type, 1, false));

				this.builder.positionAtEnd(uneq_block);
				this.builder.buildRet(llvm::constInt(this.bool_type, 0, false));
			}
			case StructOpCmp -> {
				const entry_block = this.builder.getInsertBlock();
				const uneq_block = this.llvm_context.appendBasicBlock(this.current_function, "uneq");

				var cmp_values: List!<llvm::ValueRef>;
				var cmp_blocks: List!<llvm::BasicBlockRef>;

				for i in 0u..decl.member_variables.size() {
					const lhs = this.builder.buildExtractValue(param0, i, "");
					const rhs = this.builder.buildExtractValue(param1, i, "");
					var parameters: List!<llvm::ValueRef>;
					parameters.append(lhs);
					parameters.append(rhs);

					var sign = llvm::ValueRef();
					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;
						sign = this.codegenCall(member_type.op_compare, parameters, ReturnKind::Value, signature_span);
					} else {
						sign = this.codegenInlineBuiltinFunctionCall(InlineBuiltinFunction::UIntOpCmp(decl.member_variables[i].type), parameters);
					}
					cmp_values.append(sign);
					cmp_blocks.append(this.builder.getInsertBlock());

					const next_block = this.llvm_context.appendBasicBlock(this.current_function, "next");

					const equal = this.builder.buildICmp(LLVMIntPredicate::LLVMIntEQ, sign, llvm::constInt(this.int_type, 0, false), "");
					this.builder.buildCondBr(equal, next_block, uneq_block);
					this.builder.positionAtEnd(next_block);
				}

				this.builder.buildRet(llvm::constInt(this.int_type, 0, false));

				this.builder.positionAtEnd(uneq_block);
				var phi = this.builder.buildPhi(this.int_type, "");
				phi.addIncoming(cmp_values, cmp_blocks);
				this.builder.buildRet(phi);
			}
			case ArrayDefaultConstructor -> {
				// TODO: turn into a loop for better code size (llvm can unroll it for performance)
				const array_type = (decl.body as Array).value();
				const element_type = array_type.element_type;
				const element_type_decl = element_type.decl;

				for i in 0u..array_type.size {
					var indices: List!<llvm::ValueRef>;
					indices.append(llvm::constInt(this.int_type, 0, false));
					indices.append(llvm::constInt(this.int_type, i as int, false));
					const element_ptr = this.builder.buildGEP2(type, param0, indices, "");

					discard this.codegenCall(element_type_decl.default_constructor, List!<llvm::ValueRef>(1u, element_ptr), ReturnKind::None, signature_span);
				}

				this.builder.buildRetVoid();
			}
			case ArrayCopyConstructor
			| ArrayDestructor
			| ArrayOpAssign -> {
				// TODO: turn into a loop for better code size (llvm can unroll it for performance)
				const array_type = (decl.body as Array).value();
				const element_type = array_type.element_type;
				const element_type_decl = element_type.decl;

				for i in 0u..array_type.size {
					var indices: List!<llvm::ValueRef>;
					indices.append(llvm::constInt(this.int_type, 0, false));
					indices.append(llvm::constInt(this.int_type, i as int, false));
					const element_ptr = this.builder.buildGEP2(type, param0, indices, "");

					if !(function is ArrayCopyConstructor) {
						discard this.codegenCall(element_type_decl.destructor, List!<llvm::ValueRef>(1u, element_ptr), ReturnKind::None, signature_span);
					}

					if !(function is ArrayDestructor) {
						const other_element = this.builder.buildExtractValue(param1, i, "");

						var parameters: List!<llvm::ValueRef>;
						parameters.append(element_ptr);
						parameters.append(other_element);

						discard this.codegenCall(element_type_decl.copy_constructor, parameters, ReturnKind::None, signature_span);
					}
				}

				this.builder.buildRetVoid();
			}
			case ArrayOpEqual -> {
				// TODO: turn into a loop for better code size (llvm can unroll it for performance)
				const array_type = (decl.body as Array).value();
				const element_type = array_type.element_type;
				const element_type_decl = element_type.decl;

				const uneq_block = this.llvm_context.appendBasicBlock(this.current_function, "uneq");

				for i in 0u..array_type.size {
					const lhs = this.builder.buildExtractValue(param0, i, "");
					const rhs = this.builder.buildExtractValue(param1, i, "");

					var equal = llvm::ValueRef();
					if element_type.reference_kind == None {
						var parameters: List!<llvm::ValueRef>;
						parameters.append(lhs);
						parameters.append(rhs);

						equal = this.codegenCall(element_type_decl.op_equal, parameters, ReturnKind::Value, signature_span);
					} else {
						equal = this.builder.buildICmp(LLVMIntPredicate::LLVMIntEQ, lhs, rhs, "");
					}

					const next_block = this.llvm_context.appendBasicBlock(this.current_function, "next");

					this.builder.buildCondBr(equal, next_block, uneq_block);
					this.builder.positionAtEnd(next_block);
				}

				this.builder.buildRet(llvm::constInt(this.bool_type, 1, false));

				this.builder.positionAtEnd(uneq_block);
				this.builder.buildRet(llvm::constInt(this.bool_type, 0, false));
			}
		}
	}

	func codegenInlineBuiltinFunctionCall(this: &&CGContext, function: InlineBuiltinFunction, parameters: List!<llvm::ValueRef>) -> llvm::ValueRef {
		match function {
			case NoOp -> return llvm::ValueRef();

			case BitStoreNull -> {
				this.builder.buildStore(llvm::constNull(this.getType(function.base_type)), parameters[0u]);
				return llvm::ValueRef();
			}
			case BitStoreValue -> {
				this.builder.buildStore(parameters[1u], parameters[0u]);
				return llvm::ValueRef();
			}

			case BitOpEQ -> return this.builder.buildICmp(LLVMIntPredicate::LLVMIntEQ, parameters[0u], parameters[1u], "");
			case BitOpNE -> return this.builder.buildICmp(LLVMIntPredicate::LLVMIntNE, parameters[0u], parameters[1u], "");

			case BitOpAnd -> return this.builder.buildAnd(parameters[0u], parameters[1u], "");
			case BitOpOr -> return this.builder.buildOr(parameters[0u], parameters[1u], "");
			case BitOpXOr -> return this.builder.buildXor(parameters[0u], parameters[1u], "");
			case BitOpNot -> return this.builder.buildNot(parameters[0u], "");
			case BitOpShl -> return this.builder.buildShl(parameters[0u], parameters[1u], "");
			case BitOpLShr -> return this.builder.buildLShr(parameters[0u], parameters[1u], "");
			case BitOpAShr -> return this.builder.buildAShr(parameters[0u], parameters[1u], "");

			case BitOpAndAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildAnd(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return llvm::ValueRef();
			}
			case BitOpOrAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildOr(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return llvm::ValueRef();
			}
			case BitOpXOrAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildXor(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return llvm::ValueRef();
			}
			case BitOpShlAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildShl(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return llvm::ValueRef();
			}
			case BitOpLShrAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildLShr(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return llvm::ValueRef();
			}
			case BitOpAShrAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildAShr(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return llvm::ValueRef();
			}

			case IntOpAdd -> return this.builder.buildAdd(parameters[0u], parameters[1u], "");
			case IntOpSub -> return this.builder.buildSub(parameters[0u], parameters[1u], "");
			case IntOpMul -> return this.builder.buildMul(parameters[0u], parameters[1u], "");
			case IntOpNeg -> return this.builder.buildNeg(parameters[0u], "");

			case IntOpInc -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildAdd(lhs, llvm::constInt(type, 1, false), "");
				this.builder.buildStore(result, parameters[0u]);
				return llvm::ValueRef();
			}
			case IntOpDec -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildSub(lhs, llvm::constInt(type, 1, false), "");
				this.builder.buildStore(result, parameters[0u]);
				return llvm::ValueRef();
			}

			case IntOpAddAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildAdd(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return llvm::ValueRef();
			}
			case IntOpSubAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildSub(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return llvm::ValueRef();
			}
			case IntOpMulAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildMul(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return llvm::ValueRef();
			}

			case SIntOpLT -> return this.builder.buildICmp(LLVMIntPredicate::LLVMIntSLT, parameters[0u], parameters[1u], "");
			case SIntOpLE -> return this.builder.buildICmp(LLVMIntPredicate::LLVMIntSLE, parameters[0u], parameters[1u], "");
			case SIntOpGT -> return this.builder.buildICmp(LLVMIntPredicate::LLVMIntSGT, parameters[0u], parameters[1u], "");
			case SIntOpGE -> return this.builder.buildICmp(LLVMIntPredicate::LLVMIntSGE, parameters[0u], parameters[1u], "");
			case SIntOpCmp -> return this.builder.buildSub(
				this.builder.buildZExt(this.builder.buildICmp(LLVMIntPredicate::LLVMIntSGT, parameters[0u], parameters[1u], ""), this.int_type, ""),
				this.builder.buildZExt(this.builder.buildICmp(LLVMIntPredicate::LLVMIntSLT, parameters[0u], parameters[1u], ""), this.int_type, ""), ""
			);

			case SIntOpDiv -> return this.builder.buildSDiv(parameters[0u], parameters[1u], "");
			case SIntOpMod -> return this.builder.buildSRem(parameters[0u], parameters[1u], "");

			case SIntOpDivAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildSDiv(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return llvm::ValueRef();
			}
			case SIntOpModAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildSRem(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return llvm::ValueRef();
			}

			case UIntOpLT -> return this.builder.buildICmp(LLVMIntPredicate::LLVMIntULT, parameters[0u], parameters[1u], "");
			case UIntOpLE -> return this.builder.buildICmp(LLVMIntPredicate::LLVMIntULE, parameters[0u], parameters[1u], "");
			case UIntOpGT -> return this.builder.buildICmp(LLVMIntPredicate::LLVMIntUGT, parameters[0u], parameters[1u], "");
			case UIntOpGE -> return this.builder.buildICmp(LLVMIntPredicate::LLVMIntUGE, parameters[0u], parameters[1u], "");
			case UIntOpCmp -> return this.builder.buildSub(
				this.builder.buildZExt(this.builder.buildICmp(LLVMIntPredicate::LLVMIntUGT, parameters[0u], parameters[1u], ""), this.int_type, ""),
				this.builder.buildZExt(this.builder.buildICmp(LLVMIntPredicate::LLVMIntULT, parameters[0u], parameters[1u], ""), this.int_type, ""), ""
			);

			case UIntOpDiv -> return this.builder.buildUDiv(parameters[0u], parameters[1u], "");
			case UIntOpMod -> return this.builder.buildURem(parameters[0u], parameters[1u], "");

			case UIntOpDivAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildUDiv(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return llvm::ValueRef();
			}
			case UIntOpModAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildURem(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return llvm::ValueRef();
			}

			case FloatOpEQ -> return this.builder.buildFCmp(LLVMRealPredicate::LLVMRealOEQ, parameters[0u], parameters[1u], "");
			case FloatOpNE -> return this.builder.buildFCmp(LLVMRealPredicate::LLVMRealONE, parameters[0u], parameters[1u], "");
			case FloatOpLT -> return this.builder.buildFCmp(LLVMRealPredicate::LLVMRealOLT, parameters[0u], parameters[1u], "");
			case FloatOpLE -> return this.builder.buildFCmp(LLVMRealPredicate::LLVMRealOLE, parameters[0u], parameters[1u], "");
			case FloatOpGT -> return this.builder.buildFCmp(LLVMRealPredicate::LLVMRealOGT, parameters[0u], parameters[1u], "");
			case FloatOpGE -> return this.builder.buildFCmp(LLVMRealPredicate::LLVMRealOGE, parameters[0u], parameters[1u], "");
			case FloatOpCmp -> return this.builder.buildSub(
				this.builder.buildZExt(this.builder.buildFCmp(LLVMRealPredicate::LLVMRealOGT, parameters[0u], parameters[1u], ""), this.int_type, ""),
				this.builder.buildZExt(this.builder.buildFCmp(LLVMRealPredicate::LLVMRealOLT, parameters[0u], parameters[1u], ""), this.int_type, ""), ""
			);

			case FloatOpAdd -> return this.builder.buildFAdd(parameters[0u], parameters[1u], "");
			case FloatOpSub -> return this.builder.buildFSub(parameters[0u], parameters[1u], "");
			case FloatOpMul -> return this.builder.buildFMul(parameters[0u], parameters[1u], "");
			case FloatOpDiv -> return this.builder.buildFDiv(parameters[0u], parameters[1u], "");
			case FloatOpMod -> return this.builder.buildFRem(parameters[0u], parameters[1u], "");
			case FloatOpNeg -> return this.builder.buildFNeg(parameters[0u], "");

			case FloatOpAddAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildFAdd(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return llvm::ValueRef();
			}
			case FloatOpSubAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildFSub(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return llvm::ValueRef();
			}
			case FloatOpMulAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildFMul(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return llvm::ValueRef();
			}
			case FloatOpDivAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildFDiv(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return llvm::ValueRef();
			}
			case FloatOpModAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildFRem(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return llvm::ValueRef();
			}

			case PointerGetNull -> return llvm::constNull(this.getType(function.base_type));
			case PointerToRef -> return parameters[0u];	// reference & pointer types are the same in llvm
			case RefToPointer -> return parameters[0u];	// reference & pointer types are the same in llvm
			case PointerCast -> return parameters[0u];	// all pointer types are the same in llvm

			case PointerDiff -> {
				const pointer_type = (function.base_type.decl.body as Pointer).value();
				const pointee_type = this.getType(pointer_type.base_type);
				return this.builder.buildPtrDiff2(pointee_type, parameters[0u], parameters[1u], "");
			}
			case PointerOffset
			| PointerOpIndex -> {
				const pointer_type = (function.base_type.decl.body as Pointer).value();
				const pointee_type = this.getType(pointer_type.base_type);

				var indices: List!<llvm::ValueRef>;
				indices.append(parameters[1u]);
				return this.builder.buildGEP2(pointee_type, parameters[0u], indices, "");
			}

			case IntCast: target -> {
				const source_type = this.getType(function.base_type);
				const target_type = this.getType(target);

				const source_width = source_type.getIntTypeWidth();
				const target_width = target_type.getIntTypeWidth();

				if source_width == target_width {
					return parameters[0u];
				} else if source_width > target_width {
					return this.builder.buildTrunc(parameters[0u], target_type, "");
				} else if function.base_type.isSigned() && target.isSigned() {
					return this.builder.buildSExt(parameters[0u], target_type, "");
				} else {
					return this.builder.buildZExt(parameters[0u], target_type, "");
				}
			}
			case FloatCast: target -> {
				const source_type = this.getType(function.base_type);
				const target_type = this.getType(target);

				const source_width = source_type.getIntTypeWidth();
				const target_width = target_type.getIntTypeWidth();

				if source_width == target_width {
					return parameters[0u];
				} else if source_width > target_width {
					return this.builder.buildFPTrunc(parameters[0u], target_type, "");
				} else {
					return this.builder.buildFPExt(parameters[0u], target_type, "");
				}
			}
			case IntToFloat: target -> {
				if function.base_type.isSigned() {
					return this.builder.buildSIToFP(parameters[0u], this.getType(target), "");
				} else {
					return this.builder.buildUIToFP(parameters[0u], this.getType(target), "");
				}
			}
			case FloatToInt: target -> {
				if target.isSigned() {
					return this.builder.buildFPToSI(parameters[0u], this.getType(target), "");
				} else {
					return this.builder.buildFPToUI(parameters[0u], this.getType(target), "");
				}
			}

			case SizeOf -> {
				// ptrtoint (ptr getelementptr (type, ptr null, i32 1) to i64)
				const type = this.getType(function.base_type);
				return llvm::constPtrToInt(
					llvm::constGEP2(
						type,
						llvm::constNull(this.ptr_type),
						List!<llvm::ValueRef>(1u, llvm::constInt(this.int_type, 1, false))
					),
					this.int_type
				);
			}
			case AlignmentOf -> return llvm::constInt(this.int_type, this.data_layout.getPreferredAlignmentOfType(this.getType(function.base_type)) as int, false);
			case ReferenceKindOf -> return llvm::constInt(this.int_type, function.base_type.reference_kind as int, false);

			case VariantOpUnsafeAs: id -> {
				const case_decl = function.base_type.decl.getVariantCase(id).value();
				var result = this.builder.buildStructGEP2(this.getType(function.base_type), parameters[0u], 1u, "");
				if case_decl.type.reference_kind != None {
					result = this.builder.buildLoad2(this.getType(case_decl.type), result, "");
				}
				return result;
			}

			case VariantOpIs: id -> {
				const id_type = this.getType(function.base_type.decl.id_type);
				const object_id = this.builder.buildExtractValue(parameters[0u], 0u, "");
				return this.builder.buildICmp(LLVMIntPredicate::LLVMIntEQ, object_id, llvm::constInt(id_type, id, false), "");
			}

			case ArrayGetSize -> {
				const size = (function.base_type.decl.body as Array).value().size;
				return llvm::constInt(this.int_type, size as int, false);
			}
			case ArrayGetDataPointer -> {
				var indices: List!<llvm::ValueRef>;
				indices.append(llvm::constInt(this.int_type, 0, false));
				indices.append(llvm::constInt(this.int_type, 0, false));
				return this.builder.buildGEP2(this.getType(function.base_type), parameters[0u], indices, "");
			}
		}
	}

	func codegenStmt(this: &&CGContext, stmt: Stmt) -> void {
		match stmt {
			case Compound: compound_stmt -> this.codegenCompoundStmt(compound_stmt);
			case Expr: expr -> {
				discard this.codegenExpr(expr);
				if expr.type == this.program.never_type {
					this.builder.buildUnreachable();
				}
			}
			case If: if_stmt -> this.codegenIfStmt(if_stmt, stmt.span);
			case While: while_stmt -> this.codegenWhileStmt(while_stmt, stmt.span);
			case Break -> {
				this.setCurrentDebugLocation(stmt.span);
				this.builder.buildBr(this.break_target);
			}
			case Continue -> {
				this.setCurrentDebugLocation(stmt.span);
				this.builder.buildBr(this.continue_target);
			}
			case Yield -> {
				this.setCurrentDebugLocation(stmt.span);
				this.builder.buildBr(this.yield_target);
			}
			case Return: value -> {
				if value is Void && this.current_function == this.functions.get(this.program.main_function).value() {
					this.setCurrentDebugLocation(stmt.span);
					this.builder.buildRet(llvm::constInt(this.int_type, 0, false));
				} else {
					const built_value = this.codegenExpr(value);
					this.setCurrentDebugLocation(stmt.span);
					this.builder.buildRet(built_value);
				}
			}
			case LifeTimeStart: variable -> {
				const var_decl = variable.forceLock();
				if !(var_decl.destructor_call is Undefined) {
					this.codegenLifeTimeStart(this.getVariable(variable));
				}
				discard this.codegenExpr(var_decl.constructor_call);
			}
			case LifeTimeEnd: variable -> {
				const var_decl = variable.forceLock();
				discard this.codegenExpr(var_decl.destructor_call);
				if !(var_decl.destructor_call is Undefined) {
					this.codegenLifeTimeEnd(this.getVariable(variable));
				}
			}
			case Empty -> {}
			else -> this.todo("finish codegen of statements", stmt.span);
		}
	}

	func codegenCompoundStmt(this: &&CGContext, compound_stmt: CompoundStmt) -> void {
		for stmt in compound_stmt.children {
			this.codegenStmt(stmt);
		}
	}

	func codegenIfStmt(this: &&CGContext, if_stmt: IfStmt, span: Span) -> void {
		const condition = this.codegenExpr(if_stmt.condition);
		for stmt in if_stmt.condition_cleanup {
			discard this.codegenStmt(stmt);
		}

		const then_block = this.llvm_context.appendBasicBlock(this.current_function, "then");
		const else_block = this.llvm_context.appendBasicBlock(this.current_function, "else");
		const cont_block = this.llvm_context.appendBasicBlock(this.current_function, "cont");

		var then_branch_terminates = false;
		var else_branch_terminates = false;

		this.setCurrentDebugLocation(span);
		this.builder.buildCondBr(condition, then_block, else_block);

		this.builder.positionAtEnd(then_block);
		this.codegenStmt(if_stmt.then_branch);
		if !this.builder.getInsertBlock().hasTerminator() {
			this.builder.buildBr(cont_block);
		} else {
			then_branch_terminates = true;
		}

		this.builder.positionAtEnd(else_block);
		this.codegenStmt(if_stmt.else_branch);
		if !this.builder.getInsertBlock().hasTerminator() {
			this.builder.buildBr(cont_block);
		} else {
			else_branch_terminates = true;
		}

		this.builder.positionAtEnd(cont_block);

		if then_branch_terminates && else_branch_terminates {
			this.builder.buildUnreachable();
		}
	}

	func codegenWhileStmt(this: &&CGContext, while_stmt: WhileStmt, span: Span) -> void {
		const cond_block = this.llvm_context.appendBasicBlock(this.current_function, "cond");
		const loop_block = this.llvm_context.appendBasicBlock(this.current_function, "loop");
		const cont_block = this.llvm_context.appendBasicBlock(this.current_function, "cont");

		const prev_continue_target = this.continue_target;
		const prev_break_target = this.break_target;

		this.continue_target = cond_block;
		this.break_target = cont_block;

		this.setCurrentDebugLocation(span);

		if while_stmt.kind == While {
			this.builder.buildBr(cond_block);
		} else {
			this.builder.buildBr(loop_block);
		}

		this.builder.positionAtEnd(cond_block);
		const condition = this.codegenExpr(while_stmt.condition);
		for stmt in while_stmt.condition_cleanup {
			discard this.codegenStmt(stmt);
		}
		this.builder.buildCondBr(condition, loop_block, cont_block);

		var body_terminates = false;

		this.builder.positionAtEnd(loop_block);
		this.codegenStmt(while_stmt.body);

		if !this.builder.getInsertBlock().hasTerminator() {
			this.builder.buildBr(cond_block);
		} else {
			body_terminates = true;
		}

		this.builder.positionAtEnd(cont_block);
		if body_terminates && while_stmt.kind == DoWhile {
			this.builder.buildUnreachable();
		}

		this.continue_target = prev_continue_target;
		this.break_target = prev_break_target;
	}

	func codegenStringGlobal(this: &&CGContext, value: String) -> llvm::ValueRef {
		match this.string_globals.get(value) {
			case Some: result -> return result;
			else -> {}
		}

		const string_value = this.llvm_context.constString(value, true);
		const string_type = string_value.getType();

		var result = this.llvm_module.addGlobal(string_type, "");
		result.setLinkage(LLVMLinkage::LLVMPrivateLinkage);
		result.setUnnamedAddress(LLVMUnnamedAddr::LLVMGlobalUnnamedAddr);
		result.setAlignment(1u);
		result.setInitializer(string_value);
		result.setGlobalConstant(true);

		this.string_globals.set(value, result);
		return result;
	}

	func codegenExpr(this: &&CGContext, expr: Expr) -> llvm::ValueRef {
		const span = expr.span;

		match expr {
			case Undefined -> {
				if expr.type == this.program.void_type || expr.type.isUnknown() {
					return llvm::ValueRef();
				} else {
					return this.getType(expr.type).getUndef();
				}
			}
			case Void -> return llvm::ValueRef();
			case Integer: value -> return llvm::constInt(this.getType(expr.type), value, expr.type.isSigned());
			case Float: value -> return llvm::constFloat(this.getType(expr.type), value);
			case String: value -> {
				const data_ptr = this.codegenStringGlobal(value);
				var result = llvm::constNull(this.getType(expr.type));
				result = this.builder.buildInsertValue(result, data_ptr, 0u, "");
				result = this.builder.buildInsertValue(result, llvm::constInt(this.int_type, value.size() as int, false), 1u, ""); // size
				result = this.builder.buildInsertValue(result, llvm::constInt(this.int_type, value.size() as int, false), 2u, ""); // capacity
				return result;
			}
			case ConstAggregate: elements -> {
				var result = llvm::constNull(this.getType(expr.type));
				for i in 0u..elements.size() {
					const element = this.codegenExpr(elements[i]);
					result = this.builder.buildInsertValue(result, element, i, "");
				}
				return result;
			}
			case Call: call_expr -> return this.codegenCall(call_expr, expr.span);
			case VarInvoke: variable -> {
				const decl = variable.forceLock();
				if decl.type.reference_kind == None || decl.is_parameter {
					return this.getVariable(variable);
				} else {
					this.setCurrentDebugLocation(span);
					return this.builder.buildLoad2(this.getType(decl.type), this.getVariable(variable), "");
				}
			}
			case MemberVarInvoke: member_var_invoke_expr -> {
				const object_type_decl = member_var_invoke_expr.object.type.decl;
				const member_decl = object_type_decl.member_variables[member_var_invoke_expr.id];

				const object = this.codegenExpr(member_var_invoke_expr.object);
				const object_type = this.getType(member_var_invoke_expr.object.type.base());

				var id = member_var_invoke_expr.id;
				if member_var_invoke_expr.object.type.isVariant() {
					id += 2;
				}

				this.setCurrentDebugLocation(span);
				const ptr = this.builder.buildStructGEP2(object_type, object, id, "");

				if member_decl.type.reference_kind == None {
					return ptr;
				} else {
					return this.builder.buildLoad2(this.getType(member_decl.type), ptr, "");
				}
			}
			case Dereference: base -> {
				this.setCurrentDebugLocation(span);
				return this.builder.buildLoad2(this.getType(expr.type), this.codegenExpr(base), "");
			}
			case Match: match_expr -> return this.codegenMatchExpr(match_expr, expr.span);
			case ShallowCopy: shallow_copy_expr -> {
				var dst = llvm::ValueRef();
				match shallow_copy_expr.destination.operator unwrap() {
					case VarInvoke: variable -> dst = this.getVariable(variable);
					case MemberVarInvoke: member_var_invoke_expr -> {
						const object = this.codegenExpr(member_var_invoke_expr.object);
						const object_type = this.getType(member_var_invoke_expr.object.type.base());

						var id = member_var_invoke_expr.id;
						if member_var_invoke_expr.object.type.isVariant() {
							id += 2;
						}

						dst = this.builder.buildStructGEP2(object_type, object, member_var_invoke_expr.id, "");
					}
					else -> panic("invalid shallow copy expr");
				}

				const val = this.codegenExpr(shallow_copy_expr.value);

				this.setCurrentDebugLocation(span);
				this.builder.buildStore(val, dst);
				return val;
			}
			case TypeRef -> return llvm::ValueRef();
			case FunctionRef: function -> return this.functions.get(function).value();
		}
	}

	func codegenCall(this: &&CGContext, call_expr: CallExpr, span: Span) -> llvm::ValueRef {
		var parameters: List!<llvm::ValueRef>;
		for parameter in call_expr.parameters {
			parameters.append(this.codegenExpr(parameter));
		}

		return this.codegenCall(call_expr.function, parameters, call_expr.return_kind, call_expr.result_var, span);
	}

	func codegenCall(this: &&CGContext, function: SharedHandle!<FunctionDecl>, parameters: List!<llvm::ValueRef>, return_kind: ReturnKind, span: Span) -> llvm::ValueRef {
		assert(return_kind == ReturnKind::None || return_kind == ReturnKind::Value);
		return this.codegenCall(function, parameters, return_kind, WeakPtr!<VarDecl>(), span);
	}

	func codegenCall(this: &&CGContext, function: SharedHandle!<FunctionDecl>, parameters: List!<llvm::ValueRef>, return_kind: ReturnKind, result_var: WeakPtr!<VarDecl>, span: Span) -> llvm::ValueRef {
		this.setCurrentDebugLocation(span);

		match function.body {
			case InlineBuiltin: function -> return this.codegenInlineBuiltinFunctionCall(function, parameters);
			else -> {
				if return_kind is Parameter {
					this.codegenLifeTimeStart(this.getVariable(result_var));
				}

				const function_impl = this.functions.get(function).value();
				const function_type = this.function_types.get(function).value();
				const result = this.builder.buildCall2(function_type, function_impl, parameters, "");

				match return_kind {
					case None -> return llvm::ValueRef();
					case Value -> return result;
					case Variable -> {
						const built_result_var = this.getVariable(result_var);
						this.builder.buildStore(result, built_result_var);
						return built_result_var;
					}
					case Parameter -> return this.getVariable(result_var);
					case VariableButYieldNone -> {
						const built_result_var = this.getVariable(result_var);
						this.builder.buildStore(result, built_result_var);
						return llvm::ValueRef();
					}
				}
			}
		}
	}

	func codegenMatchExpr(this: &&CGContext, match_expr: MatchExpr, span: Span) -> llvm::ValueRef {
		var value = this.codegenExpr(match_expr.value);

		if match_expr.value.type.isVariant() {
			const value_type_decl = match_expr.value.type.decl;
			value = this.builder.buildLoad2(
				this.getType(value_type_decl.id_type),
				this.builder.buildStructGEP2(
					this.getType(match_expr.value.type.base()),
					value, 0u, ""
				), ""
			);
		} else if match_expr.value.type.reference_kind != None {
			value = this.builder.buildLoad2(
				this.getType(match_expr.value.type.base()),
				value, ""
			);
		}

		var case_blocks: List!<llvm::BasicBlockRef>;
		for i in 0u..match_expr.cases.size() {
			case_blocks.append(this.llvm_context.appendBasicBlock(this.current_function, "case"));
		}

		const else_block = this.llvm_context.appendBasicBlock(this.current_function, "else");
		const cont_block = this.llvm_context.appendBasicBlock(this.current_function, "cont");

		const prev_yield_target = this.yield_target;
		this.yield_target = cont_block;

		this.setCurrentDebugLocation(span);

		var switch_instr = this.builder.buildSwitch(value, else_block, case_blocks.size());

		for i in 0u..match_expr.cases.size() {
			for pattern in match_expr.cases[i].patterns {
				const built_pattern = this.codegenExpr(pattern);
				switch_instr.addCase(built_pattern, case_blocks[i]);
			}
		}

		for i in 0u..match_expr.cases.size() {
			this.builder.positionAtEnd(case_blocks[i]);
			this.codegenStmt(match_expr.cases[i].body);
			if !this.builder.getInsertBlock().hasTerminator() {
				this.builder.buildBr(cont_block);
			}
		}

		this.builder.positionAtEnd(else_block);
		match match_expr.else_case {
			case Some: stmt -> {
				this.codegenStmt(stmt);
				if !this.builder.getInsertBlock().hasTerminator() {
					this.builder.buildBr(cont_block);
				}
			}
			else -> this.builder.buildUnreachable();
		}

		this.builder.positionAtEnd(cont_block);
		this.yield_target = prev_yield_target;

		return this.variables.get(match_expr.yield_var) ?? llvm::ValueRef();
	}

	func codegenIntrinsicCall(this: &&CGContext, intrinsic_name: String, parameter_types: List!<llvm::TypeRef>, parameters: List!<llvm::ValueRef>) -> llvm::ValueRef {
		const id = llvm::lookupIntrinsicID(intrinsic_name);
		const type = this.llvm_context.getIntrinsicType(id, parameter_types);
		const declaration = this.llvm_module.getIntrinsicDeclaration(id, parameter_types);

		return this.builder.buildCall2(type, declaration, parameters, "");
	}

	func codegenLifeTimeStart(this: &&CGContext, address: llvm::ValueRef) -> void {
		var parameters: List!<llvm::ValueRef>;
		parameters.append(constInt(this.int_type, 1, false));
		parameters.append(address);
		discard this.codegenIntrinsicCall("llvm.lifetime.start", List!<llvm::TypeRef>(1u, this.ptr_type), parameters);
	}

	func codegenLifeTimeEnd(this: &&CGContext, address: llvm::ValueRef) -> void {
		var parameters: List!<llvm::ValueRef>;
		parameters.append(constInt(this.int_type, 1, false));
		parameters.append(address);
		discard this.codegenIntrinsicCall("llvm.lifetime.end", List!<llvm::TypeRef>(1u, this.ptr_type), parameters);
	}
}
