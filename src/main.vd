import std/core;
import std/io;
import std/list;
import std/libc/stdlib;
import std/path;
import std/range;
import std/string;

import args;
import options;
import program;
import span;
import typechecker;

func parseArguments(arguments: Range!<String>) -> Optional!<CompilerOptions> {
	var args_parser = ArgsParser(arguments, "");
	var options: CompilerOptions;

	var subcommands: List!<String>;
	subcommands.append("compile");
	subcommands.append("check");
	subcommands.append("run");

	options.mode = (args_parser.subcommand(subcommands.range()) ?? 0u) as Mode;

	options.dump_tokens = args_parser.flag("t", "dump-tokens", "dump tokens") ?? false;
	options.dump_ast = args_parser.flag("a", "dump-ast", "dump ast") ?? false;
	options.dump_program = args_parser.flag("p", "dump-program", "dump program") ?? false;

	options.hide_errors = args_parser.flag("q", "hide_errors", "do not display error messages") ?? false;

	options.program_name = args_parser.value("o", "program-name", "program name & output file name") ?? "";
	options.build_dir = args_parser.value("B", "build-dir", "build dir & output file location") ?? "build";

	// TODO: replace default values with host platform specific ones
	options.target_triple = args_parser.value("", "target-triple", "target triple string passed to llvm") ?? "x86_64-pc-linux-gnu";
	options.target_data_layout = args_parser.value("", "target-data-layout", "target data layout string passed to llvm") ?? "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128";
	options.codegen_only = args_parser.flag("c", "codegen-only", "don't compile output code to a binary") ?? false;
	options.generate_debug_info = args_parser.flag("g", "generate-debug-info", "generate debug information") ?? false;
	options.codegen_inline_builtin_functions = !(args_parser.flag("m", "cg-no-builtins", "don't codegen inlineable builtin functions") ?? false);

	options.codegen_lazy = args_parser.flag("M", "cg-lazy", "codegen functions lazily as needed") ?? false;
	options.codegen_asap = !(options.codegen_lazy || options.mode == Check);

	const optimization_level = args_parser.value("O", "optimization-level", "enable optimizations") ?? "0";
	if optimization_level == "1" {
		options.optimization_level = 1;
	} else if optimization_level == "2" {
		options.optimization_level = 2;
	} else if optimization_level == "3" {
		options.optimization_level = 3;
	} else if optimization_level == "s" {
		options.optimization_level = 4;
	} else if optimization_level == "z" {
		options.optimization_level = 5;
	}

	if args_parser.flag("s", "strip-symbols", "strip symbols") ?? false {
		options.symbol_type = None;
	}

	if args_parser.flag("b", "bitcode", "generate llvm bitcode") ?? false {
		options.output_type = LLVMBitcode;
	}

	if args_parser.flag("S", "emit-llvm", "generate llvm ir") ?? false {
		options.output_type = LLVMAssembly;
	}

	var library = args_parser.value("l", "link-library", "library to link against");
	while library.hasValue() {
		options.link_libraries.append(library.value());
		library = args_parser.value("l", "link-library", "library to link against");
	}

	match args_parser.anonymous("path to the root module file") {
		case Some: value -> options.root_module_path = value;
		else -> {
			eprintln("no root module specified");
			return None;
		}
	}

	options.secondary_args = args_parser.getArgsAfterSeparator();

	const path = options.root_module_path;
	if !path.endsWith(".vd") || path.size() <= 3 {
		eprintln("invalid source file");
		return None;
	}

	if options.program_name == "" {
		var name_begin: uint;
		match path.rfind('/'b) {
			case Some: index -> name_begin = index + 1;
			else -> name_begin = 0;
		}

		const name_end = path.rfind('.'b) ?? path.size();
		options.program_name = path.substring(name_begin..name_end);
	}

	options.install_path = ".";
	const compiler_binary_path = Path::getExePath();
	if const compiler_binary_dir = compiler_binary_path.parentDir() {
		if const compiler_install_dir = compiler_binary_dir.parentDir() {
			options.import_search_paths.append(compiler_install_dir);
			options.install_path = compiler_install_dir.toString();
		}
	}

	options.import_search_paths.append(Path::cwd());

	const absolute_root_module_path = Path::cwd() / Path(options.root_module_path);
	if const root_module_dir = absolute_root_module_path.parentDir() {
		options.import_search_paths.append(root_module_dir);
	}

	return Some(options);
}

func main(args: Range!<String>) -> int {
	const options = parseArguments(args) else {
		return 1;
	}

	if !Path(options.build_dir).isDirectory() {
		const mkdir_cmd = "mkdir -p " + options.build_dir + '\0'b;
		discard system(mkdir_cmd.data());
	}

	var program: Program = (options);
	typecheck(&&program);

	if options.dump_program {
		print(program.dump());
	}

	match options.mode {
		case Check -> return 1 if program.has_errors else 0;
		case Run -> {
			if program.has_errors {
				return 1;
			}

			var main_args: List!<String>;
			var main_env: List!<String>;

			main_args.append(options.program_name);
			main_args.append(options.secondary_args);

			return program.runMainFunction(main_args, main_env);
		}
		case Compile -> {
			const assembly_path = match options.output_type {
				case LLVMAssembly -> yield program.printLLVMIRToFile();
				case LLVMBitcode -> yield program.writeLLVMBitcodeToFile();
			}

			if program.has_errors || assembly_path is None {
				return 1;
			}

			if options.codegen_only {
				return 0;
			}

			var clang_command = "clang " + assembly_path.value();
			clang_command += " -o " + options.getOutputBinaryPath();
			clang_command += " -lc -lm";

			for lib in options.link_libraries {
				clang_command += " -l" + lib;
			}

			if options.symbol_type == None {
				clang_command += " -s";
			}

			if options.generate_debug_info {
				clang_command += " -g";
			}

			clang_command += " " + options.getOptimizationLevelAsClangArg();

			if !options.secondary_args.isEmpty() {
				clang_command += " " + " ".join(options.secondary_args);
			}

			clang_command += "\0";
			return system(clang_command.data()) as int;
		}
	}
}
