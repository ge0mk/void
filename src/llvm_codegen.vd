import std/core;
import std/format;
import std/list;
import std/io;
import std/map;
import std/shared_list;
import std/string;

import error;
import llvm_c;
import llvm_util;
import program;
import span;

struct CGContext {
	var program: &&Program;
	var llvm_context: LLVMContextRef;
	var llvm_module: LLVMModuleRef;
	var data_layout: LLVMTargetDataRef;
	var di_builder: LLVMDIBuilderRef;

	var current_di_scope: LLVMMetadataRef;

	var void_type: LLVMTypeRef;
	var bool_type: LLVMTypeRef;
	var byte_type: LLVMTypeRef;
	var int_type: LLVMTypeRef;
	var ptr_type: LLVMTypeRef;

	var builder: LLVMBuilderRef;
	var current_function: LLVMValueRef;
	var current_function_decl: SharedHandle!<FunctionDecl>;
	var variables: Map!<SharedHandle!<VarDecl>, LLVMValueRef>;

	var break_target: LLVMBasicBlockRef;
	var continue_target: LLVMBasicBlockRef;
	var yield_target: LLVMBasicBlockRef;

	func constructor(this: &&CGContext, program: &&Program) -> void {
		this.program := &&program;
		this.llvm_context := program.llvm_context;
		this.llvm_module := program.llvm_module;
		this.data_layout := program.data_layout;
		this.di_builder := program.di_builder;

		this.void_type := LLVMVoidTypeInContext(this.llvm_context);
		this.bool_type := LLVMIntTypeInContext(this.llvm_context, 1u);
		this.byte_type := LLVMIntTypeInContext(this.llvm_context, 8u);
		this.int_type := LLVMIntTypeInContext(this.llvm_context, LLVMPointerSize(this.data_layout) as uint * 8);
		this.ptr_type := LLVMPointerTypeInContext(this.llvm_context, 0u);
	}

	func destructor(this: &&CGContext) -> void = default;

	func error(this: &CGContext, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Error, ErrorStage::CodeGenerator, span));
	}

	func info(this: &CGContext, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Info, ErrorStage::CodeGenerator, span));
	}

	func todo(this: &CGContext, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Todo, ErrorStage::CodeGenerator, span));
	}

	func getASTNode(this: &&CGContext, id: uint) -> Node {
		return this.current_function_decl.parent_namespace.file.nodes[id];
	}

	func getType(this: &&CGContext, type: Type) -> LLVMTypeRef {
		if type.isUnknown() {
			return this.void_type;
		}

		match type.reference_kind {
			case None -> {
				if type.decl.llvm_type == LLVMTypeRef::null() {
					this.codegenType(type.decl);

					if type.decl.llvm_type == LLVMTypeRef::null() {
						panic("invalid codegen for type '" + type.signature() + "'");
					}
				}

				return type.decl.llvm_type;
			}
			else -> return this.ptr_type;
		}
	}

	func getDIType(this: &&CGContext, type: Type) -> LLVMMetadataRef {
		if type.decl.llvm_di == LLVMMetadataRef::null() {
			this.codegenTypeDI(type.decl);

			if type.decl.llvm_di == LLVMMetadataRef::null() {
				panic("invalid debug info for type '" + type.signature() + "'");
			}
		}

		if type.reference_kind == None {
			return type.decl.llvm_di;
		} else {
			return LLVMDIBuilderCreateReferenceType(this.di_builder, DWARFTag::Tag_reference_type, type.decl.llvm_di);
		}
	}

	func getFunction(this: &&CGContext, function: SharedHandle!<FunctionDecl>) -> LLVMValueRef {
		if function.llvm_func != LLVMValueRef::null() {
			return function.llvm_func;
		}

		this.codegenFunctionDecl(function);
		this.codegenFunctionBody(function);
		return function.llvm_func;
	}

	func getVariable(this: &CGContext, variable: SharedHandle!<VarDecl>) -> LLVMValueRef {
		const impl = this.variables.get(variable) else {
			panic("invalid codegen for variable '" + variable.name + "'");
		}

		return impl;
	}

	func getDebugLocation(this: &&CGContext, span: Span) -> LLVMMetadataRef {
		return LLVMDIBuilderCreateDebugLocation(this.llvm_context, span.line as uint + 1, span.column as uint + 1, this.current_di_scope);
	}

	func setCurrentDebugLocation(this: &&CGContext, span: Span) -> void {
		if this.program.options.generate_debug_info {
			LLVMSetCurrentDebugLocation2(this.builder, this.getDebugLocation(span));
		}
	}

	func getTypeName(this: &CGContext, type: SharedHandle!<TypeDecl>) -> String {
		var name = "";
		match this.program.options.symbol_type {
			case None -> {}
			case Name -> name = type.name;
			case Full -> name = type.signature();
		}

		return name;
	}

	func codegenType(this: &&CGContext, type: SharedHandle!<TypeDecl>) -> void {
		if type.isIncompleteTemplate() || type.llvm_type != LLVMTypeRef::null() {
			return;
		}

		const name = this.getTypeName(type);

		match type.body {
			case Empty -> type.llvm_type = this.void_type;
			case Void -> type.llvm_type = this.void_type;
			case Bool -> type.llvm_type = this.bool_type;
			case Byte -> type.llvm_type = this.byte_type;
			case Int: bits -> {
				if bits == 0 {
					type.llvm_type = this.int_type;
				} else {
					type.llvm_type = LLVMIntTypeInContext(this.llvm_context, bits);
				}
			}
			case UInt: bits -> {
				if bits == 0 {
					type.llvm_type = this.int_type;
				} else {
					type.llvm_type = LLVMIntTypeInContext(this.llvm_context, bits);
				}
			}
			case Float: bits -> match bits {
				case 32 -> type.llvm_type = LLVMFloatTypeInContext(this.llvm_context);
				case 64 -> type.llvm_type = LLVMDoubleTypeInContext(this.llvm_context);
				else -> this.error("invalid size for float type: " + format(bits), type.span);
			}
			case Pointer | Function -> type.llvm_type = this.ptr_type;
			case Vector: vector_type -> type.llvm_type = LLVMVectorType(this.getType(vector_type.element_type), vector_type.size);
			case Array: array_type -> type.llvm_type = LLVMArrayType(this.getType(array_type.element_type), array_type.size);
			case Range | RangeIterator | NumericRange | NumericIterator | Tuple | Struct -> {
				type.llvm_type = LLVMStructCreateNamed(this.llvm_context, name);

				var element_types: List!<LLVMTypeRef>;
				for member_variable in type.member_variables {
					element_types.append(this.getType(member_variable.type));
				}

				LLVMStructSetBody(type.llvm_type, element_types, type.is_packed);
			}
			case Enum -> type.llvm_type = this.getType(type.id_type);
			case Variant -> {
				type.llvm_type = LLVMStructCreateNamed(this.llvm_context, name);

				var element_types: List!<LLVMTypeRef>;
				element_types.append(this.getType(type.id_type));

				var max_size = 0u;
				var max_alignment = 1u;

				for case_decl in type.variant_cases {
					if case_decl.type == this.program.void_type {
						continue;
					}

					var case_type = this.getType(case_decl.type);

					const current_size = LLVMStoreSizeOfType(this.data_layout, case_type) as uint;
					if current_size > max_size {
						max_size = current_size;
					}

					const current_alignment = LLVMPreferredAlignmentOfType(this.data_layout, case_type) as uint;
					if current_alignment > max_alignment {
						max_alignment = current_alignment;
					}
				}

				const max_alignment_type = LLVMIntTypeInContext(this.llvm_context, max_alignment * 8);
				element_types.append(LLVMArrayType(max_alignment_type, max_size / max_alignment));

				for member_variable in type.member_variables {
					element_types.append(this.getType(member_variable.type));
				}

				LLVMStructSetBody(type.llvm_type, element_types, type.is_packed);
			}
			case Unchecked -> panic("can't codegen unchecked type");
		}
	}

	func codegenTypeDI(this: &&CGContext, type: SharedHandle!<TypeDecl>) -> void {
		if type.isIncompleteTemplate() || type.llvm_di != LLVMMetadataRef::null() {
			return;
		}

		const line = type.name_span.line as uint;
		const di_file = this.program.files[type.span.file as uint].llvm_di_file;
		const parent_namespace = type.parent_namespace.llvm_di;

		const llvm_type = this.getType(Type(type));

		var size_in_bits = 0u;
		if llvm_type != this.void_type {
			size_in_bits = LLVMStoreSizeOfType(this.data_layout, llvm_type) as uint * 8;
		}

		var alignment_in_bits = 0u;
		if llvm_type != this.void_type {
			alignment_in_bits = LLVMPreferredAlignmentOfType(this.data_layout, llvm_type) as uint * 8;
		}

		const type_scope = type.linked_namespace.llvm_di;
		const di_name = type.name + type.template_parameters.format();

		match type.body {
			case Empty -> type.llvm_di = LLVMDIBuilderCreateUnspecifiedType(this.di_builder, di_name);
			case Void -> type.llvm_di = LLVMDIBuilderCreateBasicType(this.di_builder, di_name, size_in_bits, 0 as DWARFTypeEncoding, LLVMDIFlags::LLVMDIFlagZero);
			case Bool -> type.llvm_di = LLVMDIBuilderCreateBasicType(this.di_builder, di_name, size_in_bits, DWARFTypeEncoding::Type_boolean, LLVMDIFlags::LLVMDIFlagZero);
			case Byte -> type.llvm_di = LLVMDIBuilderCreateBasicType(this.di_builder, di_name, size_in_bits, DWARFTypeEncoding::Type_unsigned_char, LLVMDIFlags::LLVMDIFlagZero);
			case Int -> type.llvm_di = LLVMDIBuilderCreateBasicType(this.di_builder, di_name, size_in_bits, DWARFTypeEncoding::Type_signed, LLVMDIFlags::LLVMDIFlagZero);
			case UInt -> type.llvm_di = LLVMDIBuilderCreateBasicType(this.di_builder, di_name, size_in_bits, DWARFTypeEncoding::Type_unsigned, LLVMDIFlags::LLVMDIFlagZero);
			case Float -> type.llvm_di = LLVMDIBuilderCreateBasicType(this.di_builder, di_name, size_in_bits, DWARFTypeEncoding::Type_float, LLVMDIFlags::LLVMDIFlagZero);
			case Pointer: pointer_type -> {
				type.llvm_di = LLVMDIBuilderCreateReplaceableCompositeType(this.di_builder, DWARFTag::Tag_unspecified_type, di_name, parent_namespace, di_file, line, 0u32, size_in_bits, alignment_in_bits, LLVMDIFlags::LLVMDIFlagZero, type.signature());

				const pointee_type = match pointer_type.pointee_type.isUnknown() {
					case true -> yield this.getDIType(this.program.void_type);
					case false -> yield this.getDIType(pointer_type.pointee_type);
				};

				const di_type = LLVMDIBuilderCreatePointerType(this.di_builder, pointee_type, size_in_bits, alignment_in_bits, 0u, di_name);

				LLVMMetadataReplaceAllUsesWith(type.llvm_di, di_type);
				type.llvm_di = di_type;
			}
			case Function: function_type -> {
				var di_return_and_parameter_types: List!<LLVMMetadataRef>;

				di_return_and_parameter_types.append(this.getDIType(function_type.return_type));
				for parameter_type in function_type.parameter_types {
					di_return_and_parameter_types.append(this.getDIType(parameter_type));
				}

				type.llvm_di = LLVMDIBuilderCreatePointerType(this.di_builder, LLVMDIBuilderCreateSubroutineType(
					this.di_builder,
					this.program.files[type.span.file as uint].llvm_di_file,
					di_return_and_parameter_types,
					LLVMDIFlags::LLVMDIFlagZero
				), size_in_bits, alignment_in_bits, 0u, di_name);
			}
			case Vector: vector_type -> {
				type.llvm_di = LLVMDIBuilderCreateReplaceableCompositeType(this.di_builder, DWARFTag::Tag_unspecified_type, di_name, parent_namespace, di_file, line, 0u32, size_in_bits, alignment_in_bits, LLVMDIFlags::LLVMDIFlagZero, type.signature());
				const di_type = LLVMDIBuilderCreateVectorType(this.di_builder, vector_type.size, alignment_in_bits, this.getDIType(vector_type.element_type), List!<LLVMMetadataRef>());
				LLVMMetadataReplaceAllUsesWith(type.llvm_di, di_type);
				type.llvm_di = di_type;
			}
			case Array: array_type -> {
				type.llvm_di = LLVMDIBuilderCreateReplaceableCompositeType(this.di_builder, DWARFTag::Tag_unspecified_type, di_name, parent_namespace, di_file, line, 0u32, size_in_bits, alignment_in_bits, LLVMDIFlags::LLVMDIFlagZero, type.signature());
				const di_type = LLVMDIBuilderCreateArrayType(this.di_builder, array_type.size, alignment_in_bits, this.getDIType(array_type.element_type), List!<LLVMMetadataRef>());
				LLVMMetadataReplaceAllUsesWith(type.llvm_di, di_type);
				type.llvm_di = di_type;
			}
			case Range | RangeIterator | NumericRange | NumericIterator
			| Tuple | Struct | Variant -> {
				type.llvm_di = LLVMDIBuilderCreateReplaceableCompositeType(this.di_builder, DWARFTag::Tag_unspecified_type, di_name, parent_namespace, di_file, line, 0u32, size_in_bits, alignment_in_bits, LLVMDIFlags::LLVMDIFlagZero, type.signature());

				var members: List!<LLVMMetadataRef>;

				if type.body is Variant {
					var cases: List!<LLVMMetadataRef>;
					var payload_members: List!<LLVMMetadataRef>;
					for c in type.variant_cases {
						cases.append(LLVMDIBuilderCreateEnumerator(this.di_builder, c.name, c.id, true));

						if c.type == this.program.void_type {
							continue;
						}

						payload_members.append(LLVMDIBuilderCreateMemberType(
							this.di_builder,
							type_scope,
							c.name,
							di_file,
							c.span.line as uint,
							LLVMStoreSizeOfType(this.data_layout, this.getType(c.type)) as uint * 8,
							LLVMPreferredAlignmentOfType(this.data_layout, this.getType(c.type)) as uint * 8,
							0u,
							LLVMDIFlags::LLVMDIFlagZero,
							this.getDIType(c.type)
						));
					}

					const id_size_in_bits = LLVMStoreSizeOfType(this.data_layout, this.getType(type.id_type)) as uint * 8;
					const id_alignment_in_bits = LLVMPreferredAlignmentOfType(this.data_layout, this.getType(type.id_type)) as uint * 8;
					const id_offset_in_bits = LLVMOffsetOfElement(this.data_layout, llvm_type, 0u) * 8;
					const id_type = LLVMDIBuilderCreateEnumerationType(this.di_builder, parent_namespace, di_name + "::Id", di_file, line, id_size_in_bits, id_alignment_in_bits, cases, this.getDIType(type.id_type));
					members.append(LLVMDIBuilderCreateMemberType(
						this.di_builder,
						type_scope,
						"#id",
						di_file,
						line,
						id_size_in_bits,
						id_alignment_in_bits,
						id_offset_in_bits,
						LLVMDIFlags::LLVMDIFlagZero,
						id_type
					));

					const payload_type_impl = LLVMStructGetTypeAtIndex(llvm_type, 1u);
					const payload_size_in_bits = LLVMStoreSizeOfType(this.data_layout, payload_type_impl) as uint * 8;
					const payload_alignment_in_bits = LLVMPreferredAlignmentOfType(this.data_layout, payload_type_impl) as uint * 8;
					const payload_offset_in_bits = LLVMOffsetOfElement(this.data_layout, llvm_type, 1u) * 8;
					const payload_type = LLVMDIBuilderCreateUnionType(this.di_builder, type_scope, di_name + "::Payload", di_file, line, payload_size_in_bits, payload_alignment_in_bits, LLVMDIFlags::LLVMDIFlagZero, payload_members, 0u32, type.signature() + "::Payload");
					members.append(LLVMDIBuilderCreateMemberType(
						this.di_builder,
						type_scope,
						"#payload",
						di_file,
						line,
						payload_size_in_bits,
						payload_alignment_in_bits,
						payload_offset_in_bits,
						LLVMDIFlags::LLVMDIFlagZero,
						payload_type
					));
				}

				for i in 0u..type.member_variables.size() {
					const member_variable = type.member_variables[i];
					const member_type = this.getType(member_variable.type);
					if member_type == this.void_type {
						continue;
					}

					const member_di_type = this.getDIType(member_variable.type);

					const member_size_in_bits = LLVMStoreSizeOfType(this.data_layout, llvm_type) as uint * 8;
					const member_alignment_in_bits = LLVMPreferredAlignmentOfType(this.data_layout, llvm_type) as uint * 8;
					const member_offset_in_bits = LLVMOffsetOfElement(this.data_layout, llvm_type, i + (2u if type.body is Variant else 0u)) * 8;

					members.append(LLVMDIBuilderCreateMemberType(
						this.di_builder,
						type_scope,
						member_variable.name,
						di_file,
						member_variable.span.line as uint,
						member_size_in_bits,
						member_alignment_in_bits,
						member_offset_in_bits,
						LLVMDIFlags::LLVMDIFlagZero,
						member_di_type
					));
				}

				const di_type = LLVMDIBuilderCreateStructType(
					this.di_builder,
					parent_namespace,
					di_name,
					di_file,
					line,
					size_in_bits,
					alignment_in_bits,
					LLVMDIFlags::LLVMDIFlagZero,
					LLVMMetadataRef(),
					members,
					0u32,
					LLVMMetadataRef(),
					type.signature()
				);

				LLVMMetadataReplaceAllUsesWith(type.llvm_di, di_type);
				type.llvm_di = di_type;
			}
			case Enum -> {
				type.llvm_di = LLVMDIBuilderCreateReplaceableCompositeType(this.di_builder, DWARFTag::Tag_unspecified_type, di_name, parent_namespace, di_file, line, 0u32, size_in_bits, alignment_in_bits, LLVMDIFlags::LLVMDIFlagZero, type.signature());

				var cases: List!<LLVMMetadataRef>;
				for c in type.enum_cases {
					cases.append(LLVMDIBuilderCreateEnumerator(this.di_builder, c.name, c.id, true));
				}

				const di_type = LLVMDIBuilderCreateEnumerationType(this.di_builder, parent_namespace, di_name, di_file, line, size_in_bits, alignment_in_bits, cases, this.getDIType(type.id_type));

				LLVMMetadataReplaceAllUsesWith(type.llvm_di, di_type);
				type.llvm_di = di_type;
			}
			case Unchecked -> panic("can't codegen unchecked type");
		}
	}

	func codegenFunctionDecl(this: &&CGContext, function: SharedHandle!<FunctionDecl>) -> void {
		if function.isIncompleteTemplate() || function.llvm_func != LLVMValueRef::null() {
			return;
		}

		var return_type = this.getType(function.return_type);
		var parameter_types: List!<LLVMTypeRef>;

		if function == this.program.main_function {
			parameter_types.append(this.ptr_type);
			parameter_types.append(this.int_type);
			return_type = this.int_type;
		} else {
			for type in function.parameter_types {
				parameter_types.append(this.getType(type));
			}
		}

		const function_type = LLVMFunctionType(return_type, parameter_types, false);
		function.llvm_type = function_type;

		var name = "";
		match this.program.options.symbol_type {
			case None -> {}
			case Name -> name = function.name;
			case Full -> name = function.signature();
		}

		if function.extern_name != "" {
			name = function.extern_name;
		} else if function == this.program.main_function {
			name = "void_main";
		}

		function.llvm_func = LLVMAddFunction(this.llvm_module, name, function_type);
	}

	func codegenFunctionBody(this: &&CGContext, function: SharedHandle!<FunctionDecl>) -> void {
		if function.isIncompleteTemplate() || function.has_errors {
			return;
		}

		match function.body {
			case Empty | Extern -> return;
			case Unchecked -> {
				this.error("unchecked function: " + function.signature(), function.signature_span);
				return;
			}
			else -> {}
		}

		if function.llvm_func == LLVMValueRef::null() {
			this.error("function decl for " + function.signature() + " not yet built", function.signature_span);
			return;
		}

		if LLVMCountBasicBlocks(function.llvm_func) > 0 {
			this.error("function body for " + function.signature() + " already built", function.signature_span);
			return;
		}

		const prev_di_scope = this.current_di_scope;
		const prev_builder = this.builder;
		const prev_function = this.current_function;
		const prev_function_decl = this.current_function_decl;
		const prev_variables = this.variables;

		this.variables.clear();
		this.current_function = function.llvm_func;
		this.current_function_decl = function;

		// setup debug info for the function
		if this.program.options.generate_debug_info {
			var di_return_and_parameter_types: List!<LLVMMetadataRef>;

			di_return_and_parameter_types.append(this.getDIType(function.return_type));
			for parameter_type in function.parameter_types {
				di_return_and_parameter_types.append(this.getDIType(parameter_type));
			}

			const di_function_type = LLVMDIBuilderCreateSubroutineType(
				this.di_builder,
				this.program.files[function.span.file as uint].llvm_di_file,
				di_return_and_parameter_types,
				LLVMDIFlags::LLVMDIFlagZero
			);

			const di_namespace = function.parent_namespace.llvm_di;
			const di_name = function.name + function.template_parameters.format();

			function.llvm_di = LLVMDIBuilderCreateFunction(
				this.di_builder,
				di_namespace,
				di_name,
				function.extern_name,
				this.program.files[function.span.file as uint].llvm_di_file,
				function.signature_span.line as uint + 1,
				di_function_type,
				false, 		// is local to unit
				true,		// is definition
				function.signature_span.line as uint + 1,
				LLVMDIFlags::LLVMDIFlagZero,
				this.program.options.optimization_level != 0
			);

			LLVMSetSubprogram(function.llvm_func, function.llvm_di);
			this.current_di_scope = function.llvm_di;
		}

		this.builder = LLVMCreateBuilderInContext(this.llvm_context);
		const entry_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "");
		LLVMPositionBuilderAtEnd(this.builder, entry_block);

		// initialize function parameters & variables
		if function.body is Stmt {
			for variable in function.variables {
				if variable.type.isUnknown() {
					this.error("variable '" + variable.name + "' has unknown type", variable.span);
					continue;
				}

				if variable.is_parameter {
					if function == this.program.main_function {
						var args = LLVMConstNull(this.getType(function.parameter_types[0u]));
						args = LLVMBuildInsertValue(this.builder, args, LLVMGetParam(this.current_function, 0u), 0u, "");
						args = LLVMBuildInsertValue(this.builder, args, LLVMGetParam(this.current_function, 1u), 1u, "");
						this.variables.set(variable, args);
					} else {
						const parameter = LLVMGetParam(this.current_function, variable.id);
						this.variables.set(variable, parameter);

						if this.program.options.generate_debug_info {
							const di_variable = LLVMDIBuilderCreateParameterVariable(
								this.di_builder,
								this.current_di_scope,
								variable.name,
								variable.id + 1, // ArgNo starts counting at 1
								this.program.files[function.span.file as uint].llvm_di_file,
								variable.span.line as uint,
								this.getDIType(variable.type),
								false,
								LLVMDIFlags::LLVMDIFlagZero
							);

							discard LLVMDIBuilderInsertDeclareAtEnd(
								this.di_builder,
								parameter,
								di_variable,
								LLVMDIBuilderCreateExpression(this.di_builder, ptr!<u64, true>::null(), 0u),
								this.getDebugLocation(variable.span),
								entry_block
							);
						}
					}
				} else {
					this.setCurrentDebugLocation(variable.span);
					const address = LLVMBuildAlloca(this.builder, this.getType(variable.type), variable.name);
					this.variables.set(variable, address);

					if this.program.options.generate_debug_info {
						var alignment_in_bits = LLVMPreferredAlignmentOfType(this.data_layout, this.getType(variable.type)) as uint * 8;

						const di_variable = LLVMDIBuilderCreateAutoVariable(
							this.di_builder,
							this.current_di_scope,
							variable.name,
							this.program.files[function.span.file as uint].llvm_di_file,
							variable.span.line as uint,
							this.getDIType(variable.type),
							false,
							LLVMDIFlags::LLVMDIFlagZero,
							alignment_in_bits
						);

						discard LLVMDIBuilderInsertDeclareAtEnd(
							this.di_builder,
							address,
							di_variable,
							LLVMDIBuilderCreateExpression(this.di_builder, ptr!<u64, true>::null(), 0u),
							this.getDebugLocation(variable.span),
							entry_block
						);
					}

					LLVMSetCurrentDebugLocation2(this.builder, LLVMMetadataRef());
				}
			}
		}

		// codegen body
		match function.body {
			case Builtin: builtin_function -> this.codegenBuiltinFunction(builtin_function, function.signature_span);
			case Stmt: &stmt -> discard this.codegenNode(this.getASTNode(stmt));
			else -> panic("invalid function body for codegen");
		}

		if !LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) {
			if function == this.program.main_function {
				discard LLVMBuildRet(this.builder, LLVMConstInt(this.int_type, 0, false));
			} else if function.return_type == this.program.void_type {
				discard LLVMBuildRetVoid(this.builder);
			} else {
				this.error("function doesn't have a terminator", function.signature_span);
			}
		}

		if this.program.options.generate_debug_info {
			LLVMDIBuilderFinalizeSubprogram(this.di_builder, function.llvm_di);
		}

		LLVMDisposeBuilder(this.builder)

		this.current_di_scope = prev_di_scope;
		this.builder = prev_builder;
		this.current_function = prev_function;
		this.current_function_decl = prev_function_decl;
		this.variables = prev_variables;
	}

	func codegenBuiltinFunction(this: &&CGContext, function: BuiltinFunction, signature_span: Span) -> void {
		const type = this.getType(function.base_type);
		const decl = function.base_type.decl;

		const param0 = LLVMGetParam(this.current_function, 0u);
		const param1 = LLVMGetParam(this.current_function, 1u);

		match function {
			case Empty -> panic("empty builtin function");
			case StructValueConstructor -> {
				for i in 0u..decl.member_variables.size() {
					const member_ptr = LLVMBuildStructGEP2(this.builder, type, param0, i, "");
					const member_type = decl.member_variables[i].type.decl;

					var parameters: List!<LLVMValueRef>;
					parameters.append(member_ptr);
					parameters.append(LLVMGetParam(this.current_function, i + 1));

					discard this.codegenCall(member_type.copy_constructor, parameters, ReturnKind::None, signature_span);
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case StructDefaultConstructor -> {
				for i in 0u..decl.member_variables.size() {
					const member_ptr = LLVMBuildStructGEP2(this.builder, type, param0, i, "");
					const member_type = decl.member_variables[i].type.decl;

					var parameters: List!<LLVMValueRef>;
					parameters.append(member_ptr);

					discard this.codegenCall(member_type.default_constructor, parameters, ReturnKind::None, signature_span);
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case StructCopyConstructor -> {
				for i in 0u..decl.member_variables.size() {
					const member_ptr = LLVMBuildStructGEP2(this.builder, type, param0, i, "");
					const initializer = LLVMBuildExtractValue(this.builder, param1, i, "");

					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;

						var parameters: List!<LLVMValueRef>;
						parameters.append(member_ptr);
						parameters.append(initializer);

						discard this.codegenCall(member_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						discard LLVMBuildStore(this.builder, initializer, member_ptr);
					}
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case StructDestructor -> {
				for i in 0u..decl.member_variables.size() {
					if decl.member_variables[i].type.reference_kind != None {
						continue;
					}

					const member_ptr = LLVMBuildStructGEP2(this.builder, type, param0, i, "");
					const member_type = decl.member_variables[i].type.decl;

					var parameters: List!<LLVMValueRef>;
					parameters.append(member_ptr);

					discard this.codegenCall(member_type.destructor, parameters, ReturnKind::None, signature_span);
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case StructOpAssign -> {
				for i in 0u..decl.member_variables.size() {
					const member_ptr = LLVMBuildStructGEP2(this.builder, type, param0, i, "");
					const initializer = LLVMBuildExtractValue(this.builder, param1, i, "");

					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;

						var parameters: List!<LLVMValueRef>;
						parameters.append(member_ptr);
						parameters.append(initializer);

						discard this.codegenCall(member_type.op_assign, parameters, ReturnKind::None, signature_span);
					} else {
						discard LLVMBuildStore(this.builder, initializer, member_ptr);
					}
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case VariantCaseConstructor: case_id -> {
				const id_type = this.getType(decl.id_type);
				const id_ptr = LLVMBuildStructGEP2(this.builder, type, param0, 0u, "");
				discard LLVMBuildStore(this.builder, LLVMConstInt(id_type, case_id, false), id_ptr);

				const this_payload_ptr = LLVMBuildStructGEP2(this.builder, type, param0, 1u, "");
				discard LLVMBuildStore(this.builder, LLVMConstNull(LLVMStructGetTypeAtIndex(type, 1u32)), this_payload_ptr);

				var member_var_param_offset = 1u;	// first param is this

				const case_decl = decl.getVariantCase(case_id).value();
				if case_decl.type != this.program.void_type {
					member_var_param_offset += 1;	// payload is passed before member variables
					const initializer = param1;
					if case_decl.type.reference_kind == None {
						const case_type = case_decl.type.decl;

						var parameters: List!<LLVMValueRef>;
						parameters.append(this_payload_ptr);
						parameters.append(initializer);

						discard this.codegenCall(case_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						discard LLVMBuildStore(this.builder, initializer, this_payload_ptr);
					}
				}

				for i in 0u..decl.member_variables.size() {
					const this_member_ptr = LLVMBuildStructGEP2(this.builder, type, param0, i + 2, "");
					const initializer = LLVMGetParam(this.current_function, i + member_var_param_offset);

					if decl.member_variables[i].type.reference_kind == None {
						var parameters: List!<LLVMValueRef>;
						parameters.append(this_member_ptr);
						parameters.append(initializer);

						const member_type = decl.member_variables[i].type.decl;

						discard this.codegenCall(member_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						discard LLVMBuildStore(this.builder, initializer, this_member_ptr);
					}
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case VariantCopyConstructor -> {
				const id_type = this.getType(decl.id_type);
				const id_ptr = LLVMBuildStructGEP2(this.builder, type, param0, 0u, "");
				const this_payload_ptr = LLVMBuildStructGEP2(this.builder, type, param0, 1u, "");

				const other_payload_ptr = LLVMBuildAlloca(this.builder, LLVMStructGetTypeAtIndex(type, 1u), "");
				discard LLVMBuildStore(this.builder, LLVMBuildExtractValue(this.builder, param1, 1u, ""), other_payload_ptr);

				const other_id = LLVMBuildExtractValue(this.builder, param1, 0u, "");
				discard LLVMBuildStore(this.builder, other_id, id_ptr);

				discard LLVMBuildStore(this.builder, LLVMConstNull(LLVMStructGetTypeAtIndex(type, 1u32)), this_payload_ptr);

				const cont_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "cont");

				var case_count = 0u;
				for case_decl in decl.variant_cases {
					if case_decl.type != this.program.void_type {
						case_count++;
					}
				}

				var switch_instr = LLVMBuildSwitch(this.builder, other_id, cont_block, case_count);

				for case_decl in decl.variant_cases {
					if case_decl.type == this.program.void_type {
						continue;
					}

					const case_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "case");
					LLVMAddCase(switch_instr, LLVMConstInt(id_type, case_decl.id, false), case_block);
					LLVMPositionBuilderAtEnd(this.builder, case_block);

					const other_payload = LLVMBuildLoad2(this.builder, this.getType(case_decl.type), other_payload_ptr, "");

					if case_decl.type.reference_kind == None {
						const case_type = case_decl.type.decl;
						var parameters: List!<LLVMValueRef>;
						parameters.append(this_payload_ptr);
						parameters.append(other_payload);

						discard this.codegenCall(case_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						discard LLVMBuildStore(this.builder, other_payload, this_payload_ptr);
					}

					discard LLVMBuildBr(this.builder, cont_block);
				}

				LLVMPositionBuilderAtEnd(this.builder, cont_block);

				for i in 0u..decl.member_variables.size() {
					const this_member_ptr = LLVMBuildStructGEP2(this.builder, type, param0, i + 2, "");
					const other_member = LLVMBuildExtractValue(this.builder, param1, i + 2, "");

					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;

						var parameters: List!<LLVMValueRef>;
						parameters.append(this_member_ptr);
						parameters.append(other_member);

						discard this.codegenCall(member_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						discard LLVMBuildStore(this.builder, other_member, this_member_ptr);
					}
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case VariantDestructor -> {
				const id_type = this.getType(decl.id_type);
				const id_ptr = LLVMBuildStructGEP2(this.builder, type, param0, 0u, "");
				const this_id = LLVMBuildLoad2(this.builder, id_type, id_ptr, "");
				const this_payload_ptr = LLVMBuildStructGEP2(this.builder, type, param0, 1u, "");

				var case_destructor_args: List!<LLVMValueRef>;
				case_destructor_args.append(this_payload_ptr);

				const cont_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "cont");

				var case_count = 0u;
				for case_decl in decl.variant_cases {
					if case_decl.type != this.program.void_type && case_decl.type.reference_kind == None {
						case_count++;
					}
				}
				var switch_instr = LLVMBuildSwitch(this.builder, this_id, cont_block, case_count);

				for case_decl in decl.variant_cases {
					if case_decl.type == this.program.void_type || case_decl.type.reference_kind != None {
						continue;
					}

					const case_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "case");
					LLVMAddCase(switch_instr, LLVMConstInt(id_type, case_decl.id, false), case_block);
					LLVMPositionBuilderAtEnd(this.builder, case_block);

					const case_type = case_decl.type.decl;

					discard this.codegenCall(case_type.destructor, case_destructor_args, ReturnKind::None, signature_span);

					discard LLVMBuildBr(this.builder, cont_block);
				}

				LLVMPositionBuilderAtEnd(this.builder, cont_block);

				for i in 0u..decl.member_variables.size() {
					if decl.member_variables[i].type.reference_kind != None {
						continue;
					}

					const member_type = decl.member_variables[i].type.decl;

					var parameters: List!<LLVMValueRef>;
					parameters.append(LLVMBuildStructGEP2(this.builder, type, param0, i + 2, ""));

					discard this.codegenCall(member_type.destructor, parameters, ReturnKind::None, signature_span);
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case VariantOpAssign -> {
				const id_type = this.getType(decl.id_type);
				const payload_type = LLVMStructGetTypeAtIndex(type, 1u);

				const id_ptr = LLVMBuildStructGEP2(this.builder, type, param0, 0u, "");
				const this_id = LLVMBuildLoad2(this.builder, id_type, id_ptr, "");
				const this_payload_ptr = LLVMBuildStructGEP2(this.builder, type, param0, 1u, "");

				const other_payload_ptr = LLVMBuildAlloca(this.builder, payload_type, "");
				discard LLVMBuildStore(this.builder, LLVMBuildExtractValue(this.builder, param1, 1u, ""), other_payload_ptr);
				const other_id = LLVMBuildExtractValue(this.builder, param1, 0u, "");

				const payload_copy_ptr = LLVMBuildAlloca(this.builder, LLVMStructGetTypeAtIndex(type, 1u), "");

				var copy_case_count = 0u;
				var dest_case_count = 0u;
				for case_decl in decl.variant_cases {
					if case_decl.type != this.program.void_type {
						copy_case_count++;

						if case_decl.type.reference_kind == None {
							dest_case_count++;
						}
					}
				}

				// copy payload to temporary
				const dest_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "cont");

				var copy_switch_instr = LLVMBuildSwitch(this.builder, other_id, dest_block, copy_case_count);

				for case_decl in decl.variant_cases {
					if case_decl.type == this.program.void_type {
						continue;
					}

					const case_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "case");
					LLVMAddCase(copy_switch_instr, LLVMConstInt(id_type, case_decl.id, false), case_block);
					LLVMPositionBuilderAtEnd(this.builder, case_block);

					const other_payload = LLVMBuildLoad2(this.builder, this.getType(case_decl.type), other_payload_ptr, "");

					if case_decl.type.reference_kind == None {
						const case_type = case_decl.type.decl;
						var parameters: List!<LLVMValueRef>;
						parameters.append(payload_copy_ptr);
						parameters.append(other_payload);

						discard this.codegenCall(case_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						discard LLVMBuildStore(this.builder, other_payload, payload_copy_ptr);
					}

					discard LLVMBuildBr(this.builder, dest_block);
				}

				LLVMPositionBuilderAtEnd(this.builder, dest_block);

				// destruct old payload
				var case_destructor_args: List!<LLVMValueRef>;
				case_destructor_args.append(this_payload_ptr);

				const cont_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "cont");

				var switch_instr = LLVMBuildSwitch(this.builder, this_id, cont_block, dest_case_count);

				for case_decl in decl.variant_cases {
					if case_decl.type == this.program.void_type || case_decl.type.reference_kind != None {
						continue;
					}

					const case_type = case_decl.type.decl;

					const case_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "case");
					LLVMAddCase(switch_instr, LLVMConstInt(id_type, case_decl.id, false), case_block);
					LLVMPositionBuilderAtEnd(this.builder, case_block);

					discard this.codegenCall(case_type.destructor, case_destructor_args, ReturnKind::None, signature_span);

					discard LLVMBuildBr(this.builder, cont_block);
				}

				LLVMPositionBuilderAtEnd(this.builder, cont_block);

				// move temporary payload to this
				discard LLVMBuildStore(this.builder, LLVMBuildLoad2(this.builder, payload_type, payload_copy_ptr, ""), this_payload_ptr);
				discard LLVMBuildStore(this.builder, other_id, id_ptr);

				// assign member variables
				for i in 0u..decl.member_variables.size() {
					const member_ptr = LLVMBuildStructGEP2(this.builder, type, param0, i + 2, "");
					const initializer = LLVMBuildExtractValue(this.builder, param1, i + 2, "");

					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;

						var parameters: List!<LLVMValueRef>;
						parameters.append(member_ptr);
						parameters.append(initializer);

						discard this.codegenCall(member_type.op_assign, parameters, ReturnKind::None, signature_span);
					} else {
						discard LLVMBuildStore(this.builder, initializer, member_ptr);
					}
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case StructOpEqual
			| VariantOpEqual -> {
				const uneq_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "uneq");

				if function is VariantOpEqual {
					const id_type = this.getType(decl.id_type);
					const data_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "data");

					// store lhs & rhs on stack to access the payload in a safe way
					const lhs_id = LLVMBuildExtractValue(this.builder, param0, 0u, "");
					const lhs_data = LLVMBuildAlloca(this.builder, type, "");
					discard LLVMBuildStore(this.builder, param0, lhs_data);
					const lhs_payload_ptr = LLVMBuildStructGEP2(this.builder, type, lhs_data, 1u, "");

					const rhs_id = LLVMBuildExtractValue(this.builder, param1, 0u, "");
					const rhs_data = LLVMBuildAlloca(this.builder, type, "");
					discard LLVMBuildStore(this.builder, param1, rhs_data);
					const rhs_payload_ptr = LLVMBuildStructGEP2(this.builder, type, rhs_data, 1u, "");

					const same_id = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, lhs_id, rhs_id, "");
					discard LLVMBuildCondBr(this.builder, same_id, data_block, uneq_block);

					LLVMPositionBuilderAtEnd(this.builder, data_block);

					const cont_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "cont");

					var case_count = 0u;
					for case_decl in decl.variant_cases {
						if case_decl.type != this.program.void_type {
							case_count++;
						}
					}
					var switch_instr = LLVMBuildSwitch(this.builder, lhs_id, cont_block, case_count);

					for case_decl in decl.variant_cases {
						if case_decl.type == this.program.void_type {
							continue;
						}

						const case_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "case")
						LLVMAddCase(switch_instr, LLVMConstInt(id_type, case_decl.id, false), case_block);
						LLVMPositionBuilderAtEnd(this.builder, case_block);

						const lhs = LLVMBuildLoad2(this.builder, this.getType(case_decl.type), lhs_payload_ptr, "");
						const rhs = LLVMBuildLoad2(this.builder, this.getType(case_decl.type), rhs_payload_ptr, "");

						var equal = LLVMValueRef();
						if case_decl.type.reference_kind == None {
							const case_type = case_decl.type.decl;
							var parameters: List!<LLVMValueRef>;
							parameters.append(lhs);
							parameters.append(rhs);

							equal = this.codegenCall(case_type.op_equal, parameters, ReturnKind::Value, signature_span);
						} else {
							equal = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, lhs, rhs, "");
						}

						discard LLVMBuildCondBr(this.builder, equal, cont_block, uneq_block);
					}

					LLVMPositionBuilderAtEnd(this.builder, cont_block);
				}

				const member_var_offset = 2u if function is VariantOpEqual else 0u;
				for i in 0u..decl.member_variables.size() {
					const lhs = LLVMBuildExtractValue(this.builder, param0, i + member_var_offset, "");
					const rhs = LLVMBuildExtractValue(this.builder, param1, i + member_var_offset, "");

					var equal = LLVMValueRef();
					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;
						var parameters: List!<LLVMValueRef>;
						parameters.append(lhs);
						parameters.append(rhs);

						equal = this.codegenCall(member_type.op_equal, parameters, ReturnKind::Value, signature_span);
					} else {
						equal = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, lhs, rhs, "");
					}

					const next_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "next");

					discard LLVMBuildCondBr(this.builder, equal, next_block, uneq_block);
					LLVMPositionBuilderAtEnd(this.builder, next_block);
				}

				discard LLVMBuildRet(this.builder, LLVMConstInt(this.bool_type, 1, false));

				LLVMPositionBuilderAtEnd(this.builder, uneq_block);
				discard LLVMBuildRet(this.builder, LLVMConstInt(this.bool_type, 0, false));
			}
			case StructOpCmp -> {
				const entry_block = LLVMGetInsertBlock(this.builder);
				const uneq_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "uneq");

				var cmp_values: List!<LLVMValueRef>;
				var cmp_blocks: List!<LLVMBasicBlockRef>;

				for i in 0u..decl.member_variables.size() {
					const lhs = LLVMBuildExtractValue(this.builder, param0, i, "");
					const rhs = LLVMBuildExtractValue(this.builder, param1, i, "");
					var parameters: List!<LLVMValueRef>;
					parameters.append(lhs);
					parameters.append(rhs);

					var sign = LLVMValueRef();
					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;
						sign = this.codegenCall(member_type.op_compare, parameters, ReturnKind::Value, signature_span);
					} else {
						sign = this.codegenInlineBuiltinFunctionCall(BuiltinFunction::PrimitiveOp(PrimitiveOp::Cmp, decl.member_variables[i].type), parameters);
					}
					cmp_values.append(sign);
					cmp_blocks.append(LLVMGetInsertBlock(this.builder));

					const next_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "next");

					const equal = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, sign, LLVMConstInt(this.int_type, 0, false), "");
					discard LLVMBuildCondBr(this.builder, equal, next_block, uneq_block);
					LLVMPositionBuilderAtEnd(this.builder, next_block);
				}

				discard LLVMBuildRet(this.builder, LLVMConstInt(this.int_type, 0, false));

				LLVMPositionBuilderAtEnd(this.builder, uneq_block);
				const phi = LLVMBuildPhi(this.builder, this.int_type, "");
				LLVMAddIncoming(phi, cmp_values, cmp_blocks);
				discard LLVMBuildRet(this.builder, phi);
			}
			case ArrayDefaultConstructor -> {
				// TODO: turn into a loop for better code size (llvm can unroll it for performance)
				const array_type = (decl.body as Array).value();
				const element_type = array_type.element_type;
				const element_type_decl = element_type.decl;

				for i in 0u..array_type.size {
					var indices: List!<LLVMValueRef>;
					indices.append(LLVMConstInt(this.int_type, 0, false));
					indices.append(LLVMConstInt(this.int_type, i as int, false));
					const element_ptr = LLVMBuildGEP2(this.builder, type, param0, indices, "");

					discard this.codegenCall(element_type_decl.default_constructor, List!<LLVMValueRef>(1u, element_ptr), ReturnKind::None, signature_span);
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case ArrayCopyConstructor
			| ArrayDestructor
			| ArrayOpAssign -> {
				// TODO: turn into a loop for better code size (llvm can unroll it for performance)
				const array_type = (decl.body as Array).value();
				const element_type = array_type.element_type;
				const element_type_decl = element_type.decl;

				for i in 0u..array_type.size {
					var indices: List!<LLVMValueRef>;
					indices.append(LLVMConstInt(this.int_type, 0, false));
					indices.append(LLVMConstInt(this.int_type, i as int, false));
					const element_ptr = LLVMBuildGEP2(this.builder, type, param0, indices, "");

					if !(function is ArrayCopyConstructor) {
						discard this.codegenCall(element_type_decl.destructor, List!<LLVMValueRef>(1u, element_ptr), ReturnKind::None, signature_span);
					}

					if !(function is ArrayDestructor) {
						const other_element = LLVMBuildExtractValue(this.builder, param1, i, "");

						var parameters: List!<LLVMValueRef>;
						parameters.append(element_ptr);
						parameters.append(other_element);

						discard this.codegenCall(element_type_decl.copy_constructor, parameters, ReturnKind::None, signature_span);
					}
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case ArrayOpEqual -> {
				// TODO: turn into a loop for better code size (llvm can unroll it for performance)
				const array_type = (decl.body as Array).value();
				const element_type = array_type.element_type;
				const element_type_decl = element_type.decl;

				const uneq_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "uneq");

				for i in 0u..array_type.size {
					const lhs = LLVMBuildExtractValue(this.builder, param0, i, "");
					const rhs = LLVMBuildExtractValue(this.builder, param1, i, "");

					var equal = LLVMValueRef();
					if element_type.reference_kind == None {
						var parameters: List!<LLVMValueRef>;
						parameters.append(lhs);
						parameters.append(rhs);

						equal = this.codegenCall(element_type_decl.op_equal, parameters, ReturnKind::Value, signature_span);
					} else {
						equal = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, lhs, rhs, "");
					}

					const next_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "next");

					discard LLVMBuildCondBr(this.builder, equal, next_block, uneq_block);
					LLVMPositionBuilderAtEnd(this.builder, next_block);
				}

				discard LLVMBuildRet(this.builder, LLVMConstInt(this.bool_type, 1, false));

				LLVMPositionBuilderAtEnd(this.builder, uneq_block);
				discard LLVMBuildRet(this.builder, LLVMConstInt(this.bool_type, 0, false));
			}
			else -> {
				var parameters: List!<LLVMValueRef>;
				for i in 0u32..LLVMCountParams(this.current_function) {
					parameters.append(LLVMGetParam(this.current_function, i));
				}

				discard LLVMBuildRet(this.builder, this.codegenInlineBuiltinFunctionCall(function, parameters));
			}
		}
	}

	func codegenPrimitiveOp(this: &&CGContext, type: Type, op: PrimitiveOp, parameters: &List!<LLVMValueRef>) -> LLVMValueRef {
		const llvm_type = this.getType(type);
		var lhs = parameters.at(0u) ?? LLVMGetPoison(llvm_type);
		var rhs = parameters.at(1u) ?? LLVMGetPoison(llvm_type);
		if op.isAssignment() && op.getOp() > Swap {
			lhs = LLVMBuildLoad2(this.builder, llvm_type, lhs, "");
		}

		if (op & RHSToVector) == RHSToVector {
			const vector_type = (type.decl.body as Vector).value();
			rhs = LLVMGetPoison(llvm_type);
			for i in 0u..vector_type.size {
				if parameters.size() > 2 {
					rhs = LLVMBuildInsertElement(this.builder, rhs, parameters[i + 1], LLVMConstInt(this.int_type, i as int, false), "");
				} else {
					rhs = LLVMBuildInsertElement(this.builder, rhs, parameters[1u], LLVMConstInt(this.int_type, i as int, false), "");
				}
			}
		}

		var result: LLVMValueRef;
		match op.getOp() {
			case NoOp -> {}
			case ConstNull -> result = LLVMConstNull(llvm_type);
			case Copy -> result = rhs;
			case Swap -> {
				const a = LLVMBuildLoad2(this.builder, llvm_type, parameters[0u], "");
				const b = LLVMBuildLoad2(this.builder, llvm_type, parameters[1u], "");
				discard LLVMBuildStore(this.builder, b, parameters[0u]);
				discard LLVMBuildStore(this.builder, a, parameters[1u]);
			}
			case (PrimitiveOp::And)				-> result = LLVMBuildAnd(this.builder, lhs, rhs, "");
			case (PrimitiveOp::Or)				-> result = LLVMBuildOr(this.builder, lhs, rhs, "");
			case (PrimitiveOp::XOr)				-> result = LLVMBuildXor(this.builder, lhs, rhs, "");
			case (PrimitiveOp::Not)				-> result = LLVMBuildNot(this.builder, lhs, "");
			case (PrimitiveOp::Shl)				-> result = LLVMBuildShl(this.builder, lhs, rhs, "");
			case (PrimitiveOp::Shr | Unsigned)	-> result = LLVMBuildLShr(this.builder, lhs, rhs, "");
			case (PrimitiveOp::Shr | Signed)	-> result = LLVMBuildAShr(this.builder, lhs, rhs, "");
			case (PrimitiveOp::Rotl)			-> result = this.codegenIntrinsicCall("llvm.fshl", List!<LLVMTypeRef>(1u, llvm_type), List!<LLVMValueRef>(2u, parameters[0u]) + parameters[1u]);
			case (PrimitiveOp::Rotr)			-> result = this.codegenIntrinsicCall("llvm.fshr", List!<LLVMTypeRef>(1u, llvm_type), List!<LLVMValueRef>(2u, parameters[0u]) + parameters[1u]);
			case (PrimitiveOp::Add | Unsigned)
			| (PrimitiveOp::Add | Signed)		-> result = LLVMBuildAdd(this.builder, lhs, rhs, "");
			case (PrimitiveOp::Add | Float)		-> result = LLVMBuildFAdd(this.builder, lhs, rhs, "");
			case (PrimitiveOp::Sub | Unsigned)
			| (PrimitiveOp::Sub | Signed)		-> result = LLVMBuildSub(this.builder, lhs, rhs, "");
			case (PrimitiveOp::Sub | Float)		-> result = LLVMBuildFSub(this.builder, lhs, rhs, "");
			case (PrimitiveOp::Mul | Unsigned)
			| (PrimitiveOp::Mul | Signed)		-> result = LLVMBuildMul(this.builder, lhs, rhs, "");
			case (PrimitiveOp::Mul | Float)		-> result = LLVMBuildFMul(this.builder, lhs, rhs, "");
			case (PrimitiveOp::Div | Unsigned)	-> result = LLVMBuildUDiv(this.builder, lhs, rhs, "");
			case (PrimitiveOp::Div | Signed)	-> result = LLVMBuildSDiv(this.builder, lhs, rhs, "");
			case (PrimitiveOp::Div | Float)		-> result = LLVMBuildFDiv(this.builder, lhs, rhs, "");
			case (PrimitiveOp::Mod | Unsigned)	-> result = LLVMBuildURem(this.builder, lhs, rhs, "");
			case (PrimitiveOp::Mod | Signed)	-> result = LLVMBuildSRem(this.builder, lhs, rhs, "");
			case (PrimitiveOp::Mod | Float)		-> result = LLVMBuildFRem(this.builder, lhs, rhs, "");
			case (PrimitiveOp::Neg)				-> result = LLVMBuildNeg(this.builder, lhs, "");
			case (PrimitiveOp::Neg | Float)		-> result = LLVMBuildFNeg(this.builder, lhs, "");
			case (PrimitiveOp::Inc)				-> result = LLVMBuildAdd(this.builder, lhs, LLVMConstInt(llvm_type, 1, false), "");
			case (PrimitiveOp::Dec)				-> result = LLVMBuildSub(this.builder, lhs, LLVMConstInt(llvm_type, 1, false), "");
			case (PrimitiveOp::EQ | Unsigned)
			| (PrimitiveOp::EQ | Signed)		-> result = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, lhs, rhs, "");
			case (PrimitiveOp::EQ | Float)		-> result = LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOEQ, lhs, rhs, "");
			case (PrimitiveOp::NE | Unsigned)
			| (PrimitiveOp::NE | Signed)		-> result = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntNE, lhs, rhs, "");
			case (PrimitiveOp::NE | Float)		-> result = LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealONE, lhs, rhs, "");
			case (PrimitiveOp::LT | Unsigned)	-> result = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULT, lhs, rhs, "");
			case (PrimitiveOp::LT | Signed)		-> result = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSLT, lhs, rhs, "");
			case (PrimitiveOp::LT | Float)		-> result = LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOLT, lhs, rhs, "");
			case (PrimitiveOp::LE | Unsigned)	-> result = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULE, lhs, rhs, "");
			case (PrimitiveOp::LE | Signed)		-> result = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSLE, lhs, rhs, "");
			case (PrimitiveOp::LE | Float)		-> result = LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOLE, lhs, rhs, "");
			case (PrimitiveOp::GT | Unsigned)	-> result = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntUGT, lhs, rhs, "");
			case (PrimitiveOp::GT | Signed)		-> result = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSGT, lhs, rhs, "");
			case (PrimitiveOp::GT | Float)		-> result = LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOGT, lhs, rhs, "");
			case (PrimitiveOp::GE | Unsigned)	-> result = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntUGE, lhs, rhs, "");
			case (PrimitiveOp::GE | Signed)		-> result = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSGE, lhs, rhs, "");
			case (PrimitiveOp::GE | Float)		-> result = LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOGE, lhs, rhs, "");
			case (PrimitiveOp::Cmp | Unsigned)	-> result = LLVMBuildSub(this.builder,
				LLVMBuildZExt(this.builder, LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntUGT, lhs, rhs, ""), this.int_type, ""),
				LLVMBuildZExt(this.builder, LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULT, lhs, rhs, ""), this.int_type, ""), ""
			);
			case (PrimitiveOp::Cmp | Signed)	-> result = LLVMBuildSub(this.builder,
				LLVMBuildZExt(this.builder, LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSGT, lhs, rhs, ""), this.int_type, ""),
				LLVMBuildZExt(this.builder, LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSLT, lhs, rhs, ""), this.int_type, ""), ""
			);
			case (PrimitiveOp::Cmp | Float)		-> result = LLVMBuildSub(this.builder,
				LLVMBuildZExt(this.builder, LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOGT, lhs, rhs, ""), this.int_type, ""),
				LLVMBuildZExt(this.builder, LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOLT, lhs, rhs, ""), this.int_type, ""), ""
			);
			case (PrimitiveOp::Abs | Unsigned)	-> result = parameters[0u];
			case (PrimitiveOp::Abs | Signed)	-> result = this.codegenIntrinsicCall("llvm.abs", List!<LLVMTypeRef>(1u, llvm_type), parameters + LLVMConstNull(this.bool_type));
			case (PrimitiveOp::Abs | Float)		-> result = this.codegenIntrinsicCall("llvm.fabs", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::Min | Unsigned)	-> result = this.codegenIntrinsicCall("llvm.umin", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::Min | Signed)	-> result = this.codegenIntrinsicCall("llvm.smin", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::Min | Float)		-> result = this.codegenIntrinsicCall("llvm.minimum", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::Max | Unsigned)	-> result = this.codegenIntrinsicCall("llvm.umax", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::Max | Signed)	-> result = this.codegenIntrinsicCall("llvm.smax", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::Max | Float)		-> result = this.codegenIntrinsicCall("llvm.maximum", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::Clamp | Unsigned) -> result = this.codegenIntrinsicCall("llvm.umin", List!<LLVMTypeRef>(1u, llvm_type), List!<LLVMValueRef>(1u, parameters[2u]) +
				this.codegenIntrinsicCall("llvm.umax", List!<LLVMTypeRef>(1u, llvm_type), List!<LLVMValueRef>(1u, parameters[0u]) + parameters[1u])
			);
			case (PrimitiveOp::Clamp | Signed)	-> result = this.codegenIntrinsicCall("llvm.smin", List!<LLVMTypeRef>(1u, llvm_type), List!<LLVMValueRef>(1u, parameters[2u]) +
				this.codegenIntrinsicCall("llvm.smax", List!<LLVMTypeRef>(1u, llvm_type), List!<LLVMValueRef>(1u, parameters[0u]) + parameters[1u])
			);
			case (PrimitiveOp::Clamp | Float)	-> result = this.codegenIntrinsicCall("llvm.minimum", List!<LLVMTypeRef>(1u, llvm_type), List!<LLVMValueRef>(1u, parameters[2u]) +
				this.codegenIntrinsicCall("llvm.maximum", List!<LLVMTypeRef>(1u, llvm_type), List!<LLVMValueRef>(1u, parameters[0u]) + parameters[1u])
			);
			case (PrimitiveOp::Lerp | Unsigned)
			| (PrimitiveOp::Lerp | Signed)		-> result = LLVMBuildAdd(this.builder, parameters[0u], LLVMBuildMul(this.builder, LLVMBuildSub(this.builder, parameters[1u], parameters[0u], ""), parameters[2u], ""), "");
			case (PrimitiveOp::Lerp | Float)	-> result = LLVMBuildFAdd(this.builder, parameters[0u], LLVMBuildFMul(this.builder, LLVMBuildFSub(this.builder, parameters[1u], parameters[0u], ""), parameters[2u], ""), "");
			case BitwiseReverse					-> result = this.codegenIntrinsicCall("llvm.bitreverse", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case BytewiseReverse				-> result = this.codegenIntrinsicCall("llvm.bswap", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case PopCount						-> result = this.codegenIntrinsicCall("llvm.ctpop", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case CountLeadingZeros				-> result = this.codegenIntrinsicCall("llvm.ctlz", List!<LLVMTypeRef>(1u, llvm_type), parameters + LLVMConstNull(this.bool_type));
			case CountTrailingZeros				-> result = this.codegenIntrinsicCall("llvm.cttz", List!<LLVMTypeRef>(1u, llvm_type), parameters + LLVMConstNull(this.bool_type));
			case (PrimitiveOp::Sqrt | Float)	-> result = this.codegenIntrinsicCall("llvm.sqrt", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::ISqrt | Float)	-> result = LLVMBuildFDiv(this.builder, LLVMConstReal(llvm_type, 1.0), this.codegenIntrinsicCall("llvm.sqrt", List!<LLVMTypeRef>(1u, llvm_type), parameters), "");
			case (PrimitiveOp::Pow | Float)		-> result = this.codegenIntrinsicCall("llvm.pow", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::Exp | Float)		-> result = this.codegenIntrinsicCall("llvm.exp", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::Exp2 | Float)	-> result = this.codegenIntrinsicCall("llvm.exp2", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::Exp10 | Float)	-> result = this.codegenIntrinsicCall("llvm.exp10", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::Log | Float)		-> result = this.codegenIntrinsicCall("llvm.log", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::Log2 | Float)	-> result = this.codegenIntrinsicCall("llvm.log2", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::Log10 | Float)	-> result = this.codegenIntrinsicCall("llvm.log10", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::Floor | Float)	-> result = this.codegenIntrinsicCall("llvm.floor", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::Ceil | Float)	-> result = this.codegenIntrinsicCall("llvm.ceil", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::Fract | Float)	-> result = LLVMBuildFSub(this.builder, parameters[0u], this.codegenIntrinsicCall("llvm.floor", List!<LLVMTypeRef>(1u, llvm_type), parameters), "");
			case (PrimitiveOp::Round | Float)	-> result = this.codegenIntrinsicCall("llvm.round", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::RoundEven | Float) -> result = this.codegenIntrinsicCall("llvm.roundeven", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::Sin | Float)		-> result = this.codegenIntrinsicCall("llvm.sin", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::Cos | Float)		-> result = this.codegenIntrinsicCall("llvm.cos", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::VectorEQ | Unsigned)
			| (PrimitiveOp::VectorEQ | Signed)	-> {
				const tmp = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, lhs, rhs, "");
				result = this.codegenIntrinsicCall("llvm.vector.reduce.and", List!<LLVMTypeRef>(1u, LLVMTypeOf(tmp)), List!<LLVMValueRef>(1u, tmp));
			}
			case (PrimitiveOp::VectorEQ | Float) -> {
				const tmp = LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOEQ, lhs, rhs, "");
				result = this.codegenIntrinsicCall("llvm.vector.reduce.and", List!<LLVMTypeRef>(1u, LLVMTypeOf(tmp)), List!<LLVMValueRef>(1u, tmp));
			}
			case (PrimitiveOp::VectorNE | Unsigned)
			| (PrimitiveOp::VectorNE | Signed)	-> {
				const tmp = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, lhs, rhs, "");
				result = this.codegenIntrinsicCall("llvm.vector.reduce.and", List!<LLVMTypeRef>(1u, LLVMTypeOf(tmp)), List!<LLVMValueRef>(1u, tmp));
			}
			case (PrimitiveOp::VectorNE | Float) -> {
				const tmp = LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealONE, lhs, rhs, "");
				result = this.codegenIntrinsicCall("llvm.vector.reduce.and", List!<LLVMTypeRef>(1u, LLVMTypeOf(tmp)), List!<LLVMValueRef>(1u, tmp));
			}
			case (PrimitiveOp::VectorReduceAdd | Unsigned)
			| (PrimitiveOp::VectorReduceAdd | Signed)		-> result = this.codegenIntrinsicCall("llvm.vector.reduce.add", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::VectorReduceAdd | Float)		-> {
				const start = LLVMConstReal(LLVMGetElementType(llvm_type), 1.0);
				result = this.codegenIntrinsicCall("llvm.vector.reduce.fadd", List!<LLVMTypeRef>(1u, llvm_type), List!<LLVMValueRef>(1u, start) + parameters);
			}
			case (PrimitiveOp::VectorReduceMul | Unsigned)
			| (PrimitiveOp::VectorReduceMul | Signed)		-> result = this.codegenIntrinsicCall("llvm.vector.reduce.mul", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::VectorReduceMul | Float)		-> {
				const start = LLVMConstReal(LLVMGetElementType(llvm_type), 1.0);
				result = this.codegenIntrinsicCall("llvm.vector.reduce.fmul", List!<LLVMTypeRef>(1u, llvm_type), List!<LLVMValueRef>(1u, start) + parameters);
			}
			case (PrimitiveOp::VectorReduceMin | Unsigned)	-> result = this.codegenIntrinsicCall("llvm.vector.reduce.umin", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::VectorReduceMin | Signed)	-> result = this.codegenIntrinsicCall("llvm.vector.reduce.smin", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::VectorReduceMin | Float)		-> result = this.codegenIntrinsicCall("llvm.vector.reduce.fmin", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::VectorReduceMax | Unsigned)	-> result = this.codegenIntrinsicCall("llvm.vector.reduce.umax", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::VectorReduceMax | Signed)	-> result = this.codegenIntrinsicCall("llvm.vector.reduce.smax", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::VectorReduceMax | Float)		-> result = this.codegenIntrinsicCall("llvm.vector.reduce.fmax", List!<LLVMTypeRef>(1u, llvm_type), parameters);
			case (PrimitiveOp::VectorDotProduct | Unsigned)
			| (PrimitiveOp::VectorDotProduct | Signed)		-> {
				const tmp = LLVMBuildMul(this.builder, parameters[0u], parameters[1u], "");
				result = this.codegenIntrinsicCall("llvm.vector.reduce.add", List!<LLVMTypeRef>(1u, llvm_type), List!<LLVMValueRef>(1u, tmp));
			}
			case (PrimitiveOp::VectorDotProduct | Float)	-> {
				const tmp = LLVMBuildFMul(this.builder, parameters[0u], parameters[1u], "");
				const start = LLVMConstReal(LLVMGetElementType(llvm_type), 0.0);
				result = this.codegenIntrinsicCall("llvm.vector.reduce.fadd", List!<LLVMTypeRef>(1u, llvm_type), List!<LLVMValueRef>(1u, start) + tmp);
			}
			else -> panic("invalid primitive op");
		}

		if op.isAssignment() {
			discard LLVMBuildStore(this.builder, result, parameters[0u]);
			return LLVMValueRef();
		} else {
			return result;
		}
	}

	func codegenInlineBuiltinFunctionCall(this: &&CGContext, function: BuiltinFunction, parameters: &List!<LLVMValueRef>) -> LLVMValueRef {
		match function {
			case PrimitiveOp: op -> return this.codegenPrimitiveOp(function.base_type, op, parameters);
			case PointerToRef -> return parameters[0u];	// reference & pointer types are the same in llvm
			case RefToPointer -> return parameters[0u];	// reference & pointer types are the same in llvm
			case PointerCast -> return parameters[0u];	// all pointer types are the same in llvm

			case PointerDiff -> {
				const pointer_type = (function.base_type.decl.body as Pointer).value();
				const pointee_type = this.getType(pointer_type.pointee_type);
				return LLVMBuildPtrDiff2(this.builder, pointee_type, parameters[0u], parameters[1u], "");
			}
			case PointerOffset
			| PointerOpIndex -> {
				const pointer_type = (function.base_type.decl.body as Pointer).value();
				const pointee_type = this.getType(pointer_type.pointee_type);

				var indices: List!<LLVMValueRef>;
				indices.append(parameters[1u]);
				return LLVMBuildGEP2(this.builder, pointee_type, parameters[0u], indices, "");
			}

			case FunctionPointerCall -> {
				const function_type = (function.base_type.decl.body as Function).value();

				const return_type = this.getType(function_type.return_type);
				var parameter_types: List!<LLVMTypeRef>;
				for p in function_type.parameter_types {
					parameter_types.append(this.getType(p));
				}
				const llvm_function_type = LLVMFunctionType(return_type, parameter_types, false);

				const call_parameters = List!<LLVMValueRef>(parameters[1u..parameters.size()]);
				const result = LLVMBuildCall2(this.builder, llvm_function_type, parameters[0u], call_parameters, "");

				if return_type == this.void_type {
					return LLVMValueRef();
				} else {
					return result;
				}
			}

			case IntCast: target -> {
				const source_width = match function.base_type.decl.body {
					case Vector: vector_type -> yield LLVMGetIntTypeWidth(this.getType(vector_type.element_type));
					else -> yield LLVMGetIntTypeWidth(this.getType(function.base_type));
				};
				const target_width = match target.decl.body {
					case Vector: vector_type -> yield LLVMGetIntTypeWidth(this.getType(vector_type.element_type));
					else -> yield LLVMGetIntTypeWidth(this.getType(target));
				};

				if source_width == target_width {
					return parameters[0u];
				} else if source_width > target_width {
					return LLVMBuildTrunc(this.builder, parameters[0u], this.getType(target), "");
				} else if function.base_type.isSigned(true) && target.isSigned(true) {
					return LLVMBuildSExt(this.builder, parameters[0u], this.getType(target), "");
				} else {
					return LLVMBuildZExt(this.builder, parameters[0u], this.getType(target), "");
				}
			}
			case FloatCast: target -> {
				const source_width = match function.base_type.decl.body {
					case Vector: vector_type -> yield LLVMStoreSizeOfType(this.data_layout, this.getType(vector_type.element_type));
					else -> yield LLVMStoreSizeOfType(this.data_layout, this.getType(function.base_type));
				};
				const target_width = match target.decl.body {
					case Vector: vector_type -> yield LLVMStoreSizeOfType(this.data_layout, this.getType(vector_type.element_type));
					else -> yield LLVMStoreSizeOfType(this.data_layout, this.getType(target));
				};

				if source_width == target_width {
					return parameters[0u];
				} else if source_width > target_width {
					return LLVMBuildFPTrunc(this.builder, parameters[0u], this.getType(target), "");
				} else {
					return LLVMBuildFPExt(this.builder, parameters[0u], this.getType(target), "");
				}
			}
			case IntToFloat: target -> {
				if function.base_type.isSigned(true) {
					return LLVMBuildSIToFP(this.builder, parameters[0u], this.getType(target), "");
				} else {
					return LLVMBuildUIToFP(this.builder, parameters[0u], this.getType(target), "");
				}
			}
			case FloatToInt: target -> {
				if target.isSigned(true) {
					return LLVMBuildFPToSI(this.builder, parameters[0u], this.getType(target), "");
				} else {
					return LLVMBuildFPToUI(this.builder, parameters[0u], this.getType(target), "");
				}
			}

			case SizeOf -> {
				// ptrtoint (ptr getelementptr (type, ptr null, i32 1) to i64)
				const type = this.getType(function.base_type);
				return LLVMConstPtrToInt(
					LLVMConstGEP2(
						type,
						LLVMConstNull(this.ptr_type),
						List!<LLVMValueRef>(1u, LLVMConstInt(this.int_type, 1, false))
					),
					this.int_type
				);
			}
			case AlignmentOf -> return LLVMConstInt(this.int_type, LLVMPreferredAlignmentOfType(this.data_layout, this.getType(function.base_type)) as int, false);
			case ReferenceKindOf -> return LLVMConstInt(this.byte_type, function.base_type.reference_kind as int, false);
			case HasDefaultConstructor -> return LLVMConstInt(this.bool_type, function.base_type.decl.default_constructor.isAlive() as int, false);
			case HasCopyConstructor -> return LLVMConstInt(this.bool_type, function.base_type.decl.copy_constructor.isAlive() as int, false);

			case Assert | AssertError -> {
				const panic_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "panic");
				const ok_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "ok");
				discard LLVMBuildCondBr(this.builder, parameters[0u], ok_block, panic_block);

				LLVMPositionBuilderAtEnd(this.builder, panic_block);
				var panic_args: List!<LLVMValueRef>;
				if function is Assert {
					panic_args.append(LLVMConstInt(this.getType(this.program.error_type), Error::EASSERTFAILED as int, false));
				} else {
					panic_args.append(parameters[1u]);
				}
				discard this.codegenCall(this.program.panic_function, panic_args, ReturnKind::None, Span());
				discard LLVMBuildUnreachable(this.builder);

				LLVMPositionBuilderAtEnd(this.builder, ok_block);
				return LLVMValueRef();
			}

			case RangeGetData -> return LLVMBuildExtractValue(this.builder, parameters[0u], 0u, "");
			case RangeGetSize -> return LLVMBuildExtractValue(this.builder, parameters[0u], 1u, "");
			case RangeGetIterator: iterator_type -> {
				const pointee_type = (function.base_type.decl.template_parameters[0u].value as Type).value();

				const begin = LLVMBuildExtractValue(this.builder, parameters[0u], 0u, "");
				const size = LLVMBuildExtractValue(this.builder, parameters[0u], 1u, "");
				const end = LLVMBuildGEP2(this.builder, this.getType(pointee_type), begin, List!<LLVMValueRef>(1u, size), "");

				var iterator = LLVMConstNull(this.getType(iterator_type));
				iterator = LLVMBuildInsertValue(this.builder, iterator, begin, 0u, "");
				iterator = LLVMBuildInsertValue(this.builder, iterator, end, 1u, "");
				return iterator;
			}
			case RangeIteratorHasNext -> {
				const current = LLVMBuildExtractValue(this.builder, parameters[0u], 0u, "");
				const next = LLVMBuildExtractValue(this.builder, parameters[0u], 1u, "");
				return LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULT, current, next, "");
			}
			case RangeIteratorGetNext -> {
				const pointee_type = (function.base_type.decl.template_parameters[0u].value as Type).value();
				const current_ptr = LLVMBuildStructGEP2(this.builder, this.getType(function.base_type), parameters[0u], 0u, "");
				const current = LLVMBuildLoad2(this.builder, this.ptr_type, current_ptr, "");

				const end_ptr = LLVMBuildStructGEP2(this.builder, this.getType(function.base_type), parameters[0u], 1u, "");
				const end = LLVMBuildLoad2(this.builder, this.ptr_type, end_ptr, "");

				var assert_args: List!<LLVMValueRef>;
				assert_args.append(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULT, current, end, ""));
				assert_args.append(LLVMConstInt(this.getType(this.program.error_type), Error::EBOUNDS as int, false));
				discard this.codegenCall(this.program.assert_error_function, assert_args, ReturnKind::None, Span());

				var indices: List!<LLVMValueRef>;
				indices.append(LLVMConstInt(this.int_type, 1, false));
				const next = LLVMBuildGEP2(this.builder, this.getType(pointee_type), current, indices, "");
				discard LLVMBuildStore(this.builder, next, current_ptr);

				return current;
			}

			case NumericTypeRangeOperator: range_type -> {
				var value = LLVMConstNull(this.getType(range_type));
				value = LLVMBuildInsertValue(this.builder, value, parameters[0u], 0u, "");
				value = LLVMBuildInsertValue(this.builder, value, parameters[1u], 1u, "");
				if function.base_type.isIntType(false) {
					value = LLVMBuildInsertValue(this.builder, value, LLVMConstInt(this.getType(function.base_type), 1, false), 2u, "");
				} else {
					value = LLVMBuildInsertValue(this.builder, value, LLVMConstReal(this.getType(function.base_type), 1.0), 2u, "");
				}
				return value;
			}

			case NumericRangeSetStep -> return LLVMBuildInsertValue(this.builder, parameters[0u], parameters[1u], 2u, "");
			case NumericRangeGetIterator: iterator_type -> {
				const numeric_type = function.base_type.decl.member_variables[0u].type;
				const start = LLVMBuildExtractValue(this.builder, parameters[0u], 0u, "");
				const end = LLVMBuildExtractValue(this.builder, parameters[0u], 1u, "");

				var is_ascending: LLVMValueRef;
				if numeric_type.isIntType(false) {
					const comparison_kind = LLVMIntPredicate::LLVMIntSLT if numeric_type.isSigned(false) else LLVMIntPredicate::LLVMIntULT;
					is_ascending = LLVMBuildICmp(this.builder, comparison_kind, start, end, "");
				} else {
					is_ascending = LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOLT, start, end, "");
				}

				var step = LLVMBuildExtractValue(this.builder, parameters[0u], 2u, "");
				step = LLVMBuildSelect(
					this.builder, is_ascending, step,
					LLVMBuildNeg(this.builder, step, "") if numeric_type.isIntType(false) else LLVMBuildFNeg(this.builder, step, ""), ""
				);

				var iterator = LLVMConstNull(this.getType(iterator_type));
				iterator = LLVMBuildInsertValue(this.builder, iterator, start, 0u, "");
				iterator = LLVMBuildInsertValue(this.builder, iterator, end, 1u, "");
				iterator = LLVMBuildInsertValue(this.builder, iterator, step, 2u, "");
				iterator = LLVMBuildInsertValue(this.builder, iterator, is_ascending, 3u, "");
				return iterator;
			}
			case NumericIteratorHasNext: numeric_type -> {
				const current = LLVMBuildExtractValue(this.builder, parameters[0u], 0u, "");
				const end = LLVMBuildExtractValue(this.builder, parameters[0u], 1u, "");
				const is_ascending = LLVMBuildExtractValue(this.builder, parameters[0u], 3u, "");

				var lt: LLVMValueRef;
				var gt: LLVMValueRef;

				if numeric_type.isIntType(false) {
					lt = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSLT if numeric_type.isSigned(false) else LLVMIntPredicate::LLVMIntULT, current, end, "");
					gt = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSGT if numeric_type.isSigned(false) else LLVMIntPredicate::LLVMIntUGT, current, end, "");
				} else {
					lt = LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOLT, current, end, "");
					gt = LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOGT, current, end, "");
				}

				return LLVMBuildSelect(this.builder, is_ascending, lt, gt, "");
			}
			case NumericIteratorGetNext: numeric_type -> {
				const current_ptr = LLVMBuildStructGEP2(this.builder, this.getType(function.base_type), parameters[0u], 0u, "");
				const current = LLVMBuildLoad2(this.builder, this.getType(numeric_type), current_ptr, "");
				const step_ptr = LLVMBuildStructGEP2(this.builder, this.getType(function.base_type), parameters[0u], 2u, "");
				const step = LLVMBuildLoad2(this.builder, this.getType(numeric_type), step_ptr, "");

				var next: LLVMValueRef;
				if numeric_type.isIntType(false) {
					next = LLVMBuildAdd(this.builder, current, step, "");
				} else {
					next = LLVMBuildFAdd(this.builder, current, step, "");
				}

				discard LLVMBuildStore(this.builder, next, current_ptr);
				return current;
			}

			case VariantOpUnsafeAs: id -> {
				const case_decl = function.base_type.decl.getVariantCase(id).value();
				var result = LLVMBuildStructGEP2(this.builder, this.getType(function.base_type), parameters[0u], 1u, "");
				if case_decl.type.reference_kind != None {
					result = LLVMBuildLoad2(this.builder, this.getType(case_decl.type), result, "");
				}
				return result;
			}

			case VariantOpIs: id -> {
				const id_type = this.getType(function.base_type.decl.id_type);
				const object_id = LLVMBuildExtractValue(this.builder, parameters[0u], 0u, "");
				return LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, object_id, LLVMConstInt(id_type, id, false), "");
			}

			case ArrayGetSize -> {
				const size = (function.base_type.decl.body as Array).value().size;
				return LLVMConstInt(this.int_type, size as int, false);
			}
			case ArrayGetDataPointer -> {
				var indices: List!<LLVMValueRef>;
				indices.append(LLVMConstInt(this.int_type, 0, false));
				indices.append(LLVMConstInt(this.int_type, 0, false));
				return LLVMBuildGEP2(this.builder, this.getType(function.base_type), parameters[0u], indices, "");
			}
			else -> panic("builtin function is not inlineable");
		}
	}

	func codegenNode(this: &&CGContext, node: &Node) -> LLVMValueRef {
		var result = LLVMValueRef();
		if node.type.isAlive() && node.type != this.program.void_type && node.type != this.program.never_type {
			result = LLVMGetUndef(this.getType(node.type));
		}

		match node {
			case Empty | Garbage -> {}
			case CompoundStmt: &children -> {
				for child in children {
					discard this.codegenNode(this.getASTNode(child));
				}
			}
			case IfStmt: &if_stmt -> this.codegenIfStmt(if_stmt, node.span);
			case WhileStmt: &while_stmt -> this.codegenWhileStmt(while_stmt, node.span);
			case ForStmt: &for_stmt -> this.codegenForStmt(for_stmt, node.span);
			case BreakStmt -> {
				this.setCurrentDebugLocation(node.span);
				discard LLVMBuildBr(this.builder, this.break_target);
			}
			case ContinueStmt -> {
				this.setCurrentDebugLocation(node.span);
				discard LLVMBuildBr(this.builder, this.continue_target);
			}
			case YieldStmt -> {
				this.setCurrentDebugLocation(node.span);
				discard LLVMBuildBr(this.builder, this.yield_target);
			}
			case ReturnStmt: &value -> {
				if value == 0 && this.current_function_decl == this.program.main_function {
					this.setCurrentDebugLocation(node.span);
					discard LLVMBuildRet(this.builder, LLVMConstInt(this.int_type, 0, false));
				} else {
					const built_value = this.codegenNode(this.getASTNode(value));
					this.setCurrentDebugLocation(node.span);
					discard LLVMBuildRet(this.builder, built_value);
				}
			}
			case LifeTimeStart: variable -> {
				if variable.destructor_call > 1 {
					this.codegenLifeTimeStart(this.getVariable(variable));
				}
				discard this.codegenNode(this.getASTNode(variable.constructor_call));
			}
			case LifeTimeEnd: variable -> {
				discard this.codegenNode(this.getASTNode(variable.destructor_call));
				if variable.destructor_call > 1 {
					this.codegenLifeTimeEnd(this.getVariable(variable));
				}
			}
			case BoolLiteralExpr: value -> result = LLVMConstInt(this.getType(node.type), value as int, false);
			case IntegerLiteralExpr: value -> result = LLVMConstInt(this.getType(node.type), value, node.type.isSigned(false));
			case FloatLiteralExpr: value -> result = LLVMConstReal(this.getType(node.type), value);
			case StringLiteralExpr: expr -> {
				const data_ptr = this.codegenStringGlobal(expr.value);
				result = LLVMConstNull(this.getType(node.type));
				result = LLVMBuildInsertValue(this.builder, result, data_ptr, 0u, "");
				result = LLVMBuildInsertValue(this.builder, result, LLVMConstInt(this.int_type, expr.value.size() as int, false), 1u, ""); // size
				result = LLVMBuildInsertValue(this.builder, result, LLVMConstInt(this.int_type, expr.value.size() as int, false), 2u, ""); // capacity
			}
			case ConstAggregateExpr: &elements -> {
				result = LLVMConstNull(this.getType(node.type));
				for i in 0u..elements.size() {
					const element = this.codegenNode(this.getASTNode(elements[i]));
					result = LLVMBuildInsertValue(this.builder, result, element, i, "");
				}
			}
			case CallExpr: &call_expr -> {
				var parameters: List!<LLVMValueRef>;
				for parameter in call_expr.parameters {
					parameters.append(this.codegenNode(this.getASTNode(parameter)));
				}

				result = this.codegenCall(call_expr.function, parameters, call_expr.return_kind, call_expr.result_var, node.span);
			}
			case VarInvokeExpr: &variable -> {
				if variable.type.reference_kind == None || variable.is_parameter {
					result = this.getVariable(variable);
				} else {
					this.setCurrentDebugLocation(node.span);
					result = LLVMBuildLoad2(this.builder, this.getType(variable.type), this.getVariable(variable), "");
				}
			}
			case MemberVarInvokeExpr: &member_var_invoke_expr -> {
				const object_type = this.getASTNode(member_var_invoke_expr.object).type;
				const object = this.codegenNode(this.getASTNode(member_var_invoke_expr.object));

				var id = member_var_invoke_expr.id;
				if object_type.isVariant() {
					id += 2;
				}

				this.setCurrentDebugLocation(node.span);
				result = LLVMBuildStructGEP2(this.builder, this.getType(object_type.base()), object, id, "");

				const member_decl = object_type.decl.member_variables[member_var_invoke_expr.id];
				if member_decl.type.reference_kind != None {
					result = LLVMBuildLoad2(this.builder, this.getType(member_decl.type), result, "");
				}
			}
			case DereferenceExpr: &base -> {
				this.setCurrentDebugLocation(node.span);
				result = LLVMBuildLoad2(this.builder, this.getType(node.type), this.codegenNode(this.getASTNode(base)), "");
			}
			case MatchExpr: &match_expr -> result = this.codegenMatchExpr(match_expr, node.span);
			case ShallowCopyExpr: shallow_copy_expr -> {
				var dst = LLVMValueRef();
				match this.getASTNode(shallow_copy_expr.destination) {
					case VarInvokeExpr: &variable -> dst = this.getVariable(variable);
					case MemberVarInvokeExpr: &member_var_invoke_expr -> {
						const object_type = this.getASTNode(member_var_invoke_expr.object).type;
						const object = this.codegenNode(this.getASTNode(member_var_invoke_expr.object));

						var id = member_var_invoke_expr.id;
						if object_type.isVariant() {
							id += 2;
						}

						dst = LLVMBuildStructGEP2(this.builder, this.getType(object_type.base()), object, member_var_invoke_expr.id, "");
					}
					else -> panic("invalid shallow copy expr");
				}

				result = this.codegenNode(this.getASTNode(shallow_copy_expr.value));

				this.setCurrentDebugLocation(node.span);
				discard LLVMBuildStore(this.builder, result, dst);
			}
			case FunctionRefExpr: function -> result = this.getFunction(function);
			case VectorGetElementExpr: expr -> {
				const vector = this.codegenNode(this.getASTNode(expr.vector));
				const index = this.codegenNode(this.getASTNode(expr.index));
				result = LLVMBuildExtractElement(this.builder, vector, index, "");
			}
			case VectorSetElementExpr: expr -> {
				const vector_type = this.getType(this.getASTNode(expr.vector).type.base());
				const vector = this.codegenNode(this.getASTNode(expr.vector));
				const index = this.codegenNode(this.getASTNode(expr.index));
				const value = this.codegenNode(this.getASTNode(expr.value));
				discard LLVMBuildStore(this.builder,
					LLVMBuildInsertElement(this.builder,
						LLVMBuildLoad2(this.builder, vector_type, vector, ""), value, index, ""
					), vector
				);
			}
			case VectorGetSwizzleExpr: expr -> {
				const vector = this.codegenNode(this.getASTNode(expr.vector));
				var mask = LLVMGetPoison(LLVMVectorType(this.int_type, expr.indices.size()));
				for i in 0u..expr.indices.size() {
					mask = LLVMBuildInsertElement(
						this.builder, mask,
						LLVMConstInt(this.int_type, expr.indices[i] as int, false),
						LLVMConstInt(this.int_type, i as int, false),
						""
					);
				}

				result = LLVMBuildShuffleVector(this.builder, vector, LLVMGetPoison(LLVMTypeOf(vector)), mask, "");
			}
			case VectorSetSwizzleExpr: expr -> {
				const vector_type = this.getASTNode(expr.vector).type.base();
				const element_type = (vector_type.decl.body as Vector).value().element_type;
				const vector_size = (vector_type.decl.body as Vector).value().size;
				const llvm_type = this.getType(vector_type);

				var value_extend_mask = LLVMGetPoison(LLVMVectorType(this.int_type, vector_size));
				var mix_mask = LLVMGetPoison(LLVMVectorType(this.int_type, vector_size));
				for i in 0u..vector_size {
					value_extend_mask = LLVMBuildInsertElement(
						this.builder, value_extend_mask,
						LLVMConstInt(this.int_type, i as int, false) if i < expr.indices.size() else LLVMGetPoison(this.int_type),
						LLVMConstInt(this.int_type, i as int, false),
						""
					);

					var dst = i;
					if const k = expr.indices.find(i) {
						dst = vector_size + k;
					}

					mix_mask = LLVMBuildInsertElement(
						this.builder, mix_mask,
						LLVMConstInt(this.int_type, dst as int, false),
						LLVMConstInt(this.int_type, i as int, false),
						""
					);
				}

				const vector = this.codegenNode(this.getASTNode(expr.vector));
				const value = this.codegenNode(this.getASTNode(expr.value));
				const extented_value = LLVMBuildShuffleVector(this.builder, value, LLVMGetPoison(LLVMTypeOf(value)), value_extend_mask, "");
				discard LLVMBuildStore(
					this.builder,
					LLVMBuildShuffleVector(
						this.builder,
						LLVMBuildLoad2(this.builder, llvm_type, vector, ""),
						extented_value,
						mix_mask, ""
					),
					vector
				);
			}
			else -> {
				this.error("invalid node for codegen '" + node.name() + "'", node.span);
			}
		}

		if node.type == this.program.never_type && !LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) {
			discard LLVMBuildUnreachable(this.builder);
		}
		return result;
	}

	func codegenIfStmt(this: &&CGContext, if_stmt: &IfStmt, span: Span) -> void {
		const condition = this.codegenNode(this.getASTNode(if_stmt.condition));
		for stmt in if_stmt.condition_cleanup {
			discard this.codegenNode(this.getASTNode(stmt));
		}

		const then_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "then");
		const else_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "else");
		const exit_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "exit");

		var then_branch_terminates = false;
		var else_branch_terminates = false;

		this.setCurrentDebugLocation(span);
		discard LLVMBuildCondBr(this.builder, condition, then_block, else_block);

		LLVMPositionBuilderAtEnd(this.builder, then_block);
		discard this.codegenNode(this.getASTNode(if_stmt.then_branch));
		if !LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) {
			discard LLVMBuildBr(this.builder, exit_block);
		} else {
			then_branch_terminates = true;
		}

		LLVMPositionBuilderAtEnd(this.builder, else_block);
		discard this.codegenNode(this.getASTNode(if_stmt.else_branch));
		if !LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) {
			discard LLVMBuildBr(this.builder, exit_block);
		} else {
			else_branch_terminates = true;
		}

		LLVMPositionBuilderAtEnd(this.builder, exit_block);

		if then_branch_terminates && else_branch_terminates {
			discard LLVMBuildUnreachable(this.builder);
		}
	}

	func codegenWhileStmt(this: &&CGContext, while_stmt: &WhileStmt, span: Span) -> void {
		const header_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "header");
		const body_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "body");
		const exit_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "exit");

		const prev_continue_target = this.continue_target;
		const prev_break_target = this.break_target;

		this.continue_target = header_block;
		this.break_target = exit_block;

		this.setCurrentDebugLocation(span);

		if while_stmt.kind == While {
			discard LLVMBuildBr(this.builder, header_block);
		} else {
			discard LLVMBuildBr(this.builder, body_block);
		}

		LLVMPositionBuilderAtEnd(this.builder, header_block);
		const condition = this.codegenNode(this.getASTNode(while_stmt.condition));
		for stmt in while_stmt.condition_cleanup {
			discard this.codegenNode(this.getASTNode(stmt));
		}
		discard LLVMBuildCondBr(this.builder, condition, body_block, exit_block);

		var body_terminates = false;

		LLVMPositionBuilderAtEnd(this.builder, body_block);
		discard this.codegenNode(this.getASTNode(while_stmt.body));

		if !LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) {
			discard LLVMBuildBr(this.builder, header_block);
		} else {
			body_terminates = true;
		}

		LLVMPositionBuilderAtEnd(this.builder, exit_block);
		if body_terminates && while_stmt.kind == DoWhile {
			discard LLVMBuildUnreachable(this.builder);
		}

		this.continue_target = prev_continue_target;
		this.break_target = prev_break_target;
	}

	func codegenForStmt(this: &&CGContext, for_stmt: &ForStmt, span: Span) -> void {
		const header_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "header");
		const body_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "body");
		const latch_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "latch");
		const exit_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "exit");

		const prev_continue_target = this.continue_target;
		const prev_break_target = this.break_target;

		this.continue_target = latch_block;
		this.break_target = exit_block;

		const iterator_type = this.getASTNode(for_stmt.iterator).type;
		const enumerator_type = iterator_type.decl.member_variables[0u].type;

		// range only
		const element_type = (iterator_type.decl.template_parameters[0u].value as Type).value();

		const iterator = this.codegenNode(this.getASTNode(for_stmt.iterator));
		const begin = LLVMBuildExtractValue(this.builder, iterator, 0u, "");
		const end = LLVMBuildExtractValue(this.builder, iterator, 1u, "");
		const step = LLVMBuildExtractValue(this.builder, iterator, 2u, "") if for_stmt.kind is Count else LLVMValueRef();
		const is_ascending = LLVMBuildExtractValue(this.builder, iterator, 3u, "") if for_stmt.kind is Count else LLVMValueRef();

		discard LLVMBuildBr(this.builder, header_block);

		const pre_header = LLVMGetInsertBlock(this.builder);
		LLVMPositionBuilderAtEnd(this.builder, header_block);
		const phi = LLVMBuildPhi(this.builder, this.getType(enumerator_type), "");

		var condition = LLVMValueRef();
		if for_stmt.kind == Range {
			condition = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULT, phi, end, "");
		} else {
			const lt_predicate = LLVMIntPredicate::LLVMIntSLT if enumerator_type.isSigned(false) else LLVMIntPredicate::LLVMIntULT;
			const gt_predicate = LLVMIntPredicate::LLVMIntSGT if enumerator_type.isSigned(false) else LLVMIntPredicate::LLVMIntUGT;
			const lt = LLVMBuildICmp(this.builder, lt_predicate, phi, end, "");
			const gt = LLVMBuildICmp(this.builder, gt_predicate, phi, end, "");
			condition = LLVMBuildSelect(this.builder, is_ascending, lt, gt, "");
		}

		discard LLVMBuildCondBr(this.builder, condition, body_block, exit_block);

		LLVMPositionBuilderAtEnd(this.builder, body_block);
		this.codegenLifeTimeStart(this.getVariable(for_stmt.enumerator_variable));

		if for_stmt.kind == Range {
			if for_stmt.enumerator_variable.type.reference_kind == None {
				var parameters: List!<LLVMValueRef>;
				parameters.append(this.getVariable(for_stmt.enumerator_variable));
				parameters.append(LLVMBuildLoad2(this.builder, this.getType(element_type), phi, ""));
				discard this.codegenCall(element_type.decl.copy_constructor, parameters, ReturnKind::None, for_stmt.enumerator_variable.span);
			} else {
				discard LLVMBuildStore(this.builder, phi, this.getVariable(for_stmt.enumerator_variable));
			}
		} else {
			var parameters: List!<LLVMValueRef>;
			parameters.append(this.getVariable(for_stmt.enumerator_variable));
			parameters.append(phi);
			discard this.codegenCall(enumerator_type.decl.copy_constructor, parameters, ReturnKind::None, for_stmt.enumerator_variable.span);
		}

		discard this.codegenNode(this.getASTNode(for_stmt.body));

		if !LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) {
			discard LLVMBuildBr(this.builder, latch_block);
		}

		LLVMPositionBuilderAtEnd(this.builder, latch_block);

		var next = LLVMValueRef();
		if for_stmt.kind == Range {
			next = LLVMBuildGEP2(this.builder, this.getType(element_type), phi, List!<LLVMValueRef>(1u, LLVMConstInt(this.int_type, 1, false)), "");
		} else {
			next = LLVMBuildAdd(this.builder, phi, step, "");
		}

		var incoming_blocks: List!<LLVMBasicBlockRef>;
		incoming_blocks.append(pre_header);
		incoming_blocks.append(latch_block);

		var incoming_values: List!<LLVMValueRef>;
		incoming_values.append(begin);
		incoming_values.append(next);

		LLVMAddIncoming(phi, incoming_values, incoming_blocks);

		discard LLVMBuildBr(this.builder, header_block);

		LLVMPositionBuilderAtEnd(this.builder, exit_block);

		this.continue_target = prev_continue_target;
		this.break_target = prev_break_target;
	}

	func codegenStringGlobal(this: &&CGContext, value: String) -> LLVMValueRef {
		match this.program.string_globals.get(value) {
			case Some: result -> return result;
			else -> {}
		}

		const string_value = LLVMConstStringInContext(this.llvm_context, value, true);
		const result = LLVMAddGlobal(this.llvm_module, LLVMTypeOf(string_value), "");
		LLVMSetLinkage(result, LLVMLinkage::LLVMPrivateLinkage);
		LLVMSetUnnamedAddress(result, LLVMUnnamedAddr::LLVMGlobalUnnamedAddr);
		LLVMSetAlignment(result, 1u);
		LLVMSetInitializer(result, string_value);
		LLVMSetGlobalConstant(result, true);

		this.program.string_globals.set(value, result);
		return result;
	}

	func codegenCall(this: &&CGContext, function: SharedHandle!<FunctionDecl>, parameters: &List!<LLVMValueRef>, return_kind: ReturnKind, span: Span) -> LLVMValueRef {
		assert(return_kind == ReturnKind::None || return_kind == ReturnKind::Value);
		return this.codegenCall(function, parameters, return_kind, SharedHandle!<VarDecl>(), span);
	}

	func codegenCall(this: &&CGContext, function: SharedHandle!<FunctionDecl>, parameters: &List!<LLVMValueRef>, return_kind: ReturnKind, result_var: SharedHandle!<VarDecl>, span: Span) -> LLVMValueRef {
		this.setCurrentDebugLocation(span);

		if return_kind is Parameter {
			this.codegenLifeTimeStart(this.getVariable(result_var));
		}

		const result = match function.body {
			case Builtin: builtin_function -> {
				if builtin_function.isInlineable() {
					yield this.codegenInlineBuiltinFunctionCall(builtin_function, parameters);
				} else {
					const llvm_func = this.getFunction(function);
					yield LLVMBuildCall2(this.builder, function.llvm_type, llvm_func, parameters, "");
				}
			}
			else -> {
				const llvm_func = this.getFunction(function);
				yield LLVMBuildCall2(this.builder, function.llvm_type, llvm_func, parameters, "");
			}
		}

		match return_kind {
			case None -> return LLVMValueRef();
			case Value -> return result;
			case Variable -> {
				const built_result_var = this.getVariable(result_var);
				discard LLVMBuildStore(this.builder, result, built_result_var);
				return built_result_var;
			}
			case Parameter -> return this.getVariable(result_var);
			case VariableButYieldNone -> {
				const built_result_var = this.getVariable(result_var);
				discard LLVMBuildStore(this.builder, result, built_result_var);
				return LLVMValueRef();
			}
		}
	}

	func codegenMatchExpr(this: &&CGContext, match_expr: &MatchExpr, span: Span) -> LLVMValueRef {
		const value_type = this.getASTNode(match_expr.value).type;
		var value = this.codegenNode(this.getASTNode(match_expr.value));

		if value_type.isVariant() {
			const value_type_decl = value_type.decl;
			value = LLVMBuildLoad2(this.builder,
				this.getType(value_type_decl.id_type),
				LLVMBuildStructGEP2(this.builder,
					this.getType(value_type.base()),
					value, 0u, ""
				), ""
			);
		} else if value_type.reference_kind != None {
			value = LLVMBuildLoad2(this.builder,
				this.getType(value_type.base()),
				value, ""
			);
		}

		var case_blocks: List!<LLVMBasicBlockRef>;
		for i in 0u..match_expr.cases.size() {
			case_blocks.append(LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "case"));
		}

		const else_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "else");
		const cont_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "cont");

		const prev_yield_target = this.yield_target;
		this.yield_target = cont_block;

		this.setCurrentDebugLocation(span);

		var switch_instr = LLVMBuildSwitch(this.builder, value, else_block, case_blocks.size());

		for i in 0u..match_expr.cases.size() {
			const case_stmt = (this.getASTNode(match_expr.cases[i]) as CaseStmt).value();
			for pattern in case_stmt.patterns {
				const built_pattern = this.codegenNode(this.getASTNode(pattern));
				LLVMAddCase(switch_instr, built_pattern, case_blocks[i]);
			}
		}

		for i in 0u..match_expr.cases.size() {
			const case_stmt = (this.getASTNode(match_expr.cases[i]) as CaseStmt).value();
			LLVMPositionBuilderAtEnd(this.builder, case_blocks[i]);
			discard this.codegenNode(this.getASTNode(case_stmt.body));
			if !LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) {
				discard LLVMBuildBr(this.builder, cont_block);
			}
		}

		LLVMPositionBuilderAtEnd(this.builder, else_block);
		if match_expr.else_case > 1 {
			discard this.codegenNode(this.getASTNode(match_expr.else_case));
			if !LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) {
				discard LLVMBuildBr(this.builder, cont_block);
			}
		} else {
			discard LLVMBuildUnreachable(this.builder);
		}

		LLVMPositionBuilderAtEnd(this.builder, cont_block);
		this.yield_target = prev_yield_target;

		return this.variables.get(match_expr.yield_var) ?? LLVMValueRef();
	}

	func codegenIntrinsicCall(this: &&CGContext, intrinsic_name: String, parameter_types: &List!<LLVMTypeRef>, parameters: &List!<LLVMValueRef>) -> LLVMValueRef {
		const id = LLVMLookupIntrinsicID(intrinsic_name);
		const type = LLVMIntrinsicGetType(this.llvm_context, id, parameter_types);
		const declaration = LLVMGetIntrinsicDeclaration(this.llvm_module, id, parameter_types);

		return LLVMBuildCall2(this.builder, type, declaration, parameters, "");
	}

	func codegenLifeTimeStart(this: &&CGContext, address: LLVMValueRef) -> void {
		var parameters: List!<LLVMValueRef>;
		parameters.append(LLVMConstInt(this.int_type, 1, false));
		parameters.append(address);
		discard this.codegenIntrinsicCall("llvm.lifetime.start", List!<LLVMTypeRef>(1u, this.ptr_type), parameters);
	}

	func codegenLifeTimeEnd(this: &&CGContext, address: LLVMValueRef) -> void {
		var parameters: List!<LLVMValueRef>;
		parameters.append(LLVMConstInt(this.int_type, 1, false));
		parameters.append(address);
		discard this.codegenIntrinsicCall("llvm.lifetime.end", List!<LLVMTypeRef>(1u, this.ptr_type), parameters);
	}
}
