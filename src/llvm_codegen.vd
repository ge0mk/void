import std/core;
import std/format;
import std/list;
import std/io;
import std/map;
import std/range;
import std/set;
import std/shared_list;
import std/string;

import error;
import llvm_c;
import llvm_util;
import options;
import program;
import span;

struct CGContext {
	var program: &&Program;
	var llvm_context: Context;
	var llvm_module: Module;
	var data_layout: TargetDataRef;
	var di_builder: DIBuilderRef;

	var current_di_scope: MetaDataRef;

	var void_type: TypeRef;
	var bool_type: TypeRef;
	var byte_type: TypeRef;
	var int_type: TypeRef;
	var ptr_type: TypeRef;

	var builder: BuilderRef;
	var current_function: ValueRef;
	var variables: Map!<SharedHandle!<VarDecl>, ValueRef>;

	var break_target: BasicBlockRef;
	var continue_target: BasicBlockRef;
	var yield_target: BasicBlockRef;

	func constructor(this: &&CGContext, program: &&Program) -> void {
		this.program := &&program;
		this.llvm_context := program.llvm_context;
		this.llvm_module := program.llvm_module;
		this.data_layout := program.data_layout;
		this.di_builder := program.di_builder;

		this.void_type := this.llvm_context.getVoidType();
		this.bool_type := this.llvm_context.getIntType(1u);
		this.byte_type := this.llvm_context.getIntType(8u);
		this.int_type := this.llvm_context.getIntType(this.data_layout.getPointerSize() * 8);
		this.ptr_type := this.llvm_context.getPointerType(0u);
	}

	func destructor(this: &&CGContext) -> void = default;

	func error(this: &CGContext, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Error, ErrorStage::CodeGenerator, span));
	}

	func info(this: &CGContext, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Info, ErrorStage::CodeGenerator, span));
	}

	func todo(this: &CGContext, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Todo, ErrorStage::CodeGenerator, span));
	}

	func getType(this: &&CGContext, type: Type) -> TypeRef {
		if type.isUnknown() {
			return this.void_type;
		}

		match type.reference_kind {
			case None -> {
				if type.decl.llvm_type.handle == vptr::null() {
					this.codegenType(type.decl);

					if type.decl.llvm_type.handle == vptr::null() {
						panic("invalid codegen for type '" + type.signature() + "'");
					}
				}

				return type.decl.llvm_type;
			}
			else -> return this.ptr_type;
		}
	}

	func getDIType(this: &&CGContext, type: Type) -> MetaDataRef {
		if type.decl.llvm_di.handle == vptr::null() {
			this.codegenTypeDI(type.decl);

			if type.decl.llvm_di.handle == vptr::null() {
				panic("invalid debug info for type '" + type.signature() + "'");
			}
		}

		if type.reference_kind == None {
			return type.decl.llvm_di;
		} else {
			return this.di_builder.createReferenceType(dwarf::Tag::Reference_type, type.decl.llvm_di);
		}
	}

	func getVariable(this: &CGContext, variable: SharedHandle!<VarDecl>) -> ValueRef {
		const impl = this.variables.get(variable) else {
			panic("invalid codegen for variable '" + variable.name + "'");
		}

		return impl;
	}

	func getDebugLocation(this: &&CGContext, span: Span) -> MetaDataRef {
		return this.llvm_context.createDebugLocation(span.line as uint + 1, span.column as uint + 1, this.current_di_scope);
	}

	func setCurrentDebugLocation(this: &&CGContext, span: Span) -> void {
		if this.program.options.generate_debug_info {
			this.builder.setCurrentDebugLocation2(this.getDebugLocation(span));
		}
	}

	func getTypeName(this: &CGContext, type: SharedHandle!<TypeDecl>) -> String {
		var name = "";
		match this.program.options.symbol_type {
			case None -> {}
			case Name -> name = type.name;
			case Full -> name = type.signature();
		}

		return name;
	}

	func codegenType(this: &&CGContext, type: SharedHandle!<TypeDecl>) -> void {
		if type.isIncompleteTemplate() || type.llvm_type.handle != vptr::null() {
			return;
		}

		const name = this.getTypeName(type);

		match type.body {
			case Empty -> type.llvm_type = this.void_type;
			case Void -> type.llvm_type = this.void_type;
			case Bool -> type.llvm_type = this.bool_type;
			case Byte -> type.llvm_type = this.byte_type;
			case Int: bits -> {
				if bits == 0 {
					type.llvm_type = this.int_type;
				} else {
					type.llvm_type = this.llvm_context.getIntType(bits);
				}
			}
			case UInt: bits -> {
				if bits == 0 {
					type.llvm_type = this.int_type;
				} else {
					type.llvm_type = this.llvm_context.getIntType(bits);
				}
			}
			case Float: bits -> match bits {
				case 32 -> type.llvm_type = this.llvm_context.getFloatType();
				case 64 -> type.llvm_type = this.llvm_context.getDoubleType();
				else -> this.error("invalid size for float type: " + format(bits), type.span);
			}
			case Pointer | Function -> type.llvm_type = this.ptr_type;
			case Array: array_type -> type.llvm_type = this.llvm_context.getArrayType(this.getType(array_type.element_type), array_type.size);
			case Tuple | Struct -> {
				type.llvm_type = this.llvm_context.createNamedStruct(name);

				var element_types: List!<TypeRef>;
				for member_variable in type.member_variables {
					element_types.append(this.getType(member_variable.type));
				}

				type.llvm_type.setStructBody(element_types, type.is_packed);
			}
			case Enum -> type.llvm_type = this.getType(type.id_type);
			case Variant -> {
				type.llvm_type = this.llvm_context.createNamedStruct(name);

				var element_types: List!<TypeRef>;
				element_types.append(this.getType(type.id_type));

				var max_size = 0u;
				var max_alignment = 1u;

				for case_decl in type.variant_cases {
					if case_decl.type == this.program.void_type {
						continue;
					}

					var case_type = this.getType(case_decl.type);

					const current_size = this.data_layout.getStoreSizeOfType(case_type);
					if current_size > max_size {
						max_size = current_size;
					}

					const current_alignment = this.data_layout.getPreferredAlignmentOfType(case_type);
					if current_alignment > max_alignment {
						max_alignment = current_alignment;
					}
				}

				const max_alignment_type = this.llvm_context.getIntType(max_alignment * 8);
				element_types.append(this.llvm_context.getArrayType(max_alignment_type, max_size / max_alignment));

				for member_variable in type.member_variables {
					element_types.append(this.getType(member_variable.type));
				}

				type.llvm_type.setStructBody(element_types, type.is_packed);
			}
		}
	}

	func codegenTypeDI(this: &&CGContext, type: SharedHandle!<TypeDecl>) -> void {
		if type.isIncompleteTemplate() || type.llvm_di.handle != vptr::null() {
			return;
		}

		const line = type.name_span.line as uint;
		const di_file = this.program.files[type.span.file as uint].llvm_di_file;
		const parent_namespace = type.parent_namespace.llvm_di;

		const llvm_type = this.getType(Type(type));

		var size_in_bits = 0u;
		if llvm_type != this.void_type {
			size_in_bits = this.data_layout.getStoreSizeOfType(llvm_type) * 8;
		}

		var alignment_in_bits = 0u;
		if llvm_type != this.void_type {
			alignment_in_bits = this.data_layout.getPreferredAlignmentOfType(llvm_type) * 8;
		}

		const type_scope = type.linked_namespace.llvm_di;
		const di_name = type.name + type.template_parameters.format();

		match type.body {
			case Empty -> type.llvm_di = this.di_builder.createUnspecifiedType(di_name);
			case Void -> type.llvm_di = this.di_builder.createBasicType(di_name, size_in_bits, 0 as dwarf::TypeEncoding, LLVMDIFlags::LLVMDIFlagZero);
			case Bool -> type.llvm_di = this.di_builder.createBasicType(di_name, size_in_bits, dwarf::TypeEncoding::Boolean, LLVMDIFlags::LLVMDIFlagZero);
			case Byte -> type.llvm_di = this.di_builder.createBasicType(di_name, size_in_bits, dwarf::TypeEncoding::Unsigned_char, LLVMDIFlags::LLVMDIFlagZero);
			case Int -> type.llvm_di = this.di_builder.createBasicType(di_name, size_in_bits, dwarf::TypeEncoding::Signed, LLVMDIFlags::LLVMDIFlagZero);
			case UInt -> type.llvm_di = this.di_builder.createBasicType(di_name, size_in_bits, dwarf::TypeEncoding::Unsigned, LLVMDIFlags::LLVMDIFlagZero);
			case Float -> type.llvm_di = this.di_builder.createBasicType(di_name, size_in_bits, dwarf::TypeEncoding::Float, LLVMDIFlags::LLVMDIFlagZero);
			case Pointer: pointer_type -> {
				type.llvm_di = this.di_builder.createReplaceableCompositeType(dwarf::Tag::Unspecified_type, di_name, parent_namespace, di_file, line, 0u32, size_in_bits, alignment_in_bits, LLVMDIFlags::LLVMDIFlagZero, type.signature());

				const pointee_type = match pointer_type.pointee_type.isUnknown() {
					case true -> yield this.getDIType(this.program.void_type);
					case false -> yield this.getDIType(pointer_type.pointee_type);
				};

				const di_type = this.di_builder.createPointerType(pointee_type, size_in_bits, alignment_in_bits, 0u, di_name);

				type.llvm_di.replaceAllUsesWith(di_type);
				type.llvm_di = di_type;
			}
			case Function: function_type -> {
				var di_return_and_parameter_types: List!<MetaDataRef>;

				di_return_and_parameter_types.append(this.getDIType(function_type.return_type));
				for parameter_type in function_type.parameter_types {
					di_return_and_parameter_types.append(this.getDIType(parameter_type));
				}

				type.llvm_di = this.di_builder.createSubroutineType(
					this.program.files[type.span.file as uint].llvm_di_file,
					di_return_and_parameter_types,
					LLVMDIFlags::LLVMDIFlagZero
				);
			}
			case Array: array_type -> {
				type.llvm_di = this.di_builder.createReplaceableCompositeType(dwarf::Tag::Unspecified_type, di_name, parent_namespace, di_file, line, 0u32, size_in_bits, alignment_in_bits, LLVMDIFlags::LLVMDIFlagZero, type.signature());

				const di_type = this.di_builder.createArrayType(array_type.size, alignment_in_bits, this.getDIType(array_type.element_type), List!<MetaDataRef>());

				type.llvm_di.replaceAllUsesWith(di_type);
				type.llvm_di = di_type;
			}
			case Tuple | Struct | Variant -> {
				type.llvm_di = this.di_builder.createReplaceableCompositeType(dwarf::Tag::Unspecified_type, di_name, parent_namespace, di_file, line, 0u32, size_in_bits, alignment_in_bits, LLVMDIFlags::LLVMDIFlagZero, type.signature());

				var members: List!<MetaDataRef>;

				if type.body is Variant {
					var cases: List!<MetaDataRef>;
					var payload_members: List!<MetaDataRef>;
					for c in type.variant_cases {
						cases.append(this.di_builder.createEnumerator(c.name, c.id, true));

						if c.type == this.program.void_type {
							continue;
						}

						payload_members.append(this.di_builder.createMemberType(
							type_scope,
							c.name,
							di_file,
							c.span.line as uint,
							this.data_layout.getStoreSizeOfType(this.getType(c.type)) * 8,
							this.data_layout.getPreferredAlignmentOfType(this.getType(c.type)) * 8,
							0u,
							LLVMDIFlags::LLVMDIFlagZero,
							this.getDIType(c.type)
						));
					}

					const id_size_in_bits = this.data_layout.getStoreSizeOfType(this.getType(type.id_type)) * 8;
					const id_alignment_in_bits = this.data_layout.getPreferredAlignmentOfType(this.getType(type.id_type)) * 8;
					const id_offset_in_bits = this.data_layout.getOffsetOfElement(llvm_type, 0u) * 8;
					const id_type = this.di_builder.createEnumerationType(parent_namespace, di_name + "::Id", di_file, line, id_size_in_bits, id_alignment_in_bits, cases, this.getDIType(type.id_type));
					members.append(this.di_builder.createMemberType(
						type_scope,
						"#id",
						di_file,
						line,
						id_size_in_bits,
						id_alignment_in_bits,
						id_offset_in_bits,
						LLVMDIFlags::LLVMDIFlagZero,
						id_type
					));

					const payload_type_impl = llvm_type.structGetTypeAtIndex(1u);
					const payload_size_in_bits = this.data_layout.getStoreSizeOfType(payload_type_impl) * 8;
					const payload_alignment_in_bits = this.data_layout.getPreferredAlignmentOfType(payload_type_impl) * 8;
					const payload_offset_in_bits = this.data_layout.getOffsetOfElement(llvm_type, 1u) * 8;
					const payload_type = this.di_builder.createUnionType(type_scope, di_name + "::Payload", di_file, line, payload_size_in_bits, payload_alignment_in_bits, LLVMDIFlags::LLVMDIFlagZero, payload_members, 0u32, type.signature() + "::Payload");
					members.append(this.di_builder.createMemberType(
						type_scope,
						"#payload",
						di_file,
						line,
						payload_size_in_bits,
						payload_alignment_in_bits,
						payload_offset_in_bits,
						LLVMDIFlags::LLVMDIFlagZero,
						payload_type
					));
				}

				for i in 0u..type.member_variables.size() {
					const member_variable = type.member_variables[i];
					const member_type = this.getType(member_variable.type);
					if member_type == this.void_type {
						continue;
					}

					const member_di_type = this.getDIType(member_variable.type);

					const member_size_in_bits = this.data_layout.getStoreSizeOfType(llvm_type) * 8;
					const member_alignment_in_bits = this.data_layout.getPreferredAlignmentOfType(llvm_type) * 8;
					const member_offset_in_bits = this.data_layout.getOffsetOfElement(llvm_type, i + (2u if type.body is Variant else 0u)) * 8;

					members.append(this.di_builder.createMemberType(
						type_scope,
						member_variable.name,
						di_file,
						member_variable.span.line as uint,
						member_size_in_bits,
						member_alignment_in_bits,
						member_offset_in_bits,
						LLVMDIFlags::LLVMDIFlagZero,
						member_di_type
					));
				}

				const di_type = this.di_builder.createStructType(
					parent_namespace,
					di_name,
					di_file,
					line,
					size_in_bits,
					alignment_in_bits,
					LLVMDIFlags::LLVMDIFlagZero,
					MetaDataRef(),
					members,
					0u32,
					MetaDataRef(),
					type.signature()
				);

				type.llvm_di.replaceAllUsesWith(di_type);
				type.llvm_di = di_type;
			}
			case Enum -> {
				type.llvm_di = this.di_builder.createReplaceableCompositeType(dwarf::Tag::Unspecified_type, di_name, parent_namespace, di_file, line, 0u32, size_in_bits, alignment_in_bits, LLVMDIFlags::LLVMDIFlagZero, type.signature());

				var cases: List!<MetaDataRef>;
				for c in type.enum_cases {
					cases.append(this.di_builder.createEnumerator(c.name, c.id, true));
				}

				const di_type = this.di_builder.createEnumerationType(parent_namespace, di_name, di_file, line, size_in_bits, alignment_in_bits, cases, this.getDIType(type.id_type));

				type.llvm_di.replaceAllUsesWith(di_type);
				type.llvm_di = di_type;
			}
		}
	}

	func codegenFunctionDecl(this: &&CGContext, function: SharedHandle!<FunctionDecl>) -> void {
		if function.isIncompleteTemplate() || function.llvm_func.handle != vptr::null() {
			return;
		}

		if function.body is InlineBuiltin && this.program.options.dont_codegen_builtins {
			return;
		}

		var return_type = this.getType(function.return_type);
		var parameter_types: List!<TypeRef>;

		if function == this.program.main_function {
			parameter_types.append(this.ptr_type);
			parameter_types.append(this.int_type);
			return_type = this.int_type;
		} else {
			for type in function.parameter_types {
				parameter_types.append(this.getType(type));
			}
		}

		const function_type = this.llvm_context.getFunctionType(return_type, parameter_types, false);
		function.llvm_type = function_type;

		var name = "";
		match this.program.options.symbol_type {
			case None -> {}
			case Name -> name = function.name;
			case Full -> name = function.signature();
		}

		if function.extern_name != "" {
			name = function.extern_name;
		} else if function == this.program.main_function {
			name = "void_main";
		}

		function.llvm_func = this.llvm_module.addFunction(name, function_type);
	}

	func codegenFunctionBody(this: &&CGContext, function: SharedHandle!<FunctionDecl>) -> void {
		if function.isIncompleteTemplate() || function.has_errors {
			return;
		}

		match function.body {
			case Empty | Extern -> return;
			case InlineBuiltin -> {
				if this.program.options.dont_codegen_builtins {
					return;
				}
			}
			case Unchecked -> {
				this.error("unchecked function: " + function.signature(), function.signature_span);
				return;
			}
			else -> {}
		}

		if function.llvm_func.handle == vptr::null() {
			this.error("function decl for " + function.signature() + " not yet built", function.signature_span);
			return;
		}

		if function.llvm_func.countBasicBlocks() > 0 {
			this.error("function body for " + function.signature() + " already built", function.signature_span);
			return;
		}

		const prev_di_scope = this.current_di_scope;
		const prev_builder = this.builder;
		const prev_function = this.current_function;
		const prev_variables = this.variables;

		this.variables.clear();
		this.current_function = function.llvm_func;

		// setup debug info for the function
		if this.program.options.generate_debug_info {
			var di_return_and_parameter_types: List!<MetaDataRef>;

			di_return_and_parameter_types.append(this.getDIType(function.return_type));
			for parameter_type in function.parameter_types {
				di_return_and_parameter_types.append(this.getDIType(parameter_type));
			}

			const di_function_type = this.di_builder.createSubroutineType(
				this.program.files[function.span.file as uint].llvm_di_file,
				di_return_and_parameter_types,
				LLVMDIFlags::LLVMDIFlagZero
			);

			const di_namespace = function.parent_namespace.llvm_di;
			const di_name = function.name + function.template_parameters.format();

			function.llvm_di = this.di_builder.createFunction(
				di_namespace,
				di_name,
				function.extern_name,
				this.program.files[function.span.file as uint].llvm_di_file,
				function.signature_span.line as uint + 1,
				di_function_type,
				false, 		// is local to unit
				true,		// is definition
				function.signature_span.line as uint + 1,
				LLVMDIFlags::LLVMDIFlagZero,
				this.program.options.optimized_build
			);

			function.llvm_func.setSubprogram(function.llvm_di);
			this.current_di_scope = function.llvm_di;
		}

		this.builder = this.llvm_context.createBuilder();
		const entry_block = this.llvm_context.appendBasicBlock(this.current_function, "");
		this.builder.positionAtEnd(entry_block);

		// initialize function parameters & variables
		if function.body is Stmt {
			for variable in function.variables {
				if variable.type.isUnknown() {
					this.error("variable '" + variable.name + "' has unknown type", variable.span);
					continue;
				}

				if variable.is_parameter {
					if function == this.program.main_function {
						var args = constNull(this.getType(function.parameter_types[0u]));
						args = this.builder.buildInsertValue(args, this.current_function.getParam(0u), 0u, "");
						args = this.builder.buildInsertValue(args, this.current_function.getParam(1u), 1u, "");
						this.variables.set(variable, args);
					} else {
						const parameter = this.current_function.getParam(variable.id);
						this.variables.set(variable, parameter);

						if this.program.options.generate_debug_info {
							const di_variable = this.di_builder.createParameterVariable(
								this.current_di_scope,
								variable.name,
								variable.id + 1, // ArgNo starts counting at 1
								this.program.files[function.span.file as uint].llvm_di_file,
								variable.span.line as uint,
								this.getDIType(variable.type),
								false,
								LLVMDIFlags::LLVMDIFlagZero
							);

							this.di_builder.insertDeclareAtEnd(
								parameter,
								di_variable,
								this.di_builder.createExpression(vptr!<u64>::null(), 0u),
								this.getDebugLocation(variable.span),
								entry_block
							);
						}
					}
				} else {
					this.setCurrentDebugLocation(variable.span);
					const address = this.builder.buildAlloca(this.getType(variable.type), variable.name);
					this.variables.set(variable, address);

					if this.program.options.generate_debug_info {
						var alignment_in_bits = this.data_layout.getPreferredAlignmentOfType(this.getType(variable.type));

						const di_variable = this.di_builder.createAutoVariable(
							this.current_di_scope,
							variable.name,
							this.program.files[function.span.file as uint].llvm_di_file,
							variable.span.line as uint,
							this.getDIType(variable.type),
							false,
							LLVMDIFlags::LLVMDIFlagZero,
							alignment_in_bits
						);

						this.di_builder.insertDeclareAtEnd(
							address,
							di_variable,
							this.di_builder.createExpression(vptr!<u64>::null(), 0u),
							this.getDebugLocation(variable.span),
							entry_block
						);
					}

					this.builder.setCurrentDebugLocation2(MetaDataRef());
				}
			}
		}

		// codegen body
		match function.body {
			case InlineBuiltin: builtin_funcion -> {
				var parameters: List!<ValueRef>;
				for i in 0u..this.current_function.countParams() {
					parameters.append(this.current_function.getParam(i));
				}

				this.builder.buildRet(this.codegenInlineBuiltinFunctionCall(builtin_funcion, parameters));
			}
			case Builtin: builtin_funcion -> this.codegenBuiltinFunction(builtin_funcion, function.signature_span);
			case Stmt: stmt -> this.codegenStmt(stmt);
			else -> panic("invalid function body for codegen");
		}

		if !this.builder.getInsertBlock().hasTerminator() {
			if function == this.program.main_function {
				this.builder.buildRet(constInt(this.int_type, 0, false));
			} else if function.return_type == this.program.void_type {
				this.builder.buildRetVoid();
			} else {
				panic("function doesn't have a terminator");
			}
		}

		if this.program.options.generate_debug_info {
			this.di_builder.finalizeSubprogram(function.llvm_di);
		}

		this.builder.dispose();

		this.current_di_scope = prev_di_scope;
		this.builder = prev_builder;
		this.current_function = prev_function;
		this.variables = prev_variables;
	}

	func codegenBuiltinFunction(this: &&CGContext, function: BuiltinFunction, signature_span: Span) -> void {
		const type = this.getType(function.base_type);
		const decl = function.base_type.decl;

		const param0 = this.current_function.getParam(0u);
		const param1 = this.current_function.getParam(1u);

		match function {
			case StructValueConstructor -> {
				for i in 0u..decl.member_variables.size() {
					const member_ptr = this.builder.buildStructGEP2(type, param0, i, "");
					const member_type = decl.member_variables[i].type.decl;

					var parameters: List!<ValueRef>;
					parameters.append(member_ptr);
					parameters.append(this.current_function.getParam(i + 1));

					discard this.codegenCall(member_type.copy_constructor, parameters, ReturnKind::None, signature_span);
				}

				this.builder.buildRetVoid();
			}
			case StructDefaultConstructor -> {
				for i in 0u..decl.member_variables.size() {
					const member_ptr = this.builder.buildStructGEP2(type, param0, i, "");
					const member_type = decl.member_variables[i].type.decl;

					var parameters: List!<ValueRef>;
					parameters.append(member_ptr);

					discard this.codegenCall(member_type.default_constructor, parameters, ReturnKind::None, signature_span);
				}

				this.builder.buildRetVoid();
			}
			case StructCopyConstructor -> {
				for i in 0u..decl.member_variables.size() {
					const member_ptr = this.builder.buildStructGEP2(type, param0, i, "");
					const initializer = this.builder.buildExtractValue(param1, i, "");

					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;

						var parameters: List!<ValueRef>;
						parameters.append(member_ptr);
						parameters.append(initializer);

						discard this.codegenCall(member_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						this.builder.buildStore(initializer, member_ptr);
					}
				}

				this.builder.buildRetVoid();
			}
			case StructDestructor -> {
				for i in 0u..decl.member_variables.size() {
					if decl.member_variables[i].type.reference_kind != None {
						continue;
					}

					const member_ptr = this.builder.buildStructGEP2(type, param0, i, "");
					const member_type = decl.member_variables[i].type.decl;

					var parameters: List!<ValueRef>;
					parameters.append(member_ptr);

					discard this.codegenCall(member_type.destructor, parameters, ReturnKind::None, signature_span);
				}

				this.builder.buildRetVoid();
			}
			case StructOpAssign -> {
				for i in 0u..decl.member_variables.size() {
					const member_ptr = this.builder.buildStructGEP2(type, param0, i, "");
					const initializer = this.builder.buildExtractValue(param1, i, "");

					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;

						var parameters: List!<ValueRef>;
						parameters.append(member_ptr);
						parameters.append(initializer);

						discard this.codegenCall(member_type.op_assign, parameters, ReturnKind::None, signature_span);
					} else {
						this.builder.buildStore(initializer, member_ptr);
					}
				}

				this.builder.buildRetVoid();
			}
			case VariantCaseConstructor: case_id -> {
				const id_type = this.getType(decl.id_type);
				const id_ptr = this.builder.buildStructGEP2(type, param0, 0u, "");
				this.builder.buildStore(constInt(id_type, case_id, false), id_ptr);

				var member_var_param_offset = 1u;	// first param is this

				const case_decl = decl.getVariantCase(case_id).value();
				if case_decl.type != this.program.void_type {
					member_var_param_offset += 1;	// payload is passed before member variables

					const this_payload_ptr = this.builder.buildStructGEP2(type, param0, 1u, "");
					const initializer = param1;

					if case_decl.type.reference_kind == None {
						const case_type = case_decl.type.decl;

						var parameters: List!<ValueRef>;
						parameters.append(this_payload_ptr);
						parameters.append(initializer);

						discard this.codegenCall(case_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						this.builder.buildStore(initializer, this_payload_ptr);
					}
				}

				for i in 0u..decl.member_variables.size() {
					const this_member_ptr = this.builder.buildStructGEP2(type, param0, i + 2, "");
					const initializer = this.current_function.getParam(i + member_var_param_offset);

					if decl.member_variables[i].type.reference_kind == None {
						var parameters: List!<ValueRef>;
						parameters.append(this_member_ptr);
						parameters.append(initializer);

						const member_type = decl.member_variables[i].type.decl;

						discard this.codegenCall(member_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						this.builder.buildStore(initializer, this_member_ptr);
					}
				}

				this.builder.buildRetVoid();
			}
			case VariantCopyConstructor -> {
				const id_type = this.getType(decl.id_type);
				const id_ptr = this.builder.buildStructGEP2(type, param0, 0u, "");
				const this_payload_ptr = this.builder.buildStructGEP2(type, param0, 1u, "");

				const other_payload_ptr = this.builder.buildAlloca(type.structGetTypeAtIndex(1u), "");
				this.builder.buildStore(this.builder.buildExtractValue(param1, 1u, ""), other_payload_ptr);

				const other_id = this.builder.buildExtractValue(param1, 0u, "");
				this.builder.buildStore(other_id, id_ptr);

				const cont_block = this.llvm_context.appendBasicBlock(this.current_function, "cont");

				var case_count = 0u;
				for case_decl in decl.variant_cases {
					if case_decl.type != this.program.void_type {
						case_count++;
					}
				}

				var switch_instr = this.builder.buildSwitch(other_id, cont_block, case_count);

				for case_decl in decl.variant_cases {
					if case_decl.type == this.program.void_type {
						continue;
					}

					const case_block = this.llvm_context.appendBasicBlock(this.current_function, "case");
					switch_instr.addCase(constInt(id_type, case_decl.id, false), case_block);
					this.builder.positionAtEnd(case_block);

					const other_payload = this.builder.buildLoad2(this.getType(case_decl.type), other_payload_ptr, "");

					if case_decl.type.reference_kind == None {
						const case_type = case_decl.type.decl;
						var parameters: List!<ValueRef>;
						parameters.append(this_payload_ptr);
						parameters.append(other_payload);

						discard this.codegenCall(case_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						this.builder.buildStore(other_payload, this_payload_ptr);
					}

					this.builder.buildBr(cont_block);
				}

				this.builder.positionAtEnd(cont_block);

				for i in 0u..decl.member_variables.size() {
					const this_member_ptr = this.builder.buildStructGEP2(type, param0, i + 2, "");
					const other_member = this.builder.buildExtractValue(param1, i + 2, "");

					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;

						var parameters: List!<ValueRef>;
						parameters.append(this_member_ptr);
						parameters.append(other_member);

						discard this.codegenCall(member_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						this.builder.buildStore(other_member, this_member_ptr);
					}
				}

				this.builder.buildRetVoid();
			}
			case VariantDestructor -> {
				const id_type = this.getType(decl.id_type);
				const id_ptr = this.builder.buildStructGEP2(type, param0, 0u, "");
				const this_id = this.builder.buildLoad2(id_type, id_ptr, "");
				const this_payload_ptr = this.builder.buildStructGEP2(type, param0, 1u, "");

				var case_destructor_args: List!<ValueRef>;
				case_destructor_args.append(this_payload_ptr);

				const cont_block = this.llvm_context.appendBasicBlock(this.current_function, "cont");

				var case_count = 0u;
				for case_decl in decl.variant_cases {
					if case_decl.type != this.program.void_type && case_decl.type.reference_kind == None {
						case_count++;
					}
				}
				var switch_instr = this.builder.buildSwitch(this_id, cont_block, case_count);

				for case_decl in decl.variant_cases {
					if case_decl.type == this.program.void_type || case_decl.type.reference_kind != None {
						continue;
					}

					const case_block = this.llvm_context.appendBasicBlock(this.current_function, "case");
					switch_instr.addCase(constInt(id_type, case_decl.id, false), case_block);
					this.builder.positionAtEnd(case_block);

					const case_type = case_decl.type.decl;

					discard this.codegenCall(case_type.destructor, case_destructor_args, ReturnKind::None, signature_span);

					this.builder.buildBr(cont_block);
				}

				this.builder.positionAtEnd(cont_block);

				for i in 0u..decl.member_variables.size() {
					if decl.member_variables[i].type.reference_kind != None {
						continue;
					}

					const member_type = decl.member_variables[i].type.decl;

					var parameters: List!<ValueRef>;
					parameters.append(this.builder.buildStructGEP2(type, param0, i + 2, ""));

					discard this.codegenCall(member_type.destructor, parameters, ReturnKind::None, signature_span);
				}

				this.builder.buildRetVoid();
			}
			case VariantOpAssign -> {
				const id_type = this.getType(decl.id_type);
				const payload_type = type.structGetTypeAtIndex(1u);

				const id_ptr = this.builder.buildStructGEP2(type, param0, 0u, "");
				const this_id = this.builder.buildLoad2(id_type, id_ptr, "");
				const this_payload_ptr = this.builder.buildStructGEP2(type, param0, 1u, "");

				const other_payload_ptr = this.builder.buildAlloca(payload_type, "");
				this.builder.buildStore(this.builder.buildExtractValue(param1, 1u, ""), other_payload_ptr);
				const other_id = this.builder.buildExtractValue(param1, 0u, "");

				const payload_copy_ptr = this.builder.buildAlloca(type.structGetTypeAtIndex(1u), "");

				var copy_case_count = 0u;
				var dest_case_count = 0u;
				for case_decl in decl.variant_cases {
					if case_decl.type != this.program.void_type {
						copy_case_count++;

						if case_decl.type.reference_kind == None {
							dest_case_count++;
						}
					}
				}

				// copy payload to temporary
				const dest_block = this.llvm_context.appendBasicBlock(this.current_function, "cont");

				var copy_switch_instr = this.builder.buildSwitch(other_id, dest_block, copy_case_count);

				for case_decl in decl.variant_cases {
					if case_decl.type == this.program.void_type {
						continue;
					}

					const case_block = this.llvm_context.appendBasicBlock(this.current_function, "case");
					copy_switch_instr.addCase(constInt(id_type, case_decl.id, false), case_block);
					this.builder.positionAtEnd(case_block);

					const other_payload = this.builder.buildLoad2(this.getType(case_decl.type), other_payload_ptr, "");

					if case_decl.type.reference_kind == None {
						const case_type = case_decl.type.decl;
						var parameters: List!<ValueRef>;
						parameters.append(payload_copy_ptr);
						parameters.append(other_payload);

						discard this.codegenCall(case_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						this.builder.buildStore(other_payload, payload_copy_ptr);
					}

					this.builder.buildBr(dest_block);
				}

				this.builder.positionAtEnd(dest_block);

				// destruct old payload
				var case_destructor_args: List!<ValueRef>;
				case_destructor_args.append(this_payload_ptr);

				const cont_block = this.llvm_context.appendBasicBlock(this.current_function, "cont");

				var switch_instr = this.builder.buildSwitch(this_id, cont_block, dest_case_count);

				for case_decl in decl.variant_cases {
					if case_decl.type == this.program.void_type || case_decl.type.reference_kind != None {
						continue;
					}

					const case_type = case_decl.type.decl;

					const case_block = this.llvm_context.appendBasicBlock(this.current_function, "case");
					switch_instr.addCase(constInt(id_type, case_decl.id, false), case_block);
					this.builder.positionAtEnd(case_block);

					discard this.codegenCall(case_type.destructor, case_destructor_args, ReturnKind::None, signature_span);

					this.builder.buildBr(cont_block);
				}

				this.builder.positionAtEnd(cont_block);

				// move temporary payload to this
				this.builder.buildStore(
					this.builder.buildLoad2(payload_type, payload_copy_ptr, ""),
					this_payload_ptr
				);
				this.builder.buildStore(other_id, id_ptr);

				// assign member variables
				for i in 0u..decl.member_variables.size() {
					const member_ptr = this.builder.buildStructGEP2(type, param0, i + 2, "");
					const initializer = this.builder.buildExtractValue(param1, i + 2, "");

					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;

						var parameters: List!<ValueRef>;
						parameters.append(member_ptr);
						parameters.append(initializer);

						discard this.codegenCall(member_type.op_assign, parameters, ReturnKind::None, signature_span);
					} else {
						this.builder.buildStore(initializer, member_ptr);
					}
				}

				this.builder.buildRetVoid();
			}
			case StructOpEqual
			| VariantOpEqual -> {
				const uneq_block = this.llvm_context.appendBasicBlock(this.current_function, "uneq");

				if function is VariantOpEqual {
					const id_type = this.getType(decl.id_type);
					const data_block = this.llvm_context.appendBasicBlock(this.current_function, "data");

					// store lhs & rhs on stack to access the payload in a safe way
					const lhs_id = this.builder.buildExtractValue(param0, 0u, "");
					const lhs_data = this.builder.buildAlloca(type, "");
					this.builder.buildStore(param0, lhs_data);
					const lhs_payload_ptr = this.builder.buildStructGEP2(type, lhs_data, 1u, "");

					const rhs_id = this.builder.buildExtractValue(param1, 0u, "");
					const rhs_data = this.builder.buildAlloca(type, "");
					this.builder.buildStore(param1, rhs_data);
					const rhs_payload_ptr = this.builder.buildStructGEP2(type, rhs_data, 1u, "");

					const same_id = this.builder.buildICmp(LLVMIntPredicate::LLVMIntEQ, lhs_id, rhs_id, "");
					this.builder.buildCondBr(same_id, data_block, uneq_block);

					this.builder.positionAtEnd(data_block);

					const cont_block = this.llvm_context.appendBasicBlock(this.current_function, "cont");

					var case_count = 0u;
					for case_decl in decl.variant_cases {
						if case_decl.type != this.program.void_type {
							case_count++;
						}
					}
					var switch_instr = this.builder.buildSwitch(lhs_id, cont_block, case_count);

					for case_decl in decl.variant_cases {
						if case_decl.type == this.program.void_type {
							continue;
						}

						const case_block = this.llvm_context.appendBasicBlock(this.current_function, "case")
						switch_instr.addCase(constInt(id_type, case_decl.id, false), case_block);
						this.builder.positionAtEnd(case_block);

						const lhs = this.builder.buildLoad2(this.getType(case_decl.type), lhs_payload_ptr, "");
						const rhs = this.builder.buildLoad2(this.getType(case_decl.type), rhs_payload_ptr, "");

						var equal = ValueRef();
						if case_decl.type.reference_kind == None {
							const case_type = case_decl.type.decl;
							var parameters: List!<ValueRef>;
							parameters.append(lhs);
							parameters.append(rhs);

							equal = this.codegenCall(case_type.op_equal, parameters, ReturnKind::Value, signature_span);
						} else {
							equal = this.builder.buildICmp(LLVMIntPredicate::LLVMIntEQ, lhs, rhs, "");
						}

						this.builder.buildCondBr(equal, cont_block, uneq_block);
					}

					this.builder.positionAtEnd(cont_block);
				}

				const member_var_offset = 2u if function is VariantOpEqual else 0u;
				for i in 0u..decl.member_variables.size() {
					const lhs = this.builder.buildExtractValue(param0, i + member_var_offset, "");
					const rhs = this.builder.buildExtractValue(param1, i + member_var_offset, "");

					var equal = ValueRef();
					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;
						var parameters: List!<ValueRef>;
						parameters.append(lhs);
						parameters.append(rhs);

						equal = this.codegenCall(member_type.op_equal, parameters, ReturnKind::Value, signature_span);
					} else {
						equal = this.builder.buildICmp(LLVMIntPredicate::LLVMIntEQ, lhs, rhs, "");
					}

					const next_block = this.llvm_context.appendBasicBlock(this.current_function, "next");

					this.builder.buildCondBr(equal, next_block, uneq_block);
					this.builder.positionAtEnd(next_block);
				}

				this.builder.buildRet(constInt(this.bool_type, 1, false));

				this.builder.positionAtEnd(uneq_block);
				this.builder.buildRet(constInt(this.bool_type, 0, false));
			}
			case StructOpCmp -> {
				const entry_block = this.builder.getInsertBlock();
				const uneq_block = this.llvm_context.appendBasicBlock(this.current_function, "uneq");

				var cmp_values: List!<ValueRef>;
				var cmp_blocks: List!<BasicBlockRef>;

				for i in 0u..decl.member_variables.size() {
					const lhs = this.builder.buildExtractValue(param0, i, "");
					const rhs = this.builder.buildExtractValue(param1, i, "");
					var parameters: List!<ValueRef>;
					parameters.append(lhs);
					parameters.append(rhs);

					var sign = ValueRef();
					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;
						sign = this.codegenCall(member_type.op_compare, parameters, ReturnKind::Value, signature_span);
					} else {
						sign = this.codegenInlineBuiltinFunctionCall(InlineBuiltinFunction::UIntOpCmp(decl.member_variables[i].type), parameters);
					}
					cmp_values.append(sign);
					cmp_blocks.append(this.builder.getInsertBlock());

					const next_block = this.llvm_context.appendBasicBlock(this.current_function, "next");

					const equal = this.builder.buildICmp(LLVMIntPredicate::LLVMIntEQ, sign, constInt(this.int_type, 0, false), "");
					this.builder.buildCondBr(equal, next_block, uneq_block);
					this.builder.positionAtEnd(next_block);
				}

				this.builder.buildRet(constInt(this.int_type, 0, false));

				this.builder.positionAtEnd(uneq_block);
				var phi = this.builder.buildPhi(this.int_type, "");
				phi.addIncoming(cmp_values, cmp_blocks);
				this.builder.buildRet(phi);
			}
			case ArrayDefaultConstructor -> {
				// TODO: turn into a loop for better code size (llvm can unroll it for performance)
				const array_type = (decl.body as Array).value();
				const element_type = array_type.element_type;
				const element_type_decl = element_type.decl;

				for i in 0u..array_type.size {
					var indices: List!<ValueRef>;
					indices.append(constInt(this.int_type, 0, false));
					indices.append(constInt(this.int_type, i as int, false));
					const element_ptr = this.builder.buildGEP2(type, param0, indices, "");

					discard this.codegenCall(element_type_decl.default_constructor, List!<ValueRef>(1u, element_ptr), ReturnKind::None, signature_span);
				}

				this.builder.buildRetVoid();
			}
			case ArrayCopyConstructor
			| ArrayDestructor
			| ArrayOpAssign -> {
				// TODO: turn into a loop for better code size (llvm can unroll it for performance)
				const array_type = (decl.body as Array).value();
				const element_type = array_type.element_type;
				const element_type_decl = element_type.decl;

				for i in 0u..array_type.size {
					var indices: List!<ValueRef>;
					indices.append(constInt(this.int_type, 0, false));
					indices.append(constInt(this.int_type, i as int, false));
					const element_ptr = this.builder.buildGEP2(type, param0, indices, "");

					if !(function is ArrayCopyConstructor) {
						discard this.codegenCall(element_type_decl.destructor, List!<ValueRef>(1u, element_ptr), ReturnKind::None, signature_span);
					}

					if !(function is ArrayDestructor) {
						const other_element = this.builder.buildExtractValue(param1, i, "");

						var parameters: List!<ValueRef>;
						parameters.append(element_ptr);
						parameters.append(other_element);

						discard this.codegenCall(element_type_decl.copy_constructor, parameters, ReturnKind::None, signature_span);
					}
				}

				this.builder.buildRetVoid();
			}
			case ArrayOpEqual -> {
				// TODO: turn into a loop for better code size (llvm can unroll it for performance)
				const array_type = (decl.body as Array).value();
				const element_type = array_type.element_type;
				const element_type_decl = element_type.decl;

				const uneq_block = this.llvm_context.appendBasicBlock(this.current_function, "uneq");

				for i in 0u..array_type.size {
					const lhs = this.builder.buildExtractValue(param0, i, "");
					const rhs = this.builder.buildExtractValue(param1, i, "");

					var equal = ValueRef();
					if element_type.reference_kind == None {
						var parameters: List!<ValueRef>;
						parameters.append(lhs);
						parameters.append(rhs);

						equal = this.codegenCall(element_type_decl.op_equal, parameters, ReturnKind::Value, signature_span);
					} else {
						equal = this.builder.buildICmp(LLVMIntPredicate::LLVMIntEQ, lhs, rhs, "");
					}

					const next_block = this.llvm_context.appendBasicBlock(this.current_function, "next");

					this.builder.buildCondBr(equal, next_block, uneq_block);
					this.builder.positionAtEnd(next_block);
				}

				this.builder.buildRet(constInt(this.bool_type, 1, false));

				this.builder.positionAtEnd(uneq_block);
				this.builder.buildRet(constInt(this.bool_type, 0, false));
			}
		}
	}

	func codegenInlineBuiltinFunctionCall(this: &&CGContext, function: InlineBuiltinFunction, parameters: &List!<ValueRef>) -> ValueRef {
		match function {
			case NoOp -> return ValueRef();

			case BitStoreNull -> {
				this.builder.buildStore(constNull(this.getType(function.base_type)), parameters[0u]);
				return ValueRef();
			}
			case BitStoreValue -> {
				this.builder.buildStore(parameters[1u], parameters[0u]);
				return ValueRef();
			}

			case BitOpEQ -> return this.builder.buildICmp(LLVMIntPredicate::LLVMIntEQ, parameters[0u], parameters[1u], "");
			case BitOpNE -> return this.builder.buildICmp(LLVMIntPredicate::LLVMIntNE, parameters[0u], parameters[1u], "");

			case BitOpAnd -> return this.builder.buildAnd(parameters[0u], parameters[1u], "");
			case BitOpOr -> return this.builder.buildOr(parameters[0u], parameters[1u], "");
			case BitOpXOr -> return this.builder.buildXor(parameters[0u], parameters[1u], "");
			case BitOpNot -> return this.builder.buildNot(parameters[0u], "");
			case BitOpShl -> return this.builder.buildShl(parameters[0u], parameters[1u], "");
			case BitOpLShr -> return this.builder.buildLShr(parameters[0u], parameters[1u], "");
			case BitOpAShr -> return this.builder.buildAShr(parameters[0u], parameters[1u], "");

			case BitOpAndAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildAnd(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return ValueRef();
			}
			case BitOpOrAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildOr(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return ValueRef();
			}
			case BitOpXOrAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildXor(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return ValueRef();
			}
			case BitOpShlAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildShl(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return ValueRef();
			}
			case BitOpLShrAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildLShr(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return ValueRef();
			}
			case BitOpAShrAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildAShr(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return ValueRef();
			}

			case IntOpAdd -> return this.builder.buildAdd(parameters[0u], parameters[1u], "");
			case IntOpSub -> return this.builder.buildSub(parameters[0u], parameters[1u], "");
			case IntOpMul -> return this.builder.buildMul(parameters[0u], parameters[1u], "");
			case IntOpNeg -> return this.builder.buildNeg(parameters[0u], "");

			case IntOpInc -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildAdd(lhs, constInt(type, 1, false), "");
				this.builder.buildStore(result, parameters[0u]);
				return ValueRef();
			}
			case IntOpDec -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildSub(lhs, constInt(type, 1, false), "");
				this.builder.buildStore(result, parameters[0u]);
				return ValueRef();
			}

			case IntOpAddAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildAdd(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return ValueRef();
			}
			case IntOpSubAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildSub(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return ValueRef();
			}
			case IntOpMulAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildMul(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return ValueRef();
			}

			case SIntOpLT -> return this.builder.buildICmp(LLVMIntPredicate::LLVMIntSLT, parameters[0u], parameters[1u], "");
			case SIntOpLE -> return this.builder.buildICmp(LLVMIntPredicate::LLVMIntSLE, parameters[0u], parameters[1u], "");
			case SIntOpGT -> return this.builder.buildICmp(LLVMIntPredicate::LLVMIntSGT, parameters[0u], parameters[1u], "");
			case SIntOpGE -> return this.builder.buildICmp(LLVMIntPredicate::LLVMIntSGE, parameters[0u], parameters[1u], "");
			case SIntOpCmp -> return this.builder.buildSub(
				this.builder.buildZExt(this.builder.buildICmp(LLVMIntPredicate::LLVMIntSGT, parameters[0u], parameters[1u], ""), this.int_type, ""),
				this.builder.buildZExt(this.builder.buildICmp(LLVMIntPredicate::LLVMIntSLT, parameters[0u], parameters[1u], ""), this.int_type, ""), ""
			);

			case SIntOpDiv -> return this.builder.buildSDiv(parameters[0u], parameters[1u], "");
			case SIntOpMod -> return this.builder.buildSRem(parameters[0u], parameters[1u], "");

			case SIntOpDivAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildSDiv(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return ValueRef();
			}
			case SIntOpModAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildSRem(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return ValueRef();
			}

			case UIntOpLT -> return this.builder.buildICmp(LLVMIntPredicate::LLVMIntULT, parameters[0u], parameters[1u], "");
			case UIntOpLE -> return this.builder.buildICmp(LLVMIntPredicate::LLVMIntULE, parameters[0u], parameters[1u], "");
			case UIntOpGT -> return this.builder.buildICmp(LLVMIntPredicate::LLVMIntUGT, parameters[0u], parameters[1u], "");
			case UIntOpGE -> return this.builder.buildICmp(LLVMIntPredicate::LLVMIntUGE, parameters[0u], parameters[1u], "");
			case UIntOpCmp -> return this.builder.buildSub(
				this.builder.buildZExt(this.builder.buildICmp(LLVMIntPredicate::LLVMIntUGT, parameters[0u], parameters[1u], ""), this.int_type, ""),
				this.builder.buildZExt(this.builder.buildICmp(LLVMIntPredicate::LLVMIntULT, parameters[0u], parameters[1u], ""), this.int_type, ""), ""
			);

			case UIntOpDiv -> return this.builder.buildUDiv(parameters[0u], parameters[1u], "");
			case UIntOpMod -> return this.builder.buildURem(parameters[0u], parameters[1u], "");

			case UIntOpDivAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildUDiv(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return ValueRef();
			}
			case UIntOpModAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildURem(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return ValueRef();
			}

			case FloatOpEQ -> return this.builder.buildFCmp(LLVMRealPredicate::LLVMRealOEQ, parameters[0u], parameters[1u], "");
			case FloatOpNE -> return this.builder.buildFCmp(LLVMRealPredicate::LLVMRealONE, parameters[0u], parameters[1u], "");
			case FloatOpLT -> return this.builder.buildFCmp(LLVMRealPredicate::LLVMRealOLT, parameters[0u], parameters[1u], "");
			case FloatOpLE -> return this.builder.buildFCmp(LLVMRealPredicate::LLVMRealOLE, parameters[0u], parameters[1u], "");
			case FloatOpGT -> return this.builder.buildFCmp(LLVMRealPredicate::LLVMRealOGT, parameters[0u], parameters[1u], "");
			case FloatOpGE -> return this.builder.buildFCmp(LLVMRealPredicate::LLVMRealOGE, parameters[0u], parameters[1u], "");
			case FloatOpCmp -> return this.builder.buildSub(
				this.builder.buildZExt(this.builder.buildFCmp(LLVMRealPredicate::LLVMRealOGT, parameters[0u], parameters[1u], ""), this.int_type, ""),
				this.builder.buildZExt(this.builder.buildFCmp(LLVMRealPredicate::LLVMRealOLT, parameters[0u], parameters[1u], ""), this.int_type, ""), ""
			);

			case FloatOpAdd -> return this.builder.buildFAdd(parameters[0u], parameters[1u], "");
			case FloatOpSub -> return this.builder.buildFSub(parameters[0u], parameters[1u], "");
			case FloatOpMul -> return this.builder.buildFMul(parameters[0u], parameters[1u], "");
			case FloatOpDiv -> return this.builder.buildFDiv(parameters[0u], parameters[1u], "");
			case FloatOpMod -> return this.builder.buildFRem(parameters[0u], parameters[1u], "");
			case FloatOpNeg -> return this.builder.buildFNeg(parameters[0u], "");

			case FloatOpAddAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildFAdd(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return ValueRef();
			}
			case FloatOpSubAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildFSub(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return ValueRef();
			}
			case FloatOpMulAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildFMul(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return ValueRef();
			}
			case FloatOpDivAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildFDiv(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return ValueRef();
			}
			case FloatOpModAssign -> {
				const type = this.getType(function.base_type);
				const lhs = this.builder.buildLoad2(type, parameters[0u], "");
				const result = this.builder.buildFRem(lhs, parameters[1u], "");
				this.builder.buildStore(result, parameters[0u]);
				return ValueRef();
			}

			case PointerGetNull -> return constNull(this.getType(function.base_type));
			case PointerToRef -> return parameters[0u];	// reference & pointer types are the same in llvm
			case RefToPointer -> return parameters[0u];	// reference & pointer types are the same in llvm
			case PointerCast -> return parameters[0u];	// all pointer types are the same in llvm

			case PointerDiff -> {
				const pointer_type = (function.base_type.decl.body as Pointer).value();
				const pointee_type = this.getType(pointer_type.pointee_type);
				return this.builder.buildPtrDiff2(pointee_type, parameters[0u], parameters[1u], "");
			}
			case PointerOffset
			| PointerOpIndex -> {
				const pointer_type = (function.base_type.decl.body as Pointer).value();
				const pointee_type = this.getType(pointer_type.pointee_type);

				var indices: List!<ValueRef>;
				indices.append(parameters[1u]);
				return this.builder.buildGEP2(pointee_type, parameters[0u], indices, "");
			}

			case FunctionPointerCall -> {
				const function_type = (function.base_type.decl.body as Function).value();

				const return_type = this.getType(function_type.return_type);
				var parameter_types: List!<TypeRef>;
				for p in function_type.parameter_types {
					parameter_types.append(this.getType(p));
				}
				const llvm_function_type = this.llvm_context.getFunctionType(return_type, parameter_types, false);

				const call_parameters = List!<ValueRef>(parameters[1u..parameters.size()]);
				return this.builder.buildCall2(llvm_function_type, parameters[0u], call_parameters, "");
			}

			case IntCast: target -> {
				const source_type = this.getType(function.base_type);
				const target_type = this.getType(target);

				const source_width = source_type.getIntTypeWidth();
				const target_width = target_type.getIntTypeWidth();

				if source_width == target_width {
					return parameters[0u];
				} else if source_width > target_width {
					return this.builder.buildTrunc(parameters[0u], target_type, "");
				} else if function.base_type.isSigned() && target.isSigned() {
					return this.builder.buildSExt(parameters[0u], target_type, "");
				} else {
					return this.builder.buildZExt(parameters[0u], target_type, "");
				}
			}
			case FloatCast: target -> {
				const source_type = this.getType(function.base_type);
				const target_type = this.getType(target);

				const source_width = source_type.getIntTypeWidth();
				const target_width = target_type.getIntTypeWidth();

				if source_width == target_width {
					return parameters[0u];
				} else if source_width > target_width {
					return this.builder.buildFPTrunc(parameters[0u], target_type, "");
				} else {
					return this.builder.buildFPExt(parameters[0u], target_type, "");
				}
			}
			case IntToFloat: target -> {
				if function.base_type.isSigned() {
					return this.builder.buildSIToFP(parameters[0u], this.getType(target), "");
				} else {
					return this.builder.buildUIToFP(parameters[0u], this.getType(target), "");
				}
			}
			case FloatToInt: target -> {
				if target.isSigned() {
					return this.builder.buildFPToSI(parameters[0u], this.getType(target), "");
				} else {
					return this.builder.buildFPToUI(parameters[0u], this.getType(target), "");
				}
			}

			case SizeOf -> {
				// ptrtoint (ptr getelementptr (type, ptr null, i32 1) to i64)
				const type = this.getType(function.base_type);
				return constPtrToInt(
					constGEP2(
						type,
						constNull(this.ptr_type),
						List!<ValueRef>(1u, constInt(this.int_type, 1, false))
					),
					this.int_type
				);
			}
			case AlignmentOf -> return constInt(this.int_type, this.data_layout.getPreferredAlignmentOfType(this.getType(function.base_type)) as int, false);
			case ReferenceKindOf -> return constInt(this.int_type, function.base_type.reference_kind as int, false);

			case VariantOpUnsafeAs: id -> {
				const case_decl = function.base_type.decl.getVariantCase(id).value();
				var result = this.builder.buildStructGEP2(this.getType(function.base_type), parameters[0u], 1u, "");
				if case_decl.type.reference_kind != None {
					result = this.builder.buildLoad2(this.getType(case_decl.type), result, "");
				}
				return result;
			}

			case VariantOpIs: id -> {
				const id_type = this.getType(function.base_type.decl.id_type);
				const object_id = this.builder.buildExtractValue(parameters[0u], 0u, "");
				return this.builder.buildICmp(LLVMIntPredicate::LLVMIntEQ, object_id, constInt(id_type, id, false), "");
			}

			case ArrayGetSize -> {
				const size = (function.base_type.decl.body as Array).value().size;
				return constInt(this.int_type, size as int, false);
			}
			case ArrayGetDataPointer -> {
				var indices: List!<ValueRef>;
				indices.append(constInt(this.int_type, 0, false));
				indices.append(constInt(this.int_type, 0, false));
				return this.builder.buildGEP2(this.getType(function.base_type), parameters[0u], indices, "");
			}
		}
	}

	func codegenStmt(this: &&CGContext, stmt: &Stmt) -> void {
		match stmt {
			case Compound: compound_stmt -> this.codegenCompoundStmt(compound_stmt);
			case Expr: expr -> {
				discard this.codegenExpr(expr);
				if expr.type == this.program.never_type {
					this.builder.buildUnreachable();
				}
			}
			case If: if_stmt -> this.codegenIfStmt(if_stmt, stmt.span);
			case While: while_stmt -> this.codegenWhileStmt(while_stmt, stmt.span);
			case Break -> {
				this.setCurrentDebugLocation(stmt.span);
				this.builder.buildBr(this.break_target);
			}
			case Continue -> {
				this.setCurrentDebugLocation(stmt.span);
				this.builder.buildBr(this.continue_target);
			}
			case Yield -> {
				this.setCurrentDebugLocation(stmt.span);
				this.builder.buildBr(this.yield_target);
			}
			case Return: value -> {
				if value is Void && this.current_function == this.program.main_function.llvm_func {
					this.setCurrentDebugLocation(stmt.span);
					this.builder.buildRet(constInt(this.int_type, 0, false));
				} else {
					const built_value = this.codegenExpr(value);
					this.setCurrentDebugLocation(stmt.span);
					this.builder.buildRet(built_value);
				}
			}
			case LifeTimeStart: variable -> {
				if !(variable.destructor_call is Undefined) {
					this.codegenLifeTimeStart(this.getVariable(variable));
				}
				discard this.codegenExpr(variable.constructor_call);
			}
			case LifeTimeEnd: variable -> {
				discard this.codegenExpr(variable.destructor_call);
				if !(variable.destructor_call is Undefined) {
					this.codegenLifeTimeEnd(this.getVariable(variable));
				}
			}
			case Empty -> {}
			else -> this.todo("finish codegen of statements", stmt.span);
		}
	}

	func codegenCompoundStmt(this: &&CGContext, compound_stmt: &CompoundStmt) -> void {
		for stmt in compound_stmt.children {
			this.codegenStmt(stmt);
		}
	}

	func codegenIfStmt(this: &&CGContext, if_stmt: &IfStmt, span: Span) -> void {
		const condition = this.codegenExpr(if_stmt.condition);
		for stmt in if_stmt.condition_cleanup {
			discard this.codegenStmt(stmt);
		}

		const then_block = this.llvm_context.appendBasicBlock(this.current_function, "then");
		const else_block = this.llvm_context.appendBasicBlock(this.current_function, "else");
		const cont_block = this.llvm_context.appendBasicBlock(this.current_function, "cont");

		var then_branch_terminates = false;
		var else_branch_terminates = false;

		this.setCurrentDebugLocation(span);
		this.builder.buildCondBr(condition, then_block, else_block);

		this.builder.positionAtEnd(then_block);
		this.codegenStmt(if_stmt.then_branch);
		if !this.builder.getInsertBlock().hasTerminator() {
			this.builder.buildBr(cont_block);
		} else {
			then_branch_terminates = true;
		}

		this.builder.positionAtEnd(else_block);
		this.codegenStmt(if_stmt.else_branch);
		if !this.builder.getInsertBlock().hasTerminator() {
			this.builder.buildBr(cont_block);
		} else {
			else_branch_terminates = true;
		}

		this.builder.positionAtEnd(cont_block);

		if then_branch_terminates && else_branch_terminates {
			this.builder.buildUnreachable();
		}
	}

	func codegenWhileStmt(this: &&CGContext, while_stmt: &WhileStmt, span: Span) -> void {
		const cond_block = this.llvm_context.appendBasicBlock(this.current_function, "cond");
		const loop_block = this.llvm_context.appendBasicBlock(this.current_function, "loop");
		const cont_block = this.llvm_context.appendBasicBlock(this.current_function, "cont");

		const prev_continue_target = this.continue_target;
		const prev_break_target = this.break_target;

		this.continue_target = cond_block;
		this.break_target = cont_block;

		this.setCurrentDebugLocation(span);

		if while_stmt.kind == While {
			this.builder.buildBr(cond_block);
		} else {
			this.builder.buildBr(loop_block);
		}

		this.builder.positionAtEnd(cond_block);
		const condition = this.codegenExpr(while_stmt.condition);
		for stmt in while_stmt.condition_cleanup {
			discard this.codegenStmt(stmt);
		}
		this.builder.buildCondBr(condition, loop_block, cont_block);

		var body_terminates = false;

		this.builder.positionAtEnd(loop_block);
		this.codegenStmt(while_stmt.body);

		if !this.builder.getInsertBlock().hasTerminator() {
			this.builder.buildBr(cond_block);
		} else {
			body_terminates = true;
		}

		this.builder.positionAtEnd(cont_block);
		if body_terminates && while_stmt.kind == DoWhile {
			this.builder.buildUnreachable();
		}

		this.continue_target = prev_continue_target;
		this.break_target = prev_break_target;
	}

	func codegenStringGlobal(this: &&CGContext, value: String) -> ValueRef {
		match this.program.string_globals.get(value) {
			case Some: result -> return result;
			else -> {}
		}

		const string_value = this.llvm_context.constString(value, true);
		const string_type = string_value.getType();

		var result = this.llvm_module.addGlobal(string_type, "");
		result.setLinkage(LLVMLinkage::LLVMPrivateLinkage);
		result.setUnnamedAddress(LLVMUnnamedAddr::LLVMGlobalUnnamedAddr);
		result.setAlignment(1u);
		result.setInitializer(string_value);
		result.setGlobalConstant(true);

		this.program.string_globals.set(value, result);
		return result;
	}

	func codegenExpr(this: &&CGContext, expr: &Expr) -> ValueRef {
		const span = expr.span;

		match expr {
			case Undefined -> {
				if expr.type == this.program.void_type || expr.type.isUnknown() {
					return ValueRef();
				} else {
					return this.getType(expr.type).getUndef();
				}
			}
			case Void -> return ValueRef();
			case Integer: value -> return constInt(this.getType(expr.type), value, expr.type.isSigned());
			case Float: value -> return constFloat(this.getType(expr.type), value);
			case String: value -> {
				const data_ptr = this.codegenStringGlobal(value);
				var result = constNull(this.getType(expr.type));
				result = this.builder.buildInsertValue(result, data_ptr, 0u, "");
				result = this.builder.buildInsertValue(result, constInt(this.int_type, value.size() as int, false), 1u, ""); // size
				result = this.builder.buildInsertValue(result, constInt(this.int_type, value.size() as int, false), 2u, ""); // capacity
				return result;
			}
			case ConstAggregate: elements -> {
				var result = constNull(this.getType(expr.type));
				for i in 0u..elements.size() {
					const element = this.codegenExpr(elements[i]);
					result = this.builder.buildInsertValue(result, element, i, "");
				}
				return result;
			}
			case Call: call_expr -> return this.codegenCall(call_expr, expr.span);
			case VarInvoke: variable -> {
				if variable.type.reference_kind == None || variable.is_parameter {
					return this.getVariable(variable);
				} else {
					this.setCurrentDebugLocation(span);
					return this.builder.buildLoad2(this.getType(variable.type), this.getVariable(variable), "");
				}
			}
			case MemberVarInvoke: member_var_invoke_expr -> {
				const object_type_decl = member_var_invoke_expr.object.type.decl;
				const member_decl = object_type_decl.member_variables[member_var_invoke_expr.id];

				const object = this.codegenExpr(member_var_invoke_expr.object);
				const object_type = this.getType(member_var_invoke_expr.object.type.base());

				var id = member_var_invoke_expr.id;
				if member_var_invoke_expr.object.type.isVariant() {
					id += 2;
				}

				this.setCurrentDebugLocation(span);
				const ptr = this.builder.buildStructGEP2(object_type, object, id, "");

				if member_decl.type.reference_kind == None {
					return ptr;
				} else {
					return this.builder.buildLoad2(this.getType(member_decl.type), ptr, "");
				}
			}
			case Dereference: base -> {
				this.setCurrentDebugLocation(span);
				return this.builder.buildLoad2(this.getType(expr.type), this.codegenExpr(base), "");
			}
			case Match: match_expr -> return this.codegenMatchExpr(match_expr, expr.span);
			case ShallowCopy: shallow_copy_expr -> {
				var dst = ValueRef();
				match shallow_copy_expr.destination.operator unwrap() {
					case VarInvoke: variable -> dst = this.getVariable(variable);
					case MemberVarInvoke: member_var_invoke_expr -> {
						const object = this.codegenExpr(member_var_invoke_expr.object);
						const object_type = this.getType(member_var_invoke_expr.object.type.base());

						var id = member_var_invoke_expr.id;
						if member_var_invoke_expr.object.type.isVariant() {
							id += 2;
						}

						dst = this.builder.buildStructGEP2(object_type, object, member_var_invoke_expr.id, "");
					}
					else -> panic("invalid shallow copy expr");
				}

				const val = this.codegenExpr(shallow_copy_expr.value);

				this.setCurrentDebugLocation(span);
				this.builder.buildStore(val, dst);
				return val;
			}
			case TypeRef -> return ValueRef();
			case FunctionRef: function -> return function.llvm_func;
		}
	}

	func codegenCall(this: &&CGContext, call_expr: &CallExpr, span: Span) -> ValueRef {
		var parameters: List!<ValueRef>;
		for parameter in call_expr.parameters {
			parameters.append(this.codegenExpr(parameter));
		}

		return this.codegenCall(call_expr.function, parameters, call_expr.return_kind, call_expr.result_var, span);
	}

	func codegenCall(this: &&CGContext, function: SharedHandle!<FunctionDecl>, parameters: &List!<ValueRef>, return_kind: ReturnKind, span: Span) -> ValueRef {
		assert(return_kind == ReturnKind::None || return_kind == ReturnKind::Value);
		return this.codegenCall(function, parameters, return_kind, SharedHandle!<VarDecl>(), span);
	}

	func codegenCall(this: &&CGContext, function: SharedHandle!<FunctionDecl>, parameters: &List!<ValueRef>, return_kind: ReturnKind, result_var: SharedHandle!<VarDecl>, span: Span) -> ValueRef {
		this.setCurrentDebugLocation(span);

		match function.body {
			case InlineBuiltin: function -> return this.codegenInlineBuiltinFunctionCall(function, parameters);
			else -> {
				if return_kind is Parameter {
					this.codegenLifeTimeStart(this.getVariable(result_var));
				}

				const function_impl = function.llvm_func;
				const function_type = function.llvm_type;
				const result = this.builder.buildCall2(function_type, function_impl, parameters, "");

				match return_kind {
					case None -> return ValueRef();
					case Value -> return result;
					case Variable -> {
						const built_result_var = this.getVariable(result_var);
						this.builder.buildStore(result, built_result_var);
						return built_result_var;
					}
					case Parameter -> return this.getVariable(result_var);
					case VariableButYieldNone -> {
						const built_result_var = this.getVariable(result_var);
						this.builder.buildStore(result, built_result_var);
						return ValueRef();
					}
				}
			}
		}
	}

	func codegenMatchExpr(this: &&CGContext, match_expr: &MatchExpr, span: Span) -> ValueRef {
		var value = this.codegenExpr(match_expr.value);

		if match_expr.value.type.isVariant() {
			const value_type_decl = match_expr.value.type.decl;
			value = this.builder.buildLoad2(
				this.getType(value_type_decl.id_type),
				this.builder.buildStructGEP2(
					this.getType(match_expr.value.type.base()),
					value, 0u, ""
				), ""
			);
		} else if match_expr.value.type.reference_kind != None {
			value = this.builder.buildLoad2(
				this.getType(match_expr.value.type.base()),
				value, ""
			);
		}

		var case_blocks: List!<BasicBlockRef>;
		for i in 0u..match_expr.cases.size() {
			case_blocks.append(this.llvm_context.appendBasicBlock(this.current_function, "case"));
		}

		const else_block = this.llvm_context.appendBasicBlock(this.current_function, "else");
		const cont_block = this.llvm_context.appendBasicBlock(this.current_function, "cont");

		const prev_yield_target = this.yield_target;
		this.yield_target = cont_block;

		this.setCurrentDebugLocation(span);

		var switch_instr = this.builder.buildSwitch(value, else_block, case_blocks.size());

		for i in 0u..match_expr.cases.size() {
			for pattern in match_expr.cases[i].patterns {
				const built_pattern = this.codegenExpr(pattern);
				switch_instr.addCase(built_pattern, case_blocks[i]);
			}
		}

		for i in 0u..match_expr.cases.size() {
			this.builder.positionAtEnd(case_blocks[i]);
			this.codegenStmt(match_expr.cases[i].body);
			if !this.builder.getInsertBlock().hasTerminator() {
				this.builder.buildBr(cont_block);
			}
		}

		this.builder.positionAtEnd(else_block);
		match match_expr.else_case {
			case Some: stmt -> {
				this.codegenStmt(stmt);
				if !this.builder.getInsertBlock().hasTerminator() {
					this.builder.buildBr(cont_block);
				}
			}
			else -> this.builder.buildUnreachable();
		}

		this.builder.positionAtEnd(cont_block);
		this.yield_target = prev_yield_target;

		return this.variables.get(match_expr.yield_var) ?? ValueRef();
	}

	func codegenIntrinsicCall(this: &&CGContext, intrinsic_name: String, parameter_types: &List!<TypeRef>, parameters: &List!<ValueRef>) -> ValueRef {
		const id = lookupIntrinsicID(intrinsic_name);
		const type = this.llvm_context.getIntrinsicType(id, parameter_types);
		const declaration = this.llvm_module.getIntrinsicDeclaration(id, parameter_types);

		return this.builder.buildCall2(type, declaration, parameters, "");
	}

	func codegenLifeTimeStart(this: &&CGContext, address: ValueRef) -> void {
		var parameters: List!<ValueRef>;
		parameters.append(constInt(this.int_type, 1, false));
		parameters.append(address);
		discard this.codegenIntrinsicCall("llvm.lifetime.start", List!<TypeRef>(1u, this.ptr_type), parameters);
	}

	func codegenLifeTimeEnd(this: &&CGContext, address: ValueRef) -> void {
		var parameters: List!<ValueRef>;
		parameters.append(constInt(this.int_type, 1, false));
		parameters.append(address);
		discard this.codegenIntrinsicCall("llvm.lifetime.end", List!<TypeRef>(1u, this.ptr_type), parameters);
	}
}
