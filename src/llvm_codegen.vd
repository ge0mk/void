import std/core;
import std/format;
import std/list;
import std/io;
import std/map;
import std/range;
import std/set;
import std/shared_list;
import std/string;

import error;
import llvm_c;
import llvm_util;
import options;
import program;
import span;

struct CGContext {
	var program: &&Program;
	var llvm_context: LLVMContextRef;
	var llvm_module: LLVMModuleRef;
	var data_layout: LLVMTargetDataRef;
	var di_builder: LLVMDIBuilderRef;

	var current_di_scope: LLVMMetadataRef;

	var void_type: LLVMTypeRef;
	var bool_type: LLVMTypeRef;
	var byte_type: LLVMTypeRef;
	var int_type: LLVMTypeRef;
	var ptr_type: LLVMTypeRef;

	var builder: LLVMBuilderRef;
	var current_function: LLVMValueRef;
	var variables: Map!<SharedHandle!<VarDecl>, LLVMValueRef>;

	var break_target: LLVMBasicBlockRef;
	var continue_target: LLVMBasicBlockRef;
	var yield_target: LLVMBasicBlockRef;

	func constructor(this: &&CGContext, program: &&Program) -> void {
		this.program := &&program;
		this.llvm_context := program.llvm_context;
		this.llvm_module := program.llvm_module;
		this.data_layout := program.data_layout;
		this.di_builder := program.di_builder;

		this.void_type := LLVMVoidTypeInContext(this.llvm_context);
		this.bool_type := LLVMIntTypeInContext(this.llvm_context, 1u);
		this.byte_type := LLVMIntTypeInContext(this.llvm_context, 8u);
		this.int_type := LLVMIntTypeInContext(this.llvm_context, LLVMPointerSize(this.data_layout) as uint * 8);
		this.ptr_type := LLVMPointerTypeInContext(this.llvm_context, 0u);
	}

	func destructor(this: &&CGContext) -> void = default;

	func error(this: &CGContext, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Error, ErrorStage::CodeGenerator, span));
	}

	func info(this: &CGContext, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Info, ErrorStage::CodeGenerator, span));
	}

	func todo(this: &CGContext, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Todo, ErrorStage::CodeGenerator, span));
	}

	func getType(this: &&CGContext, type: Type) -> LLVMTypeRef {
		if type.isUnknown() {
			return this.void_type;
		}

		match type.reference_kind {
			case None -> {
				if type.decl.llvm_type == vptr::null() {
					this.codegenType(type.decl);

					if type.decl.llvm_type == vptr::null() {
						panic("invalid codegen for type '" + type.signature() + "'");
					}
				}

				return type.decl.llvm_type;
			}
			else -> return this.ptr_type;
		}
	}

	func getDIType(this: &&CGContext, type: Type) -> LLVMMetadataRef {
		if type.decl.llvm_di == vptr::null() {
			this.codegenTypeDI(type.decl);

			if type.decl.llvm_di == vptr::null() {
				panic("invalid debug info for type '" + type.signature() + "'");
			}
		}

		if type.reference_kind == None {
			return type.decl.llvm_di;
		} else {
			return LLVMDIBuilderCreateReferenceType(this.di_builder, DWARFTag::Tag_reference_type, type.decl.llvm_di);
		}
	}

	func getFunction(this: &&CGContext, function: SharedHandle!<FunctionDecl>) -> LLVMValueRef {
		if function.llvm_func != vptr::null() {
			return function.llvm_func;
		}

		this.codegenFunctionDecl(function);
		this.codegenFunctionBody(function);
		return function.llvm_func;
	}

	func getVariable(this: &CGContext, variable: SharedHandle!<VarDecl>) -> LLVMValueRef {
		const impl = this.variables.get(variable) else {
			panic("invalid codegen for variable '" + variable.name + "'");
		}

		return impl;
	}

	func getDebugLocation(this: &&CGContext, span: Span) -> LLVMMetadataRef {
		return LLVMDIBuilderCreateDebugLocation(this.llvm_context, span.line as uint + 1, span.column as uint + 1, this.current_di_scope);
	}

	func setCurrentDebugLocation(this: &&CGContext, span: Span) -> void {
		if this.program.options.generate_debug_info {
			LLVMSetCurrentDebugLocation2(this.builder, this.getDebugLocation(span));
		}
	}

	func getTypeName(this: &CGContext, type: SharedHandle!<TypeDecl>) -> String {
		var name = "";
		match this.program.options.symbol_type {
			case None -> {}
			case Name -> name = type.name;
			case Full -> name = type.signature();
		}

		return name;
	}

	func codegenType(this: &&CGContext, type: SharedHandle!<TypeDecl>) -> void {
		if type.isIncompleteTemplate() || type.llvm_type != vptr::null() {
			return;
		}

		const name = this.getTypeName(type);

		match type.body {
			case Empty -> type.llvm_type = this.void_type;
			case Void -> type.llvm_type = this.void_type;
			case Bool -> type.llvm_type = this.bool_type;
			case Byte -> type.llvm_type = this.byte_type;
			case Int: bits -> {
				if bits == 0 {
					type.llvm_type = this.int_type;
				} else {
					type.llvm_type = LLVMIntTypeInContext(this.llvm_context, bits);
				}
			}
			case UInt: bits -> {
				if bits == 0 {
					type.llvm_type = this.int_type;
				} else {
					type.llvm_type = LLVMIntTypeInContext(this.llvm_context, bits);
				}
			}
			case Float: bits -> match bits {
				case 32 -> type.llvm_type = LLVMFloatTypeInContext(this.llvm_context);
				case 64 -> type.llvm_type = LLVMDoubleTypeInContext(this.llvm_context);
				else -> this.error("invalid size for float type: " + format(bits), type.span);
			}
			case Pointer | Function -> type.llvm_type = this.ptr_type;
			case Array: array_type -> type.llvm_type = LLVMArrayType(this.getType(array_type.element_type), array_type.size);
			case Tuple | Struct -> {
				type.llvm_type = LLVMStructCreateNamed(this.llvm_context, name);

				var element_types: List!<LLVMTypeRef>;
				for member_variable in type.member_variables {
					element_types.append(this.getType(member_variable.type));
				}

				LLVMStructSetBody(type.llvm_type, element_types, type.is_packed);
			}
			case Enum -> type.llvm_type = this.getType(type.id_type);
			case Variant -> {
				type.llvm_type = LLVMStructCreateNamed(this.llvm_context, name);

				var element_types: List!<LLVMTypeRef>;
				element_types.append(this.getType(type.id_type));

				var max_size = 0u;
				var max_alignment = 1u;

				for case_decl in type.variant_cases {
					if case_decl.type == this.program.void_type {
						continue;
					}

					var case_type = this.getType(case_decl.type);

					const current_size = LLVMStoreSizeOfType(this.data_layout, case_type) as uint;
					if current_size > max_size {
						max_size = current_size;
					}

					const current_alignment = LLVMPreferredAlignmentOfType(this.data_layout, case_type) as uint;
					if current_alignment > max_alignment {
						max_alignment = current_alignment;
					}
				}

				const max_alignment_type = LLVMIntTypeInContext(this.llvm_context, max_alignment * 8);
				element_types.append(LLVMArrayType(max_alignment_type, max_size / max_alignment));

				for member_variable in type.member_variables {
					element_types.append(this.getType(member_variable.type));
				}

				LLVMStructSetBody(type.llvm_type, element_types, type.is_packed);
			}
		}
	}

	func codegenTypeDI(this: &&CGContext, type: SharedHandle!<TypeDecl>) -> void {
		if type.isIncompleteTemplate() || type.llvm_di != vptr::null() {
			return;
		}

		const line = type.name_span.line as uint;
		const di_file = this.program.files[type.span.file as uint].llvm_di_file;
		const parent_namespace = type.parent_namespace.llvm_di;

		const llvm_type = this.getType(Type(type));

		var size_in_bits = 0u;
		if llvm_type != this.void_type {
			size_in_bits = LLVMStoreSizeOfType(this.data_layout, llvm_type) as uint * 8;
		}

		var alignment_in_bits = 0u;
		if llvm_type != this.void_type {
			alignment_in_bits = LLVMPreferredAlignmentOfType(this.data_layout, llvm_type) as uint * 8;
		}

		const type_scope = type.linked_namespace.llvm_di;
		const di_name = type.name + type.template_parameters.format();

		match type.body {
			case Empty -> type.llvm_di = LLVMDIBuilderCreateUnspecifiedType(this.di_builder, di_name);
			case Void -> type.llvm_di = LLVMDIBuilderCreateBasicType(this.di_builder, di_name, size_in_bits, 0 as DWARFTypeEncoding, LLVMDIFlags::LLVMDIFlagZero);
			case Bool -> type.llvm_di = LLVMDIBuilderCreateBasicType(this.di_builder, di_name, size_in_bits, DWARFTypeEncoding::Type_boolean, LLVMDIFlags::LLVMDIFlagZero);
			case Byte -> type.llvm_di = LLVMDIBuilderCreateBasicType(this.di_builder, di_name, size_in_bits, DWARFTypeEncoding::Type_unsigned_char, LLVMDIFlags::LLVMDIFlagZero);
			case Int -> type.llvm_di = LLVMDIBuilderCreateBasicType(this.di_builder, di_name, size_in_bits, DWARFTypeEncoding::Type_signed, LLVMDIFlags::LLVMDIFlagZero);
			case UInt -> type.llvm_di = LLVMDIBuilderCreateBasicType(this.di_builder, di_name, size_in_bits, DWARFTypeEncoding::Type_unsigned, LLVMDIFlags::LLVMDIFlagZero);
			case Float -> type.llvm_di = LLVMDIBuilderCreateBasicType(this.di_builder, di_name, size_in_bits, DWARFTypeEncoding::Type_float, LLVMDIFlags::LLVMDIFlagZero);
			case Pointer: pointer_type -> {
				type.llvm_di = LLVMDIBuilderCreateReplaceableCompositeType(this.di_builder, DWARFTag::Tag_unspecified_type, di_name, parent_namespace, di_file, line, 0u32, size_in_bits, alignment_in_bits, LLVMDIFlags::LLVMDIFlagZero, type.signature());

				const pointee_type = match pointer_type.pointee_type.isUnknown() {
					case true -> yield this.getDIType(this.program.void_type);
					case false -> yield this.getDIType(pointer_type.pointee_type);
				};

				const di_type = LLVMDIBuilderCreatePointerType(this.di_builder, pointee_type, size_in_bits, alignment_in_bits, 0u, di_name);

				LLVMMetadataReplaceAllUsesWith(type.llvm_di, di_type);
				type.llvm_di = di_type;
			}
			case Function: function_type -> {
				var di_return_and_parameter_types: List!<LLVMMetadataRef>;

				di_return_and_parameter_types.append(this.getDIType(function_type.return_type));
				for parameter_type in function_type.parameter_types {
					di_return_and_parameter_types.append(this.getDIType(parameter_type));
				}

				type.llvm_di = LLVMDIBuilderCreateSubroutineType(
					this.di_builder,
					this.program.files[type.span.file as uint].llvm_di_file,
					di_return_and_parameter_types,
					LLVMDIFlags::LLVMDIFlagZero
				);
			}
			case Array: array_type -> {
				type.llvm_di = LLVMDIBuilderCreateReplaceableCompositeType(this.di_builder, DWARFTag::Tag_unspecified_type, di_name, parent_namespace, di_file, line, 0u32, size_in_bits, alignment_in_bits, LLVMDIFlags::LLVMDIFlagZero, type.signature());

				const di_type = LLVMDIBuilderCreateArrayType(this.di_builder, array_type.size, alignment_in_bits, this.getDIType(array_type.element_type), List!<LLVMMetadataRef>());

				LLVMMetadataReplaceAllUsesWith(type.llvm_di, di_type);
				type.llvm_di = di_type;
			}
			case Tuple | Struct | Variant -> {
				type.llvm_di = LLVMDIBuilderCreateReplaceableCompositeType(this.di_builder, DWARFTag::Tag_unspecified_type, di_name, parent_namespace, di_file, line, 0u32, size_in_bits, alignment_in_bits, LLVMDIFlags::LLVMDIFlagZero, type.signature());

				var members: List!<LLVMMetadataRef>;

				if type.body is Variant {
					var cases: List!<LLVMMetadataRef>;
					var payload_members: List!<LLVMMetadataRef>;
					for c in type.variant_cases {
						cases.append(LLVMDIBuilderCreateEnumerator(this.di_builder, c.name, c.id, true));

						if c.type == this.program.void_type {
							continue;
						}

						payload_members.append(LLVMDIBuilderCreateMemberType(
							this.di_builder,
							type_scope,
							c.name,
							di_file,
							c.span.line as uint,
							LLVMStoreSizeOfType(this.data_layout, this.getType(c.type)) as uint * 8,
							LLVMPreferredAlignmentOfType(this.data_layout, this.getType(c.type)) as uint * 8,
							0u,
							LLVMDIFlags::LLVMDIFlagZero,
							this.getDIType(c.type)
						));
					}

					const id_size_in_bits = LLVMStoreSizeOfType(this.data_layout, this.getType(type.id_type)) as uint * 8;
					const id_alignment_in_bits = LLVMPreferredAlignmentOfType(this.data_layout, this.getType(type.id_type)) as uint * 8;
					const id_offset_in_bits = LLVMOffsetOfElement(this.data_layout, llvm_type, 0u) * 8;
					const id_type = LLVMDIBuilderCreateEnumerationType(this.di_builder, parent_namespace, di_name + "::Id", di_file, line, id_size_in_bits, id_alignment_in_bits, cases, this.getDIType(type.id_type));
					members.append(LLVMDIBuilderCreateMemberType(
						this.di_builder,
						type_scope,
						"#id",
						di_file,
						line,
						id_size_in_bits,
						id_alignment_in_bits,
						id_offset_in_bits,
						LLVMDIFlags::LLVMDIFlagZero,
						id_type
					));

					const payload_type_impl = LLVMStructGetTypeAtIndex(llvm_type, 1u);
					const payload_size_in_bits = LLVMStoreSizeOfType(this.data_layout, payload_type_impl) as uint * 8;
					const payload_alignment_in_bits = LLVMPreferredAlignmentOfType(this.data_layout, payload_type_impl) as uint * 8;
					const payload_offset_in_bits = LLVMOffsetOfElement(this.data_layout, llvm_type, 1u) * 8;
					const payload_type = LLVMDIBuilderCreateUnionType(this.di_builder, type_scope, di_name + "::Payload", di_file, line, payload_size_in_bits, payload_alignment_in_bits, LLVMDIFlags::LLVMDIFlagZero, payload_members, 0u32, type.signature() + "::Payload");
					members.append(LLVMDIBuilderCreateMemberType(
						this.di_builder,
						type_scope,
						"#payload",
						di_file,
						line,
						payload_size_in_bits,
						payload_alignment_in_bits,
						payload_offset_in_bits,
						LLVMDIFlags::LLVMDIFlagZero,
						payload_type
					));
				}

				for i in 0u..type.member_variables.size() {
					const member_variable = type.member_variables[i];
					const member_type = this.getType(member_variable.type);
					if member_type == this.void_type {
						continue;
					}

					const member_di_type = this.getDIType(member_variable.type);

					const member_size_in_bits = LLVMStoreSizeOfType(this.data_layout, llvm_type) as uint * 8;
					const member_alignment_in_bits = LLVMPreferredAlignmentOfType(this.data_layout, llvm_type) as uint * 8;
					const member_offset_in_bits = LLVMOffsetOfElement(this.data_layout, llvm_type, i + (2u if type.body is Variant else 0u)) * 8;

					members.append(LLVMDIBuilderCreateMemberType(
						this.di_builder,
						type_scope,
						member_variable.name,
						di_file,
						member_variable.span.line as uint,
						member_size_in_bits,
						member_alignment_in_bits,
						member_offset_in_bits,
						LLVMDIFlags::LLVMDIFlagZero,
						member_di_type
					));
				}

				const di_type = LLVMDIBuilderCreateStructType(
					this.di_builder,
					parent_namespace,
					di_name,
					di_file,
					line,
					size_in_bits,
					alignment_in_bits,
					LLVMDIFlags::LLVMDIFlagZero,
					LLVMMetadataRef(),
					members,
					0u32,
					LLVMMetadataRef(),
					type.signature()
				);

				LLVMMetadataReplaceAllUsesWith(type.llvm_di, di_type);
				type.llvm_di = di_type;
			}
			case Enum -> {
				type.llvm_di = LLVMDIBuilderCreateReplaceableCompositeType(this.di_builder, DWARFTag::Tag_unspecified_type, di_name, parent_namespace, di_file, line, 0u32, size_in_bits, alignment_in_bits, LLVMDIFlags::LLVMDIFlagZero, type.signature());

				var cases: List!<LLVMMetadataRef>;
				for c in type.enum_cases {
					cases.append(LLVMDIBuilderCreateEnumerator(this.di_builder, c.name, c.id, true));
				}

				const di_type = LLVMDIBuilderCreateEnumerationType(this.di_builder, parent_namespace, di_name, di_file, line, size_in_bits, alignment_in_bits, cases, this.getDIType(type.id_type));

				LLVMMetadataReplaceAllUsesWith(type.llvm_di, di_type);
				type.llvm_di = di_type;
			}
		}
	}

	func codegenFunctionDecl(this: &&CGContext, function: SharedHandle!<FunctionDecl>) -> void {
		if function.isIncompleteTemplate() || function.llvm_func != vptr::null() {
			return;
		}

		var return_type = this.getType(function.return_type);
		var parameter_types: List!<LLVMTypeRef>;

		if function == this.program.main_function {
			parameter_types.append(this.ptr_type);
			parameter_types.append(this.int_type);
			return_type = this.int_type;
		} else {
			for type in function.parameter_types {
				parameter_types.append(this.getType(type));
			}
		}

		const function_type = LLVMFunctionType(return_type, parameter_types, false);
		function.llvm_type = function_type;

		var name = "";
		match this.program.options.symbol_type {
			case None -> {}
			case Name -> name = function.name;
			case Full -> name = function.signature();
		}

		if function.extern_name != "" {
			name = function.extern_name;
		} else if function == this.program.main_function {
			name = "void_main";
		}

		function.llvm_func = LLVMAddFunction(this.llvm_module, name, function_type);
	}

	func codegenFunctionBody(this: &&CGContext, function: SharedHandle!<FunctionDecl>) -> void {
		if function.isIncompleteTemplate() || function.has_errors {
			return;
		}

		match function.body {
			case Empty | Extern -> return;
			case Unchecked -> {
				this.error("unchecked function: " + function.signature(), function.signature_span);
				return;
			}
			else -> {}
		}

		if function.llvm_func == vptr::null() {
			this.error("function decl for " + function.signature() + " not yet built", function.signature_span);
			return;
		}

		if LLVMCountBasicBlocks(function.llvm_func) > 0 {
			this.error("function body for " + function.signature() + " already built", function.signature_span);
			return;
		}

		const prev_di_scope = this.current_di_scope;
		const prev_builder = this.builder;
		const prev_function = this.current_function;
		const prev_variables = this.variables;

		this.variables.clear();
		this.current_function = function.llvm_func;

		// setup debug info for the function
		if this.program.options.generate_debug_info {
			var di_return_and_parameter_types: List!<LLVMMetadataRef>;

			di_return_and_parameter_types.append(this.getDIType(function.return_type));
			for parameter_type in function.parameter_types {
				di_return_and_parameter_types.append(this.getDIType(parameter_type));
			}

			const di_function_type = LLVMDIBuilderCreateSubroutineType(
				this.di_builder,
				this.program.files[function.span.file as uint].llvm_di_file,
				di_return_and_parameter_types,
				LLVMDIFlags::LLVMDIFlagZero
			);

			const di_namespace = function.parent_namespace.llvm_di;
			const di_name = function.name + function.template_parameters.format();

			function.llvm_di = LLVMDIBuilderCreateFunction(
				this.di_builder,
				di_namespace,
				di_name,
				function.extern_name,
				this.program.files[function.span.file as uint].llvm_di_file,
				function.signature_span.line as uint + 1,
				di_function_type,
				false, 		// is local to unit
				true,		// is definition
				function.signature_span.line as uint + 1,
				LLVMDIFlags::LLVMDIFlagZero,
				this.program.options.optimization_level != 0
			);

			LLVMSetSubprogram(function.llvm_func, function.llvm_di);
			this.current_di_scope = function.llvm_di;
		}

		this.builder = LLVMCreateBuilderInContext(this.llvm_context);
		const entry_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "");
		LLVMPositionBuilderAtEnd(this.builder, entry_block);

		// initialize function parameters & variables
		if function.body is Stmt {
			for variable in function.variables {
				if variable.type.isUnknown() {
					this.error("variable '" + variable.name + "' has unknown type", variable.span);
					continue;
				}

				if variable.is_parameter {
					if function == this.program.main_function {
						var args = LLVMConstNull(this.getType(function.parameter_types[0u]));
						args = LLVMBuildInsertValue(this.builder, args, LLVMGetParam(this.current_function, 0u), 0u, "");
						args = LLVMBuildInsertValue(this.builder, args, LLVMGetParam(this.current_function, 1u), 1u, "");
						this.variables.set(variable, args);
					} else {
						const parameter = LLVMGetParam(this.current_function, variable.id);
						this.variables.set(variable, parameter);

						if this.program.options.generate_debug_info {
							const di_variable = LLVMDIBuilderCreateParameterVariable(
								this.di_builder,
								this.current_di_scope,
								variable.name,
								variable.id + 1, // ArgNo starts counting at 1
								this.program.files[function.span.file as uint].llvm_di_file,
								variable.span.line as uint,
								this.getDIType(variable.type),
								false,
								LLVMDIFlags::LLVMDIFlagZero
							);

							discard LLVMDIBuilderInsertDeclareAtEnd(
								this.di_builder,
								parameter,
								di_variable,
								LLVMDIBuilderCreateExpression(this.di_builder, vptr!<u64>::null(), 0u),
								this.getDebugLocation(variable.span),
								entry_block
							);
						}
					}
				} else {
					this.setCurrentDebugLocation(variable.span);
					const address = LLVMBuildAlloca(this.builder, this.getType(variable.type), variable.name);
					this.variables.set(variable, address);

					if this.program.options.generate_debug_info {
						var alignment_in_bits = LLVMPreferredAlignmentOfType(this.data_layout, this.getType(variable.type)) as uint * 8;

						const di_variable = LLVMDIBuilderCreateAutoVariable(
							this.di_builder,
							this.current_di_scope,
							variable.name,
							this.program.files[function.span.file as uint].llvm_di_file,
							variable.span.line as uint,
							this.getDIType(variable.type),
							false,
							LLVMDIFlags::LLVMDIFlagZero,
							alignment_in_bits
						);

						discard LLVMDIBuilderInsertDeclareAtEnd(
							this.di_builder,
							address,
							di_variable,
							LLVMDIBuilderCreateExpression(this.di_builder, vptr!<u64>::null(), 0u),
							this.getDebugLocation(variable.span),
							entry_block
						);
					}

					LLVMSetCurrentDebugLocation2(this.builder, LLVMMetadataRef());
				}
			}
		}

		// codegen body
		match function.body {
			case Builtin: builtin_function -> this.codegenBuiltinFunction(builtin_function, function.signature_span);
			case Stmt: &stmt -> this.codegenStmt(stmt);
			else -> panic("invalid function body for codegen");
		}

		if !LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) {
			if function == this.program.main_function {
				discard LLVMBuildRet(this.builder, LLVMConstInt(this.int_type, 0, false));
			} else if function.return_type == this.program.void_type {
				discard LLVMBuildRetVoid(this.builder);
			} else {
				panic("function doesn't have a terminator");
			}
		}

		if this.program.options.generate_debug_info {
			LLVMDIBuilderFinalizeSubprogram(this.di_builder, function.llvm_di);
		}

		LLVMDisposeBuilder(this.builder)

		this.current_di_scope = prev_di_scope;
		this.builder = prev_builder;
		this.current_function = prev_function;
		this.variables = prev_variables;
	}

	func codegenBuiltinFunction(this: &&CGContext, function: BuiltinFunction, signature_span: Span) -> void {
		const type = this.getType(function.base_type);
		const decl = function.base_type.decl;

		const param0 = LLVMGetParam(this.current_function, 0u);
		const param1 = LLVMGetParam(this.current_function, 1u);

		match function {
			case Empty -> panic("empty builtin function");
			case StructValueConstructor -> {
				for i in 0u..decl.member_variables.size() {
					const member_ptr = LLVMBuildStructGEP2(this.builder, type, param0, i, "");
					const member_type = decl.member_variables[i].type.decl;

					var parameters: List!<LLVMValueRef>;
					parameters.append(member_ptr);
					parameters.append(LLVMGetParam(this.current_function, i + 1));

					discard this.codegenCall(member_type.copy_constructor, parameters, ReturnKind::None, signature_span);
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case StructDefaultConstructor -> {
				for i in 0u..decl.member_variables.size() {
					const member_ptr = LLVMBuildStructGEP2(this.builder, type, param0, i, "");
					const member_type = decl.member_variables[i].type.decl;

					var parameters: List!<LLVMValueRef>;
					parameters.append(member_ptr);

					discard this.codegenCall(member_type.default_constructor, parameters, ReturnKind::None, signature_span);
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case StructCopyConstructor -> {
				for i in 0u..decl.member_variables.size() {
					const member_ptr = LLVMBuildStructGEP2(this.builder, type, param0, i, "");
					const initializer = LLVMBuildExtractValue(this.builder, param1, i, "");

					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;

						var parameters: List!<LLVMValueRef>;
						parameters.append(member_ptr);
						parameters.append(initializer);

						discard this.codegenCall(member_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						discard LLVMBuildStore(this.builder, initializer, member_ptr);
					}
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case StructDestructor -> {
				for i in 0u..decl.member_variables.size() {
					if decl.member_variables[i].type.reference_kind != None {
						continue;
					}

					const member_ptr = LLVMBuildStructGEP2(this.builder, type, param0, i, "");
					const member_type = decl.member_variables[i].type.decl;

					var parameters: List!<LLVMValueRef>;
					parameters.append(member_ptr);

					discard this.codegenCall(member_type.destructor, parameters, ReturnKind::None, signature_span);
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case StructOpAssign -> {
				for i in 0u..decl.member_variables.size() {
					const member_ptr = LLVMBuildStructGEP2(this.builder, type, param0, i, "");
					const initializer = LLVMBuildExtractValue(this.builder, param1, i, "");

					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;

						var parameters: List!<LLVMValueRef>;
						parameters.append(member_ptr);
						parameters.append(initializer);

						discard this.codegenCall(member_type.op_assign, parameters, ReturnKind::None, signature_span);
					} else {
						discard LLVMBuildStore(this.builder, initializer, member_ptr);
					}
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case VariantCaseConstructor: case_id -> {
				const id_type = this.getType(decl.id_type);
				const id_ptr = LLVMBuildStructGEP2(this.builder, type, param0, 0u, "");
				discard LLVMBuildStore(this.builder, LLVMConstInt(id_type, case_id, false), id_ptr);

				var member_var_param_offset = 1u;	// first param is this

				const case_decl = decl.getVariantCase(case_id).value();
				if case_decl.type != this.program.void_type {
					member_var_param_offset += 1;	// payload is passed before member variables

					const this_payload_ptr = LLVMBuildStructGEP2(this.builder, type, param0, 1u, "");
					const initializer = param1;

					if case_decl.type.reference_kind == None {
						const case_type = case_decl.type.decl;

						var parameters: List!<LLVMValueRef>;
						parameters.append(this_payload_ptr);
						parameters.append(initializer);

						discard this.codegenCall(case_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						discard LLVMBuildStore(this.builder, initializer, this_payload_ptr);
					}
				}

				for i in 0u..decl.member_variables.size() {
					const this_member_ptr = LLVMBuildStructGEP2(this.builder, type, param0, i + 2, "");
					const initializer = LLVMGetParam(this.current_function, i + member_var_param_offset);

					if decl.member_variables[i].type.reference_kind == None {
						var parameters: List!<LLVMValueRef>;
						parameters.append(this_member_ptr);
						parameters.append(initializer);

						const member_type = decl.member_variables[i].type.decl;

						discard this.codegenCall(member_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						discard LLVMBuildStore(this.builder, initializer, this_member_ptr);
					}
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case VariantCopyConstructor -> {
				const id_type = this.getType(decl.id_type);
				const id_ptr = LLVMBuildStructGEP2(this.builder, type, param0, 0u, "");
				const this_payload_ptr = LLVMBuildStructGEP2(this.builder, type, param0, 1u, "");

				const other_payload_ptr = LLVMBuildAlloca(this.builder, LLVMStructGetTypeAtIndex(type, 1u), "");
				discard LLVMBuildStore(this.builder, LLVMBuildExtractValue(this.builder, param1, 1u, ""), other_payload_ptr);

				const other_id = LLVMBuildExtractValue(this.builder, param1, 0u, "");
				discard LLVMBuildStore(this.builder, other_id, id_ptr);

				const cont_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "cont");

				var case_count = 0u;
				for case_decl in decl.variant_cases {
					if case_decl.type != this.program.void_type {
						case_count++;
					}
				}

				var switch_instr = LLVMBuildSwitch(this.builder, other_id, cont_block, case_count);

				for case_decl in decl.variant_cases {
					if case_decl.type == this.program.void_type {
						continue;
					}

					const case_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "case");
					LLVMAddCase(switch_instr, LLVMConstInt(id_type, case_decl.id, false), case_block);
					LLVMPositionBuilderAtEnd(this.builder, case_block);

					const other_payload = LLVMBuildLoad2(this.builder, this.getType(case_decl.type), other_payload_ptr, "");

					if case_decl.type.reference_kind == None {
						const case_type = case_decl.type.decl;
						var parameters: List!<LLVMValueRef>;
						parameters.append(this_payload_ptr);
						parameters.append(other_payload);

						discard this.codegenCall(case_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						discard LLVMBuildStore(this.builder, other_payload, this_payload_ptr);
					}

					discard LLVMBuildBr(this.builder, cont_block);
				}

				LLVMPositionBuilderAtEnd(this.builder, cont_block);

				for i in 0u..decl.member_variables.size() {
					const this_member_ptr = LLVMBuildStructGEP2(this.builder, type, param0, i + 2, "");
					const other_member = LLVMBuildExtractValue(this.builder, param1, i + 2, "");

					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;

						var parameters: List!<LLVMValueRef>;
						parameters.append(this_member_ptr);
						parameters.append(other_member);

						discard this.codegenCall(member_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						discard LLVMBuildStore(this.builder, other_member, this_member_ptr);
					}
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case VariantDestructor -> {
				const id_type = this.getType(decl.id_type);
				const id_ptr = LLVMBuildStructGEP2(this.builder, type, param0, 0u, "");
				const this_id = LLVMBuildLoad2(this.builder, id_type, id_ptr, "");
				const this_payload_ptr = LLVMBuildStructGEP2(this.builder, type, param0, 1u, "");

				var case_destructor_args: List!<LLVMValueRef>;
				case_destructor_args.append(this_payload_ptr);

				const cont_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "cont");

				var case_count = 0u;
				for case_decl in decl.variant_cases {
					if case_decl.type != this.program.void_type && case_decl.type.reference_kind == None {
						case_count++;
					}
				}
				var switch_instr = LLVMBuildSwitch(this.builder, this_id, cont_block, case_count);

				for case_decl in decl.variant_cases {
					if case_decl.type == this.program.void_type || case_decl.type.reference_kind != None {
						continue;
					}

					const case_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "case");
					LLVMAddCase(switch_instr, LLVMConstInt(id_type, case_decl.id, false), case_block);
					LLVMPositionBuilderAtEnd(this.builder, case_block);

					const case_type = case_decl.type.decl;

					discard this.codegenCall(case_type.destructor, case_destructor_args, ReturnKind::None, signature_span);

					discard LLVMBuildBr(this.builder, cont_block);
				}

				LLVMPositionBuilderAtEnd(this.builder, cont_block);

				for i in 0u..decl.member_variables.size() {
					if decl.member_variables[i].type.reference_kind != None {
						continue;
					}

					const member_type = decl.member_variables[i].type.decl;

					var parameters: List!<LLVMValueRef>;
					parameters.append(LLVMBuildStructGEP2(this.builder, type, param0, i + 2, ""));

					discard this.codegenCall(member_type.destructor, parameters, ReturnKind::None, signature_span);
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case VariantOpAssign -> {
				const id_type = this.getType(decl.id_type);
				const payload_type = LLVMStructGetTypeAtIndex(type, 1u);

				const id_ptr = LLVMBuildStructGEP2(this.builder, type, param0, 0u, "");
				const this_id = LLVMBuildLoad2(this.builder, id_type, id_ptr, "");
				const this_payload_ptr = LLVMBuildStructGEP2(this.builder, type, param0, 1u, "");

				const other_payload_ptr = LLVMBuildAlloca(this.builder, payload_type, "");
				discard LLVMBuildStore(this.builder, LLVMBuildExtractValue(this.builder, param1, 1u, ""), other_payload_ptr);
				const other_id = LLVMBuildExtractValue(this.builder, param1, 0u, "");

				const payload_copy_ptr = LLVMBuildAlloca(this.builder, LLVMStructGetTypeAtIndex(type, 1u), "");

				var copy_case_count = 0u;
				var dest_case_count = 0u;
				for case_decl in decl.variant_cases {
					if case_decl.type != this.program.void_type {
						copy_case_count++;

						if case_decl.type.reference_kind == None {
							dest_case_count++;
						}
					}
				}

				// copy payload to temporary
				const dest_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "cont");

				var copy_switch_instr = LLVMBuildSwitch(this.builder, other_id, dest_block, copy_case_count);

				for case_decl in decl.variant_cases {
					if case_decl.type == this.program.void_type {
						continue;
					}

					const case_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "case");
					LLVMAddCase(copy_switch_instr, LLVMConstInt(id_type, case_decl.id, false), case_block);
					LLVMPositionBuilderAtEnd(this.builder, case_block);

					const other_payload = LLVMBuildLoad2(this.builder, this.getType(case_decl.type), other_payload_ptr, "");

					if case_decl.type.reference_kind == None {
						const case_type = case_decl.type.decl;
						var parameters: List!<LLVMValueRef>;
						parameters.append(payload_copy_ptr);
						parameters.append(other_payload);

						discard this.codegenCall(case_type.copy_constructor, parameters, ReturnKind::None, signature_span);
					} else {
						discard LLVMBuildStore(this.builder, other_payload, payload_copy_ptr);
					}

					discard LLVMBuildBr(this.builder, dest_block);
				}

				LLVMPositionBuilderAtEnd(this.builder, dest_block);

				// destruct old payload
				var case_destructor_args: List!<LLVMValueRef>;
				case_destructor_args.append(this_payload_ptr);

				const cont_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "cont");

				var switch_instr = LLVMBuildSwitch(this.builder, this_id, cont_block, dest_case_count);

				for case_decl in decl.variant_cases {
					if case_decl.type == this.program.void_type || case_decl.type.reference_kind != None {
						continue;
					}

					const case_type = case_decl.type.decl;

					const case_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "case");
					LLVMAddCase(switch_instr, LLVMConstInt(id_type, case_decl.id, false), case_block);
					LLVMPositionBuilderAtEnd(this.builder, case_block);

					discard this.codegenCall(case_type.destructor, case_destructor_args, ReturnKind::None, signature_span);

					discard LLVMBuildBr(this.builder, cont_block);
				}

				LLVMPositionBuilderAtEnd(this.builder, cont_block);

				// move temporary payload to this
				discard LLVMBuildStore(this.builder, LLVMBuildLoad2(this.builder, payload_type, payload_copy_ptr, ""), this_payload_ptr);
				discard LLVMBuildStore(this.builder, other_id, id_ptr);

				// assign member variables
				for i in 0u..decl.member_variables.size() {
					const member_ptr = LLVMBuildStructGEP2(this.builder, type, param0, i + 2, "");
					const initializer = LLVMBuildExtractValue(this.builder, param1, i + 2, "");

					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;

						var parameters: List!<LLVMValueRef>;
						parameters.append(member_ptr);
						parameters.append(initializer);

						discard this.codegenCall(member_type.op_assign, parameters, ReturnKind::None, signature_span);
					} else {
						discard LLVMBuildStore(this.builder, initializer, member_ptr);
					}
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case StructOpEqual
			| VariantOpEqual -> {
				const uneq_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "uneq");

				if function is VariantOpEqual {
					const id_type = this.getType(decl.id_type);
					const data_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "data");

					// store lhs & rhs on stack to access the payload in a safe way
					const lhs_id = LLVMBuildExtractValue(this.builder, param0, 0u, "");
					const lhs_data = LLVMBuildAlloca(this.builder, type, "");
					discard LLVMBuildStore(this.builder, param0, lhs_data);
					const lhs_payload_ptr = LLVMBuildStructGEP2(this.builder, type, lhs_data, 1u, "");

					const rhs_id = LLVMBuildExtractValue(this.builder, param1, 0u, "");
					const rhs_data = LLVMBuildAlloca(this.builder, type, "");
					discard LLVMBuildStore(this.builder, param1, rhs_data);
					const rhs_payload_ptr = LLVMBuildStructGEP2(this.builder, type, rhs_data, 1u, "");

					const same_id = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, lhs_id, rhs_id, "");
					discard LLVMBuildCondBr(this.builder, same_id, data_block, uneq_block);

					LLVMPositionBuilderAtEnd(this.builder, data_block);

					const cont_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "cont");

					var case_count = 0u;
					for case_decl in decl.variant_cases {
						if case_decl.type != this.program.void_type {
							case_count++;
						}
					}
					var switch_instr = LLVMBuildSwitch(this.builder, lhs_id, cont_block, case_count);

					for case_decl in decl.variant_cases {
						if case_decl.type == this.program.void_type {
							continue;
						}

						const case_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "case")
						LLVMAddCase(switch_instr, LLVMConstInt(id_type, case_decl.id, false), case_block);
						LLVMPositionBuilderAtEnd(this.builder, case_block);

						const lhs = LLVMBuildLoad2(this.builder, this.getType(case_decl.type), lhs_payload_ptr, "");
						const rhs = LLVMBuildLoad2(this.builder, this.getType(case_decl.type), rhs_payload_ptr, "");

						var equal = LLVMValueRef();
						if case_decl.type.reference_kind == None {
							const case_type = case_decl.type.decl;
							var parameters: List!<LLVMValueRef>;
							parameters.append(lhs);
							parameters.append(rhs);

							equal = this.codegenCall(case_type.op_equal, parameters, ReturnKind::Value, signature_span);
						} else {
							equal = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, lhs, rhs, "");
						}

						discard LLVMBuildCondBr(this.builder, equal, cont_block, uneq_block);
					}

					LLVMPositionBuilderAtEnd(this.builder, cont_block);
				}

				const member_var_offset = 2u if function is VariantOpEqual else 0u;
				for i in 0u..decl.member_variables.size() {
					const lhs = LLVMBuildExtractValue(this.builder, param0, i + member_var_offset, "");
					const rhs = LLVMBuildExtractValue(this.builder, param1, i + member_var_offset, "");

					var equal = LLVMValueRef();
					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;
						var parameters: List!<LLVMValueRef>;
						parameters.append(lhs);
						parameters.append(rhs);

						equal = this.codegenCall(member_type.op_equal, parameters, ReturnKind::Value, signature_span);
					} else {
						equal = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, lhs, rhs, "");
					}

					const next_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "next");

					discard LLVMBuildCondBr(this.builder, equal, next_block, uneq_block);
					LLVMPositionBuilderAtEnd(this.builder, next_block);
				}

				discard LLVMBuildRet(this.builder, LLVMConstInt(this.bool_type, 1, false));

				LLVMPositionBuilderAtEnd(this.builder, uneq_block);
				discard LLVMBuildRet(this.builder, LLVMConstInt(this.bool_type, 0, false));
			}
			case StructOpCmp -> {
				const entry_block = LLVMGetInsertBlock(this.builder);
				const uneq_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "uneq");

				var cmp_values: List!<LLVMValueRef>;
				var cmp_blocks: List!<LLVMBasicBlockRef>;

				for i in 0u..decl.member_variables.size() {
					const lhs = LLVMBuildExtractValue(this.builder, param0, i, "");
					const rhs = LLVMBuildExtractValue(this.builder, param1, i, "");
					var parameters: List!<LLVMValueRef>;
					parameters.append(lhs);
					parameters.append(rhs);

					var sign = LLVMValueRef();
					if decl.member_variables[i].type.reference_kind == None {
						const member_type = decl.member_variables[i].type.decl;
						sign = this.codegenCall(member_type.op_compare, parameters, ReturnKind::Value, signature_span);
					} else {
						sign = this.codegenInlineBuiltinFunctionCall(BuiltinFunction::PrimitiveOp(PrimitiveOp::UIntCmp, decl.member_variables[i].type), parameters);
					}
					cmp_values.append(sign);
					cmp_blocks.append(LLVMGetInsertBlock(this.builder));

					const next_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "next");

					const equal = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, sign, LLVMConstInt(this.int_type, 0, false), "");
					discard LLVMBuildCondBr(this.builder, equal, next_block, uneq_block);
					LLVMPositionBuilderAtEnd(this.builder, next_block);
				}

				discard LLVMBuildRet(this.builder, LLVMConstInt(this.int_type, 0, false));

				LLVMPositionBuilderAtEnd(this.builder, uneq_block);
				const phi = LLVMBuildPhi(this.builder, this.int_type, "");
				LLVMAddIncoming(phi, cmp_values, cmp_blocks);
				discard LLVMBuildRet(this.builder, phi);
			}
			case ArrayDefaultConstructor -> {
				// TODO: turn into a loop for better code size (llvm can unroll it for performance)
				const array_type = (decl.body as Array).value();
				const element_type = array_type.element_type;
				const element_type_decl = element_type.decl;

				for i in 0u..array_type.size {
					var indices: List!<LLVMValueRef>;
					indices.append(LLVMConstInt(this.int_type, 0, false));
					indices.append(LLVMConstInt(this.int_type, i as int, false));
					const element_ptr = LLVMBuildGEP2(this.builder, type, param0, indices, "");

					discard this.codegenCall(element_type_decl.default_constructor, List!<LLVMValueRef>(1u, element_ptr), ReturnKind::None, signature_span);
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case ArrayCopyConstructor
			| ArrayDestructor
			| ArrayOpAssign -> {
				// TODO: turn into a loop for better code size (llvm can unroll it for performance)
				const array_type = (decl.body as Array).value();
				const element_type = array_type.element_type;
				const element_type_decl = element_type.decl;

				for i in 0u..array_type.size {
					var indices: List!<LLVMValueRef>;
					indices.append(LLVMConstInt(this.int_type, 0, false));
					indices.append(LLVMConstInt(this.int_type, i as int, false));
					const element_ptr = LLVMBuildGEP2(this.builder, type, param0, indices, "");

					if !(function is ArrayCopyConstructor) {
						discard this.codegenCall(element_type_decl.destructor, List!<LLVMValueRef>(1u, element_ptr), ReturnKind::None, signature_span);
					}

					if !(function is ArrayDestructor) {
						const other_element = LLVMBuildExtractValue(this.builder, param1, i, "");

						var parameters: List!<LLVMValueRef>;
						parameters.append(element_ptr);
						parameters.append(other_element);

						discard this.codegenCall(element_type_decl.copy_constructor, parameters, ReturnKind::None, signature_span);
					}
				}

				discard LLVMBuildRetVoid(this.builder);
			}
			case ArrayOpEqual -> {
				// TODO: turn into a loop for better code size (llvm can unroll it for performance)
				const array_type = (decl.body as Array).value();
				const element_type = array_type.element_type;
				const element_type_decl = element_type.decl;

				const uneq_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "uneq");

				for i in 0u..array_type.size {
					const lhs = LLVMBuildExtractValue(this.builder, param0, i, "");
					const rhs = LLVMBuildExtractValue(this.builder, param1, i, "");

					var equal = LLVMValueRef();
					if element_type.reference_kind == None {
						var parameters: List!<LLVMValueRef>;
						parameters.append(lhs);
						parameters.append(rhs);

						equal = this.codegenCall(element_type_decl.op_equal, parameters, ReturnKind::Value, signature_span);
					} else {
						equal = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, lhs, rhs, "");
					}

					const next_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "next");

					discard LLVMBuildCondBr(this.builder, equal, next_block, uneq_block);
					LLVMPositionBuilderAtEnd(this.builder, next_block);
				}

				discard LLVMBuildRet(this.builder, LLVMConstInt(this.bool_type, 1, false));

				LLVMPositionBuilderAtEnd(this.builder, uneq_block);
				discard LLVMBuildRet(this.builder, LLVMConstInt(this.bool_type, 0, false));
			}
			else -> {
				var parameters: List!<LLVMValueRef>;
				for i in 0u32..LLVMCountParams(this.current_function) {
					parameters.append(LLVMGetParam(this.current_function, i));
				}

				discard LLVMBuildRet(this.builder, this.codegenInlineBuiltinFunctionCall(function, parameters));
			}
		}
	}

	func codegenPrimitiveOp(this: &&CGContext, type: LLVMTypeRef, op: PrimitiveOp, parameters: &List!<LLVMValueRef>) -> LLVMValueRef {
		var lhs = parameters.at(0u) ?? LLVMValueRef();
		var rhs = parameters.at(1u) ?? LLVMValueRef();
		if op.isAssignment() && op.getOp() > Copy {
			lhs = LLVMBuildLoad2(this.builder, type, lhs, "");
		}

		var result: LLVMValueRef;
		match op.getOp() {
			case NoOp -> {}
			case ConstNull -> result = LLVMConstNull(type);
			case Copy -> result = rhs;
			case BitwiseEQ -> result = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, lhs, rhs, "");
			case BitwiseNE -> result = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntNE, lhs, rhs, "");
			case BitwiseAnd -> result = LLVMBuildAnd(this.builder, lhs, rhs, "");
			case BitwiseOr -> result = LLVMBuildOr(this.builder, lhs, rhs, "");
			case BitwiseXOr -> result = LLVMBuildXor(this.builder, lhs, rhs, "");
			case BitwiseNot -> result = LLVMBuildNot(this.builder, lhs, "");
			case BitwiseShl -> result = LLVMBuildShl(this.builder, lhs, rhs, "");
			case BitwiseLShr -> result = LLVMBuildLShr(this.builder, lhs, rhs, "");
			case BitwiseAShr -> result = LLVMBuildAShr(this.builder, lhs, rhs, "");
			case IntAdd -> result = LLVMBuildAdd(this.builder, lhs, rhs, "");
			case IntSub -> result = LLVMBuildSub(this.builder, lhs, rhs, "");
			case IntMul -> result = LLVMBuildMul(this.builder, lhs, rhs, "");
			case IntNeg -> result = LLVMBuildNeg(this.builder, lhs, "");
			case IntInc -> result = LLVMBuildAdd(this.builder, lhs, LLVMConstInt(type, 1, false), "");
			case IntDec -> result = LLVMBuildSub(this.builder, lhs, LLVMConstInt(type, 1, false), "");
			case SIntLT -> result = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSLT, lhs, rhs, "");
			case SIntLE -> result = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSLE, lhs, rhs, "");
			case SIntGT -> result = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSGT, lhs, rhs, "");
			case SIntGE -> result = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSGE, lhs, rhs, "");
			case SIntCmp -> result = LLVMBuildSub(this.builder,
				LLVMBuildZExt(this.builder, LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSGT, lhs, rhs, ""), this.int_type, ""),
				LLVMBuildZExt(this.builder, LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSLT, lhs, rhs, ""), this.int_type, ""), ""
			);
			case SIntDiv -> result = LLVMBuildSDiv(this.builder, lhs, rhs, "");
			case SIntMod -> result = LLVMBuildSRem(this.builder, lhs, rhs, "");
			case UIntLT -> result = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULT, lhs, rhs, "");
			case UIntLE -> result = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULE, lhs, rhs, "");
			case UIntGT -> result = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntUGT, lhs, rhs, "");
			case UIntGE -> result = LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntUGE, lhs, rhs, "");
			case UIntCmp -> result = LLVMBuildSub(this.builder,
				LLVMBuildZExt(this.builder, LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntUGT, lhs, rhs, ""), this.int_type, ""),
				LLVMBuildZExt(this.builder, LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULT, lhs, rhs, ""), this.int_type, ""), ""
			);
			case UIntDiv -> result = LLVMBuildUDiv(this.builder, lhs, rhs, "");
			case UIntMod -> result = LLVMBuildURem(this.builder, lhs, rhs, "");
			case FloatEQ -> result = LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOEQ, lhs, rhs, "");
			case FloatNE -> result = LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealONE, lhs, rhs, "");
			case FloatLT -> result = LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOLT, lhs, rhs, "");
			case FloatLE -> result = LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOLE, lhs, rhs, "");
			case FloatGT -> result = LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOGT, lhs, rhs, "");
			case FloatGE -> result = LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOGE, lhs, rhs, "");
			case FloatCmp -> result = LLVMBuildSub(this.builder,
				LLVMBuildZExt(this.builder, LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOGT, lhs, rhs, ""), this.int_type, ""),
				LLVMBuildZExt(this.builder, LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOLT, lhs, rhs, ""), this.int_type, ""), ""
			);
			case FloatAdd -> result = LLVMBuildFAdd(this.builder, lhs, rhs, "");
			case FloatSub -> result = LLVMBuildFSub(this.builder, lhs, rhs, "");
			case FloatMul -> result = LLVMBuildFMul(this.builder, lhs, rhs, "");
			case FloatDiv -> result = LLVMBuildFDiv(this.builder, lhs, rhs, "");
			case FloatMod -> result = LLVMBuildFRem(this.builder, lhs, rhs, "");
			case FloatNeg -> result = LLVMBuildFNeg(this.builder, lhs, "");
			case Assign -> {}
		}

		if op.isAssignment() {
			discard LLVMBuildStore(this.builder, result, parameters[0u]);
			return LLVMValueRef();
		} else {
			return result;
		}
	}

	func codegenInlineBuiltinFunctionCall(this: &&CGContext, function: BuiltinFunction, parameters: &List!<LLVMValueRef>) -> LLVMValueRef {
		match function {
			case PrimitiveOp: op -> return this.codegenPrimitiveOp(this.getType(function.base_type), op, parameters);
			case PointerToRef -> return parameters[0u];	// reference & pointer types are the same in llvm
			case RefToPointer -> return parameters[0u];	// reference & pointer types are the same in llvm
			case PointerCast -> return parameters[0u];	// all pointer types are the same in llvm

			case PointerDiff -> {
				const pointer_type = (function.base_type.decl.body as Pointer).value();
				const pointee_type = this.getType(pointer_type.pointee_type);
				return LLVMBuildPtrDiff2(this.builder, pointee_type, parameters[0u], parameters[1u], "");
			}
			case PointerOffset
			| PointerOpIndex -> {
				const pointer_type = (function.base_type.decl.body as Pointer).value();
				const pointee_type = this.getType(pointer_type.pointee_type);

				var indices: List!<LLVMValueRef>;
				indices.append(parameters[1u]);
				return LLVMBuildGEP2(this.builder, pointee_type, parameters[0u], indices, "");
			}

			case FunctionPointerCall -> {
				const function_type = (function.base_type.decl.body as Function).value();

				const return_type = this.getType(function_type.return_type);
				var parameter_types: List!<LLVMTypeRef>;
				for p in function_type.parameter_types {
					parameter_types.append(this.getType(p));
				}
				const llvm_function_type = LLVMFunctionType(return_type, parameter_types, false);

				const call_parameters = List!<LLVMValueRef>(parameters[1u..parameters.size()]);
				const result = LLVMBuildCall2(this.builder, llvm_function_type, parameters[0u], call_parameters, "");

				if return_type == this.void_type {
					return LLVMValueRef();
				} else {
					return result;
				}
			}

			case IntCast: target -> {
				const source_type = this.getType(function.base_type);
				const target_type = this.getType(target);

				const source_width = LLVMGetIntTypeWidth(source_type);
				const target_width = LLVMGetIntTypeWidth(target_type);

				if source_width == target_width {
					return parameters[0u];
				} else if source_width > target_width {
					return LLVMBuildTrunc(this.builder, parameters[0u], target_type, "");
				} else if function.base_type.isSigned() && target.isSigned() {
					return LLVMBuildSExt(this.builder, parameters[0u], target_type, "");
				} else {
					return LLVMBuildZExt(this.builder, parameters[0u], target_type, "");
				}
			}
			case FloatCast: target -> {
				const source_type = this.getType(function.base_type);
				const target_type = this.getType(target);

				const source_width = LLVMStoreSizeOfType(this.data_layout, source_type);
				const target_width = LLVMStoreSizeOfType(this.data_layout, target_type);

				if source_width == target_width {
					return parameters[0u];
				} else if source_width > target_width {
					return LLVMBuildFPTrunc(this.builder, parameters[0u], target_type, "");
				} else {
					return LLVMBuildFPExt(this.builder, parameters[0u], target_type, "");
				}
			}
			case IntToFloat: target -> {
				if function.base_type.isSigned() {
					return LLVMBuildSIToFP(this.builder, parameters[0u], this.getType(target), "");
				} else {
					return LLVMBuildUIToFP(this.builder, parameters[0u], this.getType(target), "");
				}
			}
			case FloatToInt: target -> {
				if target.isSigned() {
					return LLVMBuildFPToSI(this.builder, parameters[0u], this.getType(target), "");
				} else {
					return LLVMBuildFPToUI(this.builder, parameters[0u], this.getType(target), "");
				}
			}

			case SizeOf -> {
				// ptrtoint (ptr getelementptr (type, ptr null, i32 1) to i64)
				const type = this.getType(function.base_type);
				return LLVMConstPtrToInt(
					LLVMConstGEP2(
						type,
						LLVMConstNull(this.ptr_type),
						List!<LLVMValueRef>(1u, LLVMConstInt(this.int_type, 1, false))
					),
					this.int_type
				);
			}
			case AlignmentOf -> return LLVMConstInt(this.int_type, LLVMPreferredAlignmentOfType(this.data_layout, this.getType(function.base_type)) as int, false);
			case ReferenceKindOf -> return LLVMConstInt(this.int_type, function.base_type.reference_kind as int, false);

			case VariantOpUnsafeAs: id -> {
				const case_decl = function.base_type.decl.getVariantCase(id).value();
				var result = LLVMBuildStructGEP2(this.builder, this.getType(function.base_type), parameters[0u], 1u, "");
				if case_decl.type.reference_kind != None {
					result = LLVMBuildLoad2(this.builder, this.getType(case_decl.type), result, "");
				}
				return result;
			}

			case VariantOpIs: id -> {
				const id_type = this.getType(function.base_type.decl.id_type);
				const object_id = LLVMBuildExtractValue(this.builder, parameters[0u], 0u, "");
				return LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, object_id, LLVMConstInt(id_type, id, false), "");
			}

			case ArrayGetSize -> {
				const size = (function.base_type.decl.body as Array).value().size;
				return LLVMConstInt(this.int_type, size as int, false);
			}
			case ArrayGetDataPointer -> {
				var indices: List!<LLVMValueRef>;
				indices.append(LLVMConstInt(this.int_type, 0, false));
				indices.append(LLVMConstInt(this.int_type, 0, false));
				return LLVMBuildGEP2(this.builder, this.getType(function.base_type), parameters[0u], indices, "");
			}
			else -> panic("builtin function is not inlineable");
		}
	}

	func codegenStmt(this: &&CGContext, stmt: &Stmt) -> void {
		match stmt {
			case Compound: &compound_stmt -> this.codegenCompoundStmt(compound_stmt);
			case Expr: &expr -> {
				discard this.codegenExpr(expr);
				if expr.type == this.program.never_type {
					discard LLVMBuildUnreachable(this.builder);
				}
			}
			case If: &if_stmt -> this.codegenIfStmt(if_stmt, stmt.span);
			case While: &while_stmt -> this.codegenWhileStmt(while_stmt, stmt.span);
			case Break -> {
				this.setCurrentDebugLocation(stmt.span);
				discard LLVMBuildBr(this.builder, this.break_target);
			}
			case Continue -> {
				this.setCurrentDebugLocation(stmt.span);
				discard LLVMBuildBr(this.builder, this.continue_target);
			}
			case Yield -> {
				this.setCurrentDebugLocation(stmt.span);
				discard LLVMBuildBr(this.builder, this.yield_target);
			}
			case Return: &value -> {
				if value is Void && this.current_function == this.getFunction(this.program.main_function) {
					this.setCurrentDebugLocation(stmt.span);
					discard LLVMBuildRet(this.builder, LLVMConstInt(this.int_type, 0, false));
				} else {
					const built_value = this.codegenExpr(value);
					this.setCurrentDebugLocation(stmt.span);
					discard LLVMBuildRet(this.builder, built_value);
				}
			}
			case LifeTimeStart: variable -> {
				if !(variable.destructor_call is Undefined) {
					this.codegenLifeTimeStart(this.getVariable(variable));
				}
				discard this.codegenExpr(variable.constructor_call);
			}
			case LifeTimeEnd: variable -> {
				discard this.codegenExpr(variable.destructor_call);
				if !(variable.destructor_call is Undefined) {
					this.codegenLifeTimeEnd(this.getVariable(variable));
				}
			}
			case Empty -> {}
			else -> this.todo("finish codegen of statements", stmt.span);
		}
	}

	func codegenCompoundStmt(this: &&CGContext, compound_stmt: &CompoundStmt) -> void {
		for stmt in compound_stmt.children {
			this.codegenStmt(stmt);
		}
	}

	func codegenIfStmt(this: &&CGContext, if_stmt: &IfStmt, span: Span) -> void {
		const condition = this.codegenExpr(if_stmt.condition);
		for stmt in if_stmt.condition_cleanup {
			discard this.codegenStmt(stmt);
		}

		const then_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "then");
		const else_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "else");
		const cont_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "cont");

		var then_branch_terminates = false;
		var else_branch_terminates = false;

		this.setCurrentDebugLocation(span);
		discard LLVMBuildCondBr(this.builder, condition, then_block, else_block);

		LLVMPositionBuilderAtEnd(this.builder, then_block);
		this.codegenStmt(if_stmt.then_branch);
		if !LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) {
			discard LLVMBuildBr(this.builder, cont_block);
		} else {
			then_branch_terminates = true;
		}

		LLVMPositionBuilderAtEnd(this.builder, else_block);
		this.codegenStmt(if_stmt.else_branch);
		if !LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) {
			discard LLVMBuildBr(this.builder, cont_block);
		} else {
			else_branch_terminates = true;
		}

		LLVMPositionBuilderAtEnd(this.builder, cont_block);

		if then_branch_terminates && else_branch_terminates {
			discard LLVMBuildUnreachable(this.builder);
		}
	}

	func codegenWhileStmt(this: &&CGContext, while_stmt: &WhileStmt, span: Span) -> void {
		const cond_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "cond");
		const loop_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "loop");
		const cont_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "cont");

		const prev_continue_target = this.continue_target;
		const prev_break_target = this.break_target;

		this.continue_target = cond_block;
		this.break_target = cont_block;

		this.setCurrentDebugLocation(span);

		if while_stmt.kind == While {
			discard LLVMBuildBr(this.builder, cond_block);
		} else {
			discard LLVMBuildBr(this.builder, loop_block);
		}

		LLVMPositionBuilderAtEnd(this.builder, cond_block);
		const condition = this.codegenExpr(while_stmt.condition);
		for stmt in while_stmt.condition_cleanup {
			discard this.codegenStmt(stmt);
		}
		discard LLVMBuildCondBr(this.builder, condition, loop_block, cont_block);

		var body_terminates = false;

		LLVMPositionBuilderAtEnd(this.builder, loop_block);
		this.codegenStmt(while_stmt.body);

		if !LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) {
			discard LLVMBuildBr(this.builder, cond_block);
		} else {
			body_terminates = true;
		}

		LLVMPositionBuilderAtEnd(this.builder, cont_block);
		if body_terminates && while_stmt.kind == DoWhile {
			discard LLVMBuildUnreachable(this.builder);
		}

		this.continue_target = prev_continue_target;
		this.break_target = prev_break_target;
	}

	func codegenStringGlobal(this: &&CGContext, value: String) -> LLVMValueRef {
		match this.program.string_globals.get(value) {
			case Some: result -> return result;
			else -> {}
		}

		const string_value = LLVMConstStringInContext(this.llvm_context, value, true);
		const result = LLVMAddGlobal(this.llvm_module, LLVMTypeOf(string_value), "");
		LLVMSetLinkage(result, LLVMLinkage::LLVMPrivateLinkage);
		LLVMSetUnnamedAddress(result, LLVMUnnamedAddr::LLVMGlobalUnnamedAddr);
		LLVMSetAlignment(result, 1u);
		LLVMSetInitializer(result, string_value);
		LLVMSetGlobalConstant(result, true);

		this.program.string_globals.set(value, result);
		return result;
	}

	func codegenExpr(this: &&CGContext, expr: &Expr) -> LLVMValueRef {
		match expr {
			case Undefined -> {
				if expr.type == this.program.void_type || expr.type.isUnknown() {
					return LLVMValueRef();
				} else {
					return LLVMGetUndef(this.getType(expr.type));
				}
			}
			case Void -> return LLVMValueRef();
			case Integer: value -> return LLVMConstInt(this.getType(expr.type), value, expr.type.isSigned());
			case Float: value -> return LLVMConstReal(this.getType(expr.type), value);
			case String: value -> {
				const data_ptr = this.codegenStringGlobal(value);
				var result = LLVMConstNull(this.getType(expr.type));
				result = LLVMBuildInsertValue(this.builder, result, data_ptr, 0u, "");
				result = LLVMBuildInsertValue(this.builder, result, LLVMConstInt(this.int_type, value.size() as int, false), 1u, ""); // size
				result = LLVMBuildInsertValue(this.builder, result, LLVMConstInt(this.int_type, value.size() as int, false), 2u, ""); // capacity
				return result;
			}
			case ConstAggregate: &elements -> {
				var result = LLVMConstNull(this.getType(expr.type));
				for i in 0u..elements.size() {
					const element = this.codegenExpr(elements[i]);
					result = LLVMBuildInsertValue(this.builder, result, element, i, "");
				}
				return result;
			}
			case Call: &call_expr -> return this.codegenCall(call_expr, expr.span);
			case VarInvoke: &variable -> {
				if variable.type.reference_kind == None || variable.is_parameter {
					return this.getVariable(variable);
				} else {
					this.setCurrentDebugLocation(expr.span);
					return LLVMBuildLoad2(this.builder, this.getType(variable.type), this.getVariable(variable), "");
				}
			}
			case MemberVarInvoke: &member_var_invoke_expr -> {
				const object_type_decl = member_var_invoke_expr.object.type.decl;
				const member_decl = object_type_decl.member_variables[member_var_invoke_expr.id];

				const object = this.codegenExpr(member_var_invoke_expr.object);
				const object_type = this.getType(member_var_invoke_expr.object.type.base());

				var id = member_var_invoke_expr.id;
				if member_var_invoke_expr.object.type.isVariant() {
					id += 2;
				}

				this.setCurrentDebugLocation(expr.span);
				const ptr = LLVMBuildStructGEP2(this.builder, object_type, object, id, "");

				if member_decl.type.reference_kind == None {
					return ptr;
				} else {
					return LLVMBuildLoad2(this.builder, this.getType(member_decl.type), ptr, "");
				}
			}
			case Dereference: &base -> {
				this.setCurrentDebugLocation(expr.span);
				return LLVMBuildLoad2(this.builder, this.getType(expr.type), this.codegenExpr(base), "");
			}
			case Match: &match_expr -> return this.codegenMatchExpr(match_expr, expr.span);
			case ShallowCopy: shallow_copy_expr -> {
				var dst = LLVMValueRef();
				match shallow_copy_expr.destination {
					case VarInvoke: &variable -> dst = this.getVariable(variable);
					case MemberVarInvoke: &member_var_invoke_expr -> {
						const object = this.codegenExpr(member_var_invoke_expr.object);
						const object_type = this.getType(member_var_invoke_expr.object.type.base());

						var id = member_var_invoke_expr.id;
						if member_var_invoke_expr.object.type.isVariant() {
							id += 2;
						}

						dst = LLVMBuildStructGEP2(this.builder, object_type, object, member_var_invoke_expr.id, "");
					}
					else -> panic("invalid shallow copy expr");
				}

				const val = this.codegenExpr(shallow_copy_expr.value);

				this.setCurrentDebugLocation(expr.span);
				discard LLVMBuildStore(this.builder, val, dst);
				return val;
			}
			case TypeRef -> return LLVMValueRef();
			case FunctionRef: function -> return this.getFunction(function);
		}
	}

	func codegenCall(this: &&CGContext, call_expr: &CallExpr, span: Span) -> LLVMValueRef {
		var parameters: List!<LLVMValueRef>;
		for parameter in call_expr.parameters {
			parameters.append(this.codegenExpr(parameter));
		}

		return this.codegenCall(call_expr.function, parameters, call_expr.return_kind, call_expr.result_var, span);
	}

	func codegenCall(this: &&CGContext, function: SharedHandle!<FunctionDecl>, parameters: &List!<LLVMValueRef>, return_kind: ReturnKind, span: Span) -> LLVMValueRef {
		assert(return_kind == ReturnKind::None || return_kind == ReturnKind::Value);
		return this.codegenCall(function, parameters, return_kind, SharedHandle!<VarDecl>(), span);
	}

	func codegenCall(this: &&CGContext, function: SharedHandle!<FunctionDecl>, parameters: &List!<LLVMValueRef>, return_kind: ReturnKind, result_var: SharedHandle!<VarDecl>, span: Span) -> LLVMValueRef {
		this.setCurrentDebugLocation(span);

		if return_kind is Parameter {
			this.codegenLifeTimeStart(this.getVariable(result_var));
		}

		const result = match function.body {
			case Builtin: builtin_function -> {
				if builtin_function.isInlineable() {
					yield this.codegenInlineBuiltinFunctionCall(builtin_function, parameters);
				} else {
					const llvm_func = this.getFunction(function);
					yield LLVMBuildCall2(this.builder, function.llvm_type, llvm_func, parameters, "");
				}
			}
			else -> {
				const llvm_func = this.getFunction(function);
				yield LLVMBuildCall2(this.builder, function.llvm_type, llvm_func, parameters, "");
			}
		}

		match return_kind {
			case None -> return LLVMValueRef();
			case Value -> return result;
			case Variable -> {
				const built_result_var = this.getVariable(result_var);
				discard LLVMBuildStore(this.builder, result, built_result_var);
				return built_result_var;
			}
			case Parameter -> return this.getVariable(result_var);
			case VariableButYieldNone -> {
				const built_result_var = this.getVariable(result_var);
				discard LLVMBuildStore(this.builder, result, built_result_var);
				return LLVMValueRef();
			}
		}
	}

	func codegenMatchExpr(this: &&CGContext, match_expr: &MatchExpr, span: Span) -> LLVMValueRef {
		var value = this.codegenExpr(match_expr.value);

		if match_expr.value.type.isVariant() {
			const value_type_decl = match_expr.value.type.decl;
			value = LLVMBuildLoad2(this.builder, 
				this.getType(value_type_decl.id_type),
				LLVMBuildStructGEP2(this.builder, 
					this.getType(match_expr.value.type.base()),
					value, 0u, ""
				), ""
			);
		} else if match_expr.value.type.reference_kind != None {
			value = LLVMBuildLoad2(this.builder, 
				this.getType(match_expr.value.type.base()),
				value, ""
			);
		}

		var case_blocks: List!<LLVMBasicBlockRef>;
		for i in 0u..match_expr.cases.size() {
			case_blocks.append(LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "case"));
		}

		const else_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "else");
		const cont_block = LLVMAppendBasicBlockInContext(this.llvm_context, this.current_function, "cont");

		const prev_yield_target = this.yield_target;
		this.yield_target = cont_block;

		this.setCurrentDebugLocation(span);

		var switch_instr = LLVMBuildSwitch(this.builder, value, else_block, case_blocks.size());

		for i in 0u..match_expr.cases.size() {
			for pattern in match_expr.cases[i].patterns {
				const built_pattern = this.codegenExpr(pattern);
				LLVMAddCase(switch_instr, built_pattern, case_blocks[i]);
			}
		}

		for i in 0u..match_expr.cases.size() {
			LLVMPositionBuilderAtEnd(this.builder, case_blocks[i]);
			this.codegenStmt(match_expr.cases[i].body);
			if !LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) {
				discard LLVMBuildBr(this.builder, cont_block);
			}
		}

		LLVMPositionBuilderAtEnd(this.builder, else_block);
		if match_expr.else_case is Empty {
			discard LLVMBuildUnreachable(this.builder);
		} else {
			this.codegenStmt(match_expr.else_case);

			if !LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) {
				discard LLVMBuildBr(this.builder, cont_block);
			}
		}

		LLVMPositionBuilderAtEnd(this.builder, cont_block);
		this.yield_target = prev_yield_target;

		return this.variables.get(match_expr.yield_var) ?? LLVMValueRef();
	}

	func codegenIntrinsicCall(this: &&CGContext, intrinsic_name: String, parameter_types: &List!<LLVMTypeRef>, parameters: &List!<LLVMValueRef>) -> LLVMValueRef {
		const id = LLVMLookupIntrinsicID(intrinsic_name);
		const type = LLVMIntrinsicGetType(this.llvm_context, id, parameter_types);
		const declaration = LLVMGetIntrinsicDeclaration(this.llvm_module, id, parameter_types);

		return LLVMBuildCall2(this.builder, type, declaration, parameters, "");
	}

	func codegenLifeTimeStart(this: &&CGContext, address: LLVMValueRef) -> void {
		var parameters: List!<LLVMValueRef>;
		parameters.append(LLVMConstInt(this.int_type, 1, false));
		parameters.append(address);
		discard this.codegenIntrinsicCall("llvm.lifetime.start", List!<LLVMTypeRef>(1u, this.ptr_type), parameters);
	}

	func codegenLifeTimeEnd(this: &&CGContext, address: LLVMValueRef) -> void {
		var parameters: List!<LLVMValueRef>;
		parameters.append(LLVMConstInt(this.int_type, 1, false));
		parameters.append(address);
		discard this.codegenIntrinsicCall("llvm.lifetime.end", List!<LLVMTypeRef>(1u, this.ptr_type), parameters);
	}
}
