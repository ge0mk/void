import std/core;
import std/list;
import std/io;
import std/shared;
import std/shared_list;
import std/string;

import program;
import span;

func createCoreDecls(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	program.any_concept = program.createConcept(Concept::Any("type"));
	program.bool_concept = program.createConcept(Concept::Boolean("bool"));
	program.int_concept = program.createConcept(Concept::Integer(true, "int"));
	program.uint_concept = program.createConcept(Concept::Integer(false, "uint"));
	program.string_concept = program.createConcept(Concept::String("String"));

	program.void_type = Type(program.createType(dest_namespace, "void", TypeBody::Void));
	program.never_type = Type(program.createType(dest_namespace, "never", TypeBody::Void));

	program.core_namespace = dest_namespace;

	createPrimitiveCastTemplates(&&program, dest_namespace);
	createCoreReflectionFunctionTemplates(&&program, dest_namespace);

	createBoolType(&&program, dest_namespace);

	// requires bool type for comparision operators
	createPtrSizedIntType(&&program, dest_namespace, true);
	createPtrSizedIntType(&&program, dest_namespace, false);

	// requires uint-literal concept created by ptr-sized uint type
	createIntTypeTemplate(&&program, dest_namespace, true);
	createIntTypeTemplate(&&program, dest_namespace, false);

	// requires ptr-sized signed int type for <=> operator
	createByteType(&&program, dest_namespace);

	createOpaquePtrType(&&program, dest_namespace, true);
	createOpaquePtrType(&&program, dest_namespace, false);

	createPtrTypeTemplate(&&program, dest_namespace, true);
	createPtrTypeTemplate(&&program, dest_namespace, false);

	createFunctionTypeTemplate(&&program, dest_namespace);

	createFloatTypeTemplate(&&program, dest_namespace);

	createTupleTypeTemplate(&&program, dest_namespace);
}

func createPrimitiveCastTemplates(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var cast_template_parameters = List!<TemplateParameterDecl>();
	cast_template_parameters.append(TemplateParameterDecl("Source", program.any_concept, false));
	cast_template_parameters.append(TemplateParameterDecl("Target", program.any_concept, false));

	discard program.createFunction(dest_namespace, "intCast", cast_template_parameters, BuiltinFunction::IntCast(Type::unknown(), Type::unknown()));
	discard program.createFunction(dest_namespace, "floatCast", cast_template_parameters, BuiltinFunction::FloatCast(Type::unknown(), Type::unknown()));
	discard program.createFunction(dest_namespace, "intToFloat", cast_template_parameters, BuiltinFunction::IntToFloat(Type::unknown(), Type::unknown()));
	discard program.createFunction(dest_namespace, "floatToInt", cast_template_parameters, BuiltinFunction::FloatToInt(Type::unknown(), Type::unknown()));
	discard program.createFunction(dest_namespace, "pointerCast", cast_template_parameters, BuiltinFunction::PointerCast(Type::unknown()));
}

func createPrimitiveCastInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, name: String, source: Type, target: Type) -> SharedHandle!<FunctionDecl> {
	var template_parameters = List!<TemplateParameterDecl>();
	template_parameters.append(TemplateParameterDecl("Source", program.any_concept, false, TemplateParameter::Type(source)));
	template_parameters.append(TemplateParameterDecl("Target", program.any_concept, false, TemplateParameter::Type(target)));

	var parameter_types = List!<Type>();
	parameter_types.append(source);

	var body = FunctionBody::Empty;
	if name == "intCast" {
		body = FunctionBody::Builtin(BuiltinFunction::IntCast(target, source));
	} else if name == "floatCast" {
		body = FunctionBody::Builtin(BuiltinFunction::FloatCast(target, source));
	} else if name == "intToFloat" {
		body = FunctionBody::Builtin(BuiltinFunction::IntToFloat(target, source));
	} else if name == "floatToInt" {
		body = FunctionBody::Builtin(BuiltinFunction::FloatToInt(target, source));
	} else if name == "pointerCast" {
		body = FunctionBody::Builtin(BuiltinFunction::PointerCast(target));
	} else {
		panic("invalid numeric cast name: " + name);
	}

	return program.createFunction(dest_namespace, name, template_parameters, parameter_types, target, body);
}

func createCoreReflectionFunctionTemplates(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var template_parameters = List!<TemplateParameterDecl>();
	template_parameters.append(TemplateParameterDecl("Type", program.any_concept, false));

	discard program.createFunction(dest_namespace, "sizeOf", template_parameters, BuiltinFunction::SizeOf(Type::unknown()));
	discard program.createFunction(dest_namespace, "alignmentOf", template_parameters, BuiltinFunction::AlignmentOf(Type::unknown()));
	discard program.createFunction(dest_namespace, "referenceKindOf", template_parameters, BuiltinFunction::ReferenceKindOf(Type::unknown()));
}

func createUnaryFunction(program: &&Program, type_namespace: SharedHandle!<Namespace>, name: String, obj: Type, return_type: Type, body: BuiltinFunction) -> SharedHandle!<FunctionDecl> {
	var parameter_types: List!<Type>;
	parameter_types.append(obj);
	return program.createFunction(type_namespace, name, parameter_types, return_type, body);
}

func createBinaryFunction(program: &&Program, type_namespace: SharedHandle!<Namespace>, name: String, lhs: Type, rhs: Type, return_type: Type, body: BuiltinFunction) -> SharedHandle!<FunctionDecl> {
	var parameter_types: List!<Type>;
	parameter_types.append(lhs);
	parameter_types.append(rhs);
	return program.createFunction(type_namespace, name, parameter_types, return_type, body);
}

func createBasicFunctions(program: &&Program, type: Type, type_namespace: SharedHandle!<Namespace>) -> void {
	type.decl.default_constructor = program.createUnaryFunction(type_namespace, "constructor", type.varRef(), program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::ConstNull | Assign, type));
	type.decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
	type.decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::NoOp, type));
	type.decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
}

func createIntComparisonOperators(program: &&Program, type: Type, type_namespace: SharedHandle!<Namespace>, is_signed: bool) -> void {
	type.decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseEQ, type));
	discard program.createBinaryFunction(type_namespace, "operator !=", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseNE, type));

	if is_signed {
		discard program.createBinaryFunction(type_namespace, "operator <", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::SIntLT, type));
		discard program.createBinaryFunction(type_namespace, "operator <=", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::SIntLE, type));
		discard program.createBinaryFunction(type_namespace, "operator >", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::SIntGT, type));
		discard program.createBinaryFunction(type_namespace, "operator >=", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::SIntGE, type));
		type.decl.op_compare = program.createBinaryFunction(type_namespace, "operator <=>", type, type, program.int_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::SIntCmp, type));
	} else {
		discard program.createBinaryFunction(type_namespace, "operator <", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::UIntLT, type));
		discard program.createBinaryFunction(type_namespace, "operator <=", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::UIntLE, type));
		discard program.createBinaryFunction(type_namespace, "operator >", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::UIntGT, type));
		discard program.createBinaryFunction(type_namespace, "operator >=", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::UIntGE, type));
		type.decl.op_compare = program.createBinaryFunction(type_namespace, "operator <=>", type, type, program.int_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::UIntCmp, type));
	}
}

func createBitwiseOperators(program: &&Program, type: Type, type_namespace: SharedHandle!<Namespace>, arithmetic_right_shift: bool) -> void {
	discard program.createBinaryFunction(type_namespace, "operator &", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseAnd, type));
	discard program.createBinaryFunction(type_namespace, "operator |", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseOr, type));
	discard program.createBinaryFunction(type_namespace, "operator ^", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseXOr, type));

	discard program.createUnaryFunction(type_namespace, "operator ~", type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseNot, type));

	discard program.createBinaryFunction(type_namespace, "operator <<", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseShl, type));
	if arithmetic_right_shift {
		discard program.createBinaryFunction(type_namespace, "operator >>", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseAShr, type));
	} else {
		discard program.createBinaryFunction(type_namespace, "operator >>", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseLShr, type));
	}

	discard program.createBinaryFunction(type_namespace, "operator &=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseAnd | Assign, type));
	discard program.createBinaryFunction(type_namespace, "operator |=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseOr | Assign, type));
	discard program.createBinaryFunction(type_namespace, "operator ^=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseXOr | Assign, type));

	discard program.createBinaryFunction(type_namespace, "operator <<=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseShl | Assign, type));
	if arithmetic_right_shift {
		discard program.createBinaryFunction(type_namespace, "operator >>=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseAShr | Assign, type));
	} else {
		discard program.createBinaryFunction(type_namespace, "operator >>=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseLShr | Assign, type));
	}
}

func createIntArithmeticOperators(program: &&Program, type: Type, type_namespace: SharedHandle!<Namespace>, is_signed: bool) -> void {
	discard program.createBinaryFunction(type_namespace, "operator +", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::IntAdd, type));
	discard program.createBinaryFunction(type_namespace, "operator -", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::IntSub, type));
	discard program.createBinaryFunction(type_namespace, "operator *", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::IntMul, type));

	if is_signed {
		discard program.createBinaryFunction(type_namespace, "operator /", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::SIntDiv, type));
		discard program.createBinaryFunction(type_namespace, "operator %", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::SIntMod, type));
	} else {
		discard program.createBinaryFunction(type_namespace, "operator /", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::UIntDiv, type));
		discard program.createBinaryFunction(type_namespace, "operator %", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::UIntMod, type));
	}

	if is_signed {
		discard program.createUnaryFunction(type_namespace, "operator -", type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::IntNeg, type));
	}

	discard program.createUnaryFunction(type_namespace, "operator ++", type.varRef(), program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::IntInc | Assign, type));
	discard program.createUnaryFunction(type_namespace, "operator --", type.varRef(), program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::IntDec | Assign, type));

	discard program.createBinaryFunction(type_namespace, "operator +=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::IntAdd | Assign, type));
	discard program.createBinaryFunction(type_namespace, "operator -=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::IntSub | Assign, type));
	discard program.createBinaryFunction(type_namespace, "operator *=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::IntMul | Assign, type));

	if is_signed {
		discard program.createBinaryFunction(type_namespace, "operator /=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::SIntDiv | Assign, type));
		discard program.createBinaryFunction(type_namespace, "operator %=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::SIntMod | Assign, type));
	} else {
		discard program.createBinaryFunction(type_namespace, "operator /=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::UIntDiv | Assign, type));
		discard program.createBinaryFunction(type_namespace, "operator %=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::UIntMod | Assign, type));
	}
}

func createBoolType(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	const type = Type(program.createType(dest_namespace, "bool", TypeBody::Bool), ReferenceKind::None);
	const type_namespace = type.decl.linked_namespace;

	program.bool_type = type;

	createBasicFunctions(&&program, type, type_namespace);

	type.decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseEQ, type));
	discard program.createBinaryFunction(type_namespace, "operator !=", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseNE, type));

	discard program.createBinaryFunction(type_namespace, "operator &&", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseAnd, type));
	discard program.createBinaryFunction(type_namespace, "operator ||", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseOr, type));
	discard program.createBinaryFunction(type_namespace, "operator ^", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseXOr, type));

	discard program.createUnaryFunction(type_namespace, "operator !", type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseNot, type));

	discard program.createBinaryFunction(type_namespace, "operator &=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseAnd | Assign, type));
	discard program.createBinaryFunction(type_namespace, "operator |=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseOr | Assign, type));
	discard program.createBinaryFunction(type_namespace, "operator ^=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseXOr | Assign, type));
}

func createPtrSizedIntType(program: &&Program, dest_namespace: SharedHandle!<Namespace>, is_signed: bool) -> void {
	const name = "int" if is_signed else "uint";
	const body = TypeBody::Int(0u) if is_signed else TypeBody::UInt(0u);
	const type = Type(program.createType(dest_namespace, name, body), ReferenceKind::None);
	const type_namespace = type.decl.linked_namespace;

	if is_signed {
		program.int_type = type;
	} else {
		program.uint_type = type;
	}

	createBasicFunctions(&&program, type, type_namespace);
	createIntComparisonOperators(&&program, type, type_namespace, is_signed);
	createIntArithmeticOperators(&&program, type, type_namespace, is_signed);
	createBitwiseOperators(&&program, type, type_namespace, is_signed);
}

func createIntTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>, is_signed: bool) -> void {
	const name = "int" if is_signed else "uint";
	const body = TypeBody::Int(0u) if is_signed else TypeBody::UInt(0u);

	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Size", program.uint_concept, false));

	discard program.createType(dest_namespace, name, template_parameters, body);
}

func createIntTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, is_signed: bool, size: int) -> Type {
	const name = "int" if is_signed else "uint";
	const body = TypeBody::Int(size as uint) if is_signed else TypeBody::UInt(size as uint);

	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Size", program.uint_concept, false, TemplateParameter::Integer(size)));

	const type = Type(program.createType(dest_namespace, name, template_parameters, body), ReferenceKind::None);
	const type_namespace = type.decl.linked_namespace;

	createBasicFunctions(&&program, type, type_namespace);
	createIntComparisonOperators(&&program, type, type_namespace, is_signed);
	createIntArithmeticOperators(&&program, type, type_namespace, is_signed);
	createBitwiseOperators(&&program, type, type_namespace, is_signed);

	return type;
}

func createByteType(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	const type = Type(program.createType(dest_namespace, "byte", TypeBody::Byte), ReferenceKind::None);
	const type_namespace = type.decl.linked_namespace;
	program.byte_type = type;

	createBasicFunctions(&&program, type, type_namespace);
	createIntComparisonOperators(&&program, type, type_namespace, false);
	createBitwiseOperators(&&program, type, type_namespace, false);
}

func createOpaquePtrType(program: &&Program, dest_namespace: SharedHandle!<Namespace>, is_const: bool) -> void {
	const type = Type(program.createType(dest_namespace, "cptr" if is_const else "vptr", TypeBody::Pointer((pointee_type: Type::unknown(), is_const: is_const))), ReferenceKind::None);
	const type_namespace = type.decl.linked_namespace;

	if is_const {
		program.cptr_type = type;
	} else {
		program.vptr_type = type;
	}

	createBasicFunctions(&&program, type, type_namespace);
	createIntComparisonOperators(&&program, type, type_namespace, false);

	discard program.createFunction(type_namespace, "null", List!<Type>(), type, BuiltinFunction::PrimitiveOp(PrimitiveOp::ConstNull, type));
}

func createPtrTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>, is_const: bool) -> void {
	const name = "cptr" if is_const else "vptr";
	const body = TypeBody::Pointer((pointee_type: Type::unknown(), is_const: is_const));

	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Pointee", program.any_concept, false));

	discard program.createType(dest_namespace, name, template_parameters, body);
}

func createPtrTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, is_const: bool, pointee_type: Type) -> Type {
	const name = "cptr" if is_const else "vptr";
	const body = TypeBody::Pointer((pointee_type: pointee_type, is_const: is_const));

	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Pointee", program.any_concept, false, TemplateParameter::Type(pointee_type)));

	const type = Type(program.createType(dest_namespace, name, template_parameters, body), ReferenceKind::None);
	const type_namespace = type.decl.linked_namespace;

	createBasicFunctions(&&program, type, type_namespace);
	createIntComparisonOperators(&&program, type, type_namespace, false);

	const empty_parameter_types = List!<Type>();
	discard program.createFunction(type_namespace, "null", empty_parameter_types, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::ConstNull, type));

	const pointee_reference_type = pointee_type.constRef() if is_const else pointee_type.varRef();

	discard program.createUnaryFunction(type_namespace, "value", type, pointee_reference_type, BuiltinFunction::PointerToRef(type));
	discard program.createUnaryFunction(type_namespace, "addressOf", pointee_reference_type, type, BuiltinFunction::RefToPointer(type));

	discard program.createBinaryFunction(type_namespace, "operator -", type, type, program.int_type, BuiltinFunction::PointerDiff(type));

	discard program.createBinaryFunction(type_namespace, "operator +", type, program.int_type, type, BuiltinFunction::PointerOffset(type));
	discard program.createBinaryFunction(type_namespace, "operator +", type, program.uint_type, type, BuiltinFunction::PointerOffset(type));

	discard program.createBinaryFunction(type_namespace, "operator []", type, program.int_type, pointee_type.constRef() if is_const else pointee_type.varRef(), BuiltinFunction::PointerOpIndex(type));
	discard program.createBinaryFunction(type_namespace, "operator []", type, program.uint_type, pointee_type.constRef() if is_const else pointee_type.varRef(), BuiltinFunction::PointerOpIndex(type));

	discard program.createBinaryFunction(type_namespace, "operator ==", type, program.cptr_type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseEQ, type));
	discard program.createBinaryFunction(type_namespace, "operator ==", type, program.vptr_type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseEQ, type));

	discard program.createBinaryFunction(type_namespace, "operator !=", type, program.cptr_type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseNE, type));
	discard program.createBinaryFunction(type_namespace, "operator !=", type, program.vptr_type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseNE, type));

	discard program.createBinaryFunction(type_namespace, "operator <=>", type, program.cptr_type, program.int_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::UIntCmp, type));
	discard program.createBinaryFunction(type_namespace, "operator <=>", type, program.vptr_type, program.int_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::UIntCmp, type));

	return type;
}

func createFunctionTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("ReturnType", program.any_concept, false));
	template_parameters.append(TemplateParameterDecl("ParameterTypes", program.any_concept, true));
	discard program.createType(dest_namespace, "function", template_parameters, TypeBody::Function((parameter_types: List!<Type>(), return_type: Type::unknown())));
}

func createFunctionTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, parameter_types: &List!<Type>, return_type: Type) -> SharedHandle!<TypeDecl> {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("ReturnType", program.any_concept, false, TemplateParameter::Type(return_type)));
	for t in parameter_types {
		template_parameters.append(TemplateParameterDecl("ParameterTypes", program.any_concept, false, TemplateParameter::Type(t)));
	}

	var type_decl = program.createType(dest_namespace, "function", template_parameters, TypeBody::Function((parameter_types: parameter_types, return_type: return_type)));
	const type = Type(type_decl, ReferenceKind::None);

	const type_namespace = type_decl.linked_namespace;

	type.decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
	type.decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::NoOp, type));
	type.decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
	createIntComparisonOperators(&&program, type, type_namespace, false);

	var call_operator_parameter_types = parameter_types;
	call_operator_parameter_types.insert(0u, type);
	discard program.createFunction(type_namespace, "operator ()", call_operator_parameter_types, return_type, BuiltinFunction::FunctionPointerCall(type));

	return type_decl;
}

func createFloatTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Size", program.uint_concept, false));
	discard program.createType(dest_namespace, "float", template_parameters, TypeBody::Float(0u));
}

func createFloatTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, size: int) -> Type {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Size", program.uint_concept, false, TemplateParameter::Integer(size)));

	const type = Type(program.createType(dest_namespace, "float", template_parameters, TypeBody::Float(size as uint)), ReferenceKind::None);
	const type_namespace = type.decl.linked_namespace;

	createBasicFunctions(&&program, type, type_namespace);

	type.decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::FloatEQ, type));
	discard program.createBinaryFunction(type_namespace, "operator !=", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::FloatNE, type));
	discard program.createBinaryFunction(type_namespace, "operator <", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::FloatLT, type));
	discard program.createBinaryFunction(type_namespace, "operator <=", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::FloatLE, type));
	discard program.createBinaryFunction(type_namespace, "operator >", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::FloatGT, type));
	discard program.createBinaryFunction(type_namespace, "operator >=", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::FloatGE, type));
	type.decl.op_compare = program.createBinaryFunction(type_namespace, "operator <=>", type, type, program.int_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::FloatCmp, type));

	discard program.createBinaryFunction(type_namespace, "operator +", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::FloatAdd, type));
	discard program.createBinaryFunction(type_namespace, "operator -", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::FloatSub, type));
	discard program.createBinaryFunction(type_namespace, "operator *", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::FloatMul, type));
	discard program.createBinaryFunction(type_namespace, "operator /", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::FloatDiv, type));
	discard program.createBinaryFunction(type_namespace, "operator %", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::FloatMod, type));

	discard program.createUnaryFunction(type_namespace, "operator -", type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::FloatNeg, type));

	discard program.createBinaryFunction(type_namespace, "operator +=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::FloatAdd | Assign, type));
	discard program.createBinaryFunction(type_namespace, "operator -=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::FloatSub | Assign, type));
	discard program.createBinaryFunction(type_namespace, "operator *=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::FloatMul | Assign, type));
	discard program.createBinaryFunction(type_namespace, "operator /=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::FloatDiv | Assign, type));
	discard program.createBinaryFunction(type_namespace, "operator %=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::FloatMod | Assign, type));

	return type;
}

func createArrayTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("T", program.any_concept, false));
	template_parameters.append(TemplateParameterDecl("Size", program.uint_concept, false));
	discard program.createType(dest_namespace, "Array", template_parameters, TypeBody::Array((element_type: Type::unknown(), size: 0u)));
}

func createArrayTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, element_type: Type, size: uint, element_cptr_type: Type, element_vptr_type: Type) -> SharedHandle!<TypeDecl> {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("T", program.any_concept, false, TemplateParameter::Type(element_type)));
	template_parameters.append(TemplateParameterDecl("Size", program.uint_concept, false, TemplateParameter::Integer(size as int)));
	var type_decl = program.createType(dest_namespace, "Array", template_parameters, TypeBody::Array((element_type: element_type, size: size)));
	const type = Type(type_decl, ReferenceKind::None);

	type_decl.addContainedType(element_type);
	const type_namespace = type_decl.linked_namespace;

	type_decl.default_constructor = program.createUnaryFunction(type_namespace, "constructor", type.varRef(), program.void_type, BuiltinFunction::ArrayDefaultConstructor(type));
	type_decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, BuiltinFunction::ArrayCopyConstructor(type));
	type_decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, BuiltinFunction::ArrayDestructor(type));
	type_decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, BuiltinFunction::ArrayOpAssign(type));
	type_decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::ArrayOpEqual(type));
	discard program.createUnaryFunction(type_namespace, "data", type.constRef(), element_cptr_type, BuiltinFunction::ArrayGetDataPointer(type));
	discard program.createUnaryFunction(type_namespace, "data", type.varRef(), element_vptr_type, BuiltinFunction::ArrayGetDataPointer(type));
	discard program.createUnaryFunction(type_namespace, "size", type.constRef(), program.uint_type, BuiltinFunction::ArrayGetSize(type));

	return type_decl;
}

func createTupleTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Names", program.string_concept, false));
	template_parameters.append(TemplateParameterDecl("Types", program.any_concept, true));
	discard program.createType(dest_namespace, "Tuple", template_parameters, TypeBody::Tuple);
}

func createTupleTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, names: &List!<String>, types: &List!<Type>) -> SharedHandle!<TypeDecl> {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Names", program.string_concept, false, TemplateParameter::String(",".join(names))));
	for t in types {
		template_parameters.append(TemplateParameterDecl("Types", program.any_concept, false, TemplateParameter::Type(t)));
	}

	var type_decl = program.createType(dest_namespace, "Tuple", template_parameters, TypeBody::Tuple);
	const type = Type(type_decl, ReferenceKind::None);

	for i in 0u..types.size() {
		type_decl.createMemberVariable(Span(), names[i], types[i], Expr::Undefined(Span(), Type::unknown()));
	}

	const type_namespace = type_decl.linked_namespace;

	var value_constructor_parameter_types = types;
	value_constructor_parameter_types.insert(0u, type.varRef());
	discard program.createFunction(type_namespace, "constructor", value_constructor_parameter_types, program.void_type, BuiltinFunction::StructValueConstructor(type));

	type_decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, BuiltinFunction::StructCopyConstructor(type));
	type_decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, BuiltinFunction::StructDestructor(type));
	type_decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, BuiltinFunction::StructOpAssign(type));
	type_decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::StructOpEqual(type));

	return type_decl;
}

func createDefaultFunctions(program: &&Program, type: Type) -> void {
	var type_decl = type.decl;
	var type_namespace = type_decl.linked_namespace;

	if type_decl.body is Enum {
		if type_decl.copy_constructor.isEmpty() {
			type_decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
		}

		if type_decl.destructor.isEmpty() {
			type_decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::NoOp, type));
		}

		if type_decl.op_assign.isEmpty() {
			type_decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
		}

		if type_decl.op_equal.isEmpty() {
			type_decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseEQ, type));
		}

		if type_decl.op_compare.isEmpty() {
			type_decl.op_compare = program.createBinaryFunction(type_namespace, "operator <=>", type, type, program.int_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::UIntCmp, type));
		}
	} else if type_decl.body is Variant {
		if type_decl.copy_constructor.isEmpty() {
			type_decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, BuiltinFunction::VariantCopyConstructor(type));
		}

		if type_decl.destructor.isEmpty() {
			type_decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, BuiltinFunction::VariantDestructor(type));
		}

		if type_decl.op_assign.isEmpty() {
			type_decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, BuiltinFunction::VariantOpAssign(type));
		}

		if type_decl.op_equal.isEmpty() {
			type_decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::VariantOpEqual(type));
		}
	}
}

func createVariantCaseConstructor(program: &&Program, type: SharedHandle!<TypeDecl>, case_id: int, payload_type: Type) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Id", program.int_concept, false, TemplateParameter::Integer(case_id)));

	var parameter_types: List!<Type>;
	parameter_types.append(Type(type, ReferenceKind::Var));

	if payload_type != program.void_type {
		parameter_types.append(payload_type);
	}

	for member_variable in type.member_variables {
		parameter_types.append(member_variable.type);
	}

	const function = program.createFunction(
		type.linked_namespace,
		"constructor",
		template_parameters,
		parameter_types,
		program.void_type,
		BuiltinFunction::VariantCaseConstructor(case_id, Type(type))
	);
}

func createVariantOpIs(program: &&Program, type: SharedHandle!<TypeDecl>, case_id: int) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Id", program.int_concept, false, TemplateParameter::Integer(case_id)));

	var parameter_types: List!<Type>;
	parameter_types.append(Type(type));

	discard program.createFunction(
		type.linked_namespace,
		"operator is",
		template_parameters,
		parameter_types,
		program.bool_type,
		BuiltinFunction::VariantOpIs(case_id, Type(type))
	);
}

func createVariantOpUnsafeAs(program: &&Program, type: SharedHandle!<TypeDecl>, reference_kind: ReferenceKind, case_id: int) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Id", program.int_concept, false, TemplateParameter::Integer(case_id)));

	var parameter_types: List!<Type>;
	parameter_types.append(Type(type, reference_kind));

	var case_decl = type.getVariantCase(case_id).value();
	var result_type = case_decl.type;
	if result_type.reference_kind == None {
		result_type.reference_kind = reference_kind;
	}

	discard program.createFunction(
		type.linked_namespace,
		"operator unsafe as",
		template_parameters,
		parameter_types,
		result_type,
		BuiltinFunction::VariantOpUnsafeAs(case_id, Type(type))
	);
}

func getDefaultFunctionBody(this: &FunctionDecl) -> BuiltinFunction {
	if this.parent_namespace.linked_type.isEmpty() {
		return BuiltinFunction::Empty(Type::unknown());
	}

	const parent_type = Type(this.parent_namespace.linked_type, ReferenceKind::None);
	const type_body = parent_type.decl.body;

	if this.name == "constructor" && this.parameter_types.size() == 1 {
		if this.parameter_types[0u] == parent_type.varRef() {
			match type_body {
				case Struct -> return BuiltinFunction::StructDefaultConstructor(parent_type);
				else -> {}
			}
		}
	} else if this.name == "constructor" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type.varRef() && this.parameter_types[1u] == parent_type {
			match type_body {
				case Struct -> return BuiltinFunction::StructCopyConstructor(parent_type);
				case Enum -> return BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, parent_type);
				case Variant -> return BuiltinFunction::VariantCopyConstructor(parent_type);
				else -> {}
			}
		}
	} else if this.name == "destructor" && this.parameter_types.size() == 1 {
		if this.parameter_types[0u] == parent_type.varRef() {
			match type_body {
				case Struct -> return BuiltinFunction::StructDestructor(parent_type);
				case Enum -> return BuiltinFunction::PrimitiveOp(PrimitiveOp::NoOp, parent_type);
				case Variant -> return BuiltinFunction::VariantDestructor(parent_type);
				else -> {}
			}
		}
	} else if this.name == "operator =" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type.varRef() && this.parameter_types[1u] == parent_type {
			match type_body {
				case Struct -> return BuiltinFunction::StructOpAssign(parent_type);
				case Enum -> return BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, parent_type);
				case Variant -> return BuiltinFunction::VariantOpAssign(parent_type);
				else -> {}
			}
		}
	} else if this.name == "operator ==" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type && this.parameter_types[1u] == parent_type {
			match type_body {
				case Struct -> return BuiltinFunction::StructOpEqual(parent_type);
				case Enum -> return BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseEQ, parent_type);
				case Variant -> return BuiltinFunction::VariantOpEqual(parent_type);
				else -> {}
			}
		}
	} else if this.name == "operator <=>" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type && this.parameter_types[1u] == parent_type {
			match type_body {
				case Struct -> return BuiltinFunction::StructOpCmp(parent_type);
				case Enum -> return BuiltinFunction::PrimitiveOp(PrimitiveOp::UIntCmp, parent_type);
				else -> {}
			}
		}
	} else if this.name == "operator &" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type && this.parameter_types[1u] == parent_type {
			match type_body {
				case Enum -> return BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseAnd, parent_type);
				else -> {}
			}
		}
	} else if this.name == "operator |" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type && this.parameter_types[1u] == parent_type {
			match type_body {
				case Enum -> return BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseOr, parent_type);
				else -> {}
			}
		}
	} else if this.name == "operator &=" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type.varRef() && this.parameter_types[1u] == parent_type {
			match type_body {
				case Enum -> return BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseAnd | Assign, parent_type);
				else -> {}
			}
		}
	} else if this.name == "operator |=" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type.varRef() && this.parameter_types[1u] == parent_type {
			match type_body {
				case Enum -> return BuiltinFunction::PrimitiveOp(PrimitiveOp::BitwiseOr | Assign, parent_type);
				else -> {}
			}
		}
	}

	return BuiltinFunction::Empty(Type::unknown());
}
