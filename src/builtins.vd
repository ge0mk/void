import std/core;
import std/list;
import std/io;
import std/shared_list;
import std/string;

import program;
import span;

func createPrimitiveCastTemplates(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var cast_template_parameters = List!<TemplateParameterDecl>();
	cast_template_parameters.append(TemplateParameterDecl("Source", program.any_concept, false));
	cast_template_parameters.append(TemplateParameterDecl("Target", program.any_concept, false));

	discard program.createFunction(dest_namespace, "intCast", cast_template_parameters, BuiltinFunction::IntCast(Type::unknown(), Type::unknown()));
	discard program.createFunction(dest_namespace, "floatCast", cast_template_parameters, BuiltinFunction::FloatCast(Type::unknown(), Type::unknown()));
	discard program.createFunction(dest_namespace, "intToFloat", cast_template_parameters, BuiltinFunction::IntToFloat(Type::unknown(), Type::unknown()));
	discard program.createFunction(dest_namespace, "floatToInt", cast_template_parameters, BuiltinFunction::FloatToInt(Type::unknown(), Type::unknown()));
	discard program.createFunction(dest_namespace, "pointerCast", cast_template_parameters, BuiltinFunction::PointerCast(Type::unknown()));
}

func createPrimitiveCastInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, name: String, source: Type, target: Type) -> SharedHandle!<FunctionDecl> {
	var template_parameters = List!<TemplateParameterDecl>();
	template_parameters.append(TemplateParameterDecl("Source", program.any_concept, false, TemplateParameter::Type(source)));
	template_parameters.append(TemplateParameterDecl("Target", program.any_concept, false, TemplateParameter::Type(target)));

	var parameter_types = List!<Type>();
	parameter_types.append(source);

	var body = FunctionBody::Empty;
	if name == "intCast" {
		body = FunctionBody::Builtin(BuiltinFunction::IntCast(target, source));
	} else if name == "floatCast" {
		body = FunctionBody::Builtin(BuiltinFunction::FloatCast(target, source));
	} else if name == "intToFloat" {
		body = FunctionBody::Builtin(BuiltinFunction::IntToFloat(target, source));
	} else if name == "floatToInt" {
		body = FunctionBody::Builtin(BuiltinFunction::FloatToInt(target, source));
	} else if name == "pointerCast" {
		body = FunctionBody::Builtin(BuiltinFunction::PointerCast(target));
	} else {
		panic("invalid numeric cast name: " + name);
	}

	return program.createFunction(dest_namespace, name, template_parameters, parameter_types, target, body);
}

func createCoreReflectionFunctionTemplates(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var template_parameters = List!<TemplateParameterDecl>();
	template_parameters.append(TemplateParameterDecl("Type", program.any_concept, false));

	discard program.createFunction(dest_namespace, "sizeOf", template_parameters, BuiltinFunction::SizeOf(Type::unknown()));
	discard program.createFunction(dest_namespace, "alignmentOf", template_parameters, BuiltinFunction::AlignmentOf(Type::unknown()));
	discard program.createFunction(dest_namespace, "referenceKindOf", template_parameters, BuiltinFunction::ReferenceKindOf(Type::unknown()));
	discard program.createFunction(dest_namespace, "hasDefaultConstructor", template_parameters, BuiltinFunction::HasDefaultConstructor(Type::unknown()));
	discard program.createFunction(dest_namespace, "hasCopyConstructor", template_parameters, BuiltinFunction::HasCopyConstructor(Type::unknown()));
}

func createTypeRefTypeDecl(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	const type_decl = program.createType(dest_namespace, "typeref", TypeBody::Void);
	const type_namespace = type_decl.linked_namespace;
	const type = Type(type_decl);
	program.typeref_type = type;

	type_decl.is_comptime = true;

	type_decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
	type_decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::NoOp, type));
	type_decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
	type_decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::TypeRefOpEqual(type));
}

func createUnaryFunction(program: &&Program, type_namespace: SharedHandle!<Namespace>, name: String, obj: Type, return_type: Type, body: BuiltinFunction) -> SharedHandle!<FunctionDecl> {
	var parameter_types: List!<Type>;
	parameter_types.append(obj);
	return program.createFunction(type_namespace, name, parameter_types, return_type, body);
}

func createBinaryFunction(program: &&Program, type_namespace: SharedHandle!<Namespace>, name: String, lhs: Type, rhs: Type, return_type: Type, body: BuiltinFunction) -> SharedHandle!<FunctionDecl> {
	var parameter_types: List!<Type>;
	parameter_types.append(lhs);
	parameter_types.append(rhs);
	return program.createFunction(type_namespace, name, parameter_types, return_type, body);
}

func createBasicFunctions(program: &&Program, type: Type, type_namespace: SharedHandle!<Namespace>) -> void {
	type.decl.default_constructor = program.createUnaryFunction(type_namespace, "constructor", type.varRef(), program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::ConstNull | Assign, type));
	type.decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
	type.decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::NoOp, type));
	type.decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
}

func createComparisonOperators(program: &&Program, type: Type, type_namespace: SharedHandle!<Namespace>, flags: PrimitiveOp) -> void {
	type.decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::EQ | flags, type));
	discard program.createBinaryFunction(type_namespace, "operator !=", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::NE | flags, type));
	discard program.createBinaryFunction(type_namespace, "operator <", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::LT | flags, type));
	discard program.createBinaryFunction(type_namespace, "operator <=", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::LE | flags, type));
	discard program.createBinaryFunction(type_namespace, "operator >", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::GT | flags, type));
	discard program.createBinaryFunction(type_namespace, "operator >=", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::GE | flags, type));
	type.decl.op_compare = program.createBinaryFunction(type_namespace, "operator <=>", type, type, program.int_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Cmp | flags, type));
}

func createBitwiseOperators(program: &&Program, type: Type, type_namespace: SharedHandle!<Namespace>, sign_flag: PrimitiveOp) -> void {
	discard program.createBinaryFunction(type_namespace, "operator &", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::And, type));
	discard program.createBinaryFunction(type_namespace, "operator |", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Or, type));
	discard program.createBinaryFunction(type_namespace, "operator ^", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::XOr, type));

	discard program.createUnaryFunction(type_namespace, "operator ~", type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Not, type));

	discard program.createBinaryFunction(type_namespace, "operator <<", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Shl, type));
	discard program.createBinaryFunction(type_namespace, "operator >>", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Shr | sign_flag, type));

	discard program.createBinaryFunction(type_namespace, "operator &=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::And | Assign, type));
	discard program.createBinaryFunction(type_namespace, "operator |=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Or | Assign, type));
	discard program.createBinaryFunction(type_namespace, "operator ^=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::XOr | Assign, type));

	discard program.createBinaryFunction(type_namespace, "operator <<=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Shl | Assign, type));
	discard program.createBinaryFunction(type_namespace, "operator >>=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Shr | Assign | sign_flag, type));
}

func createArithmeticOperators(program: &&Program, type: Type, type_namespace: SharedHandle!<Namespace>, flags: PrimitiveOp) -> void {
	discard program.createBinaryFunction(type_namespace, "operator +", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Add | flags, type));
	discard program.createBinaryFunction(type_namespace, "operator -", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Sub | flags, type));
	discard program.createBinaryFunction(type_namespace, "operator *", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Mul | flags, type));
	discard program.createBinaryFunction(type_namespace, "operator /", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Div | flags, type));
	discard program.createBinaryFunction(type_namespace, "operator %", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Mod | flags, type));

	if (flags & Float) == Float {
		discard program.createUnaryFunction(type_namespace, "operator -", type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Neg | Float, type));
	} else {
		if (flags & Signed) == Signed {
			discard program.createUnaryFunction(type_namespace, "operator -", type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Neg, type));
		}

		discard program.createUnaryFunction(type_namespace, "operator ++", type.varRef(), program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Inc | Assign, type));
		discard program.createUnaryFunction(type_namespace, "operator --", type.varRef(), program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Dec | Assign, type));
	}

	discard program.createBinaryFunction(type_namespace, "operator +=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Add | Assign | flags, type));
	discard program.createBinaryFunction(type_namespace, "operator -=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Sub | Assign | flags, type));
	discard program.createBinaryFunction(type_namespace, "operator *=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Mul | Assign | flags, type));
	discard program.createBinaryFunction(type_namespace, "operator /=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Div | Assign | flags, type));
	discard program.createBinaryFunction(type_namespace, "operator %=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Mod | Assign | flags, type));
}

func createBoolType(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	const type = Type(program.createType(dest_namespace, "bool", TypeBody::Bool), ReferenceKind::None);
	const type_namespace = type.decl.linked_namespace;

	program.bool_type = type;

	createBasicFunctions(&&program, type, type_namespace);

	type.decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::EQ, type));
	discard program.createBinaryFunction(type_namespace, "operator !=", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::NE, type));

	discard program.createBinaryFunction(type_namespace, "operator &&", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::And, type));
	discard program.createBinaryFunction(type_namespace, "operator ||", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Or, type));
	discard program.createBinaryFunction(type_namespace, "operator ^", type, type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::XOr, type));

	discard program.createUnaryFunction(type_namespace, "operator !", type, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Not, type));

	discard program.createBinaryFunction(type_namespace, "operator &=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::And | Assign, type));
	discard program.createBinaryFunction(type_namespace, "operator |=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Or | Assign, type));
	discard program.createBinaryFunction(type_namespace, "operator ^=", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::XOr | Assign, type));
}

func createIntTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>, is_signed: bool) -> SharedHandle!<Namespace> {
	const name = "int" if is_signed else "uint";
	const body = TypeBody::Int(0u) if is_signed else TypeBody::UInt(0u);

	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Size", program.uint_concept, false));

	return program.createType(dest_namespace, name, template_parameters, body).linked_namespace;
}

func createIntTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, is_signed: bool, size: int) -> Type {
	const name = "int" if is_signed else "uint";
	const body = TypeBody::Int(size as uint) if is_signed else TypeBody::UInt(size as uint);

	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Size", program.uint_concept, false, TemplateParameter::Integer(size)));

	const type = Type(program.createType(dest_namespace, name, template_parameters, body), ReferenceKind::None);
	const type_namespace = type.decl.linked_namespace;

	if size == 0 {
		if is_signed {
			program.int_type = type;
		} else {
			program.uint_type = type;
		}
	}

	const flags = (PrimitiveOp::Signed if is_signed else PrimitiveOp::Unsigned);
	createBasicFunctions(&&program, type, type_namespace);
	createComparisonOperators(&&program, type, type_namespace, flags);
	createArithmeticOperators(&&program, type, type_namespace, flags);
	createBitwiseOperators(&&program, type, type_namespace, flags);

	return type;
}

func createByteType(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	const type = Type(program.createType(dest_namespace, "byte", TypeBody::Byte), ReferenceKind::None);
	const type_namespace = type.decl.linked_namespace;
	program.byte_type = type;

	createBasicFunctions(&&program, type, type_namespace);
	createComparisonOperators(&&program, type, type_namespace, PrimitiveOp::Unsigned);
	createBitwiseOperators(&&program, type, type_namespace, PrimitiveOp::Unsigned);
}

func createErrorType(program: &&Program, dest_namespace: SharedHandle!<Namespace>, i32_type: Type) -> void {
	var type_decl = program.createType(dest_namespace, "Error", TypeBody::Enum);
	type_decl.id_type = i32_type;
	type_decl.addContainedType(i32_type);

	program.error_type = Type(type_decl);
	program.createDefaultFunctions(Type(type_decl));
}

func createPtrTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	const body = TypeBody::Pointer((pointee_type: Type::unknown(), is_mutable: false));

	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Pointee", program.any_concept, false));
	template_parameters.append(TemplateParameterDecl("Mutable", program.bool_concept, false));

	discard program.createType(dest_namespace, "ptr", template_parameters, body);
}

func createPtrTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, is_mutable: bool, pointee_type: Type) -> Type {
	const body = TypeBody::Pointer((pointee_type: pointee_type, is_mutable: is_mutable));

	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Pointee", program.any_concept, false, TemplateParameter::Type(pointee_type)));
	template_parameters.append(TemplateParameterDecl("Mutable", program.bool_concept, false, TemplateParameter::Boolean(is_mutable)));

	const type = Type(program.createType(dest_namespace, "ptr", template_parameters, body), ReferenceKind::None);
	const type_namespace = type.decl.linked_namespace;

	createBasicFunctions(&&program, type, type_namespace);
	createComparisonOperators(&&program, type, type_namespace, PrimitiveOp::Unsigned);

	const empty_parameter_types = List!<Type>();
	discard program.createFunction(type_namespace, "null", empty_parameter_types, type, BuiltinFunction::PrimitiveOp(PrimitiveOp::ConstNull, type));

	if pointee_type != program.void_type && pointee_type != program.never_type {
		const pointee_reference_type = pointee_type.varRef() if is_mutable else pointee_type.constRef();

		discard program.createUnaryFunction(type_namespace, "value", type, pointee_reference_type, BuiltinFunction::PointerToRef(type));
		discard program.createUnaryFunction(type_namespace, "addressOf", pointee_reference_type, type, BuiltinFunction::RefToPointer(type));

		discard program.createBinaryFunction(type_namespace, "operator -", type, type, program.int_type, BuiltinFunction::PointerDiff(type));

		discard program.createBinaryFunction(type_namespace, "operator +", type, program.int_type, type, BuiltinFunction::PointerOffset(type));
		discard program.createBinaryFunction(type_namespace, "operator +", type, program.uint_type, type, BuiltinFunction::PointerOffset(type));

		discard program.createBinaryFunction(type_namespace, "operator []", type, program.int_type, pointee_type.varRef() if is_mutable else pointee_type.constRef(), BuiltinFunction::PointerOpIndex(type));
		discard program.createBinaryFunction(type_namespace, "operator []", type, program.uint_type, pointee_type.varRef() if is_mutable else pointee_type.constRef(), BuiltinFunction::PointerOpIndex(type));
	}

	return type;
}

func createFunctionTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("ReturnType", program.any_concept, false));
	template_parameters.append(TemplateParameterDecl("ParameterTypes", program.any_concept, true));
	discard program.createType(dest_namespace, "function", template_parameters, TypeBody::Function((parameter_types: List!<Type>(), return_type: Type::unknown())));
}

func createFunctionTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, parameter_types: &List!<Type>, return_type: Type) -> SharedHandle!<TypeDecl> {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("ReturnType", program.any_concept, false, TemplateParameter::Type(return_type)));
	for t in parameter_types {
		template_parameters.append(TemplateParameterDecl("ParameterTypes", program.any_concept, false, TemplateParameter::Type(t)));
	}

	var type_decl = program.createType(dest_namespace, "function", template_parameters, TypeBody::Function((parameter_types: parameter_types, return_type: return_type)));
	const type = Type(type_decl, ReferenceKind::None);

	const type_namespace = type_decl.linked_namespace;

	type.decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
	type.decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::NoOp, type));
	type.decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
	createComparisonOperators(&&program, type, type_namespace, PrimitiveOp::Unsigned);

	var call_operator_parameter_types = parameter_types;
	call_operator_parameter_types.insert(0u, type);
	discard program.createFunction(type_namespace, "operator ()", call_operator_parameter_types, return_type, BuiltinFunction::FunctionPointerCall(type));

	return type_decl;
}

func createFloatTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Size", program.uint_concept, false));
	discard program.createType(dest_namespace, "float", template_parameters, TypeBody::Float(0u));
}

func createFloatTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, size: int) -> Type {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Size", program.uint_concept, false, TemplateParameter::Integer(size)));

	const type = Type(program.createType(dest_namespace, "float", template_parameters, TypeBody::Float(size as uint)), ReferenceKind::None);
	const type_namespace = type.decl.linked_namespace;

	createBasicFunctions(&&program, type, type_namespace);
	createComparisonOperators(&&program, type, type_namespace, PrimitiveOp::Float);
	createArithmeticOperators(&&program, type, type_namespace, PrimitiveOp::Float);

	return type;
}

func createArrayTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("T", program.any_concept, false));
	template_parameters.append(TemplateParameterDecl("Size", program.uint_concept, false));
	discard program.createType(dest_namespace, "Array", template_parameters, TypeBody::Array((element_type: Type::unknown(), size: 0u)));
}

func createArrayTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, element_type: Type, size: uint, element_cptr_type: Type, element_vptr_type: Type) -> SharedHandle!<TypeDecl> {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("T", program.any_concept, false, TemplateParameter::Type(element_type)));
	template_parameters.append(TemplateParameterDecl("Size", program.uint_concept, false, TemplateParameter::Integer(size as int)));
	var type_decl = program.createType(dest_namespace, "Array", template_parameters, TypeBody::Array((element_type: element_type, size: size)));
	const type = Type(type_decl, ReferenceKind::None);

	type_decl.addContainedType(element_type);
	const type_namespace = type_decl.linked_namespace;

	if element_type.isPrimitive() {
		createBasicFunctions(&&program, type, type_namespace);
	} else {
		type_decl.default_constructor = program.createUnaryFunction(type_namespace, "constructor", type.varRef(), program.void_type, BuiltinFunction::ArrayDefaultConstructor(type));
		type_decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, BuiltinFunction::ArrayCopyConstructor(type));
		type_decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, BuiltinFunction::ArrayDestructor(type));
		type_decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, BuiltinFunction::ArrayOpAssign(type));
	}

	type_decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::ArrayOpEqual(type));
	discard program.createUnaryFunction(type_namespace, "data", type.constRef(), element_cptr_type, BuiltinFunction::ArrayGetDataPointer(type));
	discard program.createUnaryFunction(type_namespace, "data", type.varRef(), element_vptr_type, BuiltinFunction::ArrayGetDataPointer(type));
	discard program.createUnaryFunction(type_namespace, "size", type.constRef(), program.uint_type, BuiltinFunction::ArrayGetSize(type));

	return type_decl;
}

func createRangeTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Type", program.any_concept, false));
	template_parameters.append(TemplateParameterDecl("Mutable", program.bool_concept, false));
	discard program.createType(dest_namespace, "Range", template_parameters, TypeBody::Range((element_type: Type::unknown(), is_mutable: false)));
}

func createRangeTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, element_type: Type, is_mutable: bool, element_ptr_type: Type, iterator_type: Type, mutable_range_type: Type) -> SharedHandle!<TypeDecl> {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Type", program.any_concept, false, TemplateParameter::Type(element_type)));
	template_parameters.append(TemplateParameterDecl("Mutable", program.bool_concept, false, TemplateParameter::Boolean(is_mutable)));
	var type_decl =  program.createType(dest_namespace, "Range", template_parameters, TypeBody::Range((element_type: element_type, is_mutable: is_mutable)));
	const type = Type(type_decl, ReferenceKind::None);
	const type_namespace = type_decl.linked_namespace;

	type_decl.createMemberVariable(Span(), "data", element_ptr_type);
	type_decl.createMemberVariable(Span(), "size", program.uint_type);

	var value_constructor_parameter_types: List!<Type>;
	value_constructor_parameter_types.append(type.varRef());
	value_constructor_parameter_types.append(element_ptr_type);
	value_constructor_parameter_types.append(program.uint_type);
	discard program.createFunction(type_namespace, "constructor", value_constructor_parameter_types, program.void_type, BuiltinFunction::StructValueConstructor(type));

	type.decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));

	if !is_mutable {
		discard program.createBinaryFunction(type_namespace, "constructor", type.varRef(), mutable_range_type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
	}

	type.decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::NoOp, type));
	type.decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
	type_decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::StructOpEqual(type));

	discard program.createUnaryFunction(type_namespace, "data", type, element_ptr_type, BuiltinFunction::RangeGetData(type));
	discard program.createUnaryFunction(type_namespace, "size", type, program.uint_type, BuiltinFunction::RangeGetSize(type));
	discard program.createUnaryFunction(type_namespace, "iterator", type, iterator_type, BuiltinFunction::RangeGetIterator(iterator_type, type));

	return type_decl;
}

func createRangeIteratorTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Type", program.any_concept, false));
	template_parameters.append(TemplateParameterDecl("Mutable", program.bool_concept, false));
	discard program.createType(dest_namespace, "RangeIterator", template_parameters, TypeBody::RangeIterator((element_type: Type::unknown(), is_mutable: false)));
}

func createRangeIteratorTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, element_type: Type, is_mutable: bool, element_ptr_type: Type) -> SharedHandle!<TypeDecl> {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Type", program.any_concept, false, TemplateParameter::Type(element_type)));
	template_parameters.append(TemplateParameterDecl("Mutable", program.bool_concept, false, TemplateParameter::Boolean(is_mutable)));
	var type_decl = program.createType(dest_namespace, "RangeIterator", template_parameters, TypeBody::RangeIterator((element_type: element_type, is_mutable: is_mutable)));
	const type = Type(type_decl, ReferenceKind::None);
	const type_namespace = type_decl.linked_namespace;

	type_decl.createMemberVariable(Span(), "current", element_ptr_type);
	type_decl.createMemberVariable(Span(), "end", element_ptr_type);

	var value_constructor_parameter_types: List!<Type>;
	value_constructor_parameter_types.append(type.varRef());
	value_constructor_parameter_types.append(element_ptr_type);
	value_constructor_parameter_types.append(element_ptr_type);
	discard program.createFunction(type_namespace, "constructor", value_constructor_parameter_types, program.void_type, BuiltinFunction::StructValueConstructor(type));

	type.decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
	type.decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::NoOp, type));
	type.decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
	type_decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::StructOpEqual(type));

	discard program.createUnaryFunction(type_namespace, "hasNext", type, program.bool_type, BuiltinFunction::RangeIteratorHasNext(type));
	discard program.createUnaryFunction(type_namespace, "getNext", type.varRef(), element_type.varRef() if is_mutable else element_type.constRef(), BuiltinFunction::RangeIteratorGetNext(type));

	return type_decl;
}

func createNumericRangeTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Type", program.any_concept, false));
	discard program.createType(dest_namespace, "NumericRange", template_parameters, TypeBody::NumericRange(Type::unknown()));
}

func createNumericRangeTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, numeric_type: Type, iterator_type: Type) -> SharedHandle!<TypeDecl> {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Type", program.any_concept, false, TemplateParameter::Type(numeric_type)));
	var type_decl =  program.createType(dest_namespace, "NumericRange", template_parameters, TypeBody::NumericRange(numeric_type));
	const type = Type(type_decl, ReferenceKind::None);
	const type_namespace = type_decl.linked_namespace;

	type_decl.createMemberVariable(Span(), "start", numeric_type);
	type_decl.createMemberVariable(Span(), "end", numeric_type);
	type_decl.createMemberVariable(Span(), "step", numeric_type);

	var value_constructor_parameter_types = List!<Type>(3u, numeric_type);
	value_constructor_parameter_types.insert(0u, type.varRef());
	discard program.createFunction(type_namespace, "constructor", value_constructor_parameter_types, program.void_type, BuiltinFunction::StructValueConstructor(type));

	type.decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
	type.decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::NoOp, type));
	type.decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
	type_decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::StructOpEqual(type));

	discard program.createBinaryFunction(type_namespace, "operator |", type, numeric_type, type, BuiltinFunction::NumericRangeSetStep(numeric_type, type));
	discard program.createUnaryFunction(type_namespace, "iterator", type, iterator_type, BuiltinFunction::NumericRangeGetIterator(iterator_type, type));

	return type_decl;
}

func createNumericIteratorTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Type", program.any_concept, false));
	discard program.createType(dest_namespace, "NumericIterator", template_parameters, TypeBody::NumericIterator(Type::unknown()));
}

func createNumericIteratorTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, numeric_type: Type) -> SharedHandle!<TypeDecl> {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Type", program.any_concept, false, TemplateParameter::Type(numeric_type)));
	var type_decl = program.createType(dest_namespace, "NumericIterator", template_parameters, TypeBody::NumericIterator(numeric_type));
	const type = Type(type_decl, ReferenceKind::None);
	const type_namespace = type_decl.linked_namespace;

	type_decl.createMemberVariable(Span(), "start", numeric_type);
	type_decl.createMemberVariable(Span(), "end", numeric_type);
	type_decl.createMemberVariable(Span(), "step", numeric_type);
	type_decl.createMemberVariable(Span(), "is_ascending", program.bool_type);

	var value_constructor_parameter_types = List!<Type>(3u, numeric_type);
	value_constructor_parameter_types.append(program.bool_type);
	value_constructor_parameter_types.insert(0u, type.varRef());
	discard program.createFunction(type_namespace, "constructor", value_constructor_parameter_types, program.void_type, BuiltinFunction::StructValueConstructor(type));

	type.decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
	type.decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::NoOp, type));
	type.decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
	type_decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::StructOpEqual(type));

	discard program.createUnaryFunction(type_namespace, "hasNext", type, program.bool_type, BuiltinFunction::NumericIteratorHasNext(numeric_type, type));
	discard program.createUnaryFunction(type_namespace, "getNext", type.varRef(), numeric_type, BuiltinFunction::NumericIteratorGetNext(numeric_type, type));

	return type_decl;
}

func createTupleTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Names", program.string_concept, false));
	template_parameters.append(TemplateParameterDecl("Types", program.any_concept, true));
	discard program.createType(dest_namespace, "Tuple", template_parameters, TypeBody::Tuple);
}

func createTupleTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, names: &List!<String>, types: &List!<Type>) -> SharedHandle!<TypeDecl> {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Names", program.string_concept, false, TemplateParameter::String(",".join(names))));
	for t in types {
		template_parameters.append(TemplateParameterDecl("Types", program.any_concept, false, TemplateParameter::Type(t)));
	}

	var type_decl = program.createType(dest_namespace, "Tuple", template_parameters, TypeBody::Tuple);
	const type = Type(type_decl, ReferenceKind::None);

	for i in 0u..types.size() {
		type_decl.createMemberVariable(Span(), names[i], types[i]);
	}

	const type_namespace = type_decl.linked_namespace;

	var value_constructor_parameter_types = types;
	value_constructor_parameter_types.insert(0u, type.varRef());
	discard program.createFunction(type_namespace, "constructor", value_constructor_parameter_types, program.void_type, BuiltinFunction::StructValueConstructor(type));

	type_decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, BuiltinFunction::StructCopyConstructor(type));
	type_decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, BuiltinFunction::StructDestructor(type));
	type_decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, BuiltinFunction::StructOpAssign(type));
	type_decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::StructOpEqual(type));

	return type_decl;
}

func createDefaultFunctions(program: &&Program, type: Type) -> void {
	var type_decl = type.decl;
	var type_namespace = type_decl.linked_namespace;

	if type_decl.body is Enum {
		type_decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
		type_decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::NoOp, type));
		type_decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, type));
		type_decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::EQ, type));
		type_decl.op_compare = program.createBinaryFunction(type_namespace, "operator <=>", type, type, program.int_type, BuiltinFunction::PrimitiveOp(PrimitiveOp::Cmp, type));
	} else if type_decl.body is Variant {
		type_decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, BuiltinFunction::VariantCopyConstructor(type));
		type_decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, BuiltinFunction::VariantDestructor(type));
		type_decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, BuiltinFunction::VariantOpAssign(type));
		type_decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::VariantOpEqual(type));
	}
}

func createVariantCaseConstructor(program: &&Program, type: SharedHandle!<TypeDecl>, case_id: int, payload_type: Type) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Id", program.int_concept, false, TemplateParameter::Integer(case_id)));

	var parameter_types: List!<Type>;
	parameter_types.append(Type(type, ReferenceKind::Var));

	if payload_type != program.void_type {
		parameter_types.append(payload_type);
	}

	for member_variable in type.member_variables {
		parameter_types.append(member_variable.type);
	}

	const function = program.createFunction(
		type.linked_namespace,
		"constructor",
		template_parameters,
		parameter_types,
		program.void_type,
		BuiltinFunction::VariantCaseConstructor(case_id, Type(type))
	);
}

func createVariantOpIs(program: &&Program, type: SharedHandle!<TypeDecl>, case_id: int) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Id", program.int_concept, false, TemplateParameter::Integer(case_id)));

	var parameter_types: List!<Type>;
	parameter_types.append(Type(type));

	discard program.createFunction(
		type.linked_namespace,
		"operator is",
		template_parameters,
		parameter_types,
		program.bool_type,
		BuiltinFunction::VariantOpIs(case_id, Type(type))
	);
}

func createVariantOpUnsafeAs(program: &&Program, type: SharedHandle!<TypeDecl>, reference_kind: ReferenceKind, case_id: int) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Id", program.int_concept, false, TemplateParameter::Integer(case_id)));

	var parameter_types: List!<Type>;
	parameter_types.append(Type(type, reference_kind));

	var case_decl = type.getVariantCase(case_id).value();
	var result_type = case_decl.type;
	if result_type.reference_kind == None {
		result_type.reference_kind = reference_kind;
	}

	discard program.createFunction(
		type.linked_namespace,
		"operator unsafe as",
		template_parameters,
		parameter_types,
		result_type,
		BuiltinFunction::VariantOpUnsafeAs(case_id, Type(type))
	);
}

func getDefaultFunctionBody(this: &FunctionDecl) -> BuiltinFunction {
	if this.parent_namespace.linked_type.isEmpty() {
		return BuiltinFunction::Empty(Type::unknown());
	}

	const parent_type = Type(this.parent_namespace.linked_type, ReferenceKind::None);
	const type_body = parent_type.decl.body;

	if this.name == "constructor" && this.parameter_types.size() == 1 {
		if this.parameter_types[0u] == parent_type.varRef() {
			match type_body {
				case Struct -> return BuiltinFunction::StructDefaultConstructor(parent_type);
				else -> {}
			}
		}
	} else if this.name == "constructor" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type.varRef() && this.parameter_types[1u] == parent_type {
			match type_body {
				case Struct -> return BuiltinFunction::StructCopyConstructor(parent_type);
				case Enum -> return BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, parent_type);
				case Variant -> return BuiltinFunction::VariantCopyConstructor(parent_type);
				else -> {}
			}
		}
	} else if this.name == "destructor" && this.parameter_types.size() == 1 {
		if this.parameter_types[0u] == parent_type.varRef() {
			match type_body {
				case Struct -> return BuiltinFunction::StructDestructor(parent_type);
				case Enum -> return BuiltinFunction::PrimitiveOp(PrimitiveOp::NoOp, parent_type);
				case Variant -> return BuiltinFunction::VariantDestructor(parent_type);
				else -> {}
			}
		}
	} else if this.name == "operator =" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type.varRef() && this.parameter_types[1u] == parent_type {
			match type_body {
				case Struct -> return BuiltinFunction::StructOpAssign(parent_type);
				case Enum -> return BuiltinFunction::PrimitiveOp(PrimitiveOp::Copy | Assign, parent_type);
				case Variant -> return BuiltinFunction::VariantOpAssign(parent_type);
				else -> {}
			}
		}
	} else if this.name == "operator ==" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type && this.parameter_types[1u] == parent_type {
			match type_body {
				case Struct -> return BuiltinFunction::StructOpEqual(parent_type);
				case Enum -> return BuiltinFunction::PrimitiveOp(PrimitiveOp::EQ, parent_type);
				case Variant -> return BuiltinFunction::VariantOpEqual(parent_type);
				else -> {}
			}
		}
	} else if this.name == "operator <=>" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type && this.parameter_types[1u] == parent_type {
			match type_body {
				case Struct -> return BuiltinFunction::StructOpCmp(parent_type);
				case Enum -> return BuiltinFunction::PrimitiveOp(PrimitiveOp::Cmp, parent_type);
				else -> {}
			}
		}
	} else if this.name == "operator &" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type && this.parameter_types[1u] == parent_type {
			match type_body {
				case Enum -> return BuiltinFunction::PrimitiveOp(PrimitiveOp::And, parent_type);
				else -> {}
			}
		}
	} else if this.name == "operator |" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type && this.parameter_types[1u] == parent_type {
			match type_body {
				case Enum -> return BuiltinFunction::PrimitiveOp(PrimitiveOp::Or, parent_type);
				else -> {}
			}
		}
	} else if this.name == "operator &=" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type.varRef() && this.parameter_types[1u] == parent_type {
			match type_body {
				case Enum -> return BuiltinFunction::PrimitiveOp(PrimitiveOp::And | Assign, parent_type);
				else -> {}
			}
		}
	} else if this.name == "operator |=" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type.varRef() && this.parameter_types[1u] == parent_type {
			match type_body {
				case Enum -> return BuiltinFunction::PrimitiveOp(PrimitiveOp::Or | Assign, parent_type);
				else -> {}
			}
		}
	}

	return BuiltinFunction::Empty(Type::unknown());
}

func getPrimitiveOpParameterTypes(program: &Program, op: PrimitiveOp, base_type: Type) -> List!<Type> {
	var result: List!<Type>;

	match op.getOp() {
		case NoOp | ConstNull -> {};
		case Swap -> result = List!<Type>(2u, base_type.varRef());
		case Copy | Neg | Inc | Dec -> result = List!<Type>(1u, base_type);
		case And | Or | XOr | Not | Shl | Shr
		| Add | Sub | Mul | Div | Mod
		| EQ | NE | LT | LE | GT | GE | Cmp -> result = List!<Type>(2u, base_type);
		else -> panic("invalid primitive op");
	}

	return result;
}

func getPrimitiveOpReturnType(program: &Program, op: PrimitiveOp, base_type: Type) -> Type {
	if op.isAssignment() {
		return program.void_type;
	}

	match op.getOp() {
		case NoOp | Swap -> return program.void_type;
		case ConstNull | Copy
		| And | Or | XOr | Not | Shl | Shr
		| Add | Sub | Mul | Div | Mod | Neg | Inc | Dec -> return base_type;
		case EQ | NE | LT | LE | GT | GE -> return program.bool_type;
		case Cmp -> return program.int_type;
		else -> panic("invalid primitive op");
	}
}
