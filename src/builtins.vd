import std/core;
import std/list;
import std/io;
import std/shared;
import std/shared_list;
import std/string;

import program;
import span;

func createCoreDecls(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	program.any_concept = program.createConcept(Concept::Any("type"));
	program.string_concept = program.createConcept(Concept::StringLiteral("String"));

	program.void_type = Type(program.createType(dest_namespace, "void", TypeBody::Void));
	program.never_type = Type(program.createType(dest_namespace, "never", TypeBody::Void));

	program.core_namespace = dest_namespace;

	createPrimitiveCastTemplates(&&program, dest_namespace);
	createCoreReflectionFunctionTemplates(&&program, dest_namespace);

	createBoolType(&&program, dest_namespace);

	// requires bool type for comparision operators
	createPtrSizedIntType(&&program, dest_namespace, true);
	createPtrSizedIntType(&&program, dest_namespace, false);

	// requires uint-literal concept created by ptr-sized uint type
	createIntTypeTemplate(&&program, dest_namespace, true);
	createIntTypeTemplate(&&program, dest_namespace, false);

	// requires ptr-sized signed int type for <=> operator
	createByteType(&&program, dest_namespace);

	createOpaquePtrType(&&program, dest_namespace, true);
	createOpaquePtrType(&&program, dest_namespace, false);

	createPtrTypeTemplate(&&program, dest_namespace, true);
	createPtrTypeTemplate(&&program, dest_namespace, false);

	createFloatTypeTemplate(&&program, dest_namespace);

	createTupleTypeTemplate(&&program, dest_namespace);
}

func createPrimitiveCastTemplates(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var cast_template_parameters = List!<TemplateParameterDecl>();
	cast_template_parameters.append(TemplateParameterDecl("Source", program.any_concept, false));
	cast_template_parameters.append(TemplateParameterDecl("Target", program.any_concept, false));

	discard program.createFunction(dest_namespace, "intCast", cast_template_parameters, InlineBuiltinFunction::IntCast(Type::unknown(), Type::unknown()));
	discard program.createFunction(dest_namespace, "floatCast", cast_template_parameters, InlineBuiltinFunction::FloatCast(Type::unknown(), Type::unknown()));
	discard program.createFunction(dest_namespace, "intToFloat", cast_template_parameters, InlineBuiltinFunction::IntToFloat(Type::unknown(), Type::unknown()));
	discard program.createFunction(dest_namespace, "floatToInt", cast_template_parameters, InlineBuiltinFunction::FloatToInt(Type::unknown(), Type::unknown()));
	discard program.createFunction(dest_namespace, "pointerCast", cast_template_parameters, InlineBuiltinFunction::PointerCast(Type::unknown()));
}

func createPrimitiveCastInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, name: String, source: Type, target: Type) -> SharedHandle!<FunctionDecl> {
	var template_parameters = List!<TemplateParameterDecl>();
	template_parameters.append(TemplateParameterDecl("Source", program.any_concept, false, TemplateParameter::Type(source)));
	template_parameters.append(TemplateParameterDecl("Target", program.any_concept, false, TemplateParameter::Type(target)));

	var parameter_types = List!<Type>();
	parameter_types.append(source);

	var body = FunctionBody::Empty;
	if name == "intCast" {
		body = FunctionBody::InlineBuiltin(InlineBuiltinFunction::IntCast(target, source));
	} else if name == "floatCast" {
		body = FunctionBody::InlineBuiltin(InlineBuiltinFunction::FloatCast(target, source));
	} else if name == "intToFloat" {
		body = FunctionBody::InlineBuiltin(InlineBuiltinFunction::IntToFloat(target, source));
	} else if name == "floatToInt" {
		body = FunctionBody::InlineBuiltin(InlineBuiltinFunction::FloatToInt(target, source));
	} else if name == "pointerCast" {
		body = FunctionBody::InlineBuiltin(InlineBuiltinFunction::PointerCast(target));
	} else {
		panic("invalid numeric cast name: " + name);
	}

	return program.createFunction(dest_namespace, name, template_parameters, parameter_types, target, body);
}

func createCoreReflectionFunctionTemplates(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var template_parameters = List!<TemplateParameterDecl>();
	template_parameters.append(TemplateParameterDecl("Type", program.any_concept, false));

	discard program.createFunction(dest_namespace, "sizeOf", template_parameters, InlineBuiltinFunction::SizeOf(Type::unknown()));
	discard program.createFunction(dest_namespace, "alignmentOf", template_parameters, InlineBuiltinFunction::AlignmentOf(Type::unknown()));
	discard program.createFunction(dest_namespace, "referenceKindOf", template_parameters, InlineBuiltinFunction::ReferenceKindOf(Type::unknown()));
}

func createUnaryFunction(program: &&Program, type_namespace: SharedHandle!<Namespace>, name: String, obj: Type, return_type: Type, body: FunctionBody) -> SharedHandle!<FunctionDecl> {
	var parameter_types: List!<Type>;
	parameter_types.append(obj);
	return program.createFunction(type_namespace, name, parameter_types, return_type, body);
}

func createUnaryFunction(program: &&Program, type_namespace: SharedHandle!<Namespace>, name: String, obj: Type, return_type: Type, body: InlineBuiltinFunction) -> SharedHandle!<FunctionDecl> {
	var parameter_types: List!<Type>;
	parameter_types.append(obj);
	return program.createFunction(type_namespace, name, parameter_types, return_type, body);
}

func createUnaryFunction(program: &&Program, type_namespace: SharedHandle!<Namespace>, name: String, obj: Type, return_type: Type, body: BuiltinFunction) -> SharedHandle!<FunctionDecl> {
	var parameter_types: List!<Type>;
	parameter_types.append(obj);
	return program.createFunction(type_namespace, name, parameter_types, return_type, body);
}

func createBinaryFunction(program: &&Program, type_namespace: SharedHandle!<Namespace>, name: String, lhs: Type, rhs: Type, return_type: Type, body: FunctionBody) -> SharedHandle!<FunctionDecl> {
	var parameter_types: List!<Type>;
	parameter_types.append(lhs);
	parameter_types.append(rhs);
	return program.createFunction(type_namespace, name, parameter_types, return_type, body);
}

func createBinaryFunction(program: &&Program, type_namespace: SharedHandle!<Namespace>, name: String, lhs: Type, rhs: Type, return_type: Type, body: InlineBuiltinFunction) -> SharedHandle!<FunctionDecl> {
	var parameter_types: List!<Type>;
	parameter_types.append(lhs);
	parameter_types.append(rhs);
	return program.createFunction(type_namespace, name, parameter_types, return_type, body);
}

func createBinaryFunction(program: &&Program, type_namespace: SharedHandle!<Namespace>, name: String, lhs: Type, rhs: Type, return_type: Type, body: BuiltinFunction) -> SharedHandle!<FunctionDecl> {
	var parameter_types: List!<Type>;
	parameter_types.append(lhs);
	parameter_types.append(rhs);
	return program.createFunction(type_namespace, name, parameter_types, return_type, body);
}

func createBasicFunctions(program: &&Program, type: Type, type_namespace: SharedHandle!<Namespace>) -> void {
	type.decl.default_constructor = program.createUnaryFunction(type_namespace, "constructor", type.varRef(), program.void_type, InlineBuiltinFunction::BitStoreNull(type));
	type.decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, InlineBuiltinFunction::BitStoreValue(type));
	type.decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, InlineBuiltinFunction::NoOp(type));
	type.decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, InlineBuiltinFunction::BitStoreValue(type));
}

func createIntComparisonOperators(program: &&Program, type: Type, type_namespace: SharedHandle!<Namespace>, is_signed: bool) -> void {
	type.decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, InlineBuiltinFunction::BitOpEQ(type));
	discard program.createBinaryFunction(type_namespace, "operator !=", type, type, program.bool_type, InlineBuiltinFunction::BitOpNE(type));

	if is_signed {
		discard program.createBinaryFunction(type_namespace, "operator <", type, type, program.bool_type, InlineBuiltinFunction::SIntOpLT(type));
		discard program.createBinaryFunction(type_namespace, "operator <=", type, type, program.bool_type, InlineBuiltinFunction::SIntOpLE(type));
		discard program.createBinaryFunction(type_namespace, "operator >", type, type, program.bool_type, InlineBuiltinFunction::SIntOpGT(type));
		discard program.createBinaryFunction(type_namespace, "operator >=", type, type, program.bool_type, InlineBuiltinFunction::SIntOpGE(type));
		type.decl.op_compare = program.createBinaryFunction(type_namespace, "operator <=>", type, type, program.int_type, InlineBuiltinFunction::SIntOpCmp(type));
	} else {
		discard program.createBinaryFunction(type_namespace, "operator <", type, type, program.bool_type, InlineBuiltinFunction::UIntOpLT(type));
		discard program.createBinaryFunction(type_namespace, "operator <=", type, type, program.bool_type, InlineBuiltinFunction::UIntOpLE(type));
		discard program.createBinaryFunction(type_namespace, "operator >", type, type, program.bool_type, InlineBuiltinFunction::UIntOpGT(type));
		discard program.createBinaryFunction(type_namespace, "operator >=", type, type, program.bool_type, InlineBuiltinFunction::UIntOpGE(type));
		type.decl.op_compare = program.createBinaryFunction(type_namespace, "operator <=>", type, type, program.int_type, InlineBuiltinFunction::UIntOpCmp(type));
	}
}

func createBitwiseOperators(program: &&Program, type: Type, type_namespace: SharedHandle!<Namespace>, arithmetic_right_shift: bool) -> void {
	discard program.createBinaryFunction(type_namespace, "operator &", type, type, type, InlineBuiltinFunction::BitOpAnd(type));
	discard program.createBinaryFunction(type_namespace, "operator |", type, type, type, InlineBuiltinFunction::BitOpOr(type));
	discard program.createBinaryFunction(type_namespace, "operator ^", type, type, type, InlineBuiltinFunction::BitOpXOr(type));

	discard program.createUnaryFunction(type_namespace, "operator ~", type, type, InlineBuiltinFunction::BitOpNot(type));

	discard program.createBinaryFunction(type_namespace, "operator <<", type, type, type, InlineBuiltinFunction::BitOpShl(type));
	if arithmetic_right_shift {
		discard program.createBinaryFunction(type_namespace, "operator >>", type, type, type, InlineBuiltinFunction::BitOpAShr(type));
	} else {
		discard program.createBinaryFunction(type_namespace, "operator >>", type, type, type, InlineBuiltinFunction::BitOpLShr(type));
	}

	discard program.createBinaryFunction(type_namespace, "operator &=", type.varRef(), type, program.void_type, InlineBuiltinFunction::BitOpAndAssign(type));
	discard program.createBinaryFunction(type_namespace, "operator |=", type.varRef(), type, program.void_type, InlineBuiltinFunction::BitOpOrAssign(type));
	discard program.createBinaryFunction(type_namespace, "operator ^=", type.varRef(), type, program.void_type, InlineBuiltinFunction::BitOpXOrAssign(type));

	discard program.createBinaryFunction(type_namespace, "operator <<=", type.varRef(), type, program.void_type, InlineBuiltinFunction::BitOpShlAssign(type));
	if arithmetic_right_shift {
		discard program.createBinaryFunction(type_namespace, "operator >>=", type.varRef(), type, program.void_type, InlineBuiltinFunction::BitOpAShrAssign(type));
	} else {
		discard program.createBinaryFunction(type_namespace, "operator >>=", type.varRef(), type, program.void_type, InlineBuiltinFunction::BitOpLShrAssign(type));
	}
}

func createIntArithmeticOperators(program: &&Program, type: Type, type_namespace: SharedHandle!<Namespace>, is_signed: bool) -> void {
	discard program.createBinaryFunction(type_namespace, "operator +", type, type, type, InlineBuiltinFunction::IntOpAdd(type));
	discard program.createBinaryFunction(type_namespace, "operator -", type, type, type, InlineBuiltinFunction::IntOpSub(type));
	discard program.createBinaryFunction(type_namespace, "operator *", type, type, type, InlineBuiltinFunction::IntOpMul(type));

	if is_signed {
		discard program.createBinaryFunction(type_namespace, "operator /", type, type, type, InlineBuiltinFunction::SIntOpDiv(type));
		discard program.createBinaryFunction(type_namespace, "operator %", type, type, type, InlineBuiltinFunction::SIntOpMod(type));
	} else {
		discard program.createBinaryFunction(type_namespace, "operator /", type, type, type, InlineBuiltinFunction::UIntOpDiv(type));
		discard program.createBinaryFunction(type_namespace, "operator %", type, type, type, InlineBuiltinFunction::UIntOpMod(type));
	}

	if is_signed {
		discard program.createUnaryFunction(type_namespace, "operator -", type, type, InlineBuiltinFunction::IntOpNeg(type));
	}

	discard program.createUnaryFunction(type_namespace, "operator ++", type.varRef(), program.void_type, InlineBuiltinFunction::IntOpInc(type));
	discard program.createUnaryFunction(type_namespace, "operator --", type.varRef(), program.void_type, InlineBuiltinFunction::IntOpDec(type));

	discard program.createBinaryFunction(type_namespace, "operator +=", type.varRef(), type, program.void_type, InlineBuiltinFunction::IntOpAddAssign(type));
	discard program.createBinaryFunction(type_namespace, "operator -=", type.varRef(), type, program.void_type, InlineBuiltinFunction::IntOpSubAssign(type));
	discard program.createBinaryFunction(type_namespace, "operator *=", type.varRef(), type, program.void_type, InlineBuiltinFunction::IntOpMulAssign(type));

	if is_signed {
		discard program.createBinaryFunction(type_namespace, "operator /=", type.varRef(), type, program.void_type, InlineBuiltinFunction::SIntOpDivAssign(type));
		discard program.createBinaryFunction(type_namespace, "operator %=", type.varRef(), type, program.void_type, InlineBuiltinFunction::SIntOpModAssign(type));
	} else {
		discard program.createBinaryFunction(type_namespace, "operator /=", type.varRef(), type, program.void_type, InlineBuiltinFunction::UIntOpDivAssign(type));
		discard program.createBinaryFunction(type_namespace, "operator %=", type.varRef(), type, program.void_type, InlineBuiltinFunction::UIntOpModAssign(type));
	}
}

func createBoolType(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	const type = Type(program.createType(dest_namespace, "bool", TypeBody::Bool), ReferenceKind::None);
	const type_namespace = type.decl.linked_namespace;

	program.bool_type = type;

	createBasicFunctions(&&program, type, type_namespace);

	type.decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, InlineBuiltinFunction::BitOpEQ(type));
	discard program.createBinaryFunction(type_namespace, "operator !=", type, type, program.bool_type, InlineBuiltinFunction::BitOpNE(type));

	discard program.createBinaryFunction(type_namespace, "operator &&", type, type, type, InlineBuiltinFunction::BitOpAnd(type));
	discard program.createBinaryFunction(type_namespace, "operator ||", type, type, type, InlineBuiltinFunction::BitOpOr(type));
	discard program.createBinaryFunction(type_namespace, "operator ^", type, type, type, InlineBuiltinFunction::BitOpXOr(type));

	discard program.createUnaryFunction(type_namespace, "operator !", type, type, InlineBuiltinFunction::BitOpNot(type));

	discard program.createBinaryFunction(type_namespace, "operator &=", type.varRef(), type, program.void_type, InlineBuiltinFunction::BitOpAndAssign(type));
	discard program.createBinaryFunction(type_namespace, "operator |=", type.varRef(), type, program.void_type, InlineBuiltinFunction::BitOpOrAssign(type));
	discard program.createBinaryFunction(type_namespace, "operator ^=", type.varRef(), type, program.void_type, InlineBuiltinFunction::BitOpXOrAssign(type));
}

func createPtrSizedIntType(program: &&Program, dest_namespace: SharedHandle!<Namespace>, is_signed: bool) -> void {
	const name = "int" if is_signed else "uint";
	const body = TypeBody::Int(0u) if is_signed else TypeBody::UInt(0u);
	const type = Type(program.createType(dest_namespace, name, body), ReferenceKind::None);
	const type_namespace = type.decl.linked_namespace;

	if is_signed {
		program.int_type = type;
		program.int_concept = program.createConcept(Concept::IntLiteral(type, "int"));
	} else {
		program.uint_type = type;
		program.uint_concept = program.createConcept(Concept::IntLiteral(type, "uint"));
	}

	createBasicFunctions(&&program, type, type_namespace);
	createIntComparisonOperators(&&program, type, type_namespace, is_signed);
	createIntArithmeticOperators(&&program, type, type_namespace, is_signed);
	createBitwiseOperators(&&program, type, type_namespace, is_signed);
}

func createIntTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>, is_signed: bool) -> void {
	const name = "int" if is_signed else "uint";
	const body = TypeBody::Int(0u) if is_signed else TypeBody::UInt(0u);

	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Size", program.uint_concept, false));

	discard program.createType(dest_namespace, name, template_parameters, body);
}

func createIntTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, is_signed: bool, size: int) -> Type {
	const name = "int" if is_signed else "uint";
	const body = TypeBody::Int(size as uint) if is_signed else TypeBody::UInt(size as uint);

	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Size", program.uint_concept, false, TemplateParameter::Integer(size)));

	const type = Type(program.createType(dest_namespace, name, template_parameters, body), ReferenceKind::None);
	const type_namespace = type.decl.linked_namespace;

	createBasicFunctions(&&program, type, type_namespace);
	createIntComparisonOperators(&&program, type, type_namespace, is_signed);
	createIntArithmeticOperators(&&program, type, type_namespace, is_signed);
	createBitwiseOperators(&&program, type, type_namespace, is_signed);

	return type;
}

func createByteType(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	const type = Type(program.createType(dest_namespace, "byte", TypeBody::Byte), ReferenceKind::None);
	const type_namespace = type.decl.linked_namespace;
	program.byte_type = type;

	createBasicFunctions(&&program, type, type_namespace);
	createIntComparisonOperators(&&program, type, type_namespace, false);
	createBitwiseOperators(&&program, type, type_namespace, false);
}

func createOpaquePtrType(program: &&Program, dest_namespace: SharedHandle!<Namespace>, is_const: bool) -> void {
	const type = Type(program.createType(dest_namespace, "cptr" if is_const else "vptr", TypeBody::Pointer(PointerType(is_const))), ReferenceKind::None);
	const type_namespace = type.decl.linked_namespace;

	if is_const {
		program.cptr_type = type;
	} else {
		program.vptr_type = type;
	}

	createBasicFunctions(&&program, type, type_namespace);
	createIntComparisonOperators(&&program, type, type_namespace, false);

	discard program.createFunction(type_namespace, "null", List!<Type>(), type, InlineBuiltinFunction::PointerGetNull(type));
}

func createPtrTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>, is_const: bool) -> void {
	const name = "cptr" if is_const else "vptr";
	const body = TypeBody::Pointer(PointerType(is_const));

	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Pointee", program.any_concept, false));

	discard program.createType(dest_namespace, name, template_parameters, body);
}

func createPtrTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, is_const: bool, pointee_type: Type) -> Type {
	const name = "cptr" if is_const else "vptr";
	const body = TypeBody::Pointer(PointerType(pointee_type, is_const));

	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Pointee", program.any_concept, false, TemplateParameter::Type(pointee_type)));

	const type = Type(program.createType(dest_namespace, name, template_parameters, body), ReferenceKind::None);
	const type_namespace = type.decl.linked_namespace;

	createBasicFunctions(&&program, type, type_namespace);
	createIntComparisonOperators(&&program, type, type_namespace, false);

	const empty_parameter_types = List!<Type>();
	discard program.createFunction(type_namespace, "null", empty_parameter_types, type, InlineBuiltinFunction::PointerGetNull(type));

	const pointee_reference_type = pointee_type.constRef() if is_const else pointee_type.varRef();

	discard program.createUnaryFunction(type_namespace, "value", type, pointee_reference_type, InlineBuiltinFunction::PointerToRef(type));
	discard program.createUnaryFunction(type_namespace, "addressOf", pointee_reference_type, type, InlineBuiltinFunction::RefToPointer(type));

	discard program.createBinaryFunction(type_namespace, "operator -", type, type, program.int_type, InlineBuiltinFunction::PointerDiff(type));

	discard program.createBinaryFunction(type_namespace, "operator +", type, program.int_type, type, InlineBuiltinFunction::PointerOffset(type));
	discard program.createBinaryFunction(type_namespace, "operator +", type, program.uint_type, type, InlineBuiltinFunction::PointerOffset(type));

	discard program.createBinaryFunction(type_namespace, "operator []", type, program.int_type, pointee_type.constRef() if is_const else pointee_type.varRef(), InlineBuiltinFunction::PointerOpIndex(type));
	discard program.createBinaryFunction(type_namespace, "operator []", type, program.uint_type, pointee_type.constRef() if is_const else pointee_type.varRef(), InlineBuiltinFunction::PointerOpIndex(type));

	discard program.createBinaryFunction(type_namespace, "operator ==", type, program.cptr_type, program.bool_type, InlineBuiltinFunction::BitOpEQ(type));
	discard program.createBinaryFunction(type_namespace, "operator ==", type, program.vptr_type, program.bool_type, InlineBuiltinFunction::BitOpEQ(type));

	discard program.createBinaryFunction(type_namespace, "operator !=", type, program.cptr_type, program.bool_type, InlineBuiltinFunction::BitOpNE(type));
	discard program.createBinaryFunction(type_namespace, "operator !=", type, program.vptr_type, program.bool_type, InlineBuiltinFunction::BitOpNE(type));

	discard program.createBinaryFunction(type_namespace, "operator <=>", type, program.cptr_type, program.int_type, InlineBuiltinFunction::UIntOpCmp(type));
	discard program.createBinaryFunction(type_namespace, "operator <=>", type, program.vptr_type, program.int_type, InlineBuiltinFunction::UIntOpCmp(type));

	return type;
}

func createFloatTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Size", program.uint_concept, false));
	discard program.createType(dest_namespace, "float", template_parameters, TypeBody::Float(0u));
}

func createFloatTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, size: int) -> Type {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Size", program.uint_concept, false, TemplateParameter::Integer(size)));

	const type = Type(program.createType(dest_namespace, "float", template_parameters, TypeBody::Float(size as uint)), ReferenceKind::None);
	const type_namespace = type.decl.linked_namespace;

	createBasicFunctions(&&program, type, type_namespace);

	type.decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, InlineBuiltinFunction::FloatOpEQ(type));
	discard program.createBinaryFunction(type_namespace, "operator !=", type, type, program.bool_type, InlineBuiltinFunction::FloatOpNE(type));
	discard program.createBinaryFunction(type_namespace, "operator <", type, type, program.bool_type, InlineBuiltinFunction::FloatOpLT(type));
	discard program.createBinaryFunction(type_namespace, "operator <=", type, type, program.bool_type, InlineBuiltinFunction::FloatOpLE(type));
	discard program.createBinaryFunction(type_namespace, "operator >", type, type, program.bool_type, InlineBuiltinFunction::FloatOpGT(type));
	discard program.createBinaryFunction(type_namespace, "operator >=", type, type, program.bool_type, InlineBuiltinFunction::FloatOpGE(type));
	type.decl.op_compare = program.createBinaryFunction(type_namespace, "operator <=>", type, type, program.int_type, InlineBuiltinFunction::FloatOpCmp(type));

	discard program.createBinaryFunction(type_namespace, "operator +", type, type, type, InlineBuiltinFunction::FloatOpAdd(type));
	discard program.createBinaryFunction(type_namespace, "operator -", type, type, type, InlineBuiltinFunction::FloatOpSub(type));
	discard program.createBinaryFunction(type_namespace, "operator *", type, type, type, InlineBuiltinFunction::FloatOpMul(type));
	discard program.createBinaryFunction(type_namespace, "operator /", type, type, type, InlineBuiltinFunction::FloatOpDiv(type));
	discard program.createBinaryFunction(type_namespace, "operator %", type, type, type, InlineBuiltinFunction::FloatOpMod(type));

	discard program.createUnaryFunction(type_namespace, "operator -", type, type, InlineBuiltinFunction::FloatOpNeg(type));

	discard program.createBinaryFunction(type_namespace, "operator +=", type.varRef(), type, program.void_type, InlineBuiltinFunction::FloatOpAddAssign(type));
	discard program.createBinaryFunction(type_namespace, "operator -=", type.varRef(), type, program.void_type, InlineBuiltinFunction::FloatOpSubAssign(type));
	discard program.createBinaryFunction(type_namespace, "operator *=", type.varRef(), type, program.void_type, InlineBuiltinFunction::FloatOpMulAssign(type));
	discard program.createBinaryFunction(type_namespace, "operator /=", type.varRef(), type, program.void_type, InlineBuiltinFunction::FloatOpDivAssign(type));
	discard program.createBinaryFunction(type_namespace, "operator %=", type.varRef(), type, program.void_type, InlineBuiltinFunction::FloatOpModAssign(type));

	return type;
}

func createArrayTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("T", program.any_concept, false));
	template_parameters.append(TemplateParameterDecl("Size", program.uint_concept, false));
	discard program.createType(dest_namespace, "Array", template_parameters, TypeBody::Array(ArrayType(Type::unknown(), 0u)));
}

func createArrayTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, element_type: Type, size: uint, element_cptr_type: Type, element_vptr_type: Type) -> SharedHandle!<TypeDecl> {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("T", program.any_concept, false, TemplateParameter::Type(element_type)));
	template_parameters.append(TemplateParameterDecl("Size", program.uint_concept, false, TemplateParameter::Integer(size as int)));
	var type_decl = program.createType(dest_namespace, "Array", template_parameters, TypeBody::Array(ArrayType(element_type, size)));
	const type = Type(type_decl, ReferenceKind::None);

	type_decl.addContainedType(element_type);
	const type_namespace = type_decl.linked_namespace;

	type_decl.default_constructor = program.createUnaryFunction(type_namespace, "constructor", type.varRef(), program.void_type, BuiltinFunction::ArrayDefaultConstructor(type));
	type_decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, BuiltinFunction::ArrayCopyConstructor(type));
	type_decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, BuiltinFunction::ArrayDestructor(type));
	type_decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, BuiltinFunction::ArrayOpAssign(type));
	type_decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::ArrayOpEqual(type));
	discard program.createUnaryFunction(type_namespace, "data", type.constRef(), element_cptr_type, InlineBuiltinFunction::ArrayGetDataPointer(type));
	discard program.createUnaryFunction(type_namespace, "data", type.varRef(), element_vptr_type, InlineBuiltinFunction::ArrayGetDataPointer(type));
	discard program.createUnaryFunction(type_namespace, "size", type.constRef(), program.uint_type, InlineBuiltinFunction::ArrayGetSize(type));

	return type_decl;
}

func createTupleTypeTemplate(program: &&Program, dest_namespace: SharedHandle!<Namespace>) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Names", program.string_concept, false));
	template_parameters.append(TemplateParameterDecl("Types", program.any_concept, true));
	discard program.createType(dest_namespace, "Tuple", template_parameters, TypeBody::Tuple);
}

func createTupleTypeInstance(program: &&Program, dest_namespace: SharedHandle!<Namespace>, names: List!<String>, types: List!<Type>) -> SharedHandle!<TypeDecl> {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Names", program.string_concept, false, TemplateParameter::String(",".join(names))));
	for t in types {
		template_parameters.append(TemplateParameterDecl("Types", program.any_concept, false, TemplateParameter::Type(t)));
	}

	var type_decl = program.createType(dest_namespace, "Tuple", template_parameters, TypeBody::Tuple);
	const type = Type(type_decl, ReferenceKind::None);

	for i in 0u..types.size() {
		type_decl.createMemberVariable(Span(), names[i], types[i], Expr::Undefined(Span(), Type::unknown()));
	}

	const type_namespace = type_decl.linked_namespace;

	var value_constructor_parameter_types = types;
	value_constructor_parameter_types.insert(0u, type.varRef());
	discard program.createFunction(type_namespace, "constructor", value_constructor_parameter_types, program.void_type, BuiltinFunction::StructValueConstructor(type));

	type_decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, BuiltinFunction::StructCopyConstructor(type));
	type_decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, BuiltinFunction::StructDestructor(type));
	type_decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, BuiltinFunction::StructOpAssign(type));
	type_decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::StructOpEqual(type));

	return type_decl;
}

func createDefaultFunctions(program: &&Program, type: Type) -> void {
	var type_decl = type.decl;
	var type_namespace = type_decl.linked_namespace;

	if type_decl.body is Enum {
		if type_decl.copy_constructor.isEmpty() {
			type_decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, InlineBuiltinFunction::BitStoreValue(type));
		}

		if type_decl.destructor.isEmpty() {
			type_decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, InlineBuiltinFunction::NoOp(type));
		}

		if type_decl.op_assign.isEmpty() {
			type_decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, InlineBuiltinFunction::BitStoreValue(type));
		}

		if type_decl.op_equal.isEmpty() {
			type_decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, InlineBuiltinFunction::BitOpEQ(type));
		}

		if type_decl.op_compare.isEmpty() {
			type_decl.op_compare = program.createBinaryFunction(type_namespace, "operator <=>", type, type, program.int_type, InlineBuiltinFunction::UIntOpCmp(type));
		}
	} else if type_decl.body is Variant {
		if type_decl.copy_constructor.isEmpty() {
			type_decl.copy_constructor = program.createBinaryFunction(type_namespace, "constructor", type.varRef(), type, program.void_type, BuiltinFunction::VariantCopyConstructor(type));
		}

		if type_decl.destructor.isEmpty() {
			type_decl.destructor = program.createUnaryFunction(type_namespace, "destructor", type.varRef(), program.void_type, BuiltinFunction::VariantDestructor(type));
		}

		if type_decl.op_assign.isEmpty() {
			type_decl.op_assign = program.createBinaryFunction(type_namespace, "operator =", type.varRef(), type, program.void_type, BuiltinFunction::VariantOpAssign(type));
		}

		if type_decl.op_equal.isEmpty() {
			type_decl.op_equal = program.createBinaryFunction(type_namespace, "operator ==", type, type, program.bool_type, BuiltinFunction::VariantOpEqual(type));
		}
	}
}

func createVariantCaseConstructor(program: &&Program, type: SharedHandle!<TypeDecl>, case_id: int, payload_type: Type) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Id", program.int_concept, false, TemplateParameter::Integer(case_id)));

	var parameter_types: List!<Type>;
	parameter_types.append(Type(type, ReferenceKind::Var));

	if payload_type != program.void_type {
		parameter_types.append(payload_type);
	}

	for member_variable in type.member_variables {
		parameter_types.append(member_variable.type);
	}

	const function = program.createFunction(
		type.linked_namespace,
		"constructor",
		template_parameters,
		parameter_types,
		program.void_type,
		FunctionBody::Builtin(BuiltinFunction::VariantCaseConstructor(case_id, Type(type)))
	);
}

func createVariantOpIs(program: &&Program, type: SharedHandle!<TypeDecl>, case_id: int) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Id", program.int_concept, false, TemplateParameter::Integer(case_id)));

	var parameter_types: List!<Type>;
	parameter_types.append(Type(type));

	discard program.createFunction(
		type.linked_namespace,
		"operator is",
		template_parameters,
		parameter_types,
		program.bool_type,
		FunctionBody::InlineBuiltin(InlineBuiltinFunction::VariantOpIs(case_id, Type(type)))
	);
}

func createVariantOpUnsafeAs(program: &&Program, type: SharedHandle!<TypeDecl>, reference_kind: ReferenceKind, case_id: int) -> void {
	var template_parameters: List!<TemplateParameterDecl>;
	template_parameters.append(TemplateParameterDecl("Id", program.int_concept, false, TemplateParameter::Integer(case_id)));

	var parameter_types: List!<Type>;
	parameter_types.append(Type(type, reference_kind));

	var case_decl = type.getVariantCase(case_id).value();
	var result_type = case_decl.type;
	if result_type.reference_kind == None {
		result_type.reference_kind = reference_kind;
	}

	discard program.createFunction(
		type.linked_namespace,
		"operator unsafe as",
		template_parameters,
		parameter_types,
		result_type,
		FunctionBody::InlineBuiltin(InlineBuiltinFunction::VariantOpUnsafeAs(case_id, Type(type)))
	);
}

func getDefaultFunctionBody(this: &FunctionDecl) -> FunctionBody {
	if this.parent_namespace.linked_type.isEmpty() {
		return FunctionBody::Empty;
	}

	const parent_type = Type(this.parent_namespace.linked_type, ReferenceKind::None);
	const type_body = parent_type.decl.body;

	if this.name == "constructor" && this.parameter_types.size() == 1 {
		if this.parameter_types[0u] == parent_type.varRef() {
			match type_body {
				case Struct -> return FunctionBody::Builtin(BuiltinFunction::StructDefaultConstructor(parent_type));
				else -> {}
			}
		}
	} else if this.name == "constructor" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type.varRef() && this.parameter_types[1u] == parent_type {
			match type_body {
				case Struct -> return FunctionBody::Builtin(BuiltinFunction::StructCopyConstructor(parent_type));
				case Enum -> return FunctionBody::InlineBuiltin(InlineBuiltinFunction::BitStoreValue(parent_type));
				case Variant -> return FunctionBody::Builtin(BuiltinFunction::VariantCopyConstructor(parent_type));
				else -> {}
			}
		}
	} else if this.name == "destructor" && this.parameter_types.size() == 1 {
		if this.parameter_types[0u] == parent_type.varRef() {
			match type_body {
				case Struct -> return FunctionBody::Builtin(BuiltinFunction::StructDestructor(parent_type));
				case Enum -> return FunctionBody::InlineBuiltin(InlineBuiltinFunction::NoOp(parent_type));
				case Variant -> return FunctionBody::Builtin(BuiltinFunction::VariantDestructor(parent_type));
				else -> {}
			}
		}
	} else if this.name == "operator =" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type.varRef() && this.parameter_types[1u] == parent_type {
			match type_body {
				case Struct -> return FunctionBody::Builtin(BuiltinFunction::StructOpAssign(parent_type));
				case Enum -> return FunctionBody::InlineBuiltin(InlineBuiltinFunction::BitStoreValue(parent_type));
				case Variant -> return FunctionBody::Builtin(BuiltinFunction::VariantOpAssign(parent_type));
				else -> {}
			}
		}
	} else if this.name == "operator ==" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type && this.parameter_types[1u] == parent_type {
			match type_body {
				case Struct -> return FunctionBody::Builtin(BuiltinFunction::StructOpEqual(parent_type));
				case Enum -> return FunctionBody::InlineBuiltin(InlineBuiltinFunction::BitOpEQ(parent_type));
				case Variant -> return FunctionBody::Builtin(BuiltinFunction::VariantOpEqual(parent_type));
				else -> {}
			}
		}
	} else if this.name == "operator <=>" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type && this.parameter_types[1u] == parent_type {
			match type_body {
				case Struct -> return FunctionBody::Builtin(BuiltinFunction::StructOpCmp(parent_type));
				case Enum -> return FunctionBody::InlineBuiltin(InlineBuiltinFunction::UIntOpCmp(parent_type));
				else -> {}
			}
		}
	} else if this.name == "operator &" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type && this.parameter_types[1u] == parent_type {
			match type_body {
				case Enum -> return FunctionBody::InlineBuiltin(InlineBuiltinFunction::BitOpAnd(parent_type));
				else -> {}
			}
		}
	} else if this.name == "operator |" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type && this.parameter_types[1u] == parent_type {
			match type_body {
				case Enum -> return FunctionBody::InlineBuiltin(InlineBuiltinFunction::BitOpOr(parent_type));
				else -> {}
			}
		}
	} else if this.name == "operator &=" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type.varRef() && this.parameter_types[1u] == parent_type {
			match type_body {
				case Enum -> return FunctionBody::InlineBuiltin(InlineBuiltinFunction::BitOpAndAssign(parent_type));
				else -> {}
			}
		}
	} else if this.name == "operator |=" && this.parameter_types.size() == 2 {
		if this.parameter_types[0u] == parent_type.varRef() && this.parameter_types[1u] == parent_type {
			match type_body {
				case Enum -> return FunctionBody::InlineBuiltin(InlineBuiltinFunction::BitOpOrAssign(parent_type));
				else -> {}
			}
		}
	}

	return FunctionBody::Empty;
}
