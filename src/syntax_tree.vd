import std/core;
import std/string;
import std/shared;
import std/list;
import std/box;
import std/format;

import error;
import lexer;
import operators;
import span;
import tree_formatter;

variant ParsedAnnotation {
	var span: Span;
	var name: String;

	case Flag;
	case String: String;
	case Number: NumberLiteral;
}

enum TypeDeclKind {
	case Struct;
	case Enum;
	case Variant;
	case Garbage;
}

variant ParsedType {
	var span: Span;

	case Empty;
	case Name: ParsedName;
	case ConstReference: Box!<ParsedType>;
	case VarReference: Box!<ParsedType>;
	case Optional: Box!<ParsedType>;
	case Tuple: List!<ParsedTupleTypeElement>;
	case List: Box!<ParsedType>;
	case Array: ParsedArrayType;
	case Dict: ParsedDictType;
	case Function: ParsedFunctionType;
	case Garbage;
}

variant ParsedStmt {
	var span: Span;
	var is_comptime: bool;

	case Empty;

	case ExternFunctionBody;
	case DefaultFunctionBody;

	case Pragma: String;
	case Import: String;
	case Namespace: ParsedNamespace;
	case TypeDecl: ParsedTypeDecl;
	case FunctionDecl: Box!<ParsedFunctionDecl>;
	case Alias: ParsedTypeAlias;

	case VarDecl: ParsedVarDecl;
	case CaseDecl: ParsedCaseDecl;

	case Compound: ParsedCompoundStmt;

	case If: Box!<ParsedIfStmt>;
	case IfVar: ParsedIfVarStmt;
	case VarElse: ParsedVarElseStmt;

	case While: ParsedWhileStmt;
	case DoWhile: ParsedDoWhileStmt;
	case For: ParsedForStmt;

	case Case: Box!<ParsedCaseStmt>;
	case ElseCase: Box!<ParsedStmt>;

	case Break;
	case Continue;
	case Throw: ParsedExpr;
	case Return: ParsedExpr;
	case Yield: ParsedExpr;

	case Discard: ParsedExpr;
	case Expr: ParsedExpr;

	case Garbage;
}

variant ParsedExpr {
	var span: Span;

	case Empty;

	case Char: CharLiteral;
	case String: StringLiteral;
	case Number: NumberLiteral;
	case Bool: bool;
	case Name: ParsedName;

	case Operator: ParsedOperatorExpr;

	case Paren: Box!<ParsedExpr>;

	case Array: List!<ParsedExpr>;
	case Tuple: List!<ParsedTupleElement>;
	case Dict: List!<ParsedDictElement>;

	case Match: Box!<ParsedMatchExpr>;

	case FunctionRef: ParsedFunctionRefExpr;
	case Type: ParsedType;

	case AnonymousFunction: Box!<ParsedFunctionDecl>;

	case Garbage;

	func toType(this: &ParsedExpr) -> ParsedType {
		match this {
			case Name: name -> return ParsedType::Name(name, this.span);
			case Operator: operator_expr -> {
				if operator_expr.operands.size() != 1 {
					return ParsedType::Garbage(this.span);
				}

				const base = operator_expr.operands[0u].toType();
				if base is Garbage {
					return ParsedType::Garbage(this.span);
				}

				match operator_expr.op {
					case ConstRef -> return ParsedType::ConstReference(Box!<ParsedType>(base), this.span);
					case VarRef -> return ParsedType::VarReference(Box!<ParsedType>(base), this.span);
					else -> return ParsedType::Garbage(this.span);
				}
			}
			case Tuple: elements -> {
				var result: List!<(name: String, type: ParsedType)>;
				for e in elements {
					const element_type = e.value.toType();
					if element_type is Garbage {
						return ParsedType::Garbage(this.span);
					}

					result.append(ParsedTupleTypeElement(e.name, element_type));
				}

				return ParsedType::Tuple(result, this.span);
			}
			case Type: parsed_type -> return parsed_type;
			// TODO: Array, List & Dict types
			else -> return ParsedType::Garbage(this.span);
		}
	}

	func isAnonymousTuple(this: &ParsedExpr) -> bool {
		const elements = this as Tuple else {
			return false;
		}

		for element in elements {
			if element.name != "" {
				return false;
			}
		}

		return true;
	}
}

alias ParsedTemplateParameterDecl = (span: Span, name: String, concept: String, value: ParsedExpr);

alias ParsedNamespace = (
	span: Span,
	name_span: Span,
	annotations: List!<ParsedAnnotation>,
	template_parameters: List!<ParsedTemplateParameterDecl>,
	name: String,
	children: SharedPtr!<List!<ParsedStmt>>
);

alias ParsedTypeDecl = (
	span: Span,
	name_span: Span,
	annotations: List!<ParsedAnnotation>,
	template_parameters: List!<ParsedTemplateParameterDecl>,
	kind: TypeDeclKind,
	name: String,
	id_type: ParsedType,
	children: SharedPtr!<List!<ParsedStmt>>
);

alias ParsedParameterDecl = (span: Span, annotations: List!<ParsedAnnotation>, name: String, type: ParsedType, initializer: ParsedExpr);
alias ParsedFunctionSignature = (span: Span, name: String, parameters: List!<ParsedParameterDecl>, return_type: ParsedType);
alias ParsedFunctionDecl = (
	span: Span,
	annotations: List!<ParsedAnnotation>,
	template_parameters: List!<ParsedTemplateParameterDecl>,
	is_comptime: bool,
	signature: ParsedFunctionSignature,
	body: ParsedStmt
);

alias ParsedTupleTypeElement = (name: String, type: ParsedType);
alias ParsedArrayType = (element_type: Box!<ParsedType>, size: Box!<ParsedExpr>);
alias ParsedDictType = (key_type: Box!<ParsedType>, value_type: Box!<ParsedType>);
alias ParsedFunctionType = (parameter_types: List!<ParsedType>, return_type: Box!<ParsedType>);

alias ParsedNameSegment = (span: Span, name: String, template_parameters: List!<ParsedExpr>);
alias ParsedName = (span: Span, segments: List!<ParsedNameSegment>);

alias ParsedTypeAlias = (name: String, type: ParsedType);
alias ParsedVarDecl = (span: Span, name: String, is_const: bool, type: ParsedType, initializer: ParsedExpr);
alias ParsedCaseDecl = (span: Span, name: String, payload: ParsedType, id: ParsedExpr);

alias ParsedCompoundStmt = (span: Span, children: SharedPtr!<List!<ParsedStmt>>);
alias ParsedIfStmt = (condition: ParsedExpr, then_branch: ParsedStmt, else_branch: ParsedStmt);
alias ParsedIfVarStmt = (var_decl: ParsedVarDecl, body: ParsedCompoundStmt);
alias ParsedVarElseStmt = (var_decl: ParsedVarDecl, body: ParsedCompoundStmt, capture_name: String, capture_kind: ReferenceKind);
alias ParsedWhileStmt = (condition: ParsedExpr, body: ParsedCompoundStmt);
alias ParsedDoWhileStmt = (body: ParsedCompoundStmt, condition: ParsedExpr);
alias ParsedForStmt = (capture_name: String, capture_kind: ReferenceKind, capture_span: Span, range: ParsedExpr, body: ParsedCompoundStmt);
alias ParsedCaseStmt = (patterns: List!<ParsedExpr>, capture_name: String, capture_kind: ReferenceKind, body: ParsedStmt);

alias ParsedOperatorExpr = (op: Operator, operands: SharedPtr!<List!<ParsedExpr>>);
alias ParsedTupleElement = (span: Span, name: String, value: ParsedExpr);
alias ParsedDictElement = (span: Span, key: ParsedExpr, value: ParsedExpr);

alias ParsedMatchExpr = (value: ParsedExpr, body: ParsedCompoundStmt);
alias ParsedFunctionRefExpr = (name: ParsedName, parameter_types: List!<ParsedType>);

func makeParsedName(span: Span, name: String) -> ParsedName {
	return ParsedName(span, List!<ParsedNameSegment>(1u, ParsedNameSegment(span, name, List!<ParsedExpr>())));
}

func makeParsedOperatorExpr(lhs: ParsedExpr, op: Operator, rhs: ParsedExpr, span: Span) -> ParsedExpr {
	var operands: SharedPtr!<List!<ParsedExpr>> = List!<ParsedExpr>();
	operands.append(lhs);
	operands.append(rhs);
	return ParsedExpr::Operator(ParsedOperatorExpr(op, operands), span);
}

func makeParsedOperatorExpr(op: Operator, rhs: ParsedExpr, span: Span) -> ParsedExpr {
	var operands: SharedPtr!<List!<ParsedExpr>> = List!<ParsedExpr>();
	operands.append(rhs);
	return ParsedExpr::Operator(ParsedOperatorExpr(op, operands), span);
}

func toString(this: ReferenceKind) -> String {
	match this {
		case None -> return "";
		case Const -> return "&";
		case Var -> return "&&";
	}
}

func dumpModule(stmts: &List!<ParsedStmt>) -> String {
	var out: TreeFormatter = ("Module");

	for i in 0u..stmts.size() {
		stmts[i].dump(&&out, i == stmts.size() - 1);
	}

	return out.finalize();
}

func dump(this: &ParsedAnnotation, out: &&TreeFormatter, is_last: bool) -> void {
	out.push("Annotation", is_last);
	out.attribute(this.name);

	match this {
		case Flag -> {}
		case String: value -> out.value(value);
		case Number: value -> out.value(value.dump());
	}

	out.span(this.span);
	out.pop();
}

func dump(this: &ParsedNamespace, out: &&TreeFormatter, is_last: bool) -> void {
	out.push("Namespace", is_last);
	out.span(this.span);
	out.value(this.name);

	for i in 0u..this.annotations.size() {
		this.annotations[i].dump(&&out, (i == this.annotations.size() - 1) && this.template_parameters.isEmpty() && this.children.isEmpty());
	}

	for i in 0u..this.template_parameters.size() {
		this.template_parameters[i].dump(&&out, (i == this.template_parameters.size() - 1) && this.children.isEmpty());
	}

	for i in 0u..this.children.size() {
		this.children[i].dump(&&out, (i == this.children.size() - 1));
	}

	out.pop();
}

func dump(this: &ParsedTypeDecl, out: &&TreeFormatter, is_last: bool) -> void {
	match this.kind {
		case Struct -> out.push("StructDecl", is_last);
		case Enum -> out.push("EnumDecl", is_last);
		case Variant -> out.push("VariantDecl", is_last);
		case Garbage -> out.push("GarbageTypeDecl", is_last);
	}

	out.attribute(this.name);
	out.span(this.span);

	for i in 0u..this.annotations.size() {
		this.annotations[i].dump(&&out, (i == this.annotations.size() - 1) && this.template_parameters.isEmpty() && this.children.isEmpty());
	}

	for i in 0u..this.template_parameters.size() {
		this.template_parameters[i].dump(&&out, (i == this.template_parameters.size() - 1) && this.children.isEmpty());
	}

	for i in 0u..this.children.size() {
		this.children[i].dump(&&out, (i == this.children.size() - 1));
	}

	out.pop();
}

func dump(this: &ParsedCaseDecl, out: &&TreeFormatter, is_last: bool) -> void {
	out.push("CaseDecl", is_last);
	out.attribute(this.name);

	this.payload.dump(&&out, false);
	this.id.dump(&&out, true);

	out.pop();
}

func dump(this: &ParsedFunctionDecl, out: &&TreeFormatter, is_last: bool) -> void {
	out.push("FunctionDecl", is_last);

	if this.is_comptime {
		out.value("comptime");
	}

	out.span(this.span);

	for annotation in this.annotations {
		annotation.dump(&&out, false);
	}

	for template_parameter in this.template_parameters {
		template_parameter.dump(&&out, false);
	}

	this.signature.dump(&&out, !(this.body is Compound));
	this.body.dump(&&out, true);

	out.pop();
}

func dump(this: &ParsedFunctionSignature, out: &&TreeFormatter, is_last: bool) -> void {
	out.push("FunctionSignature", is_last);
	out.attribute(this.name);
	out.span(this.span);

	for i in 0u..this.parameters.size() {
		this.parameters[i].dump(&&out, false);
	}

	this.return_type.dump(&&out, true);

	out.pop();
}

func dump(this: &ParsedParameterDecl, out: &&TreeFormatter, is_last: bool) -> void {
	out.push("ParameterDecl", is_last);
	out.attribute(this.name);
	out.span(this.span);

	this.type.dump(&&out, false);
	this.initializer.dump(&&out, true);

	out.pop();
}

func dump(this: &ParsedTemplateParameterDecl, out: &&TreeFormatter, is_last: bool) -> void {
	out.push("TemplateParameterDecl", is_last);
	out.attribute(this.name);
	out.text(": ");
	out.attribute(this.concept);

	this.value.dump(&&out, true);

	out.pop();
}

func dump(this: &ParsedVarDecl, out: &&TreeFormatter, is_last: bool) -> void {
	out.push("VarDecl", is_last);
	out.attribute("const" if this.is_const else "var");
	out.attribute(this.name);

	this.type.dump(&&out, false);
	this.initializer.dump(&&out, true);

	out.pop();
}

func dump(this: &ParsedType, out: &&TreeFormatter, is_last: bool) -> void {
	match this {
		case Empty -> out.push("EmptyType", is_last);
		case Name: name -> {
			out.push("NamedType", is_last);
			name.dump(&&out, true);
		}
		case ConstReference: base -> {
			out.push("ConstReferenceType", is_last);
			out.span(this.span);
			base.dump(&&out, true);
		}
		case VarReference: base -> {
			out.push("VarReferenceType", is_last);
			out.span(this.span);
			base.dump(&&out, true);
		}
		case Optional: base -> {
			out.push("OptionalType", is_last);
			out.span(this.span);
			base.dump(&&out, true);
		}
		case Tuple: elements -> {
			out.push("TupleType", is_last);
			out.span(this.span);
			for i in 0u..elements.size() {
				out.push("TupleElement", i == elements.size() - 1);
				out.value(elements[i].name);
				elements[i].type.dump(&&out, true);
			}
		}
		case List: element_type -> {
			out.push("ListType", is_last);
			out.span(this.span);
			element_type.dump(&&out, true);
		}
		case Array: array_type -> {
			out.push("ArrayType", is_last);
			out.span(this.span);
			array_type.element_type.dump(&&out, true);
			array_type.size.dump(&&out, true);
		}
		case Dict: dict_type -> {
			out.push("DictType", is_last);
			out.span(this.span);
			dict_type.key_type.dump(&&out, true);
			dict_type.value_type.dump(&&out, true);
		}
		case Function: function_type -> {
			out.push("FunctionType", is_last);
			out.span(this.span);
			for t in function_type.parameter_types {
				t.dump(&&out, false);
			}
			function_type.return_type.dump(&&out, true);
		}
		case Garbage -> {
			out.push("GarbageType", is_last);
			out.span(this.span);
		}
	}

	out.pop();
}

func dump(this: &ParsedNameSegment, out: &&TreeFormatter, is_last: bool) -> void {
	out.push("NameSegment", is_last);
	out.value(this.name);
	out.span(this.span);

	for i in 0u..this.template_parameters.size() {
		this.template_parameters[i].dump(&&out, i == this.template_parameters.size() - 1);
	}

	out.pop();
}

func dump(this: &ParsedName, out: &&TreeFormatter, is_last: bool) -> void {
	out.push("Name", is_last);
	out.span(this.span);

	for i in 0u..this.segments.size() {
		this.segments[i].dump(&&out, i == this.segments.size() - 1);
	}

	out.pop();
}

func dump(this: &ParsedStmt, out: &&TreeFormatter, is_last: bool) -> void {
	match this {
		case Empty -> {
			out.push("EmptyStmt", is_last);
			out.span(this.span);
			out.pop();
		}
		case ExternFunctionBody -> {
			out.push("ExternFunctionBody", is_last);
			out.span(this.span);
			out.pop();
		}
		case DefaultFunctionBody -> {
			out.push("DefaultFunctionBody", is_last);
			out.span(this.span);
			out.pop();
		}
		case Pragma: name -> {
			out.push("Pragma", is_last);
			out.attribute(name);
			out.span(this.span);
			out.pop();
		}
		case Import: name -> {
			out.push("Import", is_last);
			out.attribute(name);
			out.span(this.span);
			out.pop();
		}
		case Namespace: decl -> return decl.dump(&&out, is_last);
		case TypeDecl: decl -> return decl.dump(&&out, is_last);
		case FunctionDecl: decl -> return decl.dump(&&out, is_last);
		case Alias: data -> {
			out.push("Alias", is_last);
			out.value(data.name);
			out.span(this.span);
			data.type.dump(&&out, true);
			out.pop();
		}
		case VarDecl: decl -> return decl.dump(&&out, is_last);
		case CaseDecl: decl -> return decl.dump(&&out, is_last);
		case Compound: stmt -> return stmt.dump(&&out, is_last);
		case If: if_stmt -> {
			out.push("IfStmt", is_last);
			out.span(this.span);

			if_stmt.condition.dump(&&out, false);
			if_stmt.then_branch.dump(&&out, false);
			if_stmt.else_branch.dump(&&out, true);

			out.pop();
		}
		case IfVar: if_var_stmt -> {
			out.push("IfVarStmt", is_last);
			out.span(this.span);

			if_var_stmt.var_decl.dump(&&out, false);
			if_var_stmt.body.dump(&&out, true);

			out.pop();
		}
		case VarElse: var_else_stmt -> {
			out.push("VarElseStmt", is_last);
			out.attribute(var_else_stmt.capture_kind.toString() + var_else_stmt.capture_name);
			out.span(this.span);

			var_else_stmt.var_decl.dump(&&out, false);
			var_else_stmt.body.dump(&&out, true);

			out.pop();
		}
		case While: while_stmt -> {
			out.push("WhileStmt", is_last);
			out.span(this.span);

			while_stmt.condition.dump(&&out, false);
			while_stmt.body.dump(&&out, true);

			out.pop();
		}
		case DoWhile: do_while_stmt -> {
			out.push("DoWhileStmt", is_last);
			out.span(this.span);

			do_while_stmt.body.dump(&&out, false);
			do_while_stmt.condition.dump(&&out, true);

			out.pop();
		}
		case For: for_stmt -> {
			out.push("ForStmt", is_last);
			out.attribute(for_stmt.capture_kind.toString() + for_stmt.capture_name);
			out.span(this.span);

			for_stmt.range.dump(&&out, false);
			for_stmt.body.dump(&&out, true);

			out.pop();
		}
		case Case: case_stmt -> {
			out.push("CaseStmt", is_last);
			out.attribute(case_stmt.capture_kind.toString() + case_stmt.capture_name);
			out.span(this.span);

			for pattern in case_stmt.patterns {
				pattern.dump(&&out, false);
			}

			case_stmt.body.dump(&&out, true);

			out.pop();
		}
		case ElseCase: body -> {
			out.push("ElseCase", is_last);
			out.span(this.span);
			body.dump(&&out, true);
			out.pop();
		}
		case Break -> {
			out.push("BreakStmt", is_last);
			out.span(this.span);
			out.pop();
		}
		case Continue -> {
			out.push("ContinueStmt", is_last);
			out.span(this.span);
			out.pop();
		}
		case Throw: expr -> {
			out.push("ThrowStmt", is_last);
			out.span(this.span);

			expr.dump(&&out, true);

			out.pop();
		}
		case Return: return_value -> {
			out.push("ReturnStmt", is_last);
			out.span(this.span);
			return_value.dump(&&out, true);
			out.pop();
		}
		case Yield: value -> {
			out.push("YieldStmt", is_last);
			out.span(this.span);
			value.dump(&&out, true);
			out.pop();
		}
		case Discard: expr -> {
			out.push("DiscardStmt", is_last);
			out.span(this.span);

			expr.dump(&&out, true);

			out.pop();
		}
		case Expr: expr -> return expr.dump(&&out, is_last);
		case Garbage -> {
			out.push("GarbageStmt", is_last);
			out.span(this.span);
			out.pop();
		}
	}
}

func dump(this: &ParsedCompoundStmt, out: &&TreeFormatter, is_last: bool) -> void {
	out.push("CompoundStmt", is_last);
	out.span(this.span);

	for i in 0u..this.children.size() {
		this.children[i].dump(&&out, i == this.children.size() - 1);
	}

	out.pop();
}

func dump(this: &ParsedExpr, out: &&TreeFormatter, is_last: bool) -> void {
	match this {
		case Empty -> {
			out.push("EmptyEypr", is_last);
			out.span(this.span);
			out.pop();
		}
		case Char: value -> {
			out.push("CharLiteral", is_last);
			out.attribute(value.dump());
			out.span(this.span);
			out.pop();
		}
		case String: value -> {
			out.push("StringLiteral", is_last);
			out.attribute(value.dump());
			out.span(this.span);
			out.pop();
		}
		case Number: value -> {
			out.push("NumberLiteral", is_last);
			out.attribute(value.dump());
			out.span(this.span);
			out.pop();
		}
		case Bool: value -> {
			out.push("BoolLiteral", is_last);
			out.attribute(format(value));
			out.span(this.span);
			out.pop();
		}
		case Name: name -> name.dump(&&out, is_last);
		case Operator: operator_expr -> {
			if operator_expr.op.isUnaryOperator() {
				out.push("UnaryOperatorExpr", is_last);
			} else if operator_expr.op.isBinaryOperator() {
				out.push("BinaryOperatorExpr", is_last);
			} else if operator_expr.op.isTernaryOperator() {
				out.push("TernaryOperatorExpr", is_last);
			} else if operator_expr.op == Call {
				out.push("CallExpr", is_last);
			} else if operator_expr.op == Index {
				out.push("IndexExpr", is_last);
			} else if operator_expr.op == MemberAccess {
				out.push("MemberAccessExpr", is_last);
			} else {
				out.push("OperatorExpr", is_last);
			}

			out.attribute(operator_expr.op.toString());
			out.span(this.span);

			for i in 0u..operator_expr.operands.size() {
				operator_expr.operands[i].dump(&&out, i == operator_expr.operands.size() - 1);
			}

			out.pop();
		}
		case Paren: child -> {
			out.push("ParenExpr", is_last);
			out.span(this.span);
			child.dump(&&out, true);
			out.pop();
		}
		case Array: elements -> {
			out.push("ArrayExpr", is_last);
			out.span(this.span);

			for i in 0u..elements.size() {
				elements[i].dump(&&out, i == elements.size() - 1);
			}

			out.pop();
		}
		case Tuple: elements -> {
			out.push("TupleExpr", is_last);
			out.span(this.span);

			for i in 0u..elements.size() {
				elements[i].dump(&&out, i == elements.size() - 1);
			}

			out.pop();
		}
		case Dict: elements -> {
			out.push("DictExpr", is_last);
			out.span(this.span);

			for i in 0u..elements.size() {
				elements[i].dump(&&out, i == elements.size() - 1);
			}

			out.pop();
		}
		case Match: match_expr -> {
			out.push("MatchExpr", is_last);
			out.span(this.span);

			match_expr.value.dump(&&out, false);
			match_expr.body.dump(&&out, true);

			out.pop();
		}
		case FunctionRef: data -> {
			out.push("FunctionRefExpr", is_last);
			out.span(this.span);

			data.name.dump(&&out, false);
			for t in data.parameter_types {
				t.dump(&&out, false);
			}

			out.pop();
		}
		case Type: parsed_type -> {
			out.push("TypeExpr", is_last);
			out.span(this.span);
			parsed_type.dump(&&out, true);
			out.pop();
		}
		case AnonymousFunction: function_decl -> {
			out.push("AnonymousFunctionExpr", is_last);
			out.span(this.span);
			function_decl.dump(&&out, true);
			out.pop();
		}
		case Garbage -> {
			out.push("GarbageExpr", is_last);
			out.span(this.span);
			out.pop();
		}
	}
}

func dump(this: &ParsedTupleElement, out: &&TreeFormatter, is_last: bool) -> void {
	out.push("TupleElement", is_last);
	out.attribute(this.name);
	out.span(this.span);

	this.value.dump(&&out, true);

	out.pop();
}

func dump(this: &ParsedDictElement, out: &&TreeFormatter, is_last: bool) -> void {
	out.push("DictElement", is_last);
	out.span(this.span);

	this.key.dump(&&out, true);
	this.value.dump(&&out, true);

	out.pop();
}
