import jakt::platform::utility
import utility
import ast
import program {*}

struct Typechecker {
	options: CompilerOptions
	program: Program
	module: Module
	finalize: bool

	fn checkProgram(options: CompilerOptions, mut program: Program) throws {
		for module in program.modules {
			for pragma in module.parsed_module.pragmas {
				if pragma == "generate_std_core_builtins" {
					initCoreModule(program, module)
				} else if pragma == "generate_std_array_builtins" {
					initArrayModule(program, module)
				}
			}
		}

		for module in program.modules {
			mut typechecker = Typechecker(options, program, module, finalize: false)
			for parsed_type in module.parsed_module.types {
				typechecker.checkTypeDecl(parsed_type)
			}
		}

		for module in program.modules {
			mut typechecker = Typechecker(options, program, module, finalize: false)
			for parsed_type in module.parsed_module.types {
				typechecker.checkTypeExtension(parsed_type)
			}
		}

		for module in program.modules {
			mut typechecker = Typechecker(options, program, module, finalize: false)
			typechecker.checkTypeBodies()
		}

		for module in program.modules {
			mut typechecker = Typechecker(options, program, module, finalize: false)
			for parsed_function in module.parsed_module.functions {
				typechecker.checkFunctionDecl(parsed_function, parent_type: None)
			}
		}

		for module in program.modules {
			mut typechecker = Typechecker(options, program, module, finalize: true)
			for id in module.types {
				typechecker.finalizeTypeDecl(type: program.types[id])
			}
		}

		while program.containsUncheckedTypes() or program.containsUncheckedFunctions() {
			for module in program.modules {
				mut typechecker = Typechecker(options, program, module, finalize: true)
				typechecker.checkTypeBodies()
				typechecker.checkFunctionImplementations()
			}
		}
	}

	fn checkTypeBodies(mut this) throws {
		while not .module.unchecked_types.is_empty() {
			let id = .module.unchecked_types.pop()!
			if .program.types[id].kind is Unchecked(parsed_type) {
				.checkTypeBody(type: Type::Base(id), parsed_type)
			}

			.checkTypeExtension(type: Type::Base(id))

			if .finalize {
				.finalizeTypeDecl(type: .program.types[id])
			}
		}
	}

	fn checkFunctionImplementations(mut this) throws {
		while not .module.unchecked_functions.is_empty() {
			let id = .module.unchecked_functions.pop()!
			if .program.functions[id].kind is Unchecked(parsed_function) {
				.checkFunctionImpl(func: Function(id), parsed_function)
			}
		}
	}

	fn getType(mut this, namespaces: [String], name: String, template_parameters: [TemplateParameter], template_parameters_to_search: [TemplateParameter], error_span: Span) throws -> Type? {
		if namespaces.is_empty() and template_parameters.is_empty() and name.length() > 1 {
			if name.byte_at(0) == b'u' or name.byte_at(0) == b'i' {
				let bits = name.substring(start: 1, length: name.length() - 1).to_uint()
				if bits.has_value() {
					return .getType(namespaces: [],
						name: match name.byte_at(0) {
							b'u' => "uint"
							else => "int"
						}, template_parameters: [
							TemplateParameter::IntLiteral(span: Span::empty(), name: "Size", value: bits! as! i64)
						],
						template_parameters_to_search, error_span
					)
				}
			}
		}

		return .selectType(
			types: .module.getMatchingTypes(namespaces, name, template_parameters_to_search)
			template_parameters, error_span
		)
	}

	fn selectType(mut this, types: [Type], template_parameters: [TemplateParameter], error_span: Span) throws -> Type? {
		mut matches: [(i64, Type)] = []

		if types.size() == 1 and template_parameters.is_empty() and not .program.types[types[0].id].isIncompleteTemplate() {
			return types[0]
		}

		for type in types {
			let decl = .program.types[type.id]

			if decl.canBeMappedTo(template_parameters) {
				matches.push((
					decl.getMatchingTemplateParameterCount(template_parameters) as! i64,
					type
				))
			}
		}

		if matches.is_empty() {
			.module.error("no matching type found", error_span)
			.module.error("    candidates are:", Span::empty())

			mut i = 0
			for t in types {
				if i > 3 {
					.module.error(format("    ..."), Span::empty())
					break
				}
				.module.error(format("    {}", .program.formatTypeSignature(type: t)), Span::empty())
				i++
			}
			return None
		}

		mut best_score: i64 = -1
		mut best_index: usize = 0
		mut duplicates = 0

		for i in 0..matches.size() {
			if matches[i].0 > best_score {
				best_score = matches[i].0
				best_index = i
				duplicates = 1
			} else if matches[i].0 == best_score {
				duplicates += 1
			}
		}

		if duplicates > 1 {
			.module.error("too many matching types found", error_span)
			.module.error("candidates are:", span: Span::empty())
			for i in 0..matches.size() {
				if i >= 3 {
					.module.error(format("    ..."), Span::empty())
					break
				}
				if matches[i].0 == best_score {
					.module.error("    " + .program.formatTypeSignature(type: Type::Base(id: matches[i].1.id)), span: Span::empty())
				}
			}
			return None
		}

		let selected_type = matches[best_index].1
		let selected_type_decl = .program.types[selected_type.id]
		if selected_type_decl.isIncompleteTemplate() {
			mut typechecker = Typechecker(options: .options, program: .program, module: selected_type_decl.module!, finalize: .finalize)
			return typechecker.createTemplateTypeInstance(origin: selected_type_decl, template_parameters, error_module: .module, error_span)
		} else {
			return selected_type
		}
	}

	fn createTemplateTypeInstance(mut this, mut origin: TypeDecl, mut template_parameters: [TemplateParameter], mut error_module: Module, error_span: Span) throws -> Type {
		for i in 0..template_parameters.size() {
			template_parameters[i] = match template_parameters[i] {
				Type(value) => TemplateParameter::Type(span: template_parameters[i].span, name: origin.template_parameters[i].name, value)
				IntLiteral(value) => TemplateParameter::IntLiteral(span: template_parameters[i].span, name: origin.template_parameters[i].name, value)
			}
		}

		let instance = match origin.kind {
			Unchecked(parsed_type) => {
				let instance = .module.createType(name: origin.name, template_parameters)
				.checkTypeBody(type: instance, parsed_type)
				yield instance
			}
			Builtin(builtin) => match builtin {
				SInt(size) => {
					guard not size.has_value() else {
						panic("invalid template instantiation")
					}

					guard template_parameters[0] is IntLiteral(value) else {
						panic("invalid template instantiation")
					}

					yield createSIntInstance(program: .program, module: .module, size: value! as! u64)
				}
				UInt(size) => {
					guard not size.has_value() else {
						panic("invalid template instantiation")
					}

					guard template_parameters[0] is IntLiteral(value) else {
						panic("invalid template instantiation")
					}

					yield createUIntInstance(program: .program, module: .module, size: value! as! u64)
				}
				Pointer(element_type) => {
					guard not element_type.has_value() else {
						panic("invalid template instantiation")
					}
					yield .createPtrTypeInstance(original: origin, template_parameters, error_module, error_span)
				}
				Array(element_type, size) => {
					guard not element_type.has_value() and not size.has_value() else {
						panic("invalid template instantiation")
					}
					yield .createArrayTypeInstance(original: origin, template_parameters, error_module, error_span)
				}
				else => {
					error_module.error("invalid template specialization", span: error_span)
					return .program.void_type
				}
			}
			else => {
				error_module.error("invalid template specialization", span: error_span)
				return .program.void_type
			}
		}

		origin.template_instances.push(instance)
		.program.types[instance.id].additional_member_functions = origin.additional_member_functions
		.checkTypeExtension(type: instance)

		return instance
	}

	fn getFunction(mut this, namespaces: [String], name: String, parent_type: Type?, template_parameters: [TemplateParameter], param_types: [Type], firstArgRefType: Type?, span: Span, allow_spaceship_operator: bool = false) throws -> Function? {
		let is_comparison = match name {
			"operator =="
			| "operator !="
			| "operator <"
			| "operator <="
			| "operator >"
			| "operator >=" => allow_spaceship_operator
			else => false
		}
		let allow_unwrapping = name != "operator unwrap"

		let functions_with_matching_name = .module.getMatchingFunctions(namespaces, name, parent_type, is_comparison)

		mut unique_functions: {u64} = {}
		for id in functions_with_matching_name {
			let decl = .program.functions[id]

			guard decl.canBeMappedTo(template_parameters) else {
				continue
			}

			if decl.isIncompleteTemplate() {
				for instance in .getTemplateFunctionInstances(func: decl, template_parameters, span) {
					unique_functions.add(instance)
				}
			} else {
				unique_functions.add(decl.id)
			}
		}

		mut matching_functions: [u64] = []
		mut most_matching_parameters = 0
		for id in unique_functions {
			let (is_match, matching_parameters) = .doFunctionParametersMatch(func: Function(id), param_types, firstArgRefType, allow_unwrapping)

			guard is_match and matching_parameters >= most_matching_parameters else {
				continue
			}

			if matching_parameters > most_matching_parameters {
				most_matching_parameters = matching_parameters
				matching_functions = []
			}

			matching_functions.push(id)
		}

		if matching_functions.is_empty() {
			if not allow_spaceship_operator and namespaces.is_empty() and parent_type.has_value() {
				return .getFunction(namespaces, name, parent_type, template_parameters, param_types, firstArgRefType, span, allow_spaceship_operator: true)
			}

			.module.error(format("no matching function found: {}::{}{}{}", 
				match parent_type.has_value() {
					true => .program.formatTypeSignature(type: parent_type!)
					else => join(namespaces, separator: "::")
				},
				name,
				.program.formatTemplateParameters(template_parameters),
				.program.formatFunctionParameterTypes(param_types)
			), span)

			if not unique_functions.is_empty() {
				.module.error("candidates are:", span: Span::empty())
				mut i = 0
				for id in unique_functions {
					if i > 3 {
						.module.error(format("    ..."), Span::empty())
						break
					}
					.module.error(format("    {}", .program.formatFunctionSignature(func: Function(id))), span: Span::empty())
					i++
				}
			}
			return None
		}

		if parent_type.has_value() {
			// if there are 1-3 matching functions return the one where
			// the first parameter is passed as the "highest" reference version
			if param_types.size() > 0 and matching_functions.size() > 1 and matching_functions.size() <= 3 {
				mut base_variant: Function? = None
				mut const_ref_variant: Function? = None
				mut var_ref_variant: Function? = None

				for id in matching_functions {
					let this_type = .program.functions[id].type.param_types[0]

					if this_type is VarRef {
						var_ref_variant = Function(id)
					} else if this_type is ConstRef {
						const_ref_variant = Function(id)
					} else {
						base_variant = Function(id)
					}
				}

				if var_ref_variant.has_value() {
					return var_ref_variant!
				} else if const_ref_variant.has_value() {
					return const_ref_variant!
				} else if base_variant.has_value() {
					return base_variant!
				}
			}

			// if there is 1 or more matching functions,
			// but exactly one is a member function of parent_type, return that one
			mut child_func: Function? = None
			for id in matching_functions {
				let other_parent_type = .program.functions[id].parent_type
				guard other_parent_type.has_value() else {
					continue
				}

				if other_parent_type.has_value() and other_parent_type!.equals(other: parent_type!) {
					if child_func.has_value() {
						child_func = None
						break
					}
					child_func = Function(id)
				}
			}
			if child_func.has_value() {
				return child_func!
			}
		}

		// if there is more than 1 function,
		// but one of them is an exact match
		// and the others are alternative comparison operators
		// return the exact match
		mut prefered_match: Function? = None
		for id in matching_functions {
			if .program.functions[id].name == name {
				if prefered_match.has_value() {
					prefered_match = None
					break
				}
				prefered_match = Function(id)
			}
		}
		if prefered_match.has_value() {
			return prefered_match!
		}

		guard matching_functions.size() == 1 else {
			.module.error(format("too many matching functions found: {}::{}{}{}",
				match parent_type.has_value() {
					true => .program.formatTypeSignature(type: parent_type!)
					else => join(namespaces, separator: "::")
				}
				name,
				.program.formatTemplateParameters(template_parameters),
				.program.formatFunctionParameterTypes(param_types)
			), span)
			.module.error("candidates are:", span: Span::empty())
			mut i = 0
			for id in matching_functions {
				if i > 3 {
					.module.error(format("    ..."), Span::empty())
					break
				}
				.module.error(format("    {}", .program.formatFunctionSignature(func: Function(id))), span: Span::empty())
				i++
			}
			return None
		}

		return Function(id: matching_functions[0])
	}

	fn getTemplateFunctionSpecializations(this, func: FunctionDecl) throws -> [FunctionDecl] {
		mut specializations: [FunctionDecl] = []

		for id in func.module!.functions {
			let other = .program.functions[id]
			guard func.name == other.name else {
				continue
			}

			guard func.parent_type.has_value() == other.parent_type.has_value() else {
				continue
			}

			if func.parent_type.has_value() {
				guard func.parent_type!.equals(other: other.parent_type!) else {
					continue
				}
			}

			guard func.template_parameters.size() == other.template_parameters.size() else {
				continue
			}

			mut matching_template_parameters = true
			for i in 0..func.template_parameters.size() {
				let param_a = func.template_parameters[i]
				let param_b = other.template_parameters[i]

				guard param_a.name == param_b.name else {
					matching_template_parameters = false
					break
				}

				guard (param_a is Type and param_b is Type) or (param_a is IntLiteral and param_b is IntLiteral) else {
					matching_template_parameters = false
					break
				}
			}

			guard matching_template_parameters else {
				continue
			}

			if other.getSpecialzedTemplateParameterCount() > func.getSpecialzedTemplateParameterCount() {
				specializations.push(other)
			}
		}

		return specializations
	}

	fn getTemplateFunctionInstances(mut this, func: FunctionDecl, template_parameters: [TemplateParameter], span: Span) throws -> {u64} {
		mut matches: {u64} = {}
		mut best_score: u64 = 0

		for other in .getTemplateFunctionSpecializations(func) {
			if other.canBeMappedTo(template_parameters) {
				let score = other.getMatchingTemplateParameterCount(template_parameters)
				if score > best_score {
					matches = {}
					best_score = score
				}
				matches.add(other.id)
			}
		}

		if matches.is_empty() {
			matches.add(func.id)
		}

		for id in matches {
			let selected_func = .program.functions[id]
			if selected_func.isIncompleteTemplate() {
				mut typechecker = Typechecker(options: .options, program: .program, module: selected_func.module!, finalize: .finalize)
				let instance = typechecker.createTemplateFunctionInstance(func: selected_func, template_parameters, error_span: span)
				matches.remove(id)
				matches.add(instance.id)
			}
		}

		return matches
	}

	fn createTemplateFunctionInstance(mut this, func: FunctionDecl, mut template_parameters: [TemplateParameter], error_span: Span) throws -> Function {
		for i in 0..template_parameters.size() {
			template_parameters[i] = match template_parameters[i] {
				Type(value) => TemplateParameter::Type(span: template_parameters[i].span, name: func.template_parameters[i].name, value)
				IntLiteral(value) => TemplateParameter::IntLiteral(span: template_parameters[i].span, name: func.template_parameters[i].name, value)
			}
		}

		return match func.kind {
			InlineBuiltin(builtinFunction) => match builtinFunction {
				IntCast | FloatCast | IntToFloat | FloatToInt => {
					guard template_parameters.size() == 2 else { panic("invalid template parameters for " + func.name) }
					guard template_parameters[0] is Type(value: target) else { panic("invalid template parameters for " + func.name) }
					guard template_parameters[1] is Type(value: source) else { panic("invalid template parameters for " + func.name) }

					let instance = .module.createBuiltinFunction2(
						parent_type: None,
						func.name, [source!], target!,
						match builtinFunction {
							IntCast => InlineBuiltinFunction::IntCast(target, source)
							FloatCast => InlineBuiltinFunction::FloatCast(target, source)
							IntToFloat => InlineBuiltinFunction::IntToFloat(target, source)
							FloatToInt => InlineBuiltinFunction::FloatToInt(target, source)
							else => { panic("unreachable") }
						},
						template_parameters
					)

					yield instance
				}
				PointerCast => {
					guard template_parameters.size() == 2 else { panic("invalid template parameters for ptrCast: invalid amount of template parameters") }
					guard template_parameters[0] is Type(value: target) else { panic("invalid template parameters for ptrCast: target is not a type") }
					guard template_parameters[1] is Type(value: source) else { panic("invalid template parameters for ptrCast: source is not a type") }

					guard .program.isPtrType(type: target!) else { panic("invalid template parameters for ptrCast: target is not a pointer type") }
					guard .program.isPtrType(type: source!) else { panic("invalid template parameters for ptrCast: source is not a pointer type") }

					guard .program.types[target!.id].kind is Builtin(builtin: builtin1) else { panic("invalid template parameters for ptrCast: target is not a builtin type") }
					guard .program.types[source!.id].kind is Builtin(builtin: builtin2) else { panic("invalid template parameters for ptrCast: source is not a builtin type") }

					let is_const_target = match builtin1 {
						Pointer(is_const) => is_const
						OpaquePointer(is_const) => is_const
						else => { panic("invalid template parameters for ptrCast: source is not a builtin-ptr type") }
					}
					let is_const_source = match builtin2 {
						Pointer(is_const) => is_const
						OpaquePointer(is_const) => is_const
						else => { panic("invalid template parameters for ptrCast: source is not a builtin-ptr type") }
					}

					if is_const_source and not is_const_target {
						.module.error("annot cast const-pointer to var-pointer", error_span)
					}

					let instance = .module.createBuiltinFunction2(
						parent_type: None,
						"ptrCast", [source!], target!,
						InlineBuiltinFunction::PointerCast,
						template_parameters
					)

					yield instance
				}
				SizeOf => {
					guard template_parameters.size() == 1 else { panic("invalid template parameters for sizeOf") }
					guard template_parameters[0] is Type(value) else { panic("invalid template parameters for sizeOf") }

					let instance = .module.createBuiltinFunction2(
						parent_type: None,
						"sizeOf", [], .program.uint_type,
						InlineBuiltinFunction::SizeOf(value!),
						template_parameters
					)

					yield instance
				}
				AlignmentOf => {
					guard template_parameters.size() == 1 else { panic("invalid template parameters for alignmentOf") }
					guard template_parameters[0] is Type(value) else { panic("invalid template parameters for alignmentOf") }

					let instance = .module.createBuiltinFunction2(
						parent_type: None,
						"alignmentOf", [], .program.uint_type,
						InlineBuiltinFunction::AlignmentOf(value!),
						template_parameters
					)

					yield instance
				}
				IsVarRef => {
					guard template_parameters.size() == 1 else { panic("invalid template parameters for isVarRef") }
					guard template_parameters[0] is Type(value) else { panic("invalid template parameters for isVarRef") }

					let instance = .module.createBuiltinFunction2(
						parent_type: None,
						"isVarRef", [], .program.bool_type,
						InlineBuiltinFunction::IsVarRef(value!),
						template_parameters
					)

					yield instance
				}
				IsConstRef => {
					guard template_parameters.size() == 1 else { panic("invalid template parameters for isConstRef") }
					guard template_parameters[0] is Type(value) else { panic("invalid template parameters for isConstRef") }

					let instance = .module.createBuiltinFunction2(
						parent_type: None,
						"isConstRef", [], .program.bool_type,
						InlineBuiltinFunction::IsConstRef(value!),
						template_parameters
					)

					yield instance
				}
				Memset => {
					guard template_parameters.size() == 1 else { panic("invalid template parameters for memset") }
					guard template_parameters[0] is Type(value) else { panic("invalid template parameters for memset") }

					let ptr_type = .getType(namespaces: [], name: "vptr", template_parameters, template_parameters_to_search: [], error_span: Span::empty())
					guard ptr_type.has_value() else {
						panic("invalid template instantiation: memset: no ptr type found")
					}

					let instance = .module.createBuiltinFunction2(
						parent_type: None,
						"memset", [ptr_type!, .program.byte_type, .program.uint_type], .program.void_type,
						InlineBuiltinFunction::Memset(value!),
						template_parameters
					)

					yield instance
				}
				Memcpy => {
					guard template_parameters.size() == 1 else { panic("invalid template parameters for memcpy") }
					guard template_parameters[0] is Type(value) else { panic("invalid template parameters for memcpy") }

					let cptr_type = .getType(namespaces: [], name: "cptr", template_parameters, template_parameters_to_search: [], error_span: Span::empty())
					let vptr_type = .getType(namespaces: [], name: "vptr", template_parameters, template_parameters_to_search: [], error_span: Span::empty())
					guard cptr_type.has_value() and vptr_type.has_value() else {
						panic("invalid template instantiation: memcpy: no ptr type found")
					}

					let instance = .module.createBuiltinFunction2(
						parent_type: None,
						"memcpy", [vptr_type!, cptr_type!, .program.uint_type], .program.void_type,
						InlineBuiltinFunction::Memcpy(value!),
						template_parameters
					)

					yield instance
				}
				Memmove => {
					guard template_parameters.size() == 1 else { panic("invalid template parameters for memmove") }
					guard template_parameters[0] is Type(value) else { panic("invalid template parameters for memmove") }

					let cptr_type = .getType(namespaces: [], name: "cptr", template_parameters, template_parameters_to_search: [], error_span: Span::empty())
					let vptr_type = .getType(namespaces: [], name: "vptr", template_parameters, template_parameters_to_search: [], error_span: Span::empty())
					guard cptr_type.has_value() and vptr_type.has_value() else {
						panic("invalid template instantiation: memmove: no ptr type found")
					}

					let instance = .module.createBuiltinFunction2(
						parent_type: None,
						"memmove", [vptr_type!, cptr_type!, .program.uint_type], .program.void_type,
						InlineBuiltinFunction::Memmove(value!),
						template_parameters
					)

					yield instance
				}
				else => {
					panic("builtin function is not a template")
				}
			}
			Unchecked(parsed_function) => {
				let instance = .module.createFunction(name: func.name, template_parameters, parent_type: func.parent_type)
				let type = .checkFunctionType(func: Function(id: instance.id), parsed_function)
				mut decl = .program.functions[instance.id]

				.module.setFunctionType(func: Function(id: instance.id), type)
				decl.span = parsed_function.span
				decl.kind = FunctionDeclKind::Unchecked(parsed_function)
				.module.unchecked_functions.push(instance.id)

				.checkForDuplicateFunction(func: decl)

				yield instance
			}
			else => {
				panic("invalid template function")
			}
		}
	}

	fn doFunctionParametersMatch(this, func: Function, param_types: [Type], firstArgRefType: Type?, allow_unwrapping: bool) throws -> (bool, i64) {
		let func_type = .program.functions[func.id].type

		if param_types.size() != func_type.param_types.size() {
			return (false, 0)
		}

		mut matching_parameters = 0
		for index in 0..param_types.size() {
			mut givenType = param_types[index]
			let requiredType = func_type.param_types[index]
			mut must_be_unwrapped = false

			if index == 0 and firstArgRefType.has_value() {
				givenType = firstArgRefType!
			}

			if givenType.id != requiredType.id and allow_unwrapping and .program.types[givenType.id].unwrapped.has_value() {
				givenType = givenType.withId(other: .program.types[givenType.id].unwrapped!)
				must_be_unwrapped = true
			}

			if givenType.id != requiredType.id {
				return (false, matching_parameters)
			}

			if givenType is ConstRef and requiredType is VarRef {
				return (false, matching_parameters)
			} else if givenType is Base and  not requiredType is Base {
				return (false, matching_parameters)
			}

			if not must_be_unwrapped {
				matching_parameters++
			}
		}

		return (true, matching_parameters)
	}

	fn checkTypeDecl(mut this, parsed_type: ParsedTypeDecl) throws {
		if parsed_type is Extension {
			return
		}

		let template_parameters = .checkTemplateParameterDecl(parsed_type.template_parameters)
		let type = .module.createType(name: parsed_type.name, template_parameters)
		.program.types[type.id].kind = TypeDeclKind::Unchecked(parsed_type)
		.module.unchecked_types.push(type.id)
	}

	fn checkTypeExtension(mut this, parsed_type: ParsedTypeDecl) throws {
		let template_parameters = .checkTemplateParameterDecl(parsed_type.template_parameters)
		guard parsed_type is Extension else {
			return
		}

		let type = .module.getTypeDecl(name: parsed_type.name, template_parameters)
		guard type.has_value() else {
			.module.error("type must be declared before beeing extended", parsed_type.span)
			return
		}
		.program.types[type!.id].additional_member_functions.push_values(&parsed_type.member_functions)
		if not .module.unchecked_types.contains(type!.id) {
			.module.unchecked_types.push(type!.id)
		}
	}

	fn checkFunctionDecl(mut this, parsed_function: ParsedFunctionDecl, parent_type: Type?) throws {
		let template_parameters = .checkTemplateParameterDecl(parsed_function.template_parameters)
		let func = .module.createFunction(name: parsed_function.name, template_parameters, parent_type)
		mut decl = .program.functions[func.id]
		let type = .checkFunctionType(func, parsed_function)
		.module.setFunctionType(func, type)

		decl.span = parsed_function.span
		decl.kind = FunctionDeclKind::Unchecked(parsed_function)
		.module.unchecked_functions.push(func.id)

		.checkForDuplicateFunction(func: decl)

		if parsed_function.body is ExternFunctionBody {
			.program.functions[func.id].extern_name = .program.functions[func.id].name
		}

		for annotation in parsed_function.annotations {
			if annotation.name == "extern_name" and annotation is String(value) {
				.program.functions[func.id].extern_name = value
			} else {
				.module.error("unsupported annotation", annotation.span)
			}
		}

		if parsed_function.name == "constructor" or parsed_function.name == "destructor" {
			guard parent_type.has_value() else {
				.module.error("constructor / destructor must be declared as member function", parsed_function.span)
				return
			}

			guard type.return_type is Base and type.return_type.id == .program.void_type.id else {
				.module.error("constructor / destructor must return void", parsed_function.span)
				return
			}
		} else if parsed_function.name == "main" {
			guard not .program.main.has_value() else {
				.module.error("redefinition of main", parsed_function.span)
				return
			}

			guard type.return_type.equals(other: .program.int_type) or type.return_type.equals(other: .program.void_type) else {
				.module.error("return type of main must be int or void", parsed_function.span)
				return
			}

			.program.main = func
		} else if parsed_function.name == "operator unwrap" {
			guard type.param_types.size() == 1 else {
				.module.error("invalid parameters for unwrap operator", parsed_function.span)
				return
			}

			guard type.param_types[0].hasSameKind(other: type.return_type) else {
				.module.error("return type and this param type must have same reference strength", parsed_function.span)
				return
			}

			let src_type = type.param_types[0].base()
			let dst_type = type.return_type.base()

			if .program.types[src_type.id].unwrapped.has_value() and not .program.types[src_type.id].unwrapped!.equals(other: dst_type) {
				.module.error("unwrap operator redeclared with different type", parsed_function.span)
			}

			.program.types[src_type.id].unwrapped = dst_type
		}
	}

	fn checkForDuplicateFunction(mut this, func: FunctionDecl) throws {
		for id in func.getSiblingIds() {
			let other = .program.functions[id]

			if other.name != func.name or func.template_parameters.size() != other.template_parameters.size() {
				continue
			}

			if not func.template_parameters.is_empty() {
				mut equal_template_parameters = true
				for i in 0..func.template_parameters.size() {
					if not func.template_parameters[i].equals(other: other.template_parameters[i]) {
						equal_template_parameters = false
						break
					}
				}

				if equal_template_parameters {
					.module.error("function redeclared with equal template parameters", func.span)
					.module.error("previously declared here", other.span)
					return
				}
			}

			if func.isIncompleteTemplate() or other.isIncompleteTemplate() {
				continue
			}

			if func.type.param_types.size() != other.type.param_types.size() {
				continue
			}

			mut equal_param_types = true
			for i in 0..func.type.param_types.size() {
				if not func.type.param_types[i].equals(other: other.type.param_types[i]) {
					equal_param_types = false
					break
				}
			}

			if equal_param_types {
				if (func.name == "operator is" or func.name == "operator as") {
					if func.type.return_type.equals(other: other.type.return_type) {
						.module.error(func.name + " redeclared with equal return type", func.span)
						.module.error("previously declared here", other.span)
						return
					}
				} else {
					.module.error("function redeclared with equal parameter types", func.span)
					.module.error("previously declared here", other.span)
					return
				}
			}
		}
	}

	fn checkTemplateParameterDecl(mut this, anon parsed_template_parameters: [ParsedTemplateParameterDecl]) throws -> [TemplateParameter] {
		mut template_parameters: [TemplateParameter] = []
		for param in parsed_template_parameters {
			guard param.type is Name(name) else {
				.module.error("invalid type for template parameters", param.type.span())
				break
			}

			match name {
				"type" => {
					template_parameters.push(
						TemplateParameter::Type(
							span: param.span,
							name: param.name,
							value: match param.value.has_value() {
								true => {
									guard param.value! is Type(type) else {
										.module.error("expected type", param.value!.span)
										return []
									}
									yield .checkTypeUsage(type, template_parameters_to_search: [])
								}
								else => None
							}
						)
					)
				}
				"int" | "uint" => {
					template_parameters.push(
						TemplateParameter::IntLiteral(
							span: param.span,
							name: param.name,
							value: match param.value.has_value() {
								true => {
									guard param.value! is IntLiteral(value) else {
										.module.error("expected int literal", param.value!.span)
										return []
									}
									yield value
								}
								else => None
							}
						)
					)
				}
				else => {
					.module.error("invalid type for template parameters", param.type.span())
				}
			}
		}
		return template_parameters
	}

	fn checkFunctionType(mut this, func: Function, parsed_function: ParsedFunctionDecl) throws -> FunctionType {
		if .program.functions[func.id].isIncompleteTemplate() {
			return FunctionType(
				param_types: [],
				return_type: .program.void_type,
			)
		}

		let decl = .program.functions[func.id]

		mut template_parameters_to_search: [TemplateParameter] = []
		if decl.parent_type.has_value() {
			let parent_type = .program.types[decl.parent_type!.id]
			for param in parent_type.template_parameters {
				template_parameters_to_search.push(param)
			}
		}
		for param in decl.template_parameters {
			template_parameters_to_search.push(param)
		}

		mut param_types: [Type] = []
		for param in parsed_function.parameters {
			param_types.push(.checkTypeUsage(type: param.type, template_parameters_to_search))
		}

		let return_type = match parsed_function.return_type.has_value() {
			true => .checkTypeUsage(type: parsed_function.return_type!, template_parameters_to_search)
			else => .program.void_type
		}

		return FunctionType(
			param_types,
			return_type,
		)
	}

	fn checkTypeBody(mut this, type: Type, parsed_type: ParsedTypeDecl) throws {
		mut decl = .program.types[type.id]

		if decl.isIncompleteTemplate() {
			return
		}

		match parsed_type {
			Struct => {
				decl.kind = TypeDeclKind::Struct

				for var in parsed_type.member_variables {
					let id = decl.member_variables.size() as! u64
					decl.member_variables.push(.checkMemberVarDecl(parent_type: type, var, id))
				}

				for parsed_function in parsed_type.member_functions {
					.checkFunctionDecl(parsed_function, parent_type: type)
				}
			}
			Enum(id_type, cases) => {
				let checked_id_type = match id_type.has_value() {
					true => .checkTypeUsage(type: id_type!, template_parameters_to_search: decl.template_parameters)
					else => .program.int_type
				}
				decl.contained_types.add(checked_id_type.id)
				if not .program.isIntType(type: checked_id_type) {
					.module.error("id type must be integer type", parsed_type.span)
				}

				mut checked_cases: [EnumCaseDecl] = []

				mut id = 0i64
				for parsed_case in cases {
					let checked_case = .checkEnumCaseDecl(parent_type: type, parsed_case, id)
					id = checked_case.id + 1
					checked_cases.push(checked_case)
				}
				decl.kind = TypeDeclKind::Enum(id_type: checked_id_type, cases: checked_cases)

				for parsed_function in parsed_type.member_functions {
					.checkFunctionDecl(parsed_function, parent_type: type)
				}

				.createCommonEnumMemberFunctions(type)
			}
			Variant(id_type, cases) => {
				let checked_id_type = match id_type.has_value() {
					true => .checkTypeUsage(type: id_type!, template_parameters_to_search: decl.template_parameters)
					else => .program.int_type
				}
				decl.contained_types.add(checked_id_type.id)
				if not .program.isIntType(type: checked_id_type) {
					.module.error("id type must be integer type", parsed_type.span)
				}

				mut checked_cases: [VariantCaseDecl] = []

				mut id = 0i64
				for parsed_case in cases {
					let checked_case = .checkVariantCaseDecl(parent_type: type, parsed_case, id)
					id = checked_case.id + 1
					checked_cases.push(checked_case)
				}

				decl.kind = TypeDeclKind::Variant(id_type: checked_id_type, cases: checked_cases)

				for var in parsed_type.member_variables {
					let id = decl.member_variables.size() as! u64
					decl.member_variables.push(.checkMemberVarDecl(parent_type: type, var, id))
				}

				for parsed_function in parsed_type.member_functions {
					.checkFunctionDecl(parsed_function, parent_type: type)
				}

				.createCommonVariantMemberFunctions(type, decl, checked_cases)
			}
			Extension => {}
		}

		for annotation in parsed_type.annotations {
			if annotation.name == "packed" and annotation is Flag {
				decl.is_packed = true
			}
		}

		if .finalize {
			.finalizeTypeDecl(type: decl)
		}
	}

	fn checkTypeExtension(mut this, type: Type) throws {
		mut decl = .program.types[type.id]
		if decl.isIncompleteTemplate() {
			return
		}

		for parsed_function in decl.additional_member_functions {
			.checkFunctionDecl(parsed_function, parent_type: type)
		}
		decl.additional_member_functions = []
	}

	fn checkMemberVarDecl(mut this, parent_type: Type, var: ParsedVarDecl, id: u64) throws -> MemberVar {
		guard var.type.has_value() else {
			.module.error("member variables must always be declared with a type", var.span)
			return MemberVar(
				span: var.span, id,
				name: var.name, type: .program.void_type,
				initializer: []
			)
		}

		let type = .checkTypeUsage(type: var.type!, template_parameters_to_search: .program.types[parent_type.id].template_parameters)

		mut decl = .program.types[parent_type.id]
		if type is Base {
			if .program.typeContainsOther(type, other: parent_type) {
				.module.error("dependency cycle in type declaration, use a reference or heap-allocated type instead", var.span)
			}

			decl.contained_types.add(type.id)
		}

		return MemberVar(
			span: var.span, id,
			name: var.name, type,
			initializer: []
		)
	}

	fn checkEnumCaseDecl(mut this, parent_type: Type, parsed_case: ParsedEnumCaseDecl, id: i64) throws -> EnumCaseDecl {
		return EnumCaseDecl(
			span: parsed_case.span,
			id: match parsed_case.id.has_value() {
				true => parsed_case.id!
				else => id
			},
			name: parsed_case.name,
		)
	}

	fn checkVariantCaseDecl(mut this, parent_type: Type, parsed_case: ParsedVariantCaseDecl, id: i64) throws -> VariantCaseDecl {
		let type = match parsed_case.type.has_value() {
			true => .checkTypeUsage(type: parsed_case.type!, template_parameters_to_search: .program.types[parent_type.id].template_parameters)
			else => .program.void_type
		}

		mut decl = .program.types[parent_type.id]
		if type is Base {
			if .program.typeContainsOther(type, other: parent_type) {
				.module.error("dependency cycle in type declaration, use a reference or heap-allocated type instead", parsed_case.span)
			}

			decl.contained_types.add(type.id)
		}

		return VariantCaseDecl(
			span: parsed_case.span,
			id: match parsed_case.id.has_value() {
				true => parsed_case.id!
				else => id
			}
			name: parsed_case.name,
			type
		)
	}

	fn finalizeTypeDecl(mut this, mut type: TypeDecl) throws {
		if type.is_finalized {
			return
		}

		match type.kind {
			Variant(cases) => {
				for v in type.member_variables {
					if v.type is Base {
						v.type_copy_constructor = .getFunction(
							namespaces: [], name: "constructor",
							parent_type: v.type,
							template_parameters: [],
							param_types: [v.type.varRef(), v.type],
							firstArgRefType: v.type.varRef(),
							span: v.span,
							allow_spaceship_operator: false
						)

						let func_type = .program.functions[v.type_copy_constructor!.id].type
						if v.type.id != func_type.param_types[1].id {
							v.type_op_unwrap = .getFunction(
								namespaces: [],
								name: "operator unwrap",
								parent_type: v.type,
								template_parameters: [],
								param_types: [v.type],
								firstArgRefType: None,
								span: Span::empty(),
							)
						}

						v.type_destructor = .getFunction(
							namespaces: [], name: "destructor",
							parent_type: v.type,
							template_parameters: [],
							param_types: [v.type.varRef()],
							firstArgRefType: v.type.varRef(),
							span: v.span,
							allow_spaceship_operator: false
						)
					}
				}

				for c in cases {
					.finalizeVariantCaseDecl(variant: type, decl: c)
				}
			}
			else => {}
		}

		type.is_finalized = true
	}

	fn finalizeVariantCaseDecl(mut this, variant: TypeDecl, mut decl: VariantCaseDecl) throws {
		guard decl.type is Base and not decl.type.equals(other: .program.void_type) else {
			return
		}

		let type = decl.type
		decl.type_copy_constructor = .getFunction(namespaces: [], name: "constructor", parent_type: type, template_parameters: [], param_types: [type.varRef(), type], firstArgRefType: type.varRef(), span: decl.span)

		let func_type = .program.functions[decl.type_copy_constructor!.id].type
		if type.id != func_type.param_types[1].id {
			decl.type_op_unwrap = .getFunction(
				namespaces: [],
				name: "operator unwrap",
				parent_type: type,
				template_parameters: [],
				param_types: [type],
				firstArgRefType: None,
				span: Span::empty(),
			)
		}

		decl.type_destructor = .getFunction(namespaces: [], name: "destructor", parent_type: type, template_parameters: [], param_types: [type.varRef()], firstArgRefType: type.varRef(), span: decl.span)

		guard decl.type_copy_constructor.has_value() and decl.type_destructor.has_value() else {
			.module.error("type attached to variant case must implement copy constructor and destructor", decl.span)
			return
		}

		if not decl.type.equals(other: .program.void_type) {
			.createVariantOpSafeAs(type: Type::Base(id: variant.id), c: decl)
			.createVariantOpSafeAs(type: Type::VarRef(id: variant.id), c: decl)
		}
	}

	fn createCommonEnumMemberFunctions(mut this, type: Type) throws {
		.module.createBuiltinFunction(
			parent_type: type, name: "constructor",
			param_types: [type.varRef(), type],
			return_type: .program.void_type,
			body: InlineBuiltinFunction::PrimitiveCopyConstructor(type)
		)

		.module.createBuiltinFunction(
			parent_type: type, name: "destructor",
			param_types: [type.varRef()],
			return_type: .program.void_type,
			body: InlineBuiltinFunction::PrimitiveDestructor
		)

		.module.createBuiltinFunction(
			parent_type: type, name: "operator =",
			param_types: [type.varRef(), type],
			return_type: .program.void_type,
			body: InlineBuiltinFunction::PrimitiveOpAssign(type)
		)

		.module.createBuiltinFunction(
			parent_type: type, name: "operator ==",
			param_types: [type, type],
			return_type: .program.bool_type,
			body: InlineBuiltinFunction::UIntOpEQ(type)
		)

		.module.createBuiltinFunction(
			parent_type: type, name: "operator !=",
			param_types: [type, type],
			return_type: .program.bool_type,
			body: InlineBuiltinFunction::UIntOpNE(type)
		)
	}

	fn createCommonVariantMemberFunctions(mut this, type: Type, decl: TypeDecl, checked_cases: [VariantCaseDecl]) throws {
		for c in checked_cases {
			mut constructor_param_types = [type.varRef()]

			if not c.type.equals(other: .program.void_type) {
				constructor_param_types.push(c.type)
			}

			for v in decl.member_variables {
				constructor_param_types.push(v.type)
			}

			.module.createBuiltinFunction(
				parent_type: type, name: "constructor",
				param_types: constructor_param_types,
				return_type: .program.void_type,
				body: BuiltinFunction::VariantCaseConstructor(type, id: c.id),
				template_parameters: [TemplateParameter::IntLiteral(span: Span::empty(), name: "id", value: c.id)]
			)

			.module.createBuiltinFunction(
				parent_type: type, name: "operator is",
				param_types: [type],
				return_type: .program.bool_type,
				body: InlineBuiltinFunction::VariantOpIs(type, id: c.id),
				template_parameters: [TemplateParameter::IntLiteral(span: Span::empty(), name: "id", value: c.id)]
			)

			if not c.type.equals(other: .program.void_type) {
				.module.createBuiltinFunction(
					parent_type: type, name: "operator unsafe as",
					param_types: [type.varRef()],
					return_type: c.type.varRef(),
					body: InlineBuiltinFunction::VariantOpUnsafeAs(type, id: c.id),
					template_parameters: [TemplateParameter::IntLiteral(span: Span::empty(), name: "id", value: c.id)]
				)
			}
		}

		.module.createBuiltinFunction(
			parent_type: type, name: "constructor",
			param_types: [type.varRef(), type],
			return_type: .program.void_type,
			body: BuiltinFunction::VariantCopyConstructor(type)
		)

		.module.createBuiltinFunction(
			parent_type: type, name: "destructor",
			param_types: [type.varRef()],
			return_type: .program.void_type,
			body: BuiltinFunction::VariantDestructor(type)
		)

		.module.createBuiltinFunction(
			parent_type: type, name: "operator =",
			param_types: [type.varRef(), type],
			return_type: .program.void_type,
			body: BuiltinFunction::VariantOpAssign(type)
		)
	}

	fn createStructDefaultConstructorImpl(mut this, type: Type, func: Function, error_span: Span) throws {
		for v in .program.types[type.id].member_variables {
			if not v.type is Base {
				continue
			}

			v.type_default_constructor = .getFunction(
				namespaces: [],
				name: "constructor",
				parent_type: v.type,
				template_parameters: [],
				param_types: [v.type.varRef()],
				firstArgRefType: v.type.varRef(),
				span: error_span
			)
		}

		.program.functions[func.id].kind = FunctionDeclKind::Builtin(
			BuiltinFunction::StructDefaultConstructor(type)
		)
	}

	fn createStructCopyConstructorImpl(mut this, type: Type, func: Function, error_span: Span) throws {
		for v in .program.types[type.id].member_variables {
			if not v.type is Base {
				continue
			}

			v.type_copy_constructor = .getFunction(
				namespaces: [],
				name: "constructor",
				parent_type: v.type,
				template_parameters: [],
				param_types: [v.type.varRef(), v.type],
				firstArgRefType: v.type.varRef(),
				span: error_span
			)

			let func_type = .program.functions[v.type_copy_constructor!.id].type
			if v.type.id != func_type.param_types[1].id {
				v.type_op_unwrap = .getFunction(
					namespaces: [],
					name: "operator unwrap",
					parent_type: v.type,
					template_parameters: [],
					param_types: [v.type],
					firstArgRefType: None,
					span: Span::empty(),
				)
			}
		}

		.program.functions[func.id].kind = FunctionDeclKind::Builtin(
			BuiltinFunction::StructCopyConstructor(type)
		)
	}

	fn createStructDefaultDestructorImpl(mut this, type: Type, func: Function, error_span: Span) throws {
		for v in .program.types[type.id].member_variables {
			if not v.type is Base {
				continue
			}

			v.type_destructor = .getFunction(
				namespaces: [],
				name: "destructor",
				parent_type: v.type,
				template_parameters: [],
				param_types: [v.type.varRef()],
				firstArgRefType: v.type.varRef(),
				span: error_span
			)
		}

		.program.functions[func.id].kind = FunctionDeclKind::Builtin(
			BuiltinFunction::StructDestructor(type)
		)
	}

	fn createStructOpAssignImpl(mut this, type: Type, func: Function, error_span: Span) throws {
		for v in .program.types[type.id].member_variables {
			if not v.type is Base {
				continue
			}

			v.type_op_assign = .getFunction(
				namespaces: [],
				name: "operator =",
				parent_type: v.type,
				template_parameters: [],
				param_types: [v.type.varRef(), v.type],
				firstArgRefType: v.type.varRef(),
				span: error_span
			)

			let func_type = .program.functions[v.type_op_assign!.id].type
			if v.type.id != func_type.param_types[1].id and not v.type_op_unwrap.has_value() {
				v.type_op_unwrap = .getFunction(
					namespaces: [],
					name: "operator unwrap",
					parent_type: v.type,
					template_parameters: [],
					param_types: [v.type],
					firstArgRefType: None,
					span: Span::empty(),
				)
			}
		}

		.program.functions[func.id].kind = FunctionDeclKind::Builtin(
			BuiltinFunction::StructOpAssign(type)
		)
	}

	fn createStructOpEqImpl(mut this, type: Type, func: Function, error_span: Span) throws {
		for v in .program.types[type.id].member_variables {
			if not v.type is Base {
				continue
			}

			v.type_op_equal = .getFunction(
				namespaces: [],
				name: "operator ==",
				parent_type: v.type,
				template_parameters: [],
				param_types: [v.type, v.type],
				firstArgRefType: None,
				span: error_span
			)
		}

		.program.functions[func.id].kind = FunctionDeclKind::Builtin(
			BuiltinFunction::StructOpEqual(type)
		)
	}

	fn createEnumOpOrImpl(mut this, type: Type, func: Function) throws {
		.program.functions[func.id].kind = FunctionDeclKind::InlineBuiltin(
			InlineBuiltinFunction::BitOpOr(type)
		)
	}

	fn createEnumOpAndImpl(mut this, type: Type, func: Function) throws {
		.program.functions[func.id].kind = FunctionDeclKind::InlineBuiltin(
			InlineBuiltinFunction::BitOpOr(type)
		)
	}

	fn createEnumOpOrAssignImpl(mut this, type: Type, func: Function) throws {
		.program.functions[func.id].kind = FunctionDeclKind::InlineBuiltin(
			InlineBuiltinFunction::BitOpOrAssign(type)
		)
	}

	fn createEnumOpAndAssignImpl(mut this, type: Type, func: Function) throws {
		.program.functions[func.id].kind = FunctionDeclKind::InlineBuiltin(
			InlineBuiltinFunction::BitOpAndAssign(type)
		)
	}

	fn createEnumOpCmpImpl(mut this, type: Type, func: Function) throws {
		.program.functions[func.id].kind = FunctionDeclKind::InlineBuiltin(
			InlineBuiltinFunction::UIntOpCmp(type)
		)
	}

	fn createVariantOpEqImpl(mut this, type: Type, func: Function, error_span: Span) throws {
		mut decl = .program.types[type.id]
		guard decl.kind is Variant(cases) else {
			panic("can't create variant operator == for non variant type")
		}

		for c in cases {
			if c.type.equals(other: .program.void_type) {
				continue
			}

			if not c.type is Base {
				continue
			}

			c.type_op_equal = .getFunction(
				namespaces: [],
				name: "operator ==",
				parent_type: c.type,
				template_parameters: [],
				param_types: [c.type, c.type],
				firstArgRefType: None,
				span: error_span
			)
		}

		for v in decl.member_variables {
			if not v.type is Base {
				continue
			}

			v.type_op_equal = .getFunction(
				namespaces: [],
				name: "operator ==",
				parent_type: v.type,
				template_parameters: [],
				param_types: [v.type, v.type],
				firstArgRefType: None,
				span: error_span
			)
		}

		.program.functions[func.id].kind = FunctionDeclKind::Builtin(
			BuiltinFunction::VariantOpEqual(type)
		)
	}

	fn createVariantOpSafeAs(mut this, type: Type, c: VariantCaseDecl) throws {
		let case_type = match c.type {
			Base => match type {
				Base => c.type
				ConstRef => c.type.constRef()
				VarRef => c.type.varRef()
			}
			else => c.type
		}

		let optional_type: Type = .getType(
			namespaces: ["std", "core"],
			name: "Optional",
			template_parameters: [
				TemplateParameter::Type(span: Span::empty(), name: "T", value: case_type)
			],
			template_parameters_to_search: [],
			error_span: c.span
		)!

		let none_case = .program.getVariantCase(type: optional_type, name: "None")!
		let some_case = .program.getVariantCase(type: optional_type, name: "Some")!

		let some_constructor: Function = .getFunction(
			namespaces: [],
			name: "constructor",
			parent_type: optional_type,
			template_parameters: [
				TemplateParameter::IntLiteral(span: Span::empty(), name: "id", value: some_case.id)
			],
			param_types: [optional_type.varRef(), case_type],
			firstArgRefType: optional_type.varRef(),
			span: c.span,
			allow_spaceship_operator: false
		)!

		let none_constructor: Function = .getFunction(
			namespaces: [],
			name: "constructor",
			parent_type: optional_type,
			template_parameters: [
				TemplateParameter::IntLiteral(span: Span::empty(), name: "id", value: none_case.id)
			],
			param_types: [optional_type.varRef()],
			firstArgRefType: optional_type.varRef(),
			span: c.span,
			allow_spaceship_operator: false
		)!

		.module.createBuiltinFunction(
			parent_type: type,
			name: "operator as",
			param_types: [type],
			return_type: optional_type,
			body: BuiltinFunction::VariantOpSafeAs(
				type, id: c.id,
				optional_type,
				some_constructor,
				none_constructor,
			)
			template_parameters: [TemplateParameter::IntLiteral(span: Span::empty(), name: "id", value: c.id)]
		)
	}

	fn checkFunctionImpl(mut this, func: Function, parsed_function: ParsedFunctionDecl) throws {
		if .program.functions[func.id].isIncompleteTemplate() {
			return
		}

		match parsed_function.body {
			Compound => .checkFunctionBody(func, parsed_function)
			Expr => {
				panic("not implemented")
			}
			DefaultFunctionBody => .createDefaultFunctionImpl(func)
			ExternFunctionBody => {
				.program.functions[func.id].kind = FunctionDeclKind::Extern
			}
			else => {
				panic("invalid function body")
			}
		}
	}

	fn checkFunctionBody(mut this, func: Function, parsed_function: ParsedFunctionDecl) throws {
		let decl = .program.functions[func.id]
		let func_type = decl.type

		let body = parsed_function.body
		guard body is Compound else {
			panic("invalid function body")
		}

		mut impl = FunctionDeclBody(
			span: body.span,
			variables: [],
			body: CompoundStmt(
				span: body.span,
				children: [],
				cleanup_list: []
			)
		)

		mut template_parameters_to_search: [TemplateParameter] = []
		if decl.parent_type.has_value() {
			let parent_type = .program.types[decl.parent_type!.id]
			for param in parent_type.template_parameters {
				template_parameters_to_search.push(param)
			}
		}
		for param in decl.template_parameters {
			template_parameters_to_search.push(param)
		}

		mut context = FunctionContext(
			decl, body: impl,
			return_type: func_type.return_type,
			scopes: [],
			template_parameters_to_search,
			this_parameter_type: None,
			is_constructor: decl.name == "constructor",
			is_destructor: decl.name == "destructor",
			initialized_members: {},
			deinitialized_members: {}
		)
		context.pushScope(type: ScopeType::Function)
		defer context.popScope()

		for index in 0..func_type.param_types.size() {
			let parsed_param = parsed_function.parameters[index]
			let var = impl.createParameter(
				span: parsed_param.span,
				name: parsed_param.name,
				type: .checkTypeUsage(type: parsed_param.type, template_parameters_to_search)
				init: match parsed_param.init.has_value() {
					true => .checkExpr(expr: parsed_param.init!, context)
					else => None
				}
			)

			context.addVariable(var)
		}

		if decl.parent_type.has_value() {
			let parent_type = decl.parent_type!

			if func_type.param_types.size() > 0 and func_type.param_types[0].id == parent_type.id {
				context.this_parameter_type = func_type.param_types[0]
			}

			if decl.name == "constructor" {
				guard context.this_parameter_type.has_value() else {
					.module.error("constructor requires this parameter", parsed_function.span)
					return
				}

				guard context.this_parameter_type!.equals(other: parent_type.varRef()) else {
					.module.error(format("this parameter should be of type {}", .program.formatTypeSignature(type: decl.parent_type!.varRef())), parsed_function.parameters[0].span)
					return
				}
			} else if decl.name == "destructor" {
				guard context.this_parameter_type.has_value() else {
					.module.error("destructor requires this parameter", parsed_function.span)
					return
				}

				guard context.this_parameter_type!.id == parent_type.id and not context.this_parameter_type! is Base else {
					.module.error(format("this parameter should be of type {}", .program.formatTypeSignature(type: decl.parent_type!.constRef())), parsed_function.parameters[0].span)
					return
				}
			}
		}

		impl.body = .checkCompoundStmt(stmt: body, context)

		if context.is_constructor or context.is_destructor {
			let parent_type = .program.types[decl.parent_type!.id]
			let member_variables = parent_type.member_variables

			let thisParam = Variable(id: impl.variables[0].id)
			let object = Expr::VarInvoke(span: Span::empty(), type: context.this_parameter_type!, var: thisParam)

			if context.is_constructor {
				for i in 0..member_variables.size() {
					let var = member_variables[i]
					if context.initialized_members.contains(var.id) {
						continue
					}

					guard var.type is Base else {
						.module.error("uninitialized member reference variable", parsed_function.span)
						.module.error("  - member variable declared ", var.span)
						continue
					}

					let memberVarExpr = Expr::MemberAccess(
						span: Span::empty(),
						type: var.type.varRef(),
						object,
						var: Variable(id: var.id)
					)

					let memberConstructor = .getFunction(
						namespaces: [],
						name: "constructor",
						parent_type: var.type,
						template_parameters: [],
						param_types: [memberVarExpr.type],
						firstArgRefType: None,
						span: Span::empty()
					)

					guard memberConstructor.has_value() else {
						continue
					}

					let constructor_call = .createCall(span: Span::empty(), func: memberConstructor!, args: [memberVarExpr], caller: context.body, is_member_call: true)
					impl.body.children.push(Stmt::Expr(span: Span::empty(), constructor_call))
				}
			} else {
				for i in member_variables.size()..0 {
					let var = member_variables[i - 1]
					if context.deinitialized_members.contains(var.id) {
						continue
					}

					if not var.type is Base {
						continue
					}

					let memberVarExpr = Expr::MemberAccess(
						span: Span::empty(),
						type: match context.this_parameter_type! {
							VarRef => var.type.varRef()
							ConstRef => var.type.constRef()
							else => { panic("invalid destructor this param type") }
						},
						object,
						var: Variable(id: var.id)
					)

					let memberDestructor = .getFunction(
						namespaces: [],
						name: "destructor",
						parent_type: var.type,
						template_parameters: [],
						param_types: [memberVarExpr.type],
						firstArgRefType: None,
						span: Span::empty()
					)

					guard memberDestructor.has_value() else {
						continue
					}

					let destructor_call = .createCall(span: Span::empty(), func: memberDestructor!, args: [memberVarExpr], caller: context.body, is_member_call: true)
					impl.body.children.push(Stmt::Expr(span: Span::empty(), destructor_call))
				}
			}
		}

		.program.functions[func.id].kind = FunctionDeclKind::Code(impl)

		let return_type = .program.functions[func.id].type.return_type
		if not impl.body.doesReturn(never_type: .program.never_type) {
			if return_type.id != .program.void_type.id and return_type.id != .program.never_type.id {
				.module.error("non-void function doesn't return a value in all paths", parsed_function.span)
			} else if return_type.id == .program.void_type.id {
				mut body = impl.body
				body.children.push(Stmt::Return(span: Span::empty(), value: None, cleanup_list: []))
			}
		}

		if .module.has_errors {
			return
		}

		.createMemoryManagementCalls(stmt: impl.body, func: impl)
		.regroupDestructorCalls(func: impl, stmt: impl.body, function_cleanup_list: [], loop_cleanup_list: [])
	}

	fn createDefaultFunctionImpl(mut this, func: Function) throws {
		let decl = .program.functions[func.id]
		guard decl.parent_type.has_value() else {
			.module.error("default functions must be declared as member functions", decl.span)
			return
		}

		let parent_type = decl.parent_type!
		match .program.types[parent_type.id].kind {
			Struct => match decl.name {
				"constructor" => {
					if decl.type.param_types.size() == 1 {
						.createStructDefaultConstructorImpl(type: parent_type, func, error_span: decl.span)
					} else if decl.type.param_types.size() == 2 {
						.createStructCopyConstructorImpl(type: parent_type, func, error_span: decl.span)
					} else {
						.module.error("default implementation can't be generated for this function", decl.span)
					}
				}
				"destructor" => .createStructDefaultDestructorImpl(type: parent_type, func, error_span: decl.span)
				"operator =" => .createStructOpAssignImpl(type: parent_type, func, error_span: decl.span)
				"operator ==" => {
					if decl.type.return_type.equals(other: .program.bool_type) {
						.createStructOpEqImpl(type: parent_type, func, error_span: decl.span)
					} else {
						.module.error("the return type of operator == must be bool (" +
							.program.formatTypeSignature(type: .program.bool_type) + ")", decl.span)
					}
					
				}
				else => {
					.module.error("default implementation can't be generated for this function", decl.span)
				}
			}
			Enum => match decl.name {
				"operator |" => .createEnumOpOrImpl(type: parent_type, func)
				"operator &" => .createEnumOpAndImpl(type: parent_type, func)
				"operator |=" => .createEnumOpOrAssignImpl(type: parent_type, func)
				"operator &=" => .createEnumOpAndAssignImpl(type: parent_type, func)
				else => {
					.module.error("default implementation can't be generated for this function", decl.span)
				}
			}
			Variant => match decl.name {
				"operator ==" => .createVariantOpEqImpl(type: parent_type, func, error_span: decl.span)
				else => {
					.module.error("default implementation can't be generated for this function", decl.span)
				}
			}
			else => {
				.module.error("this type canno't contain default functions", decl.span)
			}
		}
	}

	fn checkTypeUsage(mut this, type: ParsedType, template_parameters_to_search: [TemplateParameter]) throws -> Type => match type {
		Name(span, namespaces, name, template_parameters) => {
			let checked_template_parameters = .checkTemplateParameters(template_parameters, template_parameters_to_search)
			yield .getType(namespaces, name, template_parameters: checked_template_parameters, template_parameters_to_search, error_span: span) ?? .program.void_type
		}
		ConstRefType(span, baseType) => {
			let base = .checkTypeUsage(type: baseType, template_parameters_to_search)
			guard base is Base else {
				.module.error("invalid type: double references aren't allowed", span)
				return base
			}
			yield Type::ConstRef(id: base.id)
		}
		VarRefType(span, baseType) => {
			let base = .checkTypeUsage(type: baseType, template_parameters_to_search)
			guard base is Base else {
				.module.error("invalid type: double references aren't allowed", span)
				return base
			}
			yield Type::VarRef(id: base.id)
		}
		OptionalType(span, value_type) => {
			yield .getType(namespaces: [], name: "Optional", template_parameters: [
				TemplateParameter::Type(span, name: "", value: .checkTypeUsage(type: value_type, template_parameters_to_search))
			], template_parameters_to_search, error_span: span) ?? .program.void_type
		}
		ArrayType(span, element_type, size) => {
			guard size is IntLiteral(value: checked_size) else {
				.module.error("array size must be an int literal", span)
				return .program.void_type
			}

			yield .getType(namespaces: [], name: "Array", template_parameters: [
				TemplateParameter::Type(span, name: "", value: .checkTypeUsage(type: element_type, template_parameters_to_search)),
				TemplateParameter::IntLiteral(span, name: "", value: checked_size),
			], template_parameters_to_search, error_span: span) ?? .program.void_type
		}
		ListType(span, element_type) => {
			yield .getType(namespaces: [], name: "List", template_parameters: [
				TemplateParameter::Type(span, name: "", value: .checkTypeUsage(type: element_type, template_parameters_to_search))
			], template_parameters_to_search, error_span: span) ?? .program.void_type
		}
		DictType(span, key_type, value_type) => {
			yield .getType(namespaces: [], name: "Dict", template_parameters: [
				TemplateParameter::Type(span, name: "", value: .checkTypeUsage(type: key_type, template_parameters_to_search))
				TemplateParameter::Type(span, name: "", value: .checkTypeUsage(type: value_type, template_parameters_to_search))
			], template_parameters_to_search, error_span: span) ?? .program.void_type
		}
		else => {
			.module.error("typechecking of type usage not fully implemented", type.span())
			yield Type::Base(id: 0)
		}
	}

	fn checkTemplateParameters(mut this, anon parsed_template_parameters: [ParsedTemplateParameter], template_parameters_to_search: [TemplateParameter]) throws -> [TemplateParameter] {
		mut template_parameters: [TemplateParameter] = []
		for param in parsed_template_parameters {
			match param {
				Type(type) => {
					mut found = false
					if type is Name(namespaces, name) and namespaces.is_empty() {
						for param in template_parameters_to_search {
							if param.name == name {
								found = true
								template_parameters.push(param)
							}
						}
					}

					if not found {
						template_parameters.push(TemplateParameter::Type(span: param.span, name: "", value: .checkTypeUsage(type, template_parameters_to_search)))
					}
				}
				IntLiteral(value) => {
					template_parameters.push(TemplateParameter::IntLiteral(span: param.span, name: "", value))
				}
			}
		}
		return template_parameters
	}

	fn checkCompoundStmt(mut this, stmt: ParsedStmt, mut context: FunctionContext) throws -> CompoundStmt {
		guard stmt is Compound(children) else {
			.module.error("expected compound stmt", stmt.span)
			return CompoundStmt(span: stmt.span, children: [], cleanup_list: [])
		}

		mut result = CompoundStmt(
			span: stmt.span,
			children: [],
			cleanup_list: []
		)
		mut unreachable = false

		context.pushScope(type: ScopeType::Compound)
		defer context.popScope()

		for child in children {
			if unreachable {
				.module.error("unreachable code", child.span)
				break
			}

			mut checked_child = .checkStmt(stmt: child, context)
			if checked_child is Empty {
				continue
			}

			if checked_child is Expr(expr) and expr is Call(func, args) and args.size() >= 1 {
				let function_decl = .program.functions[func.id]

				if args[0] is MemberAccess(object, var: member) and object is VarInvoke(var: objectVar) and objectVar.id == 0 {
					if context.is_constructor and function_decl.name == "constructor" {
						if context.initialized_members.contains(member.id) {
							.module.error("double initialization of member", checked_child.span)
						}

						context.initialized_members.add(member.id)
					} else if context.is_destructor and function_decl.name == "destructor" {
						context.deinitialized_members.add(member.id)
					} else if context.is_constructor and function_decl.name == "operator =" and not context.initialized_members.contains(member.id) {
						context.initialized_members.add(member.id)

						mut init = removeDereference(args[1])

						mut constructorArgs = match init {
							TempVariable(var, constructor_call) => {
								guard constructor_call is Call(args: args2) else {
									panic("invalid temp-var")
								}

								mut tmp: [Expr] = []

								if args2[0].type.id == 1 {
									for i in 1..args2.size() {
										tmp.push(args2[i])
									}
								}

								context.body.variables[var.id].unused = true

								yield tmp
							}
							else => [args[1]]
						}

						constructorArgs.insert(before_index: 0, value: args[0])

						let constructor = .getFunction(
							namespaces: [],
							name: "constructor",
							parent_type: function_decl.parent_type!,
							template_parameters: [],
							param_types: .getExprTypes(constructorArgs),
							firstArgRefType: None,
							span: expr.span
						)

						let constructor_call = .createCall(span: expr.span, func: constructor!, args: constructorArgs, caller: context.body, is_member_call: true)
						checked_child = Stmt::Expr(span: checked_child.span, constructor_call)
					}
				}
			} else if checked_child is Expr(expr) and expr is ReferenceMemberInit(member) {
				if context.initialized_members.contains(member.id) {
					.module.error("double initialization of member", checked_child.span)
				}

				context.initialized_members.add(member.id)
			}

			result.children.push(checked_child)

			if checked_child.isTerminator(never_type: .program.never_type) {
				unreachable = true
			}
		}

		return result
	}

	fn checkStmt(mut this, stmt: ParsedStmt, context: FunctionContext) throws -> Stmt => match stmt {
		Compound(span) => Stmt::Compound(span: span, .checkCompoundStmt(stmt, context))
		VarDecl(span, var) => .checkVarDeclStmt(var, context)
		If(span, is_comptime, condition, body, else_branch) => .checkIfStmt(span, is_comptime, condition, body, else_branch, context)
		IfVar(span, var, body) => .checkIfVarStmt(span, var, body, context)
		VarElse(span, var, error_capture_name, body) => .checkVarElseStmt(span, var, error_capture_name, body, context)
		While(span, condition, body, continue_expr) => .checkWhileStmt(span, condition, body, continue_expr, context)
		DoWhile(span, body, condition) => .checkDoWhileStmt(span, body, condition, context)
		For(span, capture_const, capture_reference, capture_name, range, body) => .checkForStmt(span, capture_const, capture_reference, capture_name, range, body, context)
		Match(span, value, cases, else_branch) => .checkMatchStmt(span, value, cases, else_branch, context)
		Continue => {
			guard context.isCurrentScopeInsideLoop() else {
				.module.error("continue stmt must be inside a loop", stmt.span)
				return Stmt::Garbage(span: stmt.span)
			}
			yield Stmt::Continue(span: stmt.span, cleanup_list: [])
		}
		Break => {
			guard context.isCurrentScopeInsideLoop() else {
				.module.error("break stmt must be inside a loop", stmt.span)
				return Stmt::Garbage(span: stmt.span)
			}
			yield Stmt::Break(span: stmt.span, cleanup_list: [])
		}
		Return(span, value) => .checkReturnStmt(span, value, context)
		Discard(span, value) => Stmt::Discard(span, value: .checkExpr(expr: value, context))
		Throw(span, value) => .checkThrowStmt(span, value, context)
		Expr(span, expr) => {
			let checked_expr = .checkExpr(expr, context)
			if checked_expr.type.id != .program.void_type.id and checked_expr.type.id != .program.never_type.id {
				.module.error("unused return value", span)
				return Stmt::Garbage(span)
			}
			return Stmt::Expr(span, checked_expr)
		}
		else => Stmt::Garbage(span: stmt.span)
	}

	fn checkVarDeclStmt(mut this, var: ParsedVarDecl, mut context: FunctionContext) throws -> Stmt {
		for other in context.scopes.last()!.variables {
			if context.body.variables[other.id].name == var.name {
				.module.error("redefinition of variable '" + var.name + "'", var.span)
				.module.error("    first declared here:", context.body.variables[other.id].span)
				return Stmt::Garbage(span: var.span)
			}
		}

		mut init: Expr? = match var.init.has_value() {
			true => .checkExpr(expr: var.init!, context)
			else => None
		}

		let type: Type = match var.type.has_value() {
			true => .checkTypeUsage(type: var.type!, template_parameters_to_search: context.template_parameters_to_search)
			else => match init.has_value() {
				true => init!.type
				else => {
					.module.error("vardecl without type or initializer, at least one is required", span: var.span)
					yield .program.void_type
				}
			}
		}

		let checked_var = context.body.createVariable(span: var.span, is_const: var.is_const, name: var.name, type, init)
		context.addVariable(var: checked_var)
		return Stmt::VarDecl(span: var.span, var: checked_var)
	}

	fn checkIfStmt(mut this, span: Span, is_comptime: bool, condition: ParsedExpr, body: ParsedStmt, else_branch: ParsedStmt?, context: FunctionContext) throws -> Stmt {
		mut checked_condition = .checkExpr(expr: condition, context)

		if checked_condition.type.id != .program.bool_type.id {
			if .program.types[checked_condition.type.id].unwrapped.has_value() and .program.types[checked_condition.type.id].unwrapped!.id == .program.bool_type.id {
				let unwrap_func = .getFunction(
					namespaces: [], name: "operator unwrap",
					parent_type: checked_condition.type,
					template_parameters: [],
					param_types: [checked_condition.type],
					firstArgRefType: match checked_condition {
						Dereference(value) => value.type
						else => checked_condition.type
					}, span, allow_spaceship_operator: false
				)

				checked_condition = .createCall(
					span, func: unwrap_func!,
					args: [checked_condition],
					caller: context.body,
					is_member_call: true,
					name: "operator unwrap"
				)
			} else {
				.module.error(
					format("condition has invalid type: expected {}, but got {}",
						.program.formatTypeSignature(type: .program.bool_type),
						.program.formatTypeSignature(type: checked_condition.type)
					), span: condition.span()
				)
				return Stmt::Garbage(span)
			}
		}

		if is_comptime {
			let condition = .eval(expr: checked_condition)
			if condition.toBool() {
				return .checkStmt(stmt: body, context)
			} else if else_branch.has_value() {
				return .checkStmt(stmt: else_branch!, context)
			} else {
				return Stmt::Empty(span: Span::empty())
			}
		}

		let checked_body = .checkCompoundStmt(stmt: body, context)
		let checked_else_branch: Stmt? = match else_branch.has_value() {
			true => .checkStmt(stmt: else_branch!, context)
			else => None
		}

		return Stmt::If(span, condition: checked_condition, then_branch: checked_body, else_branch: checked_else_branch)
	}

	fn checkIfVarStmt(mut this, span: Span, var: ParsedVarDecl, body: ParsedStmt, mut context: FunctionContext) throws -> Stmt {
		guard var.init.has_value() else {
			.module.error("unitintialized variable in if-var stmt", span)
			return Stmt::Garbage(span)
		}

		mut init = var.init!
		mut remove_dereference = false
		match init {
			ConstRef(expr)
			| VarRef(expr) => {
				init = expr
				remove_dereference = true
			}
			else => {}
		}

		mut value = .checkExpr(expr: init, context)
		if not value is TempVariable {
			value = .checkTemporaryVariable(
				span: value.span,
				type: value.type,
				arguments: [value],
				constructorTemplateParameters: [],
				context
			)
		}
		value = removeDereference(value)

		guard value is TempVariable(var: temp_var) else {
			panic("if var init isn't a temporary variable")
		}

		let has_value_func = .getFunction(
			namespaces: [],
			name: "hasValue",
			parent_type: value.type,
			template_parameters: [],
			param_types: [value.type],
			firstArgRefType: value.type.constRef(),
			span: var.span,
			allow_spaceship_operator: false
		)

		let get_value_func = .getFunction(
			namespaces: [],
			name: "value",
			parent_type: value.type,
			template_parameters: [],
			param_types: [value.type],
			firstArgRefType: value.type.constRef(),
			span: var.span,
			allow_spaceship_operator: false
		)

		guard has_value_func.has_value() and get_value_func.has_value() else {
			.module.error("expression has invalid type", value.span)
			return Stmt::Garbage(span)
		}

		let has_value_call = .createCall(span: var.span, func: has_value_func!, args: [
			Expr::Dereference(
				span: Span::empty(),
				type: value.type.base(),
				value: Expr::VarInvoke(span: Span::empty(), type: value.type.constRef(), var: temp_var)
			)
		], caller: context.body, is_member_call: true)

		mut get_value_call = .createCall(span: var.span, func: get_value_func!, args: [
			Expr::Dereference(
				span: Span::empty(),
				type: value.type.base(),
				value: Expr::VarInvoke(span: Span::empty(), type: value.type.constRef(), var: temp_var)
			)
		], caller: context.body, is_member_call: true)

		if remove_dereference {
			get_value_call = removeDereference(get_value_call)
		}

		context.pushScope(type: ScopeType::Compound)
		let checked_var = context.body.createVariable(span: var.span, is_const: var.is_const, name: var.name, type: get_value_call.type, init: get_value_call)
		context.addVariable(var: checked_var)

		let checked_body = .checkCompoundStmt(stmt: body, context)
		context.popScope()

		return Stmt::IfVar(span, temp_var: value, has_value_call, body: checked_body, var: checked_var)
	}

	fn checkVarElseStmt(mut this, span: Span, var: ParsedVarDecl, error_capture_name: String?, body: ParsedStmt, mut context: FunctionContext) throws -> Stmt {
		guard var.init.has_value() else {
			.module.error("unitintialized variable in var-else stmt", span)
			return Stmt::Garbage(span)
		}

		mut value = .checkExpr(expr: var.init!, context)
		if not value is TempVariable {
			value = .checkTemporaryVariable(span: value.span, type: value.type, arguments: [value], constructorTemplateParameters: [], context)
		}
		if value is Dereference(value: other) {
			value = other
		}

		guard value is TempVariable(var: temp_var) else {
			panic("unreachable")
		}

		mut error_var: Variable? = None
		if error_capture_name.has_value() {
			context.pushScope(type: ScopeType::Compound)

			let get_error_func = .getFunction(
				namespaces: []
				name: "error",
				parent_type: value.type,
				template_parameters: [],
				param_types: [value.type],
				firstArgRefType: value.type.constRef(),
				span: var.span,
				allow_spaceship_operator: false
			)

			let get_error_call = .createCall(span: var.span, func: get_error_func!, args: [
				Expr::Dereference(
					span: Span::empty(),
					type: value.type.base(),
					value: Expr::VarInvoke(span: Span::empty(), type: value.type.constRef(), var: temp_var)
				)
			], caller: context.body, is_member_call: true)

			error_var = context.body.createVariable(
				span: var.span,
				is_const: true,
				name: error_capture_name!,
				type: get_error_call.type,
				init: get_error_call
			)

			context.addVariable(var: error_var!)
		}

		mut checked_body = .checkCompoundStmt(stmt: body, context)

		if error_var.has_value() {
			context.popScope()
		}

		guard checked_body.isTerminator(never_type: .program.never_type) else {
			.module.error("body of var-else stmt must be a terminator", span)
			return Stmt::Garbage(span)
		}

		let has_value_func = .getFunction(
			namespaces: []
			name: "hasValue",
			parent_type: value.type,
			template_parameters: [],
			param_types: [value.type],
			firstArgRefType: value.type.constRef(),
			span: var.span,
			allow_spaceship_operator: false
		)

		let get_value_func = .getFunction(
			namespaces: []
			name: "value",
			parent_type: value.type,
			template_parameters: [],
			param_types: [value.type],
			firstArgRefType: value.type.constRef(),
			span: var.span,
			allow_spaceship_operator: false
		)

		guard has_value_func.has_value() and get_value_func.has_value() else {
			.module.error("expression has invalid type", value.span)
			return Stmt::Garbage(span)
		}

		let has_value_call = .createCall(span: var.span, func: has_value_func!, args: [
			Expr::Dereference(
				span: Span::empty(),
				type: value.type.base(),
				value: Expr::VarInvoke(span: Span::empty(), type: value.type.constRef(), var: temp_var)
			)
		], caller: context.body, is_member_call: true)

		let get_value_call = .createCall(span: var.span, func: get_value_func!, args: [
			Expr::Dereference(
				span: Span::empty(),
				type: value.type.base(),
				value: Expr::VarInvoke(span: Span::empty(), type: value.type.constRef(), var: temp_var)
			)
		], caller: context.body, is_member_call: true)

		for other in context.scopes.last()!.variables {
			if context.body.variables[other.id].name == var.name {
				.module.error("redefinition of variable '" + var.name + "'", var.span)
				.module.error("    first declared here:", context.body.variables[other.id].span)
				return Stmt::Garbage(span)
			}
		}

		let ok_var = context.body.createVariable(span: var.span, is_const: var.is_const, name: var.name, type: get_value_call.type, init: get_value_call)
		context.addVariable(var: ok_var)

		return Stmt::VarElse(span, temp_var: value, has_value_call, error_var, body: checked_body, ok_var)
	}

	fn checkWhileStmt(mut this, span: Span, condition: ParsedExpr, body: ParsedStmt, continue_expr: ParsedExpr?, mut context: FunctionContext) throws -> Stmt {
		context.pushScope(type: ScopeType::Loop)
		defer context.popScope()

		mut checked_condition = .checkExpr(expr: condition, context)
		if checked_condition.type.id != .program.bool_type.id {
			if .program.types[checked_condition.type.id].unwrapped.has_value() and .program.types[checked_condition.type.id].unwrapped!.id == .program.bool_type.id {
				let unwrap_func = .getFunction(
					namespaces: [], name: "operator unwrap",
					parent_type: checked_condition.type,
					template_parameters: [],
					param_types: [checked_condition.type],
					firstArgRefType: match checked_condition {
						Dereference(value) => value.type
						else => checked_condition.type
					}, span, allow_spaceship_operator: false
				)

				checked_condition = .createCall(
					span, func: unwrap_func!,
					args: [checked_condition],
					caller: context.body,
					is_member_call: true,
					name: "operator unwrap"
				)
			} else {
				.module.error(
					format("condition has invalid type: expected {}, but got {}",
						.program.formatTypeSignature(type: .program.bool_type),
						.program.formatTypeSignature(type: checked_condition.type)
					), span: condition.span()
				)
				return Stmt::Garbage(span)
			}
		}

		let checked_body = .checkCompoundStmt(stmt: body, context)
		let checked_continue_expr: Expr? = match continue_expr.has_value() {
			true => {
				let expr = .checkExpr(expr: continue_expr!, context)
				guard expr.type.equals(other: .program.void_type) else {
					.module.error("continue expr in while stmt must yield type void", continue_expr!.span())
					return Stmt::Garbage(span)
				}
				yield expr
			}
			else => None
		}

		return Stmt::While(span, condition: checked_condition, body: checked_body, continue_expr: checked_continue_expr)
	}

	fn checkDoWhileStmt(mut this, span: Span, body: ParsedStmt, condition: ParsedExpr, mut context: FunctionContext) throws -> Stmt {
		context.pushScope(type: ScopeType::Loop)
		defer context.popScope()

		let checked_body = .checkCompoundStmt(stmt: body, context)

		mut checked_condition = .checkExpr(expr: condition, context)
		if checked_condition.type.id != .program.bool_type.id {
			if .program.types[checked_condition.type.id].unwrapped.has_value() and .program.types[checked_condition.type.id].unwrapped!.id == .program.bool_type.id {
				let unwrap_func = .getFunction(
					namespaces: [], name: "operator unwrap",
					parent_type: checked_condition.type,
					template_parameters: [],
					param_types: [checked_condition.type],
					firstArgRefType: match checked_condition {
						Dereference(value) => value.type
						else => checked_condition.type
					}, span, allow_spaceship_operator: false
				)

				checked_condition = .createCall(
					span, func: unwrap_func!,
					args: [checked_condition],
					caller: context.body,
					is_member_call: true,
					name: "operator unwrap"
				)
			} else {
				.module.error(
					format("condition has invalid type: expected {}, but got {}",
						.program.formatTypeSignature(type: .program.bool_type),
						.program.formatTypeSignature(type: checked_condition.type)
					), span: condition.span()
				)
				return Stmt::Garbage(span)
			}
		}

		return Stmt::DoWhile(span, body: checked_body, condition: checked_condition)
	}

	fn checkForStmt(mut this, span: Span, capture_const: bool, capture_reference: bool, capture_name: String, range: ParsedExpr, mut body: ParsedStmt, mut context: FunctionContext) throws -> Stmt {
		// for (&&)value in range() {
		//     ...
		// }
		//   |
		//   V
		// {
		//     var #range = range();
		//     var #iterator = #range.iterator();
		//     var #next = #iterator.next()
		//     while #next.hasValue(); #next = #iterator.next() {
		//         var value = (&&)#next.value();
		//         ...
		//     }
		// }
		// temporary variables are prefixed with # to avoid naming conflicts

		mut result = CompoundStmt(
			span,
			children: [],
			cleanup_list: []
		)
		context.pushScope(type: ScopeType::Compound)
		defer context.popScope()

		mut checked_range = .checkExpr(expr: range, context, desired_type: None, is_constructor_call: false)
		if checked_range.isTemporary() or checked_range is ArrayLiteral {
			let range_var = context.body.createVariable(span: range.span(), is_const: capture_const, name: "#range", type: checked_range.type, init: checked_range)
			context.addVariable(var: range_var)
			result.children.push(Stmt::VarDecl(span: range.span(), var: range_var))
			checked_range = Expr::VarInvoke(span: range.span(), type: match capture_const {
				true => checked_range.type.constRef()
				else => checked_range.type.varRef()
			}, var: range_var)
		}
		if not checked_range.type is Base {
			checked_range = Expr::Dereference(span: range.span(), type: checked_range.type.base(), value: checked_range)
		}

		let iterator_func = .getFunction(
			namespaces: [], name: "iterator",
			parent_type: checked_range.type,
			template_parameters: [],
			param_types: [checked_range.type],
			firstArgRefType: match checked_range {
				Dereference(value) => value.type
				else => checked_range.type
			}, span: range.span(),
			allow_spaceship_operator: false
		)

		let iterator_call = .createCall(
			span: range.span(),
			func: iterator_func!,
			args: [checked_range],
			caller: context.body,
			is_member_call: true,
			name: "iterator"
		)

		let iterator_type = iterator_call.type.base()
		let iterator_var = context.body.createVariable(span: range.span(), is_const: false, name: "#iterator", type: iterator_type, init: iterator_call)
		context.addVariable(var: iterator_var)
		result.children.push(Stmt::VarDecl(span: range.span(), var: iterator_var))

		result.children.push(.checkVarDeclStmt(
			var: ParsedVarDecl(span: range.span(), is_const: false, name: "#next", type: None,
				init: ParsedExpr::MemberCall(
					span: range.span(),
					object: ParsedExpr::Name(
						span: range.span(), namespaces: [],
						name: ParsedName(span: range.span(), name: "#iterator", template_parameters: [])
					),
					name: "next",
					template_parameters: []
					arguments: []
				)
			), context
		))

		let condition = .checkExpr(expr: ParsedExpr::MemberCall(
			span: range.span(),
			object: ParsedExpr::Name(
				span: range.span(), namespaces: [],
				name: ParsedName(span: range.span(), name: "#next", template_parameters: [])
			),
			name: "hasValue",
			template_parameters: []
			arguments: []
		), context)

		let continue_expr = .checkExpr(expr: ParsedExpr::BinaryOp(
			span: range.span(),
			lhs: ParsedExpr::Name(
				span: range.span(), namespaces: [],
				name: ParsedName(span: range.span(), name: "#next", template_parameters: [])
			),
			op: ParsedBinaryOperator::Assign
			rhs: ParsedExpr::MemberCall(
				span: range.span(),
				object: ParsedExpr::Name(
					span: range.span(), namespaces: [],
					name: ParsedName(span: range.span(), name: "#iterator", template_parameters: [])
				),
				name: "next",
				template_parameters: []
				arguments: []
			)
		), context)

		guard body is Compound(children) else {
			panic("invalid for stmt")
		}

		let next_value = ParsedExpr::MemberCall(
			span: range.span(),
			object: ParsedExpr::Name(
				span: range.span(), namespaces: [],
				name: ParsedName(span: range.span(), name: "#next", template_parameters: [])
			),
			name: "value",
			template_parameters: []
			arguments: []
		)

		mut children_with_var = [
			ParsedStmt::VarDecl(span: range.span(),
				var: ParsedVarDecl(span: range.span(), is_const: capture_const, name: capture_name, type: None,
					init: match capture_reference {
						true => match capture_const {
							true => ParsedExpr::ConstRef(span: range.span(), expr: next_value)
							else => ParsedExpr::VarRef(span: range.span(), expr: next_value)
						}
						else => next_value
					}
				)
			)
		]
		children_with_var.push_values(&children)

		let checked_body = .checkCompoundStmt(
			stmt: ParsedStmt::Compound(span: body.span, children: children_with_var),
			context
		)

		result.children.push(Stmt::While(span, condition, body: checked_body, continue_expr))

		return Stmt::Compound(span, result)
	}

	fn checkMatchStmt(mut this, span: Span, value: ParsedExpr, cases: [ParsedCaseStmt], else_branch: ParsedStmt?, mut context: FunctionContext) throws -> Stmt {
		mut result = CompoundStmt(
			span,
			children: [],
			cleanup_list: []
		)
		context.pushScope(type: ScopeType::Compound)
		defer context.popScope()

		mut checked_value = .checkExpr(expr: value, context)

		let match_type = Type::Base(id: checked_value.type.id)
		let match_type_decl = .program.types[match_type.id]

		if checked_value.isTemporary() {
			let var = context.body.createVariable(span: value.span(), is_const: true, name: "#value", type: checked_value.type, init: checked_value)
			context.addVariable(var)
			result.children.push(Stmt::VarDecl(span: value.span(), var))
			checked_value = Expr::Dereference(
				span: value.span(),
				type: checked_value.type,
				value: Expr::VarInvoke(span: value.span(), type: checked_value.type.constRef(), var)
			)
		}

		mut checked_cases: [CaseStmt] = []
		let cases_to_cover = match match_type_decl.kind {
			Enum(cases) => cases.size()
			Variant(cases) => cases.size()
			Builtin(builtin) => match builtin {
				Bool => 2
				Byte => 256
				else => 0
			}
			else => 0
		}

		mut covered_cases: {i64} = {}
		for c in cases {
			let checked_case = .checkMatchCase(parsed_stmt: c, match_value: checked_value, match_type: match_type_decl, context)
			checked_cases.push(checked_case)

			for pattern in checked_case.patterns {
				guard pattern is IntLiteral(value) else {
					panic("invalid match case")
				}

				guard not covered_cases.contains(value) else {
					.module.error("duplicated case pattern", checked_case.span)
					return Stmt::Garbage(span)
				}

				covered_cases.add(value)
			}
		}
		let is_complete = cases_to_cover == covered_cases.size()

		if is_complete and else_branch.has_value() {
			.module.error("else branch not reachable", else_branch!.span)
		} else if not is_complete and not else_branch.has_value() {
			.module.error("match stmt doesn't cover all possible cases", span)
		}

		let checked_else_branch: Stmt? = match else_branch.has_value() and not is_complete {
			true => .checkStmt(stmt: else_branch!, context)
			else => None
		}

		result.children.push(Stmt::Match(
			span,
			value: checked_value,
			cases: checked_cases,
			else_branch: checked_else_branch,
			is_complete
		))
		return Stmt::Compound(span, result)
	}

	fn checkMatchCase(mut this, parsed_stmt: ParsedCaseStmt, match_value: Expr, match_type: TypeDecl, mut context: FunctionContext) throws -> CaseStmt {
		if match_type.kind is Variant(id_type, cases) {
			mut checked_patterns: [Expr] = []
			for pattern in parsed_stmt.patterns {
				guard pattern is Name(namespaces, name) else {
					.module.error("invalid match pattern, expected variant case name", pattern.span())
					return CaseStmt(
						span: parsed_stmt.span, patterns: [],
						body: Stmt::Garbage(span: parsed_stmt.body.span)
					)
				}

				let c = .program.getVariantCase(type: Type::Base(id: match_type.id), name: name.name)

				guard c.has_value() else {
					.module.error("unknown case name", pattern.span())
					return CaseStmt(
						span: parsed_stmt.span, patterns: [],
						body: Stmt::Garbage(span: parsed_stmt.body.span)
					)
				}

				checked_patterns.push(
					Expr::IntLiteral(span: pattern.span(), type: id_type, value: c!.id, isSigned: false)
				)
			}

			let body = match parsed_stmt.capture_name.has_value() {
				true => {
					guard checked_patterns.size() == 1 else {
						.module.error("capture only allowed for single patterns", span: checked_patterns[1].span)
						return CaseStmt(
							span: parsed_stmt.span, patterns: [],
							body: Stmt::Garbage(span: parsed_stmt.body.span)
						)
					}

					guard checked_patterns[0] is IntLiteral(value: case_id) else {
						panic("unreachable")
					}

					mut body = CompoundStmt(span: parsed_stmt.span, children: [], cleanup_list: [])
					context.pushScope(type: ScopeType::Compound)
					defer context.popScope()

					let cast_operator = .getFunction(
						namespaces: []
						name: "operator unsafe as",
						parent_type: match_value.type,
						template_parameters: [TemplateParameter::IntLiteral(span: Span::empty(), name: "", value: case_id)],
						param_types: [match_value.type],
						firstArgRefType: match_value.type.varRef(),
						span: parsed_stmt.span
					)

					mut init = .createCall(span: parsed_stmt.span, func: cast_operator!, args: [match_value], caller: context.body, is_member_call: true)
					if parsed_stmt.capture_reference {
						guard init is Dereference(value) else {
							.module.error("cannot take reference to const value", parsed_stmt.span)
							return CaseStmt(
								span: parsed_stmt.span, patterns: [],
								body: Stmt::Garbage(span: parsed_stmt.body.span)
							)
						}

						init = value
					}

					let var = context.body.createVariable(
						span: parsed_stmt.span,
						is_const: match init.type {
							VarRef => false
							else => true
						},
						name: parsed_stmt.capture_name!,
						type: init.type,
						init
					)

					context.addVariable(var)
					body.children.push(Stmt::VarDecl(span: Span::empty(), var))
					body.children.push(.checkStmt(stmt: parsed_stmt.body, context))
					yield Stmt::Compound(span: parsed_stmt.span, body)
				}
				else => .checkStmt(stmt: parsed_stmt.body, context)
			}

			return CaseStmt(
				span: parsed_stmt.span,
				patterns: checked_patterns,
				body
			)
		} else if .program.isIntType(type: Type::Base(id: match_type.id)) {
			mut checked_patterns: [Expr] = []
			for pattern in parsed_stmt.patterns {
				checked_patterns.push(.checkExpr(expr: pattern, context, desired_type: Type::Base(id: match_type.id)))
			}

			guard not parsed_stmt.capture_name.has_value() else {
				.module.error("match in int-types cannot capture a value", parsed_stmt.span)
				return CaseStmt(
					span: parsed_stmt.span, patterns: [],
					body: Stmt::Garbage(span: parsed_stmt.body.span)
				)
			}

			let checked_body = .checkStmt(stmt: parsed_stmt.body, context)
			return CaseStmt(
				span: parsed_stmt.span,
				patterns: checked_patterns,
				body: checked_body
			)
		} else {
			.module.error("typechecking of case stmts not yet fully implemented", parsed_stmt.span)
			return CaseStmt(
				span: parsed_stmt.span, patterns: [],
				body: Stmt::Garbage(span: parsed_stmt.body.span)
			)
		}
	}

	fn checkReturnStmt(mut this, span: Span, value: ParsedExpr?, context: FunctionContext) throws -> Stmt {
		mut checked_value: Expr? = match value.has_value() {
			true => .checkExpr(expr: value!, context, desired_type: context.return_type)
			else => None
		}

		mut return_value_type = match checked_value.has_value() {
			true => checked_value!.type
			else => .program.void_type
		}

		if checked_value.has_value() and return_value_type.id != context.return_type.id and .program.types[return_value_type.id].unwrapped?.id == Some(context.return_type.id) {
			let unwrap_func = .getFunction(
				namespaces: [], name: "operator unwrap",
				parent_type: return_value_type,
				template_parameters: [],
				param_types: [return_value_type],
				firstArgRefType: match checked_value! {
					Dereference(value) => value.type
					else => checked_value!.type
				}, span, allow_spaceship_operator: false
			)

			checked_value = .createCall(
				span, func: unwrap_func!,
				args: [checked_value!],
				caller: context.body,
				is_member_call: true,
				name: "operator unwrap"
			)

			return_value_type = checked_value!.type
		}

		guard return_value_type.equals(other: context.return_type) else {
			.module.error(
				format("return value has wrong type: expected {}, but got {}",
					.program.formatTypeSignature(type: context.return_type),
					.program.formatTypeSignature(type: return_value_type)
				), span
			)
			return Stmt::Garbage(span)
		}

		return Stmt::Return(span, value: checked_value, cleanup_list: [])
	}

	fn checkThrowStmt(mut this, span: Span, value: ParsedExpr, context: FunctionContext) throws -> Stmt {
		let result_value = .checkVariantTemporaryVariable(
			span,
			type: context.return_type,
			case_name: "Error",
			arguments: [value],
			context
		)

		return Stmt::Return(span, value: result_value, cleanup_list: [])
	}

	fn checkExpr(mut this, expr: ParsedExpr, mut context: FunctionContext, desired_type: Type? = None, is_constructor_call: bool = false) throws -> Expr => match expr {
		BoolLiteral(span, value) => .checkBoolLiteralExpr(span, value)
		IntLiteral(span, value, postfix) => .checkIntLiteralExpr(span, value, postfix, context, desired_type)
		FloatLiteral(span, value, postfix) => .checkFloatLiteralExpr(span, value, postfix, context, desired_type)
		CharLiteral(span, value, postfix) => .checkCharLiteralExpr(span, value, postfix, context)
		StringLiteral(span, value) => .checkStringLiteralExpr(span, value, context)
		Paren(span, child) => .checkExpr(expr: child, context, desired_type, is_constructor_call)
		Array(span, elements) => {
			mut checked_elements: [Expr] = []
			mut element_type: Type? = None
			mut desired_element_type: Type? = None

			if desired_type.has_value() and not .program.types[desired_type!.id].template_parameters.is_empty() {
				if .program.types[desired_type!.id].template_parameters[0] is Type(value) {
					desired_element_type = value
				}
			}

			for e in elements {
				let checked = .checkExpr(expr: e, context, desired_type: desired_element_type)
				checked_elements.push(checked)

				if element_type.has_value() {
					guard element_type!.equals(other: checked.type) else {
						.module.error("element has different type than previous elements", checked.span)
						return Expr::Garbage(span, type: .program.void_type)
					}
				} else {
					element_type = checked.type
					desired_element_type = element_type
				}
			}

			let array_type = .getType(
				namespaces: [], name: "Array",
				template_parameters: [
					TemplateParameter::Type(span: Span::empty(), name: "", value: element_type!)
					TemplateParameter::IntLiteral(span: Span::empty(), name: "", value: checked_elements.size() as! i64)
				],
				template_parameters_to_search: context.template_parameters_to_search,
				error_span: span
			)!

			yield Expr::ArrayLiteral(span, type: array_type, values: checked_elements)
		}
		MemberName(span, object, name) => {
			mut checked_object = removeDereference(.checkExpr(expr: object, context))

			let type_decl = .program.types[checked_object.type.id]

			mut var: MemberVar? = None
			for decl in type_decl.member_variables {
				if decl.name == name.name {
					var = decl
					break
				}
			}

			guard var.has_value() else {
				.module.error("no such member var on type " + .program.formatTypeSignature(type: checked_object.type), span)
				return Expr::Garbage(span, type: .program.void_type)
			}

			if checked_object is VarInvoke(var: object_var) and object_var.id == 0 {
				if context.is_constructor and not is_constructor_call {
					if not context.initialized_members.contains(var!.id) {
						.module.error("use of uninitialized member variable", span)
					}
				} else if context.is_destructor {
					if context.deinitialized_members.contains(var!.id) {
						.module.error("use of deinitialized member variable", span)
					}
				}
			}

			let result = match var!.type {
				Base => Expr::MemberAccess(
					span, type: match checked_object.type {
						Base => var!.type
						ConstRef => var!.type.constRef()
						VarRef => var!.type.varRef()
					},
					object: checked_object,
					var: Variable(id: var!.id)
				)
				else => Expr::ReferenceMemberInvoke(
					span, type: match checked_object.type {
						VarRef => match var!.type {
							VarRef => var!.type.varRef()
							else => var!.type.constRef()
						}
						else => var!.type.constRef()
					},
					object: checked_object,
					member: Variable(id: var!.id)
				)
			}

			yield match result.type {
				Base => result
				else => Expr::Dereference(span, type: Type::Base(id: result.type.id), value: result)
			}
		}
		Call(span, namespaces, name, template_parameters, arguments) => {
			mut namespace_is_template_type = false
			mut namespace_names: [String] = []
			for ns in namespaces {
				namespace_names.push(ns.name)
				if not ns.template_parameters.is_empty() {
					namespace_is_template_type = true
				}
			}

			if namespace_is_template_type {
				let type_name = namespace_names.pop()!
				let type_template_parameters = namespaces.last()!.template_parameters
				let type = .checkTypeUsage(
					type: ParsedType::Name(span, namespaces: namespace_names, name: type_name, template_parameters: type_template_parameters),
					template_parameters_to_search: context.template_parameters_to_search
				)

				if .program.getVariantCase(type, name).has_value() {
					return .checkVariantTemporaryVariable(span, type, case_name: name, arguments, context)
				} else {
					let checked_template_parameters = .checkTemplateParameters(parsed_template_parameters: template_parameters, template_parameters_to_search: context.template_parameters_to_search)

					mut checked_args: [Expr] = []
					for arg in arguments {
						checked_args.push(.checkExpr(expr: arg, context))
					}

					mut param_types: [Type] = []
					for arg in checked_args {
						param_types.push(arg.type)
					}

					let func = .getFunction(namespaces: [], name, parent_type: type, template_parameters: checked_template_parameters, param_types, firstArgRefType: None, span)
					guard func.has_value() else {
						return Expr::Garbage(span, type: .program.void_type)
					}
					return .createCall(span, func: func!, args: checked_args, caller: context.body, is_member_call: false, name)
				}
			} else if .module.existsType(namespaces: namespace_names, name, span, template_parameters_to_search: context.template_parameters_to_search) {
				let type = .checkTypeUsage(
					type: ParsedType::Name(span, namespaces: namespace_names, name, template_parameters),
					template_parameters_to_search: context.template_parameters_to_search
				)
				return .checkTemporaryVariable(span, type, arguments, constructorTemplateParameters: [], context)
			} else if template_parameters.is_empty() and namespaces.is_empty() and desired_type.has_value()
						and .program.getVariantCase(type: desired_type!, name).has_value() {
				return .checkVariantTemporaryVariable(span, type: desired_type!, case_name: name, arguments, context)
			} else if template_parameters.is_empty() and namespace_names.size() >= 1 {
				let first_namespaces = namespace_names[0..(namespace_names.size() - 1)].to_array()
				let last_namespace = namespace_names.last()!
				if .module.existsType(namespaces: first_namespaces, name: last_namespace, span, template_parameters_to_search: context.template_parameters_to_search) {
					let type = .checkTypeUsage(
						type: ParsedType::Name(
							span,
							namespaces: first_namespaces,
							name: last_namespace,
							template_parameters: []
						),
						template_parameters_to_search: context.template_parameters_to_search
					)

					if .program.types[type.id].kind is Variant {
						return .checkVariantTemporaryVariable(span, type, case_name: name, arguments, context)
					} else if .program.types[type.id].kind is Enum and arguments.is_empty() {
						return .checkEnumLiteral(span, type, case_name: name, context)
					}
				}
			}

			yield .checkFunctionCall(span, namespaces: namespace_names, name, parsed_template_parameters: template_parameters, arguments, is_member_call: false, is_binary_op: false, context)
		}
		MemberCall(span, object, name, template_parameters, arguments) => {
			mut arguments_with_this = [object]
			arguments_with_this.push_values(&arguments)
			yield .checkFunctionCall(span, namespaces: [], name, parsed_template_parameters: template_parameters, arguments: arguments_with_this, is_member_call: true, is_binary_op: false, context)
		}
		IndexOperator(span, object, arguments) => {
			yield .checkExpr(expr: ParsedExpr::MemberCall(span, object, name: "operator []", template_parameters: [], arguments), context)
		}
		ConstRef(span, expr) => {
			let checked_value = .checkExpr(expr, context)
			guard checked_value is Dereference(value) else {
				.module.error("can't reference constant", span)
				return Expr::Garbage(span, type: .program.void_type)
			}

			yield match value {
				Call(span, type, func, args, cleanup) => Expr::Call(span, type: type.constRef(), func, args, cleanup)
				MemberAccess(span, type, object, var) => Expr::MemberAccess(span, type: type.constRef(), object, var)
				VarInvoke(span, type, var) => Expr::VarInvoke(span, type: type.constRef(), var)
				ReferenceVarInvoke(span, type, var) => Expr::ReferenceVarInvoke(span, type: type.constRef(), var)
				TempVariable(span, type, constructor_call, var, destructor_call) => Expr::TempVariable(span, type: type.constRef(), constructor_call, var, destructor_call)
				else  => {
					.module.error("invalid const-ref expr", span)
					yield Expr::Garbage(span, type: .program.void_type)
				}
			}
		}
		VarRef(span, expr) => {
			let checked_value = .checkExpr(expr, context)
			guard checked_value is Dereference(value) else {
				.module.error("can't reference constant", span)
				return Expr::Garbage(span, type: .program.void_type)
			}

			guard value.type is VarRef else {
				.module.error("can't take var reference of const value", span)
				return Expr::Garbage(span, type: .program.void_type)
			}

			yield value
		}
		OperatorIs(span, value, targetType) => {
			let checked_value = .checkExpr(expr: value, context)

			let type_decl = .program.types[checked_value.type.id]

			mut template_parameters: [TemplateParameter] = []

			if type_decl.kind is Variant {
				guard targetType is Name(span, name) else {
					.module.error("expected enum case name", targetType.span())
					return Expr::Garbage(span, type: .program.void_type)
				}

				let c = .program.getVariantCase(type: checked_value.type, name)

				guard c.has_value() else {
					.module.error("unknown enum case", span)
					return Expr::Garbage(span, type: .program.void_type)
				}

				template_parameters.push(TemplateParameter::IntLiteral(span, name: "", value: c!.id))
			} else {
				let type = .checkTypeUsage(type: targetType, template_parameters_to_search: context.template_parameters_to_search)
				template_parameters.push(TemplateParameter::Type(span: targetType.span(), name: "", value: type))
			}

			let checked_args: [Expr] = [checked_value]
			let param_types: [Type] = [checked_value.type]

			mut firstArgRefType = checked_value.type
			if checked_value is Dereference(value) {
				firstArgRefType = value.type
			}

			let func = .getFunction(namespaces: [], name: "operator is", parent_type: checked_value.type, template_parameters, param_types, firstArgRefType, span)
			guard func.has_value() else {
				return Expr::Garbage(span, type: .program.void_type)
			}
			yield .createCall(span, func: func!, args: checked_args, caller: context.body, is_member_call: true)
		}
		OperatorAs(span, value, targetType) => {
			let checked_value = .checkExpr(expr: value, context, is_constructor_call)

			if .program.types[checked_value.type.id].kind is Variant and targetType is Name(namespaces, template_parameters, name) {
				if namespaces.is_empty() and template_parameters.is_empty() {
					let c = .program.getVariantCase(type: checked_value.type, name)
					if c.has_value() {
						let func = .getFunction(
							namespaces: [], name: "operator as",
							parent_type: checked_value.type,
							template_parameters: [
								TemplateParameter::IntLiteral(span, name: "", value: c!.id)
							], param_types: [
								checked_value.type
							], firstArgRefType: match checked_value {
								Dereference(value) => value.type
								else => checked_value.type
							}, span
						)

						guard func.has_value() else {
							return Expr::Garbage(span, type: .program.void_type)
						}

						return .createCall(span, func: func!, args: [checked_value], caller: context.body, is_member_call: true)
					}
				}
			}

			let checked_target_type = .checkTypeUsage(type: targetType, template_parameters_to_search: context.template_parameters_to_search)

			if checked_value.type.equals(other: checked_target_type) {
				return checked_value
			}

			let checked_args: [Expr] = [checked_value]
			let param_types: [Type] = [checked_value.type]

			if .program.isIntType(type: checked_value.type) and .program.isIntType(type: checked_target_type) {
				let func = .getFunction(
					namespaces: [],
					name: "intCast",
					parent_type: None,
					template_parameters: [
						TemplateParameter::Type(span: Span::empty(), name: "Target", value: checked_target_type)
						TemplateParameter::Type(span: Span::empty(), name: "Source", value: checked_value.type)
					], param_types, firstArgRefType: None, span
				)

				guard func.has_value() else {
					return Expr::Garbage(span, type: .program.void_type)
				}

				return .createCall(span, func: func!, args: checked_args, caller: context.body, is_member_call: true, name: "intCast")
			} else if .program.isFloatType(type: checked_value.type) and .program.isFloatType(type: checked_target_type) {
				let func = .getFunction(
					namespaces: [],
					name: "floatCast",
					parent_type: None,
					template_parameters: [
						TemplateParameter::Type(span: Span::empty(), name: "Target", value: checked_target_type)
						TemplateParameter::Type(span: Span::empty(), name: "Source", value: checked_value.type)
					], param_types, firstArgRefType: None, span
				)

				guard func.has_value() else {
					return Expr::Garbage(span, type: .program.void_type)
				}

				return .createCall(span, func: func!, args: checked_args, caller: context.body, is_member_call: true, name: "floatCast")
			} else if .program.isIntType(type: checked_value.type) and .program.isFloatType(type: checked_target_type) {
				let func = .getFunction(
					namespaces: [],
					name: "intToFloat",
					parent_type: None,
					template_parameters: [
						TemplateParameter::Type(span: Span::empty(), name: "Target", value: checked_target_type)
						TemplateParameter::Type(span: Span::empty(), name: "Source", value: checked_value.type)
					], param_types, firstArgRefType: None, span
				)

				guard func.has_value() else {
					return Expr::Garbage(span, type: .program.void_type)
				}

				return .createCall(span, func: func!, args: checked_args, caller: context.body, is_member_call: true, name: "intToFloat")
			} else if .program.isFloatType(type: checked_value.type) and .program.isIntType(type: checked_target_type) {
				let func = .getFunction(
					namespaces: [],
					name: "floatToInt",
					parent_type: None,
					template_parameters: [
						TemplateParameter::Type(span: Span::empty(), name: "Target", value: checked_target_type)
						TemplateParameter::Type(span: Span::empty(), name: "Source", value: checked_value.type)
					], param_types, firstArgRefType: None, span
				)

				guard func.has_value() else {
					return Expr::Garbage(span, type: .program.void_type)
				}

				return .createCall(span, func: func!, args: checked_args, caller: context.body, is_member_call: true, name: "floatToInt")
			} else if .program.isPtrType(type: checked_value.type) and .program.isPtrType(type: checked_target_type) {
				let func = .getFunction(
					namespaces: [],
					name: "ptrCast",
					parent_type: None,
					template_parameters: [
						TemplateParameter::Type(span: Span::empty(), name: "Target", value: checked_target_type)
						TemplateParameter::Type(span: Span::empty(), name: "Source", value: checked_value.type)
					], param_types, firstArgRefType: None, span
				)

				guard func.has_value() else {
					return Expr::Garbage(span, type: .program.void_type)
				}
				return .createCall(span, func: func!, args: checked_args, caller: context.body, is_member_call: true, name: "ptrCast")
			} else {
				mut firstArgRefType = checked_value.type
				if checked_value is Dereference(value) {
					firstArgRefType = value.type
				}

				let func = .getFunction(
					namespaces: []
					name: "operator as",
					parent_type: checked_value.type,
					template_parameters: [
						TemplateParameter::Type(span: Span::empty(), name: "", value: checked_target_type)
					], param_types, firstArgRefType, span
				)

				guard func.has_value() else {
					return Expr::Garbage(span, type: .program.void_type)
				}
				return .createCall(span, func: func!, args: checked_args, caller: context.body, is_member_call: true, name: "operator as")
			}
		}
		UnaryOp(span, expr, op) => .checkFunctionCall(span, namespaces: [], name: "operator " + op.to_string(), parsed_template_parameters: [], arguments: [expr], is_member_call: true, is_binary_op: false, context)
		BinaryOp(span, lhs, op, rhs) => .checkFunctionCall(span, namespaces: [], name: "operator " + op.to_string(), parsed_template_parameters: [], arguments: [lhs, rhs], is_member_call: true, is_binary_op: true, context)
		Name(span, namespaces, name) => {
			if namespaces.is_empty() and desired_type.has_value() {
				if .program.getVariantCase(type: desired_type!, name: name.name).has_value() {
					return .checkVariantTemporaryVariable(span, type: desired_type!, case_name: name.name, arguments: [], context)
				} else if .program.getEnumCase(type: desired_type!, name: name.name).has_value() {
					return .checkEnumLiteral(span, type: desired_type!, case_name: name.name, context)
				}
			}

			if namespaces.is_empty() {
				// variable
				let var = context.findVariable(name: name.name)
				if not var.has_value() {
					// maybe constant from template parameters
					for templateParameter in context.template_parameters_to_search {
						guard templateParameter.name == name.name else {
							continue
						}

						guard templateParameter is IntLiteral(value) else {
							continue
						}

						guard value.has_value() else {
							continue
						}

						return Expr::IntLiteral(span, type: .program.uint_type, value: value!, isSigned: true)
					}

					.module.error("variable " + name.name + " not found", span)
					return Expr::Garbage(span, type: .program.void_type)
				}

				let vardecl = context.body.variables[var!.id]
				let type = vardecl.type

				if vardecl.is_param {
					if type is Base and .program.isPrimitive(type) {
						return Expr::VarInvoke(span, type, var: var!)
					} else if type is Base {
						return Expr::Dereference(span, type: Type::Base(id: type.id), value: Expr::VarInvoke(span, type: type.constRef(), var: var!))
					} else {
						return Expr::Dereference(span, type: Type::Base(id: type.id), value: Expr::VarInvoke(span, type, var: var!))
					}
				} else if type is Base {
					let value = match vardecl.is_const {
						true => Expr::VarInvoke(span, type: Type::ConstRef(id: type.id), var: var!)
						else => Expr::VarInvoke(span, type: Type::VarRef(id: type.id), var: var!)
					}
					return Expr::Dereference(span, type: Type::Base(id: type.id), value)
				} else {
					let value = match vardecl.is_const {
						true => Expr::ReferenceVarInvoke(span, type: Type::ConstRef(id: type.id), var: var!)
						else => Expr::ReferenceVarInvoke(span, type: Type::VarRef(id: type.id), var: var!)
					}
					return Expr::Dereference(span, type: Type::Base(id: type.id), value)
				}
			} else {
				// enum value
				mut type_namespaces = cloneList<ParsedName>(namespaces)
				mut type_name = type_namespaces.pop()!

				mut namespace_names: [String] = []
				for ns in type_namespaces {
					namespace_names.push(ns.name)
				}

				let type = .getType(
					namespaces: namespace_names
					name: type_name.name,
					template_parameters: .checkTemplateParameters(parsed_template_parameters: type_name.template_parameters, template_parameters_to_search: context.template_parameters_to_search),
					template_parameters_to_search: context.template_parameters_to_search,
					error_span: span
				)

				guard type.has_value() else {
					return Expr::Garbage(span, type: .program.void_type)
				}

				let type_decl = .program.types[type!.id]

				if type_decl.kind is Enum(cases) {
					return .checkEnumLiteral(span, type: type!, case_name: name.name, context)
				} else {
					return .checkVariantTemporaryVariable(span, type: type!, case_name: name.name, arguments: [], context)
				}
			}
		}
		Try(span, expr) => .checkValidateExpr(span, expr, context, kind: ValidationKind::Try)
		Must(span, expr) => .checkValidateExpr(span, expr, context, kind: ValidationKind::Must)
		InlineIf(span, true_value, condition, false_value) => {
			let checked_true_value = .checkExpr(expr: true_value, context, desired_type, is_constructor_call)
			let checked_condition = .checkExpr(expr: condition, context, desired_type, is_constructor_call)
			let checked_false_value = .checkExpr(expr: false_value, context, desired_type, is_constructor_call)

			guard checked_condition.type.equals(other: .program.bool_type) else {
				.module.error(format("condition has invalid type: expected {}, but got {}",
					.program.formatTypeSignature(type: .program.bool_type),
					.program.formatTypeSignature(type: checked_condition.type)
				), condition.span())
				return Expr::Garbage(span, type: .program.void_type)
			}

			guard checked_true_value.type.equals(other: checked_false_value.type) else {
				.module.error("true-value has different type than false-value", span)
				return Expr::Garbage(span, type: .program.void_type)
			}

			let type = checked_true_value.type

			let result_var = context.body.createVariable(span, is_const: true, name: "", type, init: None)
			let destructor_func = .getFunction(
				namespaces: [],
				name: "destructor",
				parent_type: type,
				template_parameters: [],
				param_types: [type.varRef()],
				firstArgRefType: None, span, allow_spaceship_operator: false
			)

			let cleanup_call = .createCall(span, func: destructor_func!, args: [
				Expr::VarInvoke(span: Span::empty(), type: type.varRef(), var: result_var)
			], caller: context.body, is_member_call: true, name: "destructor")

			yield Expr::InlineIf(span, type: type,
				true_value: checked_true_value,
				condition: checked_condition,
				false_value: checked_false_value,
				result_var,
				cleanup_call,
			)
		}
		Garbage(span) => Expr::Garbage(span, type: .program.void_type)
		else => {
			.module.error("typechecking of expressions not fully implemented", span: expr.span())
			yield Expr::Garbage(span: expr.span(), type: .program.void_type)
		}
	}

	fn checkBoolLiteralExpr(mut this, span: Span, value: bool) throws -> Expr {
		return Expr::IntLiteral(span, type: .program.bool_type, value: match value {
			true => 1
			else => 0
		}, isSigned: false)
	}

	fn checkIntLiteralExpr(mut this, span: Span, value: i64, postfix: String, context: FunctionContext, desired_type: Type?) throws -> Expr => match postfix {
		"" => {
			if desired_type.has_value() and .program.isIntType(type: desired_type!) {
				return Expr::IntLiteral(span, type: desired_type!.base(), value, isSigned: true)
			} else {
				return Expr::IntLiteral(span, type: .program.int_type, value, isSigned: true)
			}
		}
		"i" => Expr::IntLiteral(span, type: .program.int_type, value, isSigned: true)
		"u" => Expr::IntLiteral(span, type: .program.uint_type, value, isSigned: false)
		else => {
			guard postfix.byte_at(0) == b'u' or postfix.byte_at(0) == b'i' else {
				.module.error("invalid postfix for int literals", span)
				return Expr::Garbage(span, type: .program.void_type)
			}

			let bits = postfix.substring(start: 1, length: postfix.length() - 1).to_uint()
			guard bits.has_value() else {
				.module.error("invalid postfix for int literals", span)
				return Expr::Garbage(span, type: .program.void_type)
			}

			let type = .getType(namespaces: [],
				name: match postfix.byte_at(0) {
					b'u' => "uint"
					else => "int"
				}, template_parameters: [
					TemplateParameter::IntLiteral(span: Span::empty(), name: "Size", value: bits! as! i64)
				],
				template_parameters_to_search: context.template_parameters_to_search,
				error_span: span
			)

			guard type.has_value() else {
				.module.error("invalid postfix for int literals", span)
				return Expr::Garbage(span, type: .program.void_type)
			}

			yield Expr::IntLiteral(span, type: type!, value, isSigned: false)
		}
	}

	fn checkFloatLiteralExpr(mut this, span: Span, value: f64, postfix: String, context: FunctionContext, desired_type: Type?) throws -> Expr => match postfix {
		"" => {
			if desired_type.has_value() and .program.isFloatType(type: desired_type!) {
				return Expr::FloatLiteral(span, type: desired_type!.base(), value)
			} else {
				let type = .getType(namespaces: [],
					name: "f64", template_parameters: [],
					template_parameters_to_search: context.template_parameters_to_search,
					error_span: span
				)
				return Expr::FloatLiteral(span, type: type!, value)
			}
		}
		else => {
			.module.error("float literal typechecking not fully implemented", span)
			yield Expr::Garbage(span, type: .program.void_type)
		}
	}

	fn checkCharLiteralExpr(mut this, span: Span, value: u8, postfix: String, context: FunctionContext) throws -> Expr => match postfix {
		"" => {
			.module.error("char literal typechecking not fully implemented", span)
			yield Expr::Garbage(span, type: .program.void_type)
		}
		"b" => Expr::IntLiteral(span, type: .program.byte_type, value: value as! i64, isSigned: false)
		"u8" => {
			let type = .getType(namespaces: [], name: postfix, template_parameters: [], template_parameters_to_search: context.template_parameters_to_search, error_span: span)
			guard type.has_value() else {
				return Expr::Garbage(span, type: .program.void_type)
			}
			yield Expr::IntLiteral(span, type: type!, value: value as! i64, isSigned: true)
		}
		else => {
			.module.error("invalid postfix for char literals", span)
			yield Expr::Garbage(span, type: .program.void_type)
		}
	}

	fn checkStringLiteralExpr(mut this, span: Span, value: String, context: FunctionContext) throws -> Expr {
		let type = .getType(namespaces: [], name: "String", template_parameters: [], template_parameters_to_search: context.template_parameters_to_search, error_span: span)
		guard type.has_value() else {
			return Expr::Garbage(span, type: .program.void_type)
		}
		return Expr::StringLiteral(span, type: type!, value)
	}

	fn checkEnumLiteral(mut this, span: Span, type: Type, case_name: String, mut context: FunctionContext) throws -> Expr {
		guard .program.types[type.id].kind is Enum(cases) else {
			.module.error("enum value access on non-enum type", span)
			return Expr::Garbage(span, type: .program.void_type)
		}

		mut case_id: i64? = None
		for c in cases {
			if c.name == case_name {
				case_id = c.id
				break
			}
		}

		guard case_id.has_value() else {
			.module.error("unknown variant case", span)
			return Expr::Garbage(span, type: .program.void_type)
		}

		return Expr::IntLiteral(span, type, value: case_id!, isSigned: true)
	}

	fn checkFunctionCall(mut this, span: Span, namespaces: [String], name: String, parsed_template_parameters: [ParsedTemplateParameter], arguments: [ParsedExpr], is_member_call: bool, is_binary_op: bool, context: FunctionContext) throws -> Expr {
		let template_parameters = .checkTemplateParameters(parsed_template_parameters, template_parameters_to_search: context.template_parameters_to_search)

		mut checked_args: [Expr] = []
		for i in 0..arguments.size() {
			let arg = arguments[i]
			if i == 0 and is_member_call {
				checked_args.push(.checkExpr(expr: arg, context, is_constructor_call: name == "constructor" or name == "operator ="))
			} else if i == 1 and is_binary_op {
				checked_args.push(.checkExpr(expr: arg, context, desired_type: checked_args[0].type))
			} else {
				checked_args.push(.checkExpr(expr: arg, context))
			}
		}

		mut param_types: [Type] = []
		for arg in checked_args {
			param_types.push(arg.type)
		}

		let parent_type: Type? = match is_member_call {
			true => checked_args[0].type
			else => None
		}

		if context.is_constructor and name == "operator =" and checked_args.size() == 2 {
			if removeDereference(checked_args[0]) is ReferenceMemberInvoke(object, member) {
				if removeDereference(object) is VarInvoke(var) and var.id == 0 and not context.initialized_members.contains(member.id) {
					return Expr::ReferenceMemberInit(span, type: .program.void_type, object, member, value: checked_args[1])
				}
			}
		}

		mut firstArgRefType: Type? = None
		if is_member_call {
			if checked_args[0] is Dereference(value) {
				firstArgRefType = value.type
			} else {
				firstArgRefType = checked_args[0].type
			}
		}

		let func = .getFunction(namespaces, name, parent_type, template_parameters, param_types, firstArgRefType, span)
		guard func.has_value() else {
			return Expr::Garbage(span, type: .program.void_type)
		}
		return .createCall(span, func: func!, args: checked_args, caller: context.body, is_member_call, name)
	}

	fn checkTemporaryVariable(mut this, span: Span, type: Type, arguments: [ParsedExpr], constructorTemplateParameters: [TemplateParameter], mut context: FunctionContext) throws -> Expr {
		mut checked_args: [Expr] = []
		for arg in arguments {
			checked_args.push(.checkExpr(expr: arg, context))
		}

		return .checkTemporaryVariable(span, type, arguments: checked_args, constructorTemplateParameters, context)
	}

	fn checkTemporaryVariable(mut this, span: Span, type: Type, arguments: [Expr], constructorTemplateParameters: [TemplateParameter], mut context: FunctionContext) throws -> Expr {
		let var = context.body.createVariable(span, is_const: true, name: "", type, init: None)

		let checked_object = Expr::VarInvoke(span, type: type.varRef(), var)

		mut checked_args: [Expr] = [checked_object]
		checked_args.push_values(&arguments)

		mut param_types: [Type] = []
		for arg in checked_args {
			param_types.push(arg.type)
		}

		mut firstArgRefType = checked_object.type
		if checked_object is Dereference(value) {
			firstArgRefType = value.type
		}

		let constructor_func = .getFunction(namespaces: [], name: "constructor", parent_type: type, template_parameters: constructorTemplateParameters, param_types, firstArgRefType, span)
		let destructor_func = .getFunction(namespaces: [], name: "destructor", parent_type: type, template_parameters: [], param_types: [checked_object.type], firstArgRefType, span)

		guard constructor_func.has_value() and destructor_func.has_value() else {
			return Expr::Garbage(span, type: .program.void_type)
		}

		let constructor_call = .createCall(span, func: constructor_func!, args: checked_args, caller: context.body, is_member_call: true)
		let destructor_call = .createCall(span, func: destructor_func!, args: [checked_object], caller: context.body, is_member_call: true)

		return Expr::Dereference(
			span, type,
			value: Expr::TempVariable(
				span, type: type.constRef(),
				constructor_call, var, destructor_call
			)
		)
	}

	fn checkVariantTemporaryVariable(mut this, span: Span, type: Type, case_name: String, arguments: [ParsedExpr], mut context: FunctionContext) throws -> Expr {
		guard .program.types[type.id].kind is Variant(cases) else {
			.module.error("variant value access on non-variant type", span)
			return Expr::Garbage(span, type: .program.void_type)
		}

		let variant_case = .program.getVariantCase(type, name: case_name)

		guard variant_case.has_value() else {
			.module.error("unknown variant case", span)
			return Expr::Garbage(span, type: .program.void_type)
		}

		mut checked_args: [Expr] = []
		for arg in arguments {
			if arguments.size() == 1 and not variant_case!.type.equals(other: .program.void_type) {
				checked_args.push(.checkExpr(expr: arg, context, desired_type: variant_case!.type))
			} else {
				checked_args.push(.checkExpr(expr: arg, context))
			}
		}

		return .checkTemporaryVariable(
			span, type, arguments: checked_args,
			constructorTemplateParameters: [TemplateParameter::IntLiteral(span: Span::empty(), name: "", value: variant_case!.id)],
			context
		)
	}

	fn checkVariantTemporaryVariable(mut this, span: Span, type: Type, case_name: String, arguments: [Expr], mut context: FunctionContext) throws -> Expr {
		guard .program.types[type.id].kind is Variant(cases) else {
			.module.error("variant value access on non-variant type", span)
			return Expr::Garbage(span, type: .program.void_type)
		}

		let c = .program.getVariantCase(type, name: case_name)

		guard c.has_value() else {
			.module.error("unknown variant case", span)
			return Expr::Garbage(span, type: .program.void_type)
		}

		return .checkTemporaryVariable(
			span, type, arguments,
			constructorTemplateParameters: [TemplateParameter::IntLiteral(span: Span::empty(), name: "", value: c!.id)],
			context
		)
	}

	fn checkValidateExpr(mut this, span: Span, expr: ParsedExpr, context: FunctionContext, kind: ValidationKind) throws -> Expr {
		let checked_expr = .checkExpr(expr, context, is_constructor_call: false)
		let temp_var_expr = .checkTemporaryVariable(span, type: checked_expr.type, arguments: [checked_expr], constructorTemplateParameters: [], context)
		guard temp_var_expr is Dereference(value: tmp) and tmp is TempVariable(var: var_id) else {
			panic("unreachable")
		}
		let var = Expr::Dereference(
			span, type: temp_var_expr.type,
			value: Expr::VarInvoke(span, type: temp_var_expr.type.constRef(), var: var_id)
		)

		let check_func = .getFunction(
			namespaces: [],
			name: "hasValue",
			parent_type: checked_expr.type,
			template_parameters: [],
			param_types: [checked_expr.type],
			firstArgRefType: None,
			span
		)

		let value_func = .getFunction(
			namespaces: [],
			name: "value",
			parent_type: checked_expr.type,
			template_parameters: [],
			param_types: [checked_expr.type],
			firstArgRefType: None,
			span
		)

		let error_func = .getFunction(
			namespaces: [],
			name: "error",
			parent_type: checked_expr.type,
			template_parameters: [],
			param_types: [checked_expr.type],
			firstArgRefType: None,
			span
		)

		guard check_func.has_value() and value_func.has_value() and error_func.has_value() else {
			.module.error("expression type must implement .hasValue(), .value() and .error()", span)
			return Expr::Garbage(span, type: .program.void_type)
		}

		let ok_type = .program.functions[value_func!.id].type.return_type

		let check_call = .createCall(span, func: check_func!, args: [var], caller: context.body, is_member_call: true)
		let value_call = removeDereference(.createCall(span, func: value_func!, args: [var], caller: context.body, is_member_call: true))
		let error_call = removeDereference(.createCall(span, func: error_func!, args: [var], caller: context.body, is_member_call: true))

		let abort_call: Expr? = match kind {
			Must => {
				let abort_func = .getFunction(
					namespaces: []
					name: "abort",
					parent_type: None,
					template_parameters: [],
					param_types: [],
					firstArgRefType: None,
					span
				)
				yield .createCall(span, func: abort_func!, args: [], caller: context.body, is_member_call: false)
			}
			else => None
		}

		let error_body = match kind {
			Try => CompoundStmt(span, children: [
				Stmt::Return(span, value: .checkVariantTemporaryVariable(
					span,
					type: context.return_type,
					case_name: "Error",
					arguments: [error_call],
					context
				), cleanup_list: [])
			], cleanup_list: [])
			Must => CompoundStmt(span, children: [
				Stmt::Expr(span, abort_call!)
			], cleanup_list: [])
		}

		let result = Expr::Validate(span, type: ok_type, var: temp_var_expr, check_call, value_call, error_body, kind)
		return match ok_type {
			Base => result
			else => Expr::Dereference(span, type: ok_type.base(), value: result)
		}
	}

	fn createCall(mut this, span: Span, func: Function, mut args: [Expr], mut caller: FunctionDeclBody, is_member_call: bool, name: String? = None) throws -> Expr {
		let func_decl = .program.functions[func.id]
		let func_type = func_decl.type
		let return_type = func_type.return_type

		for i in 0..args.size() {
			if args[i].type.id != func_type.param_types[i].id {
				let func = .getFunction(
					namespaces: [],
					name: "operator unwrap",
					parent_type: args[i].type,
					template_parameters: [],
					param_types: [args[i].type],
					firstArgRefType: match args[i] {
						Dereference(value) => value.type
						else => args[i].type
					},
					span: Span::empty(),
				)

				args[i] = .createCall(span: Span::empty(), func: func!, args: [args[i]], caller, is_member_call: true)
			}

			guard args[i].type.id == func_type.param_types[i].id else {
				.module.error("call with invalid parameter type", args[i].span)
				return Expr::Garbage(span, type: .program.void_type)
			}

			if i == 0 and is_member_call {
				let givenType = args[0].type
				let requiredType = func_type.param_types[0]

				if givenType is Base and not requiredType is Base {
					args[0] = removeDereference(args[0])
				}
			}
		}

		mut cleanup: (Variable, Expr)? = None
		if not .program.isPrimitive(type: return_type) {
			let var = caller.createVariable(span: Span::empty(), is_const: true, name: "", type: return_type, init: None)

			let args: [Expr] = [
				Expr::VarInvoke(
					span: Span::empty(),
					type: Type::VarRef(id: return_type.id),
					var: Variable(id: var.id)
				)
			]

			let param_types: [Type] = [Type::VarRef(id: return_type.id)]
			let parent_type = return_type

			let func = .getFunction(
				namespaces: [],
				name: "destructor",
				parent_type,
				template_parameters: [], param_types,
				firstArgRefType: None,
				span: Span::empty(),
			)

			let call = .createCall(span: Span::empty(), func: func!, args, caller, is_member_call: true)

			cleanup = (var, call)
		}

		mut result = Expr::Call(span, type: return_type, func, args, cleanup)
		if return_type is ConstRef or return_type is VarRef {
			result = Expr::Dereference(span, type: Type::Base(id: return_type.id), value: result)
		}
		
		if name.has_value() and name! != func_decl.name {
			if func_decl.name == "operator <=>" {
				let comp_func = match func_decl.parent_type.has_value() {
					true => .getFunction(namespaces: [], name: name!, parent_type: func_decl.parent_type!, template_parameters: [], param_types: [.program.int_type, .program.int_type], firstArgRefType: None, span)
					else => .getFunction(namespaces: [], name: name!, parent_type: None, template_parameters: [], param_types: [.program.int_type, .program.int_type], firstArgRefType: None, span)
				}
				return .createCall(span, func: comp_func!, args: [result, Expr::IntLiteral(span, type: .program.int_type, value: 0, isSigned: true)], caller, is_member_call)
			} else if func_decl.name == "operator ==" or func_decl.name == "operator !=" {
				let not_func = .getFunction(namespaces: [], name: "operator !", parent_type: .program.bool_type, template_parameters: [], param_types: [.program.bool_type], firstArgRefType: None, span)
				return .createCall(span, func: not_func!, args: [result], caller, is_member_call)
			} else {
				panic("cannot convert call")
			}
		}

		return result
	}

	fn createMemoryManagementCalls(mut this, mut stmt: Stmt, func: FunctionDeclBody) throws {
		match stmt {
			If(then_branch, else_branch) => {
				.createMemoryManagementCalls(stmt: then_branch, func)
				if else_branch.has_value() {
					.createMemoryManagementCalls(stmt: else_branch!, func)
				}
			}
			IfVar(body, var) => {
				mut var_decl = func.variables[var.id]
				var_decl.constructor_call = .createConstructorCall(var: func.variables[var.id], caller: func)
				if var_decl.type is Base {
					var_decl.destructor_call = .createDestructorCall(var: func.variables[var.id], caller: func)
				}

				.createMemoryManagementCalls(stmt: body, func)
			}
			VarElse(error_var, body, ok_var) => {
				if error_var.has_value() {
					mut error_var_decl = func.variables[error_var!.id]
					error_var_decl.constructor_call = .createConstructorCall(var: func.variables[error_var!.id], caller: func)
					if error_var_decl.type is Base {
						error_var_decl.destructor_call = .createDestructorCall(var: func.variables[error_var!.id], caller: func)
					}
				}

				.createMemoryManagementCalls(stmt: body, func)

				mut ok_var_decl = func.variables[ok_var.id]
				ok_var_decl.constructor_call = .createConstructorCall(var: func.variables[ok_var.id], caller: func)
				if ok_var_decl.type is Base {
					ok_var_decl.destructor_call = .createDestructorCall(var: func.variables[ok_var.id], caller: func)
				}
			}
			While(body) | DoWhile(body) => {
				.createMemoryManagementCalls(stmt: body, func)
			}
			Match(cases, else_branch) => {
				for c in cases {
					.createMemoryManagementCalls(stmt: c.body, func)
				}
				if else_branch.has_value() {
					.createMemoryManagementCalls(stmt: else_branch!, func)
				}
			}
			Compound(compoundStmt) => {
				.createMemoryManagementCalls(stmt: compoundStmt, func)
			}
			else => {}
		}
	}

	fn createMemoryManagementCalls(mut this, mut stmt: CompoundStmt, func: FunctionDeclBody) throws {
		for index in 0..stmt.children.size() {
			let child = stmt.children[index]
			if child is VarDecl(var) {
				mut var_decl = func.variables[var.id]
				var_decl.constructor_call = .createConstructorCall(var: func.variables[var.id], caller: func)
				if var_decl.type is Base {
					var_decl.destructor_call = .createDestructorCall(var: func.variables[var.id], caller: func)
				}
			} else {
				.createMemoryManagementCalls(stmt: stmt.children[index], func)
			}
		}
	}

	fn createConstructorCall(mut this, mut var: VarDecl, mut caller: FunctionDeclBody) throws -> Expr {
		if var.type is VarRef or var.type is ConstRef {
			guard var.init.has_value() else {
				.module.error("uninitialized reference variable", var.span)
				return Expr::Garbage(span: var.span, type: .program.void_type)
			}

			if var.init!.type is ConstRef and not var.is_const {
				.module.error("cannot store const reference in non-const variable", var.span)
				return Expr::Garbage(span: var.span, type: .program.void_type)
			}

			return Expr::ReferenceVarInit(span: var.span, type: .program.void_type, var: Variable(id: var.id), value: var.init!)
		} else {
			mut constructorArgs: [Expr] = [
				Expr::VarInvoke(
					span: Span::empty(),
					type: Type::VarRef(id: var.type.id),
					var: Variable(id: var.id)
				)
			]

			mut constructor: Function? = None

			if var.init.has_value() {
				if var.init! is Dereference(&mut value) and value is TempVariable(constructor_call, var) {
					guard constructor_call is Call(func, args) else {
						panic("invalid temp var")
					}

					if args.size() > 0 {
						for i in 1..args.size() {
							constructorArgs.push(args[i])
						}
					}

					constructor = func

					caller.variables[var.id].unused = true
				} else {
					if not .program.isPrimitive(type: var.type) and var.init! is Call(span, type, func, args) and var.type.equals(other: type) {
						var.init = Expr::Call(span, type, func, args, cleanup: None)
						return Expr::ShallowCopyInit(span: var.init!.span, type: .program.void_type, var: Variable(id: var.id), value: var.init!)
					} else {
						constructorArgs.push(var.init!)
					}
				}
			}

			mut param_types: [Type] = []
			for arg in constructorArgs {
				param_types.push(arg.type)
			}

			let parent_type = var.type

			if not constructor.has_value() {
				constructor = .getFunction(
					namespaces: [],
					name: "constructor",
					parent_type,
					template_parameters: [],
					param_types,
					firstArgRefType: None,
					span: Span::empty(),
				)
			}

			return .createCall(span: Span::empty(), func: constructor!, args: constructorArgs, caller, is_member_call: true)
		}
	}

	fn createDestructorCall(mut this, var: VarDecl, caller: FunctionDeclBody) throws -> Expr {
		let args: [Expr] = [
			Expr::VarInvoke(
				span: Span::empty(),
				type: Type::VarRef(id: var.type.id),
				var: Variable(id: var.id)
			)
		]

		let param_types: [Type] = [Type::VarRef(id: var.type.id)]
		let parent_type = var.type

		let func = .getFunction(
			namespaces: [],
			name: "destructor",
			parent_type,
			template_parameters: [], param_types,
			firstArgRefType: None,
			span: Span::empty(),
		)

		return .createCall(span: Span::empty(), func: func!, args, caller, is_member_call: true)
	}

	fn regroupDestructorCalls(mut this, func: FunctionDeclBody, mut stmt: CompoundStmt, function_cleanup_list: [Expr], loop_cleanup_list: [Expr]) throws {
		mut local_function_cleanup_list = cloneList<Expr>(list: function_cleanup_list)
		mut local_loop_cleanup_list = cloneList<Expr>(list: loop_cleanup_list)

		for i in 0..stmt.children.size() {
			match stmt.children[i] {
				VarDecl(var) => {
					mut var_decl = func.variables[var.id]
					if var_decl.destructor_call.has_value() {
						local_function_cleanup_list.insert(before_index: 0, value: var_decl.destructor_call!)
						local_loop_cleanup_list.insert(before_index: 0, value: var_decl.destructor_call!)
						stmt.cleanup_list.insert(before_index: 0, value: var_decl.destructor_call!)
					}
				}
				IfVar(var, temp_var, mut body) => {
					.regroupDestructorCalls(func, expr: temp_var, function_cleanup_list: local_function_cleanup_list, loop_cleanup_list: local_loop_cleanup_list)

					mut tmp_function_cleanup_list = cloneList<Expr>(list: local_function_cleanup_list)
					mut tmp_loop_cleanup_list = cloneList<Expr>(list: local_loop_cleanup_list)

					mut var_decl = func.variables[var.id]
					if var_decl.destructor_call.has_value() {
						tmp_function_cleanup_list.insert(before_index: 0, value: var_decl.destructor_call!)
						tmp_loop_cleanup_list.insert(before_index: 0, value: var_decl.destructor_call!)
						body.cleanup_list.insert(before_index: 0, value: var_decl.destructor_call!)
					}

					.regroupDestructorCalls(func, stmt: body, function_cleanup_list: tmp_function_cleanup_list, loop_cleanup_list: tmp_loop_cleanup_list)
				}
				VarElse(temp_var, error_var, body, ok_var) => {
					.regroupDestructorCalls(func, expr: temp_var, function_cleanup_list: local_function_cleanup_list, loop_cleanup_list: local_loop_cleanup_list)

					mut tmp_function_cleanup_list = cloneList<Expr>(local_function_cleanup_list)
					mut tmp_loop_cleanup_list = cloneList<Expr>(local_loop_cleanup_list)
					if error_var.has_value() {
						mut error_var_decl = func.variables[ok_var.id]
						tmp_function_cleanup_list.insert(before_index: 0, value: error_var_decl.destructor_call!)
						tmp_loop_cleanup_list.insert(before_index: 0, value: error_var_decl.destructor_call!)
					}

					.regroupDestructorCalls(func, stmt: body, function_cleanup_list: tmp_function_cleanup_list, loop_cleanup_list: tmp_loop_cleanup_list)

					mut ok_var_decl = func.variables[ok_var.id]
					if ok_var_decl.destructor_call.has_value() {
						local_function_cleanup_list.insert(before_index: 0, value: ok_var_decl.destructor_call!)
						local_loop_cleanup_list.insert(before_index: 0, value: ok_var_decl.destructor_call!)
						stmt.cleanup_list.insert(before_index: 0, value: ok_var_decl.destructor_call!)
					}
				}
				else => .regroupDestructorCalls(
					func, stmt: &mut stmt.children[i],
					function_cleanup_list: local_function_cleanup_list,
					loop_cleanup_list: local_loop_cleanup_list
				)
			}
		}

		if stmt.doesReturn(never_type: .program.never_type) {
			stmt.cleanup_list = []
		}
	}

	fn regroupDestructorCalls(mut this, mut func: FunctionDeclBody, stmt: &mut Stmt, function_cleanup_list: [Expr], loop_cleanup_list: [Expr]) throws {
		match stmt {
			Compound(compoundStmt) => {
				.regroupDestructorCalls(func, stmt: compoundStmt, function_cleanup_list, loop_cleanup_list)
			}
			If(condition, then_branch, &mut else_branch) => {
				.regroupDestructorCalls(func, expr: condition, function_cleanup_list, loop_cleanup_list)
				.regroupDestructorCalls(func, stmt: then_branch, function_cleanup_list, loop_cleanup_list)
				if else_branch.has_value() {
					.regroupDestructorCalls(func, stmt: &mut else_branch.value(), function_cleanup_list, loop_cleanup_list)
				}
			}
			While(condition, body, continue_expr) => {
				.regroupDestructorCalls(func, expr: condition, function_cleanup_list, loop_cleanup_list)
				.regroupDestructorCalls(func, stmt: body, function_cleanup_list, loop_cleanup_list: [])
				if continue_expr.has_value() {
					.regroupDestructorCalls(func, expr: continue_expr!, function_cleanup_list, loop_cleanup_list)
				}
			}
			DoWhile(body, condition) => {
				.regroupDestructorCalls(func, expr: condition, function_cleanup_list, loop_cleanup_list)
				.regroupDestructorCalls(func, stmt: body, function_cleanup_list, loop_cleanup_list: [])
			}
			Match(value, &mut cases, &mut else_branch) => {
				.regroupDestructorCalls(func, expr: value, function_cleanup_list, loop_cleanup_list)
				for c in cases {
					.regroupDestructorCalls(func, stmt: &mut c.body, function_cleanup_list, loop_cleanup_list)
				}

				if else_branch.has_value() {
					.regroupDestructorCalls(func, stmt: &mut else_branch.value(), function_cleanup_list, loop_cleanup_list)
				}
			}
			Continue(&mut cleanup_list) => {
				cleanup_list = cloneList<Expr>(list: loop_cleanup_list)
			}
			Break(&mut cleanup_list) => {
				cleanup_list = cloneList<Expr>(list: loop_cleanup_list)
			}
			Return(span, &mut value, &mut cleanup_list) => {
				if value.has_value() {
					.regroupDestructorCalls(func, expr: value!, function_cleanup_list, loop_cleanup_list)
				}

				cleanup_list = cloneList<Expr>(list: function_cleanup_list)

				if value.has_value() {
					mut tmp = removeDereference(value!)

					mut copyReturnValue = false

					if tmp is VarInvoke(var) {
						if func.variables[var.id].is_param and not .program.isPrimitive(type: func.variables[var.id].type) {
							copyReturnValue = true
						} else {
							// if the return value is a var-invoke expr,
							// don't call the destructor of that variable,
							// the caller should call the destructor of the returned value
							mut tmpCleanupList: [Expr] = []
							for call in cleanup_list {
								guard call is Call(args) else {
									panic("invalid cleanup_list")
								}

								guard args[0] is VarInvoke(var: other) else {
									panic("invalid destructor call")
								}

								if other.id != var.id {
									tmpCleanupList.push(call)
								}
							}
							cleanup_list = tmpCleanupList
						}
					} else if tmp is MemberAccess {
						copyReturnValue = true
					}

					// if the value is a member var invoke expr or a parameter return a copy to avoid double free
					if copyReturnValue and value!.type is Base {
						let type = value!.type
						let var = func.createVariable(span: Span::empty(), is_const: true, name: "", type, init: value!)
						let constructor_call = .createConstructorCall(var: func.variables[var.id], caller: func)

						value = Expr::Dereference(
							span: Span::empty(), type
							value: Expr::TempVariable(
								span: Span::empty(),
								type: Type::ConstRef(id: type.id),
								constructor_call, var,
								destructor_call: None
							)
						)
					}
				}
			}
			Discard(value) => {
				.regroupDestructorCalls(func, expr: value, function_cleanup_list, loop_cleanup_list)
			}
			Expr(expr) => {
				.regroupDestructorCalls(func, expr, function_cleanup_list, loop_cleanup_list)
			}
			else => {}
		}
	}

	fn regroupDestructorCalls(mut this, mut func: FunctionDeclBody, expr: Expr, function_cleanup_list: [Expr], loop_cleanup_list: [Expr]) throws {
		match expr {
			Call(args) => {
				for arg in args {
					.regroupDestructorCalls(func, expr: arg, function_cleanup_list, loop_cleanup_list)
				}
			}
			MemberAccess(object) => {
				.regroupDestructorCalls(func, expr: object, function_cleanup_list, loop_cleanup_list)
			}
			Dereference(value) => {
				.regroupDestructorCalls(func, expr: value, function_cleanup_list, loop_cleanup_list)
			}
			ReferenceVarInit(value) => {
				.regroupDestructorCalls(func, expr: value, function_cleanup_list, loop_cleanup_list)
			}
			ReferenceMemberInit(object, value) => {
				.regroupDestructorCalls(func, expr: object, function_cleanup_list, loop_cleanup_list)
				.regroupDestructorCalls(func, expr: value, function_cleanup_list, loop_cleanup_list)
			}
			ReferenceMemberInvoke(object) => {
				.regroupDestructorCalls(func, expr: object, function_cleanup_list, loop_cleanup_list)
			}
			Validate(error_body) => {
				.regroupDestructorCalls(func, stmt: error_body, function_cleanup_list, loop_cleanup_list)
			}
			ShallowCopyInit(value) => {
				.regroupDestructorCalls(func, expr: value, function_cleanup_list, loop_cleanup_list)
			}
			InlineIf(true_value, condition, false_value) => {
				.regroupDestructorCalls(func, expr: true_value, function_cleanup_list, loop_cleanup_list)
				.regroupDestructorCalls(func, expr: condition, function_cleanup_list, loop_cleanup_list)
				.regroupDestructorCalls(func, expr: false_value, function_cleanup_list, loop_cleanup_list)
			}
			else => {}
		}
	}

	fn getExprTypes(this, anon values: [Expr]) throws -> [Type] {
		mut result: [Type] = []
		for v in values {
			result.push(v.type)
		}
		return result
	}

	fn eval(mut this, expr: Expr) throws -> Expr => match expr {
		IntLiteral
		| StringLiteral => expr
		Call(span, func, args) => {
			mut built_args: [Expr] = []
			for arg in args {
				built_args.push(.eval(expr: arg))
			}
			yield .eval(func, args: built_args, span)
		}
		else => {
			.module.error("compile-time evaluation of expressions not yet fully implemented", span: expr.span)
			return Expr::Garbage(span: expr.span, type: .program.void_type)
		}
	}

	fn eval(mut this, func: Function, args: [Expr], span: Span) throws -> Expr {
		return match .program.functions[func.id].kind {
			InlineBuiltin(builtin) => .eval(func_id: func.id, builtin, args, span)
			else => {
				.module.error("compile-time evaluation of functions not yet implemented", span)
				return Expr::Garbage(span, type: .program.void_type)
			}
		}
	}

	fn eval(mut this, func_id: u64, builtin: InlineBuiltinFunction, args: [Expr], span: Span) throws -> Expr => match builtin {
		IsVarRef => {
			guard .program.functions[func_id].template_parameters[0] is Type(value) else { panic("invalid template parameter") }
			yield Expr::IntLiteral(span, type: .program.bool_type, value: match value! is VarRef {
				true => 1
				else => 0
			}, isSigned: false)
		}
		IsConstRef => {
			guard .program.functions[func_id].template_parameters[0] is Type(value) else { panic("invalid template parameter") }
			yield Expr::IntLiteral(span, type: .program.bool_type, value: match value! is ConstRef {
				true => 1
				else => 0
			}, isSigned: false)
		}
		else => {
			.module.error("compile-time evaluation of builtin functions not yet fully implemented", span)
			return Expr::Garbage(span, type: .program.void_type)
		}
	}

	fn createPtrTypeInstance(mut this, original: TypeDecl, template_parameters: [TemplateParameter], mut error_module: Module, error_span: Span) throws -> Type {
		guard template_parameters.size() == 1 else {
			.module.error("invalid template specialization for std::core::ptr<T>", span: error_span)
			return .program.void_type
		}

		guard template_parameters[0] is Type(value) else {
			.module.error("invalid template specialization for std::core::ptr<T>", span: error_span)
			return .program.void_type
		}

		guard value.has_value() else {
			.module.error("invalid template specialization for std::core::ptr<T>", span: error_span)
			return .program.void_type
		}

		guard original.kind is Builtin(builtin) and builtin is Pointer(is_const) else {
			panic("invalid ptr type instantiation")
		}

		return createPtrTypeInstance2(
			program: .program,
			module: .module,
			template_parameters,
			element_type: value!,
			is_const,
			opaque_ptr_type: match is_const {
				true => .program.cptr_type
				else => .program.vptr_type
			}
		)
	}

	fn createArrayTypeInstance(mut this, original: TypeDecl, template_parameters: [TemplateParameter], mut error_module: Module, error_span: Span) throws -> Type {
		guard template_parameters.size() == 2 else {
			.module.error("invalid template specialization for std::core::Array<T, S>", span: error_span)
			return .program.void_type
		}

		guard template_parameters[0] is Type(value: maybeElementType) and template_parameters[1] is IntLiteral(value: maybeSize) else {
			.module.error("invalid template specialization for std::core::Array<T, S>", span: error_span)
			return .program.void_type
		}

		guard maybeElementType.has_value() and maybeSize.has_value() else {
			.module.error("invalid template specialization for std::core::Array<T, S>", span: error_span)
			return .program.void_type
		}

		let element_type = maybeElementType!
		let size = maybeSize! as! u64

		guard size > 0 else {
			.module.error("invalid template specialization for std::core::Array<T, S>", span: error_span)
			return .program.void_type
		}

		let element_default_constructor = .getFunction(
			namespaces: [],
			name: "constructor",
			parent_type: element_type,
			template_parameters: [], param_types: [element_type.varRef()],
			firstArgRefType: None,
			span: Span::empty()
		)

		let element_copy_constructor = .getFunction(
			namespaces: [],
			name: "constructor",
			parent_type: element_type,
			template_parameters: [], param_types: [element_type.varRef(), element_type],
			firstArgRefType: None,
			span: Span::empty()
		)

		let element_op_assign = .getFunction(
			namespaces: [],
			name: "operator =",
			parent_type: element_type,
			template_parameters: [], param_types: [element_type.varRef(), element_type],
			firstArgRefType: None,
			span: Span::empty()
		)

		let element_destructor = .getFunction(
			namespaces: [],
			name: "destructor",
			parent_type: element_type,
			template_parameters: [], param_types: [element_type.varRef()],
			firstArgRefType: None,
			span: Span::empty()
		)

		guard element_default_constructor.has_value() else {
			.module.error("invalid template specialization for std::core::Array<T, S>", span: error_span)
			.module.error("    element-type must have a default constructor", span: Span::empty())
			return .program.void_type
		}

		guard element_copy_constructor.has_value() else {
			.module.error("invalid template specialization for std::core::Array<T, S>", span: error_span)
			.module.error("    element-type must have a copy constructor", span: Span::empty())
			return .program.void_type
		}

		guard element_op_assign.has_value() else {
			.module.error("invalid template specialization for std::core::Array<T, S>", span: error_span)
			.module.error("    element-type must have a assignment operator", span: Span::empty())
			return .program.void_type
		}

		guard element_destructor.has_value() else {
			.module.error("invalid template specialization for std::core::Array<T, S>", span: error_span)
			.module.error("    element-type must have a default constructor", span: Span::empty())
			return .program.void_type
		}

		let element_const_pointer_type = .getType(
			namespaces: [], name: "cptr",
			template_parameters: [
				TemplateParameter::Type(span: Span::empty(), name: "T", value: element_type)
			],
			template_parameters_to_search: template_parameters,
			error_span: Span::empty()
		)!

		let element_var_pointer_type = .getType(
			namespaces: [], name: "vptr",
			template_parameters: [
				TemplateParameter::Type(span: Span::empty(), name: "T", value: element_type)
			],
			template_parameters_to_search: template_parameters,
			error_span: Span::empty()
		)!

		let instance = createArrayTypeInstance2(
			program: .program,
			module: .module,
			error_span,
			template_parameters,
			element_type, size,
			element_const_pointer_type,
			element_var_pointer_type,
			element_default_constructor: element_default_constructor!
			element_copy_constructor: element_copy_constructor!
			element_op_assign: element_op_assign!
			element_destructor: element_destructor!
		)

		return instance
	}
}

fn initCoreModule(mut program: Program, mut module: Module) throws {
	program.void_type = module.createBuiltinType(
		name: "void", base: BuiltinType::Void, template_parameters: []
	)
	program.never_type = module.createBuiltinType(
		name: "never", base: BuiltinType::Void, template_parameters: []
	)

	createIntTypes(program, module)
	createFloatType(program, module, name: "f32", size: 32)
	createFloatType(program, module, name: "f64", size: 64)

	createPtrTypes(program, module)

	createReflectionFunctions(program, module)

	module.createExternFunction(parent_type: None, "exit", [program.int_type], program.never_type, "exit")
	module.createExternFunction(parent_type: None, "abort", [], program.never_type, "abort")

	module.createBuiltinFunction(
		parent_type: None,
		name: "intCast",
		param_types: [],
		return_type: program.void_type,
		body: InlineBuiltinFunction::IntCast(target: None, source: None),
		template_parameters: [
			TemplateParameter::Type(span: Span::empty(), name: "Target", value: None),
			TemplateParameter::Type(span: Span::empty(), name: "Source", value: None),
		]
	)

	module.createBuiltinFunction(
		parent_type: None,
		name: "floatCast",
		param_types: [],
		return_type: program.void_type,
		body: InlineBuiltinFunction::FloatCast(target: None, source: None),
		template_parameters: [
			TemplateParameter::Type(span: Span::empty(), name: "Target", value: None),
			TemplateParameter::Type(span: Span::empty(), name: "Source", value: None),
		]
	)

	module.createBuiltinFunction(
		parent_type: None,
		name: "intToFloat",
		param_types: [],
		return_type: program.void_type,
		body: InlineBuiltinFunction::IntToFloat(target: None, source: None),
		template_parameters: [
			TemplateParameter::Type(span: Span::empty(), name: "Target", value: None),
			TemplateParameter::Type(span: Span::empty(), name: "Source", value: None),
		]
	)

	module.createBuiltinFunction(
		parent_type: None,
		name: "floatToInt",
		param_types: [],
		return_type: program.void_type,
		body: InlineBuiltinFunction::FloatToInt(target: None, source: None),
		template_parameters: [
			TemplateParameter::Type(span: Span::empty(), name: "Target", value: None),
			TemplateParameter::Type(span: Span::empty(), name: "Source", value: None),
		]
	)

	module.createBuiltinFunction(
		parent_type: None,
		name: "ptrCast",
		param_types: [],
		return_type: program.void_type,
		body: InlineBuiltinFunction::PointerCast,
		template_parameters: [
			TemplateParameter::Type(span: Span::empty(), name: "Target", value: None),
			TemplateParameter::Type(span: Span::empty(), name: "Source", value: None),
		]
	)
}

fn initArrayModule(mut program: Program, mut module: Module) throws {
	createArrayType(program, module)
}

fn createIntTypes(mut program: Program, mut module: Module) throws {
	let bool_type = module.createBuiltinType(
		name: "bool", base: BuiltinType::Bool, template_parameters: []
	)
	program.bool_type = bool_type

	let int_template = module.createBuiltinType(
		name: "int", base: BuiltinType::SInt(size: None), template_parameters: [TemplateParameter::IntLiteral(span: Span::empty(), name: "Size", value: None)]
	)

	let uint_template = module.createBuiltinType(
		name: "uint", base: BuiltinType::UInt(size: None), template_parameters: [TemplateParameter::IntLiteral(span: Span::empty(), name: "Size", value: None)]
	)

	let int_type = module.createBuiltinType(
		name: "int", base: BuiltinType::ISize, template_parameters: []
	)
	program.int_type = int_type

	let uint_type = module.createBuiltinType(
		name: "uint", base: BuiltinType::USize, template_parameters: []
	)
	program.uint_type = uint_type

	let byte_type = module.createBuiltinType(
		name: "byte", base: BuiltinType::Byte, template_parameters: []
	)
	program.byte_type = byte_type

	// bool functions
	createPrimitiveFunctions(program, module, type: bool_type)

	module.createBuiltinFunction(bool_type, "operator ==", [bool_type, bool_type], bool_type, InlineBuiltinFunction::BitOpEQ(bool_type))
	module.createBuiltinFunction(bool_type, "operator !=", [bool_type, bool_type], bool_type, InlineBuiltinFunction::BitOpNE(bool_type))
	module.createBuiltinFunction(bool_type, "operator <=>", [bool_type, bool_type], program.int_type, InlineBuiltinFunction::UIntOpCmp(bool_type))

	module.createBuiltinFunction(bool_type, "operator &&", [bool_type, bool_type], bool_type, InlineBuiltinFunction::BitOpAnd(bool_type))
	module.createBuiltinFunction(bool_type, "operator ||", [bool_type, bool_type], bool_type, InlineBuiltinFunction::BitOpOr(bool_type))
	module.createBuiltinFunction(bool_type, "operator ^", [bool_type, bool_type], bool_type, InlineBuiltinFunction::BitOpXOr(bool_type))
	module.createBuiltinFunction(bool_type, "operator !", [bool_type], bool_type, InlineBuiltinFunction::BitOpNot(bool_type))

	module.createBuiltinFunction(bool_type, "operator &=", [bool_type.varRef(), bool_type], program.void_type, InlineBuiltinFunction::BitOpAndAssign(bool_type))
	module.createBuiltinFunction(bool_type, "operator |=", [bool_type.varRef(), bool_type], program.void_type, InlineBuiltinFunction::BitOpOrAssign(bool_type))
	module.createBuiltinFunction(bool_type, "operator ^=", [bool_type.varRef(), bool_type], program.void_type, InlineBuiltinFunction::BitOpXOrAssign(bool_type))

	// byte functions
	createPrimitiveFunctions(program, module, type: byte_type)

	module.createBuiltinFunction(byte_type, "operator ==", [byte_type, byte_type], program.bool_type, InlineBuiltinFunction::UIntOpEQ(byte_type))
	module.createBuiltinFunction(byte_type, "operator !=", [byte_type, byte_type], program.bool_type, InlineBuiltinFunction::UIntOpNE(byte_type))
	module.createBuiltinFunction(byte_type, "operator <" , [byte_type, byte_type], program.bool_type, InlineBuiltinFunction::UIntOpLT(byte_type))
	module.createBuiltinFunction(byte_type, "operator <=", [byte_type, byte_type], program.bool_type, InlineBuiltinFunction::UIntOpLE(byte_type))
	module.createBuiltinFunction(byte_type, "operator >" , [byte_type, byte_type], program.bool_type, InlineBuiltinFunction::UIntOpGT(byte_type))
	module.createBuiltinFunction(byte_type, "operator >=", [byte_type, byte_type], program.bool_type, InlineBuiltinFunction::UIntOpGE(byte_type))
	module.createBuiltinFunction(byte_type, "operator <=>", [byte_type, byte_type], program.int_type, InlineBuiltinFunction::UIntOpCmp(byte_type))

	createBitwiseOperators(program, module, type: byte_type)

	// int functions
	createPrimitiveFunctions(program, module, type: int_type)
	createBitwiseOperators(program, module, type: int_type)
	createSIntTypeMemberFunctions(program, module, int_type: int_type)

	createPrimitiveFunctions(program, module, type: uint_type)
	createBitwiseOperators(program, module, type: uint_type)
	createUIntTypeMemberFunctions(program, module, int_type: uint_type)
}

fn createSIntInstance(mut program: Program, mut module: Module, size: u64) throws -> Type {
	let instance = module.createBuiltinType(
		name: "int", base: BuiltinType::SInt(size), template_parameters: [TemplateParameter::IntLiteral(span: Span::empty(), name: "Size", value: size as! i64)]
	)

	createPrimitiveFunctions(program, module, type: instance)
	createBitwiseOperators(program, module, type: instance)
	createSIntTypeMemberFunctions(program, module, int_type: instance)

	return instance
}

fn createUIntInstance(mut program: Program, mut module: Module, size: u64) throws -> Type {
	let instance = module.createBuiltinType(
		name: "uint", base: BuiltinType::UInt(size), template_parameters: [TemplateParameter::IntLiteral(span: Span::empty(), name: "Size", value: size as! i64)]
	)

	createPrimitiveFunctions(program, module, type: instance)
	createBitwiseOperators(program, module, type: instance)
	createUIntTypeMemberFunctions(program, module, int_type: instance)

	return instance
}

fn createFloatType(mut program: Program, mut module: Module, name: String, size: u64) throws {
	let float_type = module.createBuiltinType(
		name, base: BuiltinType::Float(size), template_parameters: []
	)

	createPrimitiveFunctions(program, module, type: float_type)

	module.createBuiltinFunction(float_type, "operator ==", [float_type, float_type], program.bool_type, InlineBuiltinFunction::FloatOpEQ(float_type))
	module.createBuiltinFunction(float_type, "operator !=", [float_type, float_type], program.bool_type, InlineBuiltinFunction::FloatOpNE(float_type))
	module.createBuiltinFunction(float_type, "operator <" , [float_type, float_type], program.bool_type, InlineBuiltinFunction::FloatOpLT(float_type))
	module.createBuiltinFunction(float_type, "operator <=", [float_type, float_type], program.bool_type, InlineBuiltinFunction::FloatOpLE(float_type))
	module.createBuiltinFunction(float_type, "operator >" , [float_type, float_type], program.bool_type, InlineBuiltinFunction::FloatOpGT(float_type))
	module.createBuiltinFunction(float_type, "operator >=", [float_type, float_type], program.bool_type, InlineBuiltinFunction::FloatOpGE(float_type))
	module.createBuiltinFunction(float_type, "operator <=>", [float_type, float_type], program.int_type, InlineBuiltinFunction::FloatOpCmp(float_type))

	module.createBuiltinFunction(float_type, "operator +", [float_type, float_type], float_type, InlineBuiltinFunction::FloatOpAdd(float_type))
	module.createBuiltinFunction(float_type, "operator -", [float_type, float_type], float_type, InlineBuiltinFunction::FloatOpSub(float_type))
	module.createBuiltinFunction(float_type, "operator *", [float_type, float_type], float_type, InlineBuiltinFunction::FloatOpMul(float_type))
	module.createBuiltinFunction(float_type, "operator /", [float_type, float_type], float_type, InlineBuiltinFunction::FloatOpDiv(float_type))
	module.createBuiltinFunction(float_type, "operator %", [float_type, float_type], float_type, InlineBuiltinFunction::FloatOpMod(float_type))

	module.createBuiltinFunction(float_type, "operator -", [float_type], float_type, InlineBuiltinFunction::FloatOpNeg(float_type))

	module.createBuiltinFunction(float_type, "operator +=", [float_type.varRef(), float_type], program.void_type, InlineBuiltinFunction::FloatOpAddAssign(float_type))
	module.createBuiltinFunction(float_type, "operator -=", [float_type.varRef(), float_type], program.void_type, InlineBuiltinFunction::FloatOpSubAssign(float_type))
	module.createBuiltinFunction(float_type, "operator *=", [float_type.varRef(), float_type], program.void_type, InlineBuiltinFunction::FloatOpMulAssign(float_type))
	module.createBuiltinFunction(float_type, "operator /=", [float_type.varRef(), float_type], program.void_type, InlineBuiltinFunction::FloatOpDivAssign(float_type))
	module.createBuiltinFunction(float_type, "operator %=", [float_type.varRef(), float_type], program.void_type, InlineBuiltinFunction::FloatOpModAssign(float_type))
}

fn createPtrTypes(mut program: Program, mut module: Module) throws {
	createOpaquePtrType(program, module, is_const: true)
	createOpaquePtrType(program, module, is_const: false)

	let constPtrType = module.createBuiltinType(
		name: "cptr",
		base: BuiltinType::Pointer(element_type: None, is_const: true),
		template_parameters: [
			TemplateParameter::Type(span: Span(start: 0, end: 0), name: "T", value: None)
		]
	)

	let varPtrType = module.createBuiltinType(
		name: "vptr",
		base: BuiltinType::Pointer(element_type: None, is_const: false),
		template_parameters: [
			TemplateParameter::Type(span: Span(start: 0, end: 0), name: "T", value: None)
		]
	)

	module.createBuiltinFunction(None, "memset", [], program.void_type, InlineBuiltinFunction::Memset(None), template_parameters: [TemplateParameter::Type(span: Span::empty(), name: "T", value: None)])
	module.createBuiltinFunction(None, "memcpy", [], program.void_type, InlineBuiltinFunction::Memcpy(None), template_parameters: [TemplateParameter::Type(span: Span::empty(), name: "T", value: None)])
	module.createBuiltinFunction(None, "memmove", [], program.void_type, InlineBuiltinFunction::Memmove(None), template_parameters: [TemplateParameter::Type(span: Span::empty(), name: "T", value: None)])
}

fn createOpaquePtrType(mut program: Program, mut module: Module, is_const: bool) throws {
	let ptr_type = module.createBuiltinType(
		name: match is_const {
			true => "cptr"
			else => "vptr"
		}, base: BuiltinType::OpaquePointer(is_const), template_parameters: []
	)

	if is_const {
		program.cptr_type = ptr_type
	} else {
		program.vptr_type = ptr_type
	}

	createPrimitiveFunctions(program, module, type: ptr_type)

	module.createBuiltinFunction(ptr_type, "operator ==", [ptr_type, ptr_type], program.bool_type, InlineBuiltinFunction::PointerOpEQ)
	module.createBuiltinFunction(ptr_type, "operator !=", [ptr_type, ptr_type], program.bool_type, InlineBuiltinFunction::PointerOpNE)
	module.createBuiltinFunction(ptr_type, "operator <" , [ptr_type, ptr_type], program.bool_type, InlineBuiltinFunction::PointerOpLT)
	module.createBuiltinFunction(ptr_type, "operator <=", [ptr_type, ptr_type], program.bool_type, InlineBuiltinFunction::PointerOpLE)
	module.createBuiltinFunction(ptr_type, "operator >" , [ptr_type, ptr_type], program.bool_type, InlineBuiltinFunction::PointerOpGT)
	module.createBuiltinFunction(ptr_type, "operator >=", [ptr_type, ptr_type], program.bool_type, InlineBuiltinFunction::PointerOpGE)
	module.createBuiltinFunction(ptr_type, "operator <=>", [ptr_type, ptr_type], program.int_type, InlineBuiltinFunction::PointerOpCmp)
	module.createBuiltinFunction(ptr_type, "null", [], ptr_type, InlineBuiltinFunction::PointerGetNull)

}

fn createPtrTypeInstance2(mut program: Program, mut module: Module, template_parameters: [TemplateParameter], element_type: Type, is_const: bool, opaque_ptr_type: Type) throws -> Type {
	let instance = module.createBuiltinType(
		name: match is_const {
			true => "cptr"
			else => "vptr"
		},
		base: BuiltinType::Pointer(element_type, is_const),
		template_parameters
	)

	module.createBuiltinFunction(instance, "constructor", [instance.varRef()], program.void_type, InlineBuiltinFunction::PrimitiveNullConstructor(instance))
	module.createBuiltinFunction(instance, "constructor", [instance.varRef(), instance], program.void_type, InlineBuiltinFunction::PrimitiveCopyConstructor(instance))
	module.createBuiltinFunction(instance, "operator =", [instance.varRef(), instance], program.void_type, InlineBuiltinFunction::PrimitiveOpAssign(instance))
	module.createBuiltinFunction(instance, "destructor", [instance.varRef()], program.void_type, InlineBuiltinFunction::PrimitiveDestructor)

	module.createBuiltinFunction(instance, "operator ==", [instance, instance], program.bool_type, InlineBuiltinFunction::PointerOpEQ)
	module.createBuiltinFunction(instance, "operator !=", [instance, instance], program.bool_type, InlineBuiltinFunction::PointerOpNE)
	module.createBuiltinFunction(instance, "operator <" , [instance, instance], program.bool_type, InlineBuiltinFunction::PointerOpLT)
	module.createBuiltinFunction(instance, "operator <=", [instance, instance], program.bool_type, InlineBuiltinFunction::PointerOpLE)
	module.createBuiltinFunction(instance, "operator >" , [instance, instance], program.bool_type, InlineBuiltinFunction::PointerOpGT)
	module.createBuiltinFunction(instance, "operator >=", [instance, instance], program.bool_type, InlineBuiltinFunction::PointerOpGE)
	module.createBuiltinFunction(instance, "operator <=>", [instance, instance], program.int_type, InlineBuiltinFunction::PointerOpCmp)

	module.createBuiltinFunction(instance, "operator ==", [instance, opaque_ptr_type], program.bool_type, InlineBuiltinFunction::PointerOpEQ)
	module.createBuiltinFunction(instance, "operator !=", [instance, opaque_ptr_type], program.bool_type, InlineBuiltinFunction::PointerOpNE)
	module.createBuiltinFunction(instance, "operator <" , [instance, opaque_ptr_type], program.bool_type, InlineBuiltinFunction::PointerOpLT)
	module.createBuiltinFunction(instance, "operator <=", [instance, opaque_ptr_type], program.bool_type, InlineBuiltinFunction::PointerOpLE)
	module.createBuiltinFunction(instance, "operator >" , [instance, opaque_ptr_type], program.bool_type, InlineBuiltinFunction::PointerOpGT)
	module.createBuiltinFunction(instance, "operator >=", [instance, opaque_ptr_type], program.bool_type, InlineBuiltinFunction::PointerOpGE)
	module.createBuiltinFunction(instance, "operator <=>", [instance, opaque_ptr_type], program.int_type, InlineBuiltinFunction::PointerOpCmp)

	module.createBuiltinFunction(instance, "operator -", [instance, instance], program.int_type, InlineBuiltinFunction::PointerDiff(element_type))
	module.createBuiltinFunction(instance, "operator +", [instance, program.int_type], instance, InlineBuiltinFunction::PointerOffset(element_type))
	module.createBuiltinFunction(instance, "operator +", [instance, program.uint_type], instance, InlineBuiltinFunction::PointerOffset(element_type))

	if is_const {
		module.createBuiltinFunction(instance, "value", [instance], element_type.constRef(), InlineBuiltinFunction::PointerToRef)
		module.createBuiltinFunction(instance, "addressOf", [element_type.constRef()], instance, InlineBuiltinFunction::RefToPointer)
		module.createBuiltinFunction(instance, "operator []", [instance, program.int_type], element_type.constRef(), InlineBuiltinFunction::PointerOpIndex(element_type))
		module.createBuiltinFunction(instance, "operator []", [instance, program.uint_type], element_type.constRef(), InlineBuiltinFunction::PointerOpIndex(element_type))
	} else {
		module.createBuiltinFunction(instance, "value", [instance], element_type.varRef(), InlineBuiltinFunction::PointerToRef)
		module.createBuiltinFunction(instance, "addressOf", [element_type.varRef()], instance, InlineBuiltinFunction::RefToPointer)
		module.createBuiltinFunction(instance, "operator []", [instance, program.int_type], element_type.varRef(), InlineBuiltinFunction::PointerOpIndex(element_type))
		module.createBuiltinFunction(instance, "operator []", [instance, program.uint_type], element_type.varRef(), InlineBuiltinFunction::PointerOpIndex(element_type))
	}

	return instance
}

fn createArrayType(mut program: Program, mut module: Module) throws {
	let rangeType = module.createBuiltinType(
		name: "Array",
		base: BuiltinType::Array(element_type: None, size: None),
		template_parameters: [
			TemplateParameter::Type(span: Span::empty(), name: "T", value: None),
			TemplateParameter::IntLiteral(span: Span::empty(), name: "Size", value: None),
		]
	)
}

fn createArrayTypeInstance2(mut program: Program, mut module: Module, error_span: Span
	template_parameters: [TemplateParameter]
	element_type: Type, size: u64
	element_const_pointer_type: Type
	element_var_pointer_type: Type
	element_default_constructor: Function
	element_copy_constructor: Function
	element_op_assign: Function
	element_destructor: Function) throws -> Type {
	let instance = module.createBuiltinType(
		name: "Array",
		base:  BuiltinType::Array(element_type, size),
		template_parameters
	)

	if element_type is Base {
		if program.typeContainsOther(type: element_type, other: instance) {
			module.error("dependency cycle in type declaration, use a reference or heap-allocated type instead", error_span)
		}

		program.types[instance.id].contained_types.add(element_type.id)
	}

	mut valueConstructorArgTypes: [Type] = [instance.varRef()]
	for i in 0..size {
		valueConstructorArgTypes.push(element_type)
	}

	module.createBuiltinFunction(parent_type: instance, "constructor", [instance.varRef()], program.void_type, BuiltinFunction::ArrayDefaultConstructor(instance, element_type, size, element_default_constructor))
	module.createBuiltinFunction(parent_type: instance, "constructor", [instance.varRef(), instance], program.void_type, BuiltinFunction::ArrayCopyConstructor(instance, element_type, size, element_copy_constructor))
	module.createBuiltinFunction(parent_type: instance, "constructor", valueConstructorArgTypes, program.void_type, BuiltinFunction::ArrayValueConstructor(instance, element_type, size, element_copy_constructor))
	module.createBuiltinFunction(parent_type: instance, "operator =", [instance.varRef(), instance], program.void_type, BuiltinFunction::ArrayOpAssign(instance, element_type, size, element_op_assign))
	module.createBuiltinFunction(parent_type: instance, "destructor", [instance.varRef()], program.void_type, BuiltinFunction::ArrayDestructor(instance, element_type, size, element_destructor))

	module.createBuiltinFunction(parent_type: instance, "size", [instance.constRef()], program.uint_type, InlineBuiltinFunction::ArrayGetSize(instance, element_type, size))
	module.createBuiltinFunction(parent_type: instance, "data", [instance.constRef()], element_const_pointer_type, InlineBuiltinFunction::ArrayGetDataPointer(instance, element_type, size))
	module.createBuiltinFunction(parent_type: instance, "data", [instance.varRef()], element_var_pointer_type, InlineBuiltinFunction::ArrayGetDataPointer(instance, element_type, size))

	return instance
}

fn createReflectionFunctions(mut program: Program, mut module: Module) throws {
	module.createBuiltinFunction(
		parent_type: None,
		"sizeOf", [], program.uint_type,
		InlineBuiltinFunction::SizeOf(None),
		template_parameters: [TemplateParameter::Type(span: Span(start: 0, end: 0), name: "T", value: None)]
	)

	module.createBuiltinFunction(
		parent_type: None,
		"alignmentOf", [], program.uint_type,
		InlineBuiltinFunction::AlignmentOf(None),
		template_parameters: [TemplateParameter::Type(span: Span(start: 0, end: 0), name: "T", value: None)]
	)

	module.createBuiltinFunction(
		parent_type: None,
		"isVarRef", [], program.bool_type,
		InlineBuiltinFunction::IsVarRef(None),
		template_parameters: [TemplateParameter::Type(span: Span(start: 0, end: 0), name: "T", value: None)]
	)

	module.createBuiltinFunction(
		parent_type: None,
		"isConstRef", [], program.bool_type,
		InlineBuiltinFunction::IsConstRef(None),
		template_parameters: [TemplateParameter::Type(span: Span(start: 0, end: 0), name: "T", value: None)]
	)
}

fn createPrimitiveFunctions(mut program: Program, mut module: Module, type: Type) throws {
	module.createBuiltinFunction(type, "constructor", [type.varRef()], program.void_type, InlineBuiltinFunction::PrimitiveNullConstructor(type))
	module.createBuiltinFunction(type, "constructor", [type.varRef(), type], program.void_type, InlineBuiltinFunction::PrimitiveCopyConstructor(type))
	module.createBuiltinFunction(type, "operator =", [type.varRef(), type], program.void_type, InlineBuiltinFunction::PrimitiveOpAssign(type))
	module.createBuiltinFunction(type, "destructor", [type.varRef()], program.void_type, InlineBuiltinFunction::PrimitiveDestructor)
}

fn createBitwiseOperators(mut program: Program, mut module: Module, type: Type) throws {
	module.createBuiltinFunction(type, "operator &", [type, type], type, InlineBuiltinFunction::BitOpAnd(type))
	module.createBuiltinFunction(type, "operator |", [type, type], type, InlineBuiltinFunction::BitOpOr(type))
	module.createBuiltinFunction(type, "operator ^", [type, type], type, InlineBuiltinFunction::BitOpXOr(type))
	module.createBuiltinFunction(type, "operator <<", [type, type], type, InlineBuiltinFunction::BitOpShl(type))
	module.createBuiltinFunction(type, "operator >>", [type, type], type, InlineBuiltinFunction::BitOpLShr(type))

	module.createBuiltinFunction(type, "operator ~", [type], type, InlineBuiltinFunction::BitOpNot(type))

	module.createBuiltinFunction(type, "operator &=", [type.varRef(), type], program.void_type, InlineBuiltinFunction::BitOpAndAssign(type))
	module.createBuiltinFunction(type, "operator |=", [type.varRef(), type], program.void_type, InlineBuiltinFunction::BitOpOrAssign(type))
	module.createBuiltinFunction(type, "operator ^=", [type.varRef(), type], program.void_type, InlineBuiltinFunction::BitOpXOrAssign(type))
	module.createBuiltinFunction(type, "operator <<=", [type.varRef(), type], program.void_type, InlineBuiltinFunction::BitOpShlAssign(type))
	module.createBuiltinFunction(type, "operator >>=", [type.varRef(), type], program.void_type, InlineBuiltinFunction::BitOpAShrAssign(type))
}

fn createSIntTypeMemberFunctions(mut program: Program, mut module: Module, int_type: Type) throws {
	module.createBuiltinFunction(int_type, "operator ==", [int_type, int_type], program.bool_type, InlineBuiltinFunction::SIntOpEQ(int_type))
	module.createBuiltinFunction(int_type, "operator !=", [int_type, int_type], program.bool_type, InlineBuiltinFunction::SIntOpNE(int_type))
	module.createBuiltinFunction(int_type, "operator <" , [int_type, int_type], program.bool_type, InlineBuiltinFunction::SIntOpLT(int_type))
	module.createBuiltinFunction(int_type, "operator <=", [int_type, int_type], program.bool_type, InlineBuiltinFunction::SIntOpLE(int_type))
	module.createBuiltinFunction(int_type, "operator >" , [int_type, int_type], program.bool_type, InlineBuiltinFunction::SIntOpGT(int_type))
	module.createBuiltinFunction(int_type, "operator >=", [int_type, int_type], program.bool_type, InlineBuiltinFunction::SIntOpGE(int_type))
	module.createBuiltinFunction(int_type, "operator <=>", [int_type, int_type], program.int_type, InlineBuiltinFunction::SIntOpCmp(int_type))

	module.createBuiltinFunction(int_type, "operator +", [int_type, int_type], int_type, InlineBuiltinFunction::SIntOpAdd(int_type))
	module.createBuiltinFunction(int_type, "operator -", [int_type, int_type], int_type, InlineBuiltinFunction::SIntOpSub(int_type))
	module.createBuiltinFunction(int_type, "operator *", [int_type, int_type], int_type, InlineBuiltinFunction::SIntOpMul(int_type))
	module.createBuiltinFunction(int_type, "operator /", [int_type, int_type], int_type, InlineBuiltinFunction::SIntOpDiv(int_type))
	module.createBuiltinFunction(int_type, "operator %", [int_type, int_type], int_type, InlineBuiltinFunction::SIntOpMod(int_type))

	module.createBuiltinFunction(int_type, "operator -", [int_type], int_type, InlineBuiltinFunction::SIntOpNeg(int_type))
	module.createBuiltinFunction(int_type, "operator ++", [int_type.varRef()], program.void_type, InlineBuiltinFunction::SIntOpInc(int_type))
	module.createBuiltinFunction(int_type, "operator --", [int_type.varRef()], program.void_type, InlineBuiltinFunction::SIntOpDec(int_type))

	module.createBuiltinFunction(int_type, "operator +=", [int_type.varRef(), int_type], program.void_type, InlineBuiltinFunction::SIntOpAddAssign(int_type))
	module.createBuiltinFunction(int_type, "operator -=", [int_type.varRef(), int_type], program.void_type, InlineBuiltinFunction::SIntOpSubAssign(int_type))
	module.createBuiltinFunction(int_type, "operator *=", [int_type.varRef(), int_type], program.void_type, InlineBuiltinFunction::SIntOpMulAssign(int_type))
	module.createBuiltinFunction(int_type, "operator /=", [int_type.varRef(), int_type], program.void_type, InlineBuiltinFunction::SIntOpDivAssign(int_type))
	module.createBuiltinFunction(int_type, "operator %=", [int_type.varRef(), int_type], program.void_type, InlineBuiltinFunction::SIntOpModAssign(int_type))
}

fn createUIntTypeMemberFunctions(mut program: Program, mut module: Module, int_type: Type) throws {
	module.createBuiltinFunction(int_type, "operator ==", [int_type, int_type], program.bool_type, InlineBuiltinFunction::UIntOpEQ(int_type))
	module.createBuiltinFunction(int_type, "operator !=", [int_type, int_type], program.bool_type, InlineBuiltinFunction::UIntOpNE(int_type))
	module.createBuiltinFunction(int_type, "operator <" , [int_type, int_type], program.bool_type, InlineBuiltinFunction::UIntOpLT(int_type))
	module.createBuiltinFunction(int_type, "operator <=", [int_type, int_type], program.bool_type, InlineBuiltinFunction::UIntOpLE(int_type))
	module.createBuiltinFunction(int_type, "operator >" , [int_type, int_type], program.bool_type, InlineBuiltinFunction::UIntOpGT(int_type))
	module.createBuiltinFunction(int_type, "operator >=", [int_type, int_type], program.bool_type, InlineBuiltinFunction::UIntOpGE(int_type))
	module.createBuiltinFunction(int_type, "operator <=>", [int_type, int_type], program.int_type, InlineBuiltinFunction::UIntOpCmp(int_type))

	module.createBuiltinFunction(int_type, "operator +", [int_type, int_type], int_type, InlineBuiltinFunction::UIntOpAdd(int_type))
	module.createBuiltinFunction(int_type, "operator -", [int_type, int_type], int_type, InlineBuiltinFunction::UIntOpSub(int_type))
	module.createBuiltinFunction(int_type, "operator *", [int_type, int_type], int_type, InlineBuiltinFunction::UIntOpMul(int_type))
	module.createBuiltinFunction(int_type, "operator /", [int_type, int_type], int_type, InlineBuiltinFunction::UIntOpDiv(int_type))
	module.createBuiltinFunction(int_type, "operator %", [int_type, int_type], int_type, InlineBuiltinFunction::UIntOpMod(int_type))

	module.createBuiltinFunction(int_type, "operator ++", [int_type.varRef()], program.void_type, InlineBuiltinFunction::UIntOpInc(int_type))
	module.createBuiltinFunction(int_type, "operator --", [int_type.varRef()], program.void_type, InlineBuiltinFunction::UIntOpDec(int_type))

	module.createBuiltinFunction(int_type, "operator +=", [int_type.varRef(), int_type], program.void_type, InlineBuiltinFunction::UIntOpAddAssign(int_type))
	module.createBuiltinFunction(int_type, "operator -=", [int_type.varRef(), int_type], program.void_type, InlineBuiltinFunction::UIntOpSubAssign(int_type))
	module.createBuiltinFunction(int_type, "operator *=", [int_type.varRef(), int_type], program.void_type, InlineBuiltinFunction::UIntOpMulAssign(int_type))
	module.createBuiltinFunction(int_type, "operator /=", [int_type.varRef(), int_type], program.void_type, InlineBuiltinFunction::UIntOpDivAssign(int_type))
	module.createBuiltinFunction(int_type, "operator %=", [int_type.varRef(), int_type], program.void_type, InlineBuiltinFunction::UIntOpModAssign(int_type))
}
