import utility { FileInfo, Span }

struct ParsedModule {
	name: String
	imports: [ParsedImport]
	pragmas: [String]
	types: [ParsedTypeDecl]
	functions: [ParsedFunctionDecl]
	file: FileInfo

	fn dump(this, indent: String) throws -> String {
		mut result = ""
		result += format("{}module {} ({})\n", indent, .name, .file.path)

		for i in .imports {
			result += i.dump(indent: indent + "  ")
		}

		for type in .types {
			result += type.dump(indent: indent + "  ")
		}

		for func in .functions {
			result += func.dump(indent: indent + "  ")
		}

		return result
	}
}

struct ParsedImport {
	name: String
	span: Span

	fn dump(this, indent: String) throws -> String {
		return format("{}import {} {}\n", indent, .name, .span.format())
	}
}

struct ParsedTemplateParameterDecl {
	span: Span
	name: String
	type: ParsedType
	value: ParsedTemplateParameter?
}

enum ParsedAnnotation {
	span: Span
	name: String

	Flag
	Int(value: i64)
	String(value: String)
}

enum ParsedTypeDecl {
	span: Span
	name: String
	member_variables: [ParsedVarDecl]
	member_functions: [ParsedFunctionDecl]
	template_parameters: [ParsedTemplateParameterDecl]
	annotations: [ParsedAnnotation]

	Struct
	Enum(id_type: ParsedType?, cases: [ParsedEnumCaseDecl])
	Variant(id_type: ParsedType?, cases: [ParsedVariantCaseDecl])
	Alias(target: ParsedType)
	Extension

	fn dump(this, indent: String) throws -> String {
		mut result = indent
		result += match this {
			Struct => "struct "
			Enum => "enum "
			Variant => "variant "
			Alias => "alias "
			Extension => "alias "
		}
		result += .name + " " + .span.format() + "\n"

		for var in .member_variables {
			result += var.dump(indent: indent + "  ")
		}

		for func in .member_functions {
			result += func.dump(indent: indent + "  ")
		}

		return result
	}
}

struct ParsedFunctionDecl {
	span: Span
	name: String
	parameters: [ParsedFunctionParameterDecl]
	return_type: ParsedType?
	body: ParsedStmt
	template_parameters: [ParsedTemplateParameterDecl]
	annotations: [ParsedAnnotation]

	fn dump(this, indent: String) throws -> String {
		return format("{:#}", this) + "\n"
	}
}

struct ParsedVarDecl {
	span: Span
	is_const: bool
	name: String
	type: ParsedType?
	init: ParsedExpr?

	fn dump(this, indent: String) throws -> String {
		return format("{}{} {} {}\n", indent, match .is_const {
			true => "const"
			else => "var"
		}, .name, .span.format())
	}
}

struct ParsedEnumCaseDecl {
	span: Span
	name: String
	id: i64?
}

struct ParsedVariantCaseDecl {
	span: Span
	name: String
	type: ParsedType?
	id: i64?
}

struct ParsedFunctionParameterDecl {
	span: Span
	name: String
	type: ParsedType
	init: ParsedExpr?

	fn dump(this, indent: String) throws -> String {
		mut result = format("{}param {} {}\n", indent, .name, .span.format())

		result += .type.dump(indent: indent + "  ")

		return result
	}
}

boxed enum ParsedType {
	Name(span: Span, namespaces: [String], name: String, template_parameters: [ParsedTemplateParameter])
	TupleType(span: Span, elements: [ParsedTupleElement])
	ArrayType(span: Span, element_type: ParsedType, size: ParsedExpr)
	ListType(span: Span, element_type: ParsedType)
	DictType(span: Span, key_type: ParsedType, value_type: ParsedType)
	ConstRefType(span: Span, baseType: ParsedType)
	VarRefType(span: Span, baseType: ParsedType)
	OptionalType(span: Span, value_type: ParsedType)
	Empty

	fn span(this) => match this {
		Empty => Span::empty()
		else(span) => span
	}

	fn dump(this, indent: String) throws -> String {
		return format("{:#}", this) + "\n"
	}
}

enum ParsedTemplateParameter {
	span: Span

	Type(type: ParsedType)
	IntLiteral(value: i64)
}

struct ParsedTupleElement {
	name: String
	type: ParsedType
}

boxed enum ParsedStmt {
	span: Span
	is_comptime: bool = false

	Compound(children: [ParsedStmt])
	VarDecl(var: ParsedVarDecl)
	If(condition: ParsedExpr, body: ParsedStmt, else_branch: ParsedStmt?)
	IfVar(var: ParsedVarDecl, body: ParsedStmt)
	VarElse(var: ParsedVarDecl, error_capture_name: String?, body: ParsedStmt)
	For(capture_const: bool, capture_reference: bool, capture_name: String, range: ParsedExpr, body: ParsedStmt)
	While(condition: ParsedExpr, body: ParsedStmt, continue_expr: ParsedExpr?)
	DoWhile(body: ParsedStmt, condition: ParsedExpr)
	Match(value: ParsedExpr, cases: [ParsedCaseStmt], else_branch: ParsedStmt?)
	Continue
	Break
	Return(value: ParsedExpr?)
	Discard(value: ParsedExpr)
	Throw(value: ParsedExpr)
	Expr(expr: ParsedExpr)
	DefaultFunctionBody
	ExternFunctionBody
	Garbage
}

struct ParsedCaseStmt {
	span: Span
	patterns: [ParsedExpr]
	capture_name: String?
	capture_const: bool
	capture_reference: bool
	body: ParsedStmt
}

enum ParsedBinaryOperator {
	Add
	Sub
	Mul
	Div
	Mod

	LogicalAnd
	LogicalOr

	BitwiseAnd
	BitwiseXor
	BitwiseOr
	BitwiseLShift
	BitwiseRShift

	CompEQ
	CompNE
	CompLT
	CompLE
	CompGT
	CompGE
	Spaceship

	Coalescing
	Range

	Assign
	AddAssign
	SubAssign
	MulAssign
	ModAssign
	DivAssign

	BitwiseAndAssign
	BitwiseOrAssign
	BitwiseXorAssign
	BitwiseLShiftAssign
	BitwiseRShiftAssign

	CoalescingAssign

	fn is_assignment(this) => match this {
		Assign
		| AddAssign
		| SubAssign
		| MulAssign
		| ModAssign
		| DivAssign
		| BitwiseAndAssign
		| BitwiseOrAssign
		| BitwiseXorAssign
		| BitwiseLShiftAssign
		| BitwiseRShiftAssign
		| CoalescingAssign => true
		else => false
	}

	fn precedence(this) => match this {
		Range => 120

		Mul
		| Div
		| Mod => 100

		BitwiseLShift
		| BitwiseRShift => 95

		Add
		| Sub => 90

		BitwiseAnd => 84
		BitwiseXor => 83
		BitwiseOr => 82

		Coalescing => 81

		CompLT
		| CompLE
		| CompGT
		| CompGE
		| CompEQ
		| CompNE => 80

		Spaceship => 75

		LogicalAnd => 70
		LogicalOr => 69

		Assign
		| BitwiseAndAssign
		| BitwiseOrAssign
		| BitwiseXorAssign
		| BitwiseLShiftAssign
		| BitwiseRShiftAssign
		| AddAssign
		| SubAssign
		| MulAssign
		| ModAssign
		| DivAssign
		| CoalescingAssign => 50
	}

	fn to_string(this) => match this {
		Add => "+"
		Sub => "-"
		Mul => "*"
		Div => "/"
		Mod => "%"
		BitwiseAnd => "&"
		BitwiseXor => "^"
		BitwiseOr => "|"
		BitwiseLShift => "<<"
		BitwiseRShift => ">>"
		CompLT => "<"
		CompLE => "<="
		CompGT => ">"
		CompGE => ">="
		CompEQ => "=="
		CompNE => "!="
		LogicalAnd => "&&"
		LogicalOr => "||"
		Coalescing => "??"
		Range => ".."
		Assign => "="
		AddAssign => "+="
		SubAssign => "-="
		MulAssign => "*="
		ModAssign => "%="
		DivAssign => "/="
		BitwiseAndAssign => "&="
		BitwiseOrAssign => "|="
		BitwiseXorAssign => "^="
		BitwiseLShiftAssign => "<<="
		BitwiseRShiftAssign => ">>="
		CoalescingAssign => "??="
		Spaceship => "<=>"
	}
}

enum ParsedUnaryOperator {
	Increment
	Decrement

	Negate

	LogicalNot
	BitwiseNot

	fn to_string(this) -> String {
		return match this {
			Increment => "++"
			Decrement => "--"
			Negate => "-"
			LogicalNot => "!"
			BitwiseNot => "~"
		}
	}
}

struct ParsedName {
	span: Span
	name: String
	template_parameters: [ParsedTemplateParameter]
}

boxed enum ParsedExpr {
	BoolLiteral(span: Span, value: bool)
	IntLiteral(span: Span, value: i64, postfix: String)
	FloatLiteral(span: Span, value: f64, postfix: String)
	CharLiteral(span: Span, value: u8, postfix: String)
	StringLiteral(span: Span, value: String, postfix: String)
	Paren(span: Span, child: ParsedExpr)
	Array(span: Span, elements: [ParsedExpr])
	Dict(span: Span, elements: [(ParsedExpr, ParsedExpr)])
	Tuple(span: Span, elements: [(String?, ParsedExpr)])
	Call(span: Span, namespaces: [ParsedName], name: String, template_parameters: [ParsedTemplateParameter], arguments: [ParsedExpr])
	MemberCall(span: Span, object: ParsedExpr, name: String, template_parameters: [ParsedTemplateParameter], arguments: [ParsedExpr])
	IndexOperator(span: Span, object: ParsedExpr, arguments: [ParsedExpr])
	TupleIndex(span: Span, tuple: ParsedExpr, index: u64)
	ConstRef(span: Span, expr: ParsedExpr)
	VarRef(span: Span, expr: ParsedExpr)
	OperatorIs(span: Span, value: ParsedExpr, targetType: ParsedType)
	OperatorAs(span: Span, value: ParsedExpr, targetType: ParsedType)
	Operator(span: Span, op: ParsedBinaryOperator)
	UnaryOp(span: Span, expr: ParsedExpr, op: ParsedUnaryOperator)
	BinaryOp(span: Span, lhs: ParsedExpr, op: ParsedBinaryOperator, rhs: ParsedExpr)
	Name(span: Span, namespaces: [ParsedName], name: ParsedName)
	MemberName(span: Span, object: ParsedExpr, name: ParsedName)
	Try(span: Span, expr: ParsedExpr)
	Must(span: Span, expr: ParsedExpr)
	InlineIf(span: Span, true_value: ParsedExpr, condition: ParsedExpr, false_value: ParsedExpr)
	Garbage(Span)

	fn span(this) => match this {
		else(span) => span
	}

	fn precedence(this) => match this {
		Operator(op) => op.precedence()
		else => 0
	}
}