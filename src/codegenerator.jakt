import utility
import program {*}

import llvm {
	LLVMMemoryBufferRef
	LLVMContextRef
	LLVMModuleRef
	LLVMTypeRef
	LLVMValueRef
	LLVMBasicBlockRef
	LLVMMetadataRef
	LLVMBuilderRef
	LLVMDIBuilderRef
	LLVMTargetDataRef

	_LLVMModuleFlagBehavior
	_LLVMIntPredicate
	_LLVMRealPredicate
	_LLVMVerifierFailureAction
	_LLVMLinkage
	_LLVMDWARFSourceLanguage
	_LLVMDWARFEmissionKind
	_LLVMDIFlags

	LLVMVerifierFailureAction
	LLVMDWARFSourceLanguage
	LLVMDWARFEmissionKind
	LLVMDIFlags

	LLVMDisposeMessage

	LLVMContextCreate
	LLVMGetGlobalContext
	LLVMContextDispose

	LLVMGetTypeByName2

	LLVMModuleCreateWithNameInContext
	LLVMDisposeModule
	LLVMSetTarget
	LLVMAddModuleFlag
	LLVMPrintModuleToFile
	LLVMPrintModuleToString
	LLVMGetModuleContext
	LLVMAddFunction
	LLVMGetNamedFunction

	LLVMIntTypeInContext
	LLVMGetIntTypeWidth
	LLVMHalfTypeInContext
	LLVMFloatTypeInContext
	LLVMDoubleTypeInContext
	LLVMX86FP80TypeInContext
	LLVMFP128TypeInContext

	LLVMFunctionType
	LLVMCountParamTypes
	LLVMGetParamTypes

	LLVMStructCreateNamed
	LLVMStructSetBody

	LLVMArrayType
	LLVMPointerTypeInContext
	LLVMVectorType
	LLVMScalableVectorType
	LLVMVoidTypeInContext

	LLVMTypeOf
	LLVMIsConstant
	LLVMIsUndef
	LLVMIsPoison

	LLVMConstNull
	LLVMConstAllOnes
	LLVMGetUndef
	LLVMGetPoison
	LLVMConstInt
	LLVMConstReal
	LLVMConstStringInContext

	LLVMSetLinkage

	LLVMAddGlobal
	LLVMAddGlobalInAddressSpace
	LLVMGetNamedGlobal
	LLVMSetInitializer
	LLVMSetGlobalConstant

	LLVMLookupIntrinsicID
	LLVMGetIntrinsicID
	LLVMGetIntrinsicDeclaration
	LLVMIntrinsicGetType

	LLVMGetAlignment
	LLVMSetAlignment

	LLVMCountParams
	LLVMGetParams
	LLVMGetParam

	LLVMMetadataAsValue
	LLVMValueAsMetadata

	LLVMBasicBlockAsValue
	LLVMValueIsBasicBlock
	LLVMValueAsBasicBlock
	LLVMGetBasicBlockTerminator
	LLVMCreateBasicBlockInContext
	LLVMAppendBasicBlockInContext
	LLVMDeleteBasicBlock

	LLVMGetLastInstruction
	LLVMGetInstructionOpcode
	LLVMIsATerminatorInst

	LLVMAddIncoming

	LLVMCreateBuilderInContext
	LLVMPositionBuilderAtEnd
	LLVMGetInsertBlock
	LLVMDisposeBuilder
	LLVMSetCurrentDebugLocation2

	LLVMBuildRetVoid
	LLVMBuildRet
	LLVMBuildBr
	LLVMBuildCondBr
	LLVMBuildSwitch
	LLVMBuildUnreachable

	LLVMAddCase

	LLVMBuildAdd
	LLVMBuildFAdd
	LLVMBuildSub
	LLVMBuildFSub
	LLVMBuildMul
	LLVMBuildFMul
	LLVMBuildUDiv
	LLVMBuildSDiv
	LLVMBuildFDiv
	LLVMBuildURem
	LLVMBuildSRem
	LLVMBuildFRem

	LLVMBuildShl
	LLVMBuildLShr
	LLVMBuildAShr

	LLVMBuildAnd
	LLVMBuildOr
	LLVMBuildXor
	LLVMBuildNeg
	LLVMBuildFNeg
	LLVMBuildNot

	LLVMBuildMalloc
	LLVMBuildArrayMalloc

	LLVMBuildMemSet
	LLVMBuildMemCpy
	LLVMBuildMemMove

	LLVMBuildAlloca
	LLVMBuildArrayAlloca

	LLVMBuildFree

	LLVMBuildLoad2
	LLVMBuildStore

	LLVMBuildGEP2
	LLVMBuildInBoundsGEP2
	LLVMBuildStructGEP2

	LLVMBuildGlobalString
	LLVMBuildGlobalStringPtr

	LLVMBuildTrunc
	LLVMBuildZExt
	LLVMBuildSExt
	LLVMBuildFPToUI
	LLVMBuildFPToSI
	LLVMBuildUIToFP
	LLVMBuildSIToFP
	LLVMBuildFPTrunc
	LLVMBuildFPExt
	LLVMBuildPtrToInt
	LLVMBuildBitCast
	LLVMBuildPointerCast

	LLVMBuildICmp
	LLVMBuildFCmp

	LLVMBuildPhi

	LLVMBuildCall2

	LLVMBuildExtractValue
	LLVMBuildInsertValue
	LLVMBuildPtrDiff2
	LLVMBuildAtomicRMW

	LLVMCreateMemoryBufferWithContentsOfFile
	LLVMDisposeMemoryBuffer

	LLVMIntPtrTypeInContext

	LLVMGetModuleDataLayout
	LLVMSizeOfTypeInBits
	LLVMStoreSizeOfType
	LLVMABISizeOfType

	LLVMPreferredAlignmentOfType

	LLVMParseIRInContext

	LLVMWriteBitcodeToFile

	LLVMVerifyModule

	LLVMLinkModules2

	LLVMCreateDIBuilder
	LLVMDisposeDIBuilder
	LLVMDIBuilderFinalize
	LLVMDIBuilderCreateCompileUnit
	LLVMDIBuilderCreateFile
	LLVMDIBuilderCreateModule
	LLVMDIBuilderCreateNameSpace
	LLVMDIBuilderCreateFunction
	LLVMDIBuilderCreateLexicalBlock
	LLVMDIBuilderCreateImportedModuleFromModule
	LLVMSetSubprogram
	LLVMDIBuilderCreateBasicType
	LLVMDIBuilderCreateUnspecifiedType
	LLVMDIBuilderCreatePointerType
	LLVMDIBuilderCreateStructType
	LLVMDIBuilderCreateSubroutineType

	LLVMHelper
}

fn codegen(options: CompilerOptions, program: Program) throws -> String {
	// init
	let llvm_context = LLVMContextCreate()
	let llvm_module = LLVMModuleCreateWithNameInContext(program.root_module!.name.c_string(), llvm_context);
	LLVMSetTarget(llvm_module, "x86_64-pc-linux-gnu".c_string())

	let debug_info: DebugInfo? = match options.generate_debug_symbols {
		true => DebugInfo::create(options, program, module: program.root_module!, llvm_context, llvm_module)
		else => None
	}

	// codegen
	mut context = CodegenContext(
		llvm_context,
		llvm_module,
		data_layout: LLVMGetModuleDataLayout(llvm_module)
		debug_info,
		options,
		program,
		current_module: program.root_module!.id
		types: [:],
		functions: [:],
		functions_to_build: []
	)

	context.codegenTypes(types: program.getTypeIds())

	if options.codegen_only_reachable {
		context.codegenReachableFunctions(start: program.main!)
	} else {
		context.codegenFunctionDeclarations(functions: program.getFunctionIds())
		context.codegenFunctionImplementations(functions: program.getFunctionIds())
	}

	let file_name = context.finalize(options, module: program.root_module!)

	// cleanup
	if debug_info.has_value() {
		LLVMDisposeDIBuilder(debug_info!.builder)
	}
	LLVMDisposeModule(llvm_module)
	LLVMContextDispose(llvm_context)

	return file_name
}

struct LLVMFunction {
	id: u64
	decl: FunctionDecl
	type: LLVMTypeRef
	impl: LLVMValueRef
	args: [LLVMValueRef]
	variables: [u64: LLVMValueRef]
}

struct DebugInfo {
	builder: LLVMDIBuilderRef
	files: [u64: LLVMMetadataRef]
	modules: [u64: LLVMMetadataRef]
	compile_unit: LLVMMetadataRef
	types: [u64: LLVMMetadataRef]
	scope_stack: [LLVMMetadataRef]

	fn create(options: CompilerOptions, program: Program, module: Module, llvm_context: LLVMContextRef, llvm_module: LLVMModuleRef) throws -> DebugInfo {
		LLVMHelper::LLVMAddModuleFlag2(llvm_module, _LLVMModuleFlagBehavior::LLVMModuleFlagBehaviorMax, "Dwarf Version",
			LLVMValueAsMetadata(LLVMConstInt(LLVMIntTypeInContext(llvm_context, 32), 4, false))
		)
		LLVMHelper::LLVMAddModuleFlag2(llvm_module, _LLVMModuleFlagBehavior::LLVMModuleFlagBehaviorWarning, "Debug Info Version",
			LLVMValueAsMetadata(LLVMConstInt(LLVMIntTypeInContext(llvm_context, 32), 3, false))
		)

		let builder = LLVMCreateDIBuilder(llvm_module)

		mut files: [u64: LLVMMetadataRef] = [:]

		for m in program.modules {
			let path = m.parsed_module.file.path
			let tmp = path.split(c'/')
			let filename = tmp.last()!
			let directory = match path == filename {
				true => "."
				else => path.substring(start: 0, length: path.length() - filename.length() - 1)
			}

			files[m.id] = LLVMDIBuilderCreateFile(builder, filename.c_string(), filename.length(), directory.c_string(), directory.length())
		}

		let producer = ""
		let flags = ""
		let split_name = ""
		let sys_root = ""
		let sdk = ""

		let compile_unit = LLVMDIBuilderCreateCompileUnit(
			builder,
			_LLVMDWARFSourceLanguage::LLVMDWARFSourceLanguageC.v(),
			files[module.id],
			producer.c_string(), producer.length(),
			false,
			flags.c_string(), flags.length(),
			0,
			split_name.c_string(), split_name.length(),
			_LLVMDWARFEmissionKind::LLVMDWARFEmissionFull.v(),
			0,
			true,
			true,
			sys_root.c_string(), sys_root.length(),
			sdk.c_string(), sdk.length(),
		)

		let config_macros = ""
		let include_path = ""
		let api_notes_file = ""

		mut modules: [u64: LLVMMetadataRef] = [:]
		for m in program.modules {
			modules[m.id] = LLVMDIBuilderCreateModule(
				builder, compile_unit,
				m.name.c_string(), m.name.length(),
				config_macros.c_string(), config_macros.length()
				include_path.c_string(), include_path.length()
				api_notes_file.c_string(), api_notes_file.length()
			)
		}

		let root_scope = LLVMDIBuilderCreateNameSpace(
			builder,
			modules[module.id],
			"".c_string(), 0,
			true
		)

		return DebugInfo(
			builder,
			files,
			modules,
			compile_unit,
			types: [:],
			scope_stack: [root_scope]
		)
	}
}

struct CodegenContext {
	llvm_context: LLVMContextRef
	llvm_module: LLVMModuleRef
	data_layout: LLVMTargetDataRef

	debug_info: DebugInfo?

	options: CompilerOptions
	program: Program
	current_module: u64
	types: [u64: LLVMTypeRef]
	functions: [u64: LLVMFunction]
	functions_to_build: [u64]

	fn getSourceLocation(this, span: Span) -> (u32, u32) {
		guard .debug_info.has_value() else {
			return (0u32, 0u32)
		}

		let lines = .program.modules[.current_module].parsed_module.file.lines
		for i in 0..lines.size() {
			let line = lines[i]
			if line.start <= span.start and line.end > span.start {
				let row = i as! u32 + 1u32
				let column = (span.start - line.start) as! u32 + 1u32
				return (row, column)
			}
		}

		return (0u32, 0u32)
	}

	fn getSourceLocationMetadata(this, span: Span) -> LLVMMetadataRef {
		guard .debug_info.has_value() else {
			unsafe {
				cpp {
					"return nullptr;"
				}
			}
			abort()
		}

		let scope = .debug_info!.scope_stack.last()!
		let (row, column) = .getSourceLocation(span)

		unsafe {
			cpp {
				"return LLVMDIBuilderCreateDebugLocation(this->llvm_context, row, column, scope, nullptr);"
			}
		}

		abort()
	}

	fn getIntrinsic(this, name: String, arg_types: [LLVMTypeRef]) throws -> (LLVMValueRef, LLVMTypeRef) {
		let id = LLVMLookupIntrinsicID(name.c_string(), name.length())
		let func = LLVMGetIntrinsicDeclaration(.llvm_module, id, &raw arg_types[0], arg_types.size())
		let type = LLVMIntrinsicGetType(.llvm_context, id, &raw arg_types[0], arg_types.size())
		return (func, type)
	}

	fn codegenTypes(mut this, mut types: {u64}) throws {
		while not types.is_empty() {
			mut complete_types: {u64} = {}

			for id in types {
				let decl = .program.types[id]

				mut has_unsatisfied_dependencies = false
				for other in decl.contained_types {
					if types.contains(other) {
						has_unsatisfied_dependencies = true
						break
					}
				}
				if has_unsatisfied_dependencies {
					continue
				}

				complete_types.add(id)
			}

			if complete_types.is_empty() {
				panic("type declarations have cycles")
			}

			for id in setToOrderedList(set: complete_types) {
				let type = .program.types[id]
				.codegenTypeDeclaration(type)
				types.remove(id)
			}
		}
	}

	fn codegenFunctionDeclarations(mut this, functions: [u64]) throws {
		for func in functions {
			.codegenFunctionDeclaration(func: .program.functions[func])
		}
	}

	fn codegenFunctionImplementations(mut this, functions: [u64]) throws {
		for func in functions {
			if not .program.functions[func].isIncompleteTemplate() {
				.codegenFunctionImplementation(func: .program.functions[func])
			}
		}
	}

	fn codegenReachableFunctions(mut this, start: Function) throws {
		.codegenFunctionDeclaration(func: .program.functions[start.id])
		.codegenFunctionImplementation(func: .program.functions[start.id])

		while not .functions_to_build.is_empty() {
			let id = .functions_to_build.pop()!
			.codegenFunctionImplementation(func: .program.functions[id])
		}
	}

	fn codegenTypeDeclaration(mut this, type: TypeDecl) throws {
		if type.isIncompleteTemplate() {
			return
		}

		let name = match .options.symbol_type {
			None => ""
			Id => format("t{}", type.id)
			Name => type.name
			Signature => .program.formatTypeSignature(type: Type::Base(id: type.id))
		}

		match type.kind {
			Empty => {}
			Unchecked => {}
			Struct => {
				.types.set(type.id, LLVMStructCreateNamed(.llvm_context, name.c_string()))
				mut elements: [LLVMTypeRef] = []
				for var in type.member_variables {
					elements.push(.getType(var.type))
				}

				if not elements.is_empty() {
					LLVMStructSetBody(.types.get(type.id)!, &raw elements[0], elements.size() as! u32, type.is_packed)
				}
			}
			Enum(id_type) => {
				.types.set(type.id, .types.get(id_type.id)!)
			}
			Variant(id_type, cases) => {
				.types.set(type.id, LLVMStructCreateNamed(.llvm_context, name.c_string()))
				mut elements: [LLVMTypeRef] = [
					.types.get(id_type.id)!
				]

				mut data_size = 0u64
				for c in cases {
					let current_data_size = LLVMStoreSizeOfType(.data_layout, .getType(c.type))

					if current_data_size > data_size {
						data_size = current_data_size
					}
				}
				elements.push(LLVMArrayType(LLVMIntTypeInContext(.llvm_context, 8), data_size as! u32))

				for var in type.member_variables {
					elements.push(.getType(var.type))
				}

				LLVMStructSetBody(.types.get(type.id)!, &raw elements[0], elements.size() as! u32, type.is_packed)
			}
			Alias => {}
			Builtin(builtin) => match builtin {
				Void => {
					.types.set(type.id, LLVMVoidTypeInContext(.llvm_context))
				}
				Bool => {
					.types.set(type.id, LLVMIntTypeInContext(.llvm_context, 1))
				}
				Byte => {
					.types.set(type.id, LLVMIntTypeInContext(.llvm_context, 8))
				}
				ISize | USize => {
					.types.set(type.id, LLVMIntPtrTypeInContext(.llvm_context, .data_layout))
				}
				SInt(size) | UInt(size) => {
					.types.set(type.id, LLVMIntTypeInContext(.llvm_context, size! as! u32))
				}
				Float(size) => {
					.types.set(type.id, match size {
						16 => LLVMHalfTypeInContext(.llvm_context)
						32 => LLVMFloatTypeInContext(.llvm_context)
						64 => LLVMDoubleTypeInContext(.llvm_context)
						80 => LLVMX86FP80TypeInContext(.llvm_context)
						128 => LLVMFP128TypeInContext(.llvm_context)
						else => {
							panic("invalid float type")
						}
					})
				}
				OpaquePointer | Pointer => {
					.types.set(type.id, LLVMPointerTypeInContext(.llvm_context, 0))
				}
				Array(element_type, size) => {
					.types.set(type.id, LLVMArrayType(.types.get(element_type!.id)!, size! as! u32))
				}
			}
		}
	}

	fn getType(this, anon type: Type) -> LLVMTypeRef {
		return match type {
			Base => .types[type.id]
			else => LLVMPointerTypeInContext(.llvm_context, 0)
		}
	}

	fn codegenFunctionDeclaration(mut this, func: FunctionDecl) throws {
		if .program.functions[func.id].isIncompleteTemplate() or .program.functions[func.id].kind is InlineBuiltin {
			return
		}

		let func_type = func.type
		mut param_types: [LLVMTypeRef] = []

		for param_type in func_type.param_types {
			param_types.push(.getType(param_type))
		}

		let return_type = .getType(func_type.return_type)

		mut tmp = match param_types.size() {
			0 => null<LLVMTypeRef>()
			else => &raw param_types[0]
		}

		let name = match func.extern_name.has_value() {
			true => func.extern_name!
			else => match .options.symbol_type {
				None => ""
				Id => format("f{}", func.id)
				Name => func.name
				Signature => .program.formatFunctionSignature(func: Function(id: func.id))
			}
		}

		let type = LLVMFunctionType(return_type, tmp, param_types.size() as! u32, false)
		let impl = LLVMAddFunction(.llvm_module, name.c_string(), type)
		mut args: [LLVMValueRef] = []

		for i in 0..LLVMCountParams(impl) {
			let param = LLVMGetParam(impl, i)
			args.push(param)
		}

		.functions.set(func.id, LLVMFunction(id: func.id, decl: func, type, impl, args, variables: [:]))
	}

	fn codegenFunctionImplementation(mut this, func: FunctionDecl) throws {
		if func.kind is Extern or func.kind is Unchecked or func.kind is InlineBuiltin {
			return
		}

		guard .functions.contains(func.id) else {
			let signatureStr = .program.formatFunctionSignature(func: Function(id: func.id))
			panic(format("fn decl not built for {}", signatureStr))
		}

		let llvm_func = .functions.get(func.id)!
		let entry_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "entry".c_string())
		let builder = LLVMCreateBuilderInContext(.llvm_context)
		LLVMPositionBuilderAtEnd(builder, entry_block)

		match func.kind {
			Code(body) => {
				if not body.body.containsGarbage() {
					.codegenFunctionBody(builder, llvm_func, body, func: Function(id: func.id))
				}
			}
			Builtin(builtin) => {
				.codegenBuiltinFunction(builder, llvm_func, builtin)
			}
			else => {}
		}

		LLVMDisposeBuilder(builder)
	}

	fn codegenFunctionBody(mut this, builder: LLVMBuilderRef, mut llvm_func: LLVMFunction, body: FunctionDeclBody, func: Function) throws {
		let name = .program.formatFunctionSignature(func)
		let previous_module = .current_module
		.current_module = .program.functions[func.id].module!.id

		let (line, col) = .getSourceLocation(span: body.span)

		mut di_param_types: [LLVMMetadataRef] = []
		mut di_param_types_ptr = match di_param_types.size() {
			0 => null<LLVMMetadataRef>()
			else => &raw di_param_types[0]
		}

		if .debug_info.has_value() {
			let di_type = LLVMDIBuilderCreateSubroutineType(
				.debug_info!.builder, .debug_info!.files[.current_module],
				di_param_types_ptr, di_param_types.size() as! u32,
				_LLVMDIFlags::LLVMDIFlagZero.v()
			)

			let di_func = LLVMDIBuilderCreateFunction(
				.debug_info!.builder, .debug_info!.scope_stack.last()!,
				name.c_string(), name.length(),
				"".c_string(), 0,
				.debug_info!.files[.current_module], line,
				di_type, false, true,
				line,
				_LLVMDIFlags::LLVMDIFlagZero.v(),
				false
			)

			LLVMSetSubprogram(llvm_func.impl, di_func)
			.debug_info!.scope_stack.push(di_func)
		}

		for i in 0..llvm_func.args.size() {
			let paramType = llvm_func.decl.type.param_types[i]

			if not .program.isPrimitive(type: paramType) and LLVMStoreSizeOfType(.data_layout, .types[paramType.id]) != 0 {
				let addr = LLVMBuildAlloca(builder, .types[paramType.id], "".c_string())
				LLVMBuildStore(builder, llvm_func.args[i], addr)
				llvm_func.args[i] = addr
			}
		}

		for var in body.variables {
			if var.unused {
				continue
			}

			if var.is_param {
				llvm_func.variables[var.id] = llvm_func.args[var.id]
			} else {
				let type = var.type
				if .debug_info.has_value() {
					LLVMSetCurrentDebugLocation2(builder, .getSourceLocationMetadata(span: var.span))
				}

				if LLVMStoreSizeOfType(.data_layout, .types[type.id]) == 0 {
					let addr = LLVMBuildArrayAlloca(
						builder,
						LLVMIntTypeInContext(.llvm_context, 8),
						LLVMConstInt(LLVMIntTypeInContext(.llvm_context, 64), 0, false)
						var.name.c_string()
					)
					llvm_func.variables[var.id] = addr
				} else {
					mut llvm_type = .getType(type)
					let addr = LLVMBuildAlloca(builder, llvm_type, var.name.c_string())
					llvm_func.variables[var.id] = addr
				}
			}
		}

		.functions[llvm_func.id] = llvm_func

		.codegenCompoundStmt(builder, stmt: body.body, llvm_func, break_target: None, continue_target: None, cleanup_list: [])

		if .debug_info.has_value() {
			let _ = .debug_info!.scope_stack.pop()
		}
		.current_module = previous_module
	}

	fn codegenStmt(mut this, builder: LLVMBuilderRef, stmt: Stmt, llvm_func: LLVMFunction, break_target: LLVMBasicBlockRef?, continue_target: LLVMBasicBlockRef?, cleanup_list: [[Expr]]) throws {
		match stmt {
			Empty => {}
			VarDecl(var) => {
				if llvm_func.decl.kind is Code(body) and body.variables[var.id].constructor_call.has_value() {
					let _ = .codegenExpr(builder, expr: body.variables[var.id].constructor_call!, llvm_func, cleanup_list: [])
				}
			}
			Compound(compoundStmt) => {
				.codegenCompoundStmt(builder, stmt: compoundStmt, llvm_func, break_target, continue_target, cleanup_list: [])
			}
			If(span, condition, then_branch, else_branch) => {
				.codegenIfStmt(builder, condition, then_branch, else_branch, llvm_func, span, break_target, continue_target)
			}
			IfVar(span, temp_var, has_value_call, body, var) => {
				.codegenIfVarStmt(builder, temp_var, has_value_call, body, var, llvm_func, span, break_target, continue_target)
			}
			VarElse(span, temp_var, has_value_call, error_var, body, ok_var) => {
				.codegenVarElseStmt(builder, temp_var, has_value_call, error_var, body, ok_var, llvm_func, span, break_target, continue_target)
			}
			While(span, condition, body, continue_expr) => {
				.codegenWhileStmt(builder, condition, body, continue_expr, llvm_func, span)
			}
			DoWhile(span, body, condition) => {
				.codegenDoWhileStmt(builder, body, condition, llvm_func, span)
			}
			Match(span, value, cases, else_branch) => {
				.codegenMatchStmt(builder, value, cases, else_branch, llvm_func, span, break_target, continue_target)
				if stmt.isTerminator(never_type: .program.never_type) and not LLVMHelper::LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(builder)) {
					LLVMBuildUnreachable(builder)
				}
			}
			Continue(cleanup_list: loop_cleanup_list) => {
				for destructor_call in loop_cleanup_list {
					let _ = .codegenExpr(builder, expr: destructor_call, llvm_func, cleanup_list: [])
				}
				if .debug_info.has_value() {
					LLVMSetCurrentDebugLocation2(builder, .getSourceLocationMetadata(span: stmt.span))
				}
				LLVMBuildBr(builder, continue_target!)
			}
			Break(cleanup_list: loop_cleanup_list) => {
				for destructor_call in loop_cleanup_list {
					let _ = .codegenExpr(builder, expr: destructor_call, llvm_func, cleanup_list: [])
				}
				if .debug_info.has_value() {
					LLVMSetCurrentDebugLocation2(builder, .getSourceLocationMetadata(span: stmt.span))
				}
				LLVMBuildBr(builder, break_target!)
			}
			Return(span, value, cleanup_list: function_cleanup_list) => {
				let built_value: LLVMValueRef? = match value.has_value() {
					true => .codegenExpr(builder, expr: value!, llvm_func, cleanup_list: [])
					else => None
				}

				if value.has_value() and value! is Validate(var) {
					.codegenExprCleanup(builder, expr: var, llvm_func)
				}

				for destructor_call in function_cleanup_list {
					let _ = .codegenExpr(builder, expr: destructor_call, llvm_func, cleanup_list: [])
				}

				for i in cleanup_list.size()..0 {
					for k in cleanup_list[i - 1].size()..0 {
						.codegenExprCleanup(builder, expr: cleanup_list[i - 1][k - 1], llvm_func)
					}
				}

				if .debug_info.has_value() {
					LLVMSetCurrentDebugLocation2(builder, .getSourceLocationMetadata(span: stmt.span))
				}
				if built_value.has_value() {
					LLVMBuildRet(builder, built_value!)
				} else {
					LLVMBuildRetVoid(builder)
				}
			}
			Discard(value) => {
				let _ = .codegenExpr(builder, expr: value, llvm_func, cleanup_list: [])
				.codegenExprCleanup(builder, expr: value, llvm_func)
			}
			Expr(expr) => {
				let _ = .codegenExpr(builder, expr, llvm_func, cleanup_list: [])
				if expr.type.id == .program.never_type.id {
					LLVMBuildUnreachable(builder)
				}
			}
			Garbage => {
				panic("garbage in codegen")
			}
		}
	}

	fn codegenCompoundStmt(mut this, builder: LLVMBuilderRef, stmt: CompoundStmt, llvm_func: LLVMFunction, break_target: LLVMBasicBlockRef?, continue_target: LLVMBasicBlockRef?, cleanup_list: [[Expr]]) throws {
		if .debug_info.has_value() {
			let (line, col) = .getSourceLocation(span: stmt.span)
			let di_scope = LLVMDIBuilderCreateLexicalBlock(
				.debug_info!.builder, .debug_info!.scope_stack.last()!,
				.debug_info!.files[.current_module], line, col
			)

			.debug_info!.scope_stack.push(di_scope)
		}

		for child in stmt.children {
			.codegenStmt(builder, stmt: child, llvm_func, break_target, continue_target, cleanup_list)
		}

		for destructor_call in stmt.cleanup_list {
			let _ = .codegenExpr(builder, expr: destructor_call, llvm_func, cleanup_list: [])
		}

		if .debug_info.has_value() {
			let _ = .debug_info!.scope_stack.pop()
		}
	}

	fn codegenIfStmt(mut this, builder: LLVMBuilderRef, condition: Expr, then_branch: CompoundStmt, else_branch: Stmt?, llvm_func: LLVMFunction, span: Span, break_target: LLVMBasicBlockRef?, continue_target: LLVMBasicBlockRef?) throws {
		let val = .codegenExpr(builder, expr: condition, llvm_func, cleanup_list: [])!

		let then_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "then".c_string())
		mut else_block: LLVMBasicBlockRef? = None
		mut continue_block: LLVMBasicBlockRef? = None

		if .debug_info.has_value() {
			LLVMSetCurrentDebugLocation2(builder, .getSourceLocationMetadata(span))
		}
		if else_branch.has_value() {
			else_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "else".c_string())
			LLVMBuildCondBr(builder, val, then_block, else_block!)
		} else {
			continue_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "continue".c_string())
			LLVMBuildCondBr(builder, val, then_block, continue_block!)
		}

		LLVMPositionBuilderAtEnd(builder, then_block)
		.codegenCompoundStmt(builder, stmt: then_branch, llvm_func, break_target, continue_target, cleanup_list: [])
		if not LLVMHelper::LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(builder)) {
			if not continue_block.has_value() {
				continue_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "continue".c_string())
			}
			LLVMBuildBr(builder, continue_block!)
		}

		if else_branch.has_value() {
			LLVMPositionBuilderAtEnd(builder, else_block!)
			.codegenStmt(builder, stmt: else_branch!, llvm_func, break_target, continue_target, cleanup_list: [])

			if not LLVMHelper::LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(builder)) {
				if not continue_block.has_value() {
					continue_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "continue".c_string())
				}
				LLVMBuildBr(builder, continue_block!)
			}
		}

		if continue_block.has_value() {
			LLVMPositionBuilderAtEnd(builder, continue_block!)
		}
	}

	fn codegenIfVarStmt(mut this, builder: LLVMBuilderRef, temp_var: Expr, has_value_call: Expr, body: CompoundStmt, var: Variable, llvm_func: LLVMFunction, span: Span, break_target: LLVMBasicBlockRef?, continue_target: LLVMBasicBlockRef?) throws {
		let _ = .codegenExpr(builder, expr: temp_var, llvm_func, cleanup_list: [])
		let has_value = .codegenExpr(builder, expr: has_value_call, llvm_func, cleanup_list: [])!

		let then_branch = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "then".c_string())
		let else_branch = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "else".c_string())
		let continue_branch = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "continue".c_string())

		LLVMBuildCondBr(builder, has_value, then_branch, else_branch)

		LLVMPositionBuilderAtEnd(builder, else_branch)
		.codegenExprCleanup(builder, expr: temp_var, llvm_func)
		LLVMBuildBr(builder, continue_branch)

		LLVMPositionBuilderAtEnd(builder, then_branch)
		guard llvm_func.decl.kind is Code(body: function_body) and function_body.variables[var.id].constructor_call.has_value() else {
			panic("invalid variable in var-else stmt")
		}

		let _ = .codegenExpr(builder, expr: function_body.variables[var.id].constructor_call!, llvm_func, cleanup_list: [])
		.codegenExprCleanup(builder, expr: temp_var, llvm_func)
		.codegenCompoundStmt(builder, stmt: body, llvm_func, break_target, continue_target, cleanup_list: [])

		if not LLVMHelper::LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(builder)) {
			LLVMBuildBr(builder, continue_branch)
		}

		LLVMPositionBuilderAtEnd(builder, continue_branch)
	}

	fn codegenVarElseStmt(mut this, builder: LLVMBuilderRef, temp_var: Expr, has_value_call: Expr, error_var: Variable?, body: CompoundStmt, ok_var: Variable, llvm_func: LLVMFunction, span: Span, break_target: LLVMBasicBlockRef?, continue_target: LLVMBasicBlockRef?) throws {
		let _ = .codegenExpr(builder, expr: temp_var, llvm_func, cleanup_list: [])
		let has_value = .codegenExpr(builder, expr: has_value_call, llvm_func, cleanup_list: [])!

		let ok_branch = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "ok".c_string())
		let else_branch = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "else".c_string())
		LLVMBuildCondBr(builder, has_value, ok_branch, else_branch)

		LLVMPositionBuilderAtEnd(builder, else_branch)
		if error_var.has_value() {
			guard llvm_func.decl.kind is Code(body) and body.variables[error_var!.id].constructor_call.has_value() else {
				panic("invalid variable in var-else stmt")
			}
			let _ = .codegenExpr(builder, expr: body.variables[error_var!.id].constructor_call!, llvm_func, cleanup_list: [])
		}

		.codegenExprCleanup(builder, expr: temp_var, llvm_func)
		.codegenCompoundStmt(builder, stmt: body, llvm_func, break_target, continue_target, cleanup_list: [])

		guard LLVMHelper::LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(builder)) else {
			panic("var-else block doesn't have terminator")
		}

		LLVMPositionBuilderAtEnd(builder, ok_branch)
		guard llvm_func.decl.kind is Code(body) and body.variables[ok_var.id].constructor_call.has_value() else {
			panic("invalid variable in var-else stmt")
		}

		let _ = .codegenExpr(builder, expr: body.variables[ok_var.id].constructor_call!, llvm_func, cleanup_list: [])
		.codegenExprCleanup(builder, expr: temp_var, llvm_func)
	}

	fn codegenWhileStmt(mut this, builder: LLVMBuilderRef, condition: Expr, body: CompoundStmt, continue_expr: Expr?, llvm_func: LLVMFunction, span: Span) throws {
		let condition_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "condition".c_string())
		let loop_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "loop".c_string())
		let continue_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "continue".c_string())
		let end_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "end".c_string())

		if .debug_info.has_value() {
			LLVMSetCurrentDebugLocation2(builder, .getSourceLocationMetadata(span))
		}

		LLVMBuildBr(builder, condition_block)
		LLVMPositionBuilderAtEnd(builder, condition_block)
		let built_condition = .codegenExpr(builder, expr: condition, llvm_func, cleanup_list: [])!

		if .debug_info.has_value() {
			LLVMSetCurrentDebugLocation2(builder, .getSourceLocationMetadata(span))
		}
		LLVMBuildCondBr(builder, built_condition, loop_block, end_block)

		LLVMPositionBuilderAtEnd(builder, loop_block)
		.codegenCompoundStmt(builder, stmt: body, llvm_func, break_target: end_block, continue_target: continue_block, cleanup_list: [])
		if not LLVMHelper::LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(builder)) {
			LLVMBuildBr(builder, continue_block)
		}

		LLVMPositionBuilderAtEnd(builder, continue_block)
		if continue_expr.has_value() {
			let _ = .codegenExpr(builder, expr: continue_expr!, llvm_func, cleanup_list: [])
			.codegenExprCleanup(builder, expr: continue_expr!, llvm_func)
		}
		if not LLVMHelper::LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(builder)) {
			LLVMBuildBr(builder, condition_block)
		}

		LLVMPositionBuilderAtEnd(builder, end_block)
	}

	fn codegenDoWhileStmt(mut this, builder: LLVMBuilderRef, body: CompoundStmt, condition: Expr, llvm_func: LLVMFunction, span: Span) throws {
		let condition_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "condition".c_string())
		let loop_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "loop".c_string())
		let continue_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "continue".c_string())

		if .debug_info.has_value() {
			LLVMSetCurrentDebugLocation2(builder, .getSourceLocationMetadata(span))
		}

		LLVMBuildBr(builder, loop_block)

		LLVMPositionBuilderAtEnd(builder, loop_block)
		.codegenCompoundStmt(builder, stmt: body, llvm_func, break_target: continue_block, continue_target: condition_block, cleanup_list: [])
		if not LLVMHelper::LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(builder)) {
			LLVMBuildBr(builder, condition_block)
		}

		LLVMPositionBuilderAtEnd(builder, condition_block)
		let built_condition = .codegenExpr(builder, expr: condition, llvm_func, cleanup_list: [])!
		if .debug_info.has_value() {
			LLVMSetCurrentDebugLocation2(builder, .getSourceLocationMetadata(span))
		}
		LLVMBuildCondBr(builder, built_condition, loop_block, continue_block)

		LLVMPositionBuilderAtEnd(builder, continue_block)
	}

	fn codegenMatchStmt(mut this, builder: LLVMBuilderRef, value: Expr, cases: [CaseStmt], else_branch: Stmt?, llvm_func: LLVMFunction, span: Span, break_target: LLVMBasicBlockRef?, continue_target: LLVMBasicBlockRef?) throws {
		let value_type = .program.types[value.type.id]

		mut built_value = .codegenExpr(builder, expr: value, llvm_func, cleanup_list: [])!
		if value_type.kind is Variant(id_type) {
			built_value = LLVMBuildExtractValue(builder, built_value, 0, "".c_string())
		}

		let else_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "else".c_string())
		mut continue_block: LLVMBasicBlockRef? = None

		if .debug_info.has_value() {
			LLVMSetCurrentDebugLocation2(builder, .getSourceLocationMetadata(span))
		}
		let switch_instr = LLVMBuildSwitch(builder, built_value, else_block, cases.size() as! u32)

		LLVMPositionBuilderAtEnd(builder, else_block)
		if else_branch.has_value() {
			.codegenStmt(builder, stmt: else_branch!, llvm_func, break_target, continue_target, cleanup_list: [])

			if not LLVMHelper::LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(builder)) {
				if not continue_block.has_value() {
					continue_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "continue".c_string())
				}
				LLVMBuildBr(builder, continue_block!)
			}
		} else {
			continue_block = else_block
		}

		for c in cases {
			let case_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "case".c_string())
			for pattern in c.patterns {
				let built_pattern = .codegenExpr(builder, expr: pattern, llvm_func, cleanup_list: [])
				LLVMAddCase(switch_instr, built_pattern!, case_block)
			}

			LLVMPositionBuilderAtEnd(builder, case_block)
			.codegenStmt(builder, stmt: c.body, llvm_func, break_target, continue_target, cleanup_list: [])

			if not LLVMHelper::LLVMHasBasicBlockTerminator(LLVMGetInsertBlock(builder)) {
				if not continue_block.has_value() {
					continue_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "continue".c_string())
				}
				LLVMBuildBr(builder, continue_block!)
			}
		}

		if continue_block.has_value() {
			LLVMPositionBuilderAtEnd(builder, continue_block!)
		}
	}

	fn codegenExpr(mut this, builder: LLVMBuilderRef, expr: Expr, llvm_func: LLVMFunction, mut cleanup_list: [[Expr]]) throws -> LLVMValueRef? => match expr {
		IntLiteral(type, value, isSigned) => LLVMConstInt(.types[type.id], value, isSigned)
		FloatLiteral(type, value) => LLVMConstReal(.types[type.id], value)
		StringLiteral(span, type, value) => {
			let stringviewType = .types[type.id]
			let isize_type = LLVMIntTypeInContext(.llvm_context, 64)
			let ptrType = LLVMPointerTypeInContext(.llvm_context, 0)

			let constStr = LLVMConstStringInContext(.llvm_context, value.c_string(), value.length() as! u64, true)
			let strtype = LLVMTypeOf(constStr)
			let global = LLVMAddGlobal(.llvm_module, strtype, "".c_string())
			LLVMSetInitializer(global, constStr)
			LLVMSetGlobalConstant(global, true)
			LLVMSetAlignment(global, 1)
			LLVMSetLinkage(global, _LLVMLinkage::LLVMPrivateLinkage.v())

			let str = LLVMBuildPointerCast(builder, global, ptrType, "".c_string())
			let len = LLVMConstInt(isize_type, value.length() as! i64, false)

			if .debug_info.has_value() {
				LLVMSetCurrentDebugLocation2(builder, .getSourceLocationMetadata(span))
			}

			mut val = LLVMConstNull(stringviewType)
			val = LLVMBuildInsertValue(builder, val, str, 0, "".c_string())

			// set size & capacity to length of the string literal
			val = LLVMBuildInsertValue(builder, val, len, 1, "".c_string())
			val = LLVMBuildInsertValue(builder, val, len, 2, "".c_string())

			// set is_owner to false
			val = LLVMBuildInsertValue(builder, val, LLVMConstNull(.types[.program.bool_type.id]), 3, "".c_string())

			yield val
		}
		ArrayLiteral(span, type, values) => {
			mut result = LLVMGetUndef(.types[type.id])
			for i in 0..values.size() {
				let built_value = .codegenExpr(builder, expr: values[i], llvm_func, cleanup_list)!
				result = LLVMBuildInsertValue(builder, result, built_value, i as! u32, "".c_string())
			}
			yield result
		}
		Call(span, func, args, cleanup) => {
			mut built_args: [LLVMValueRef] = []
			mut tmp: [Expr] = []
			cleanup_list.push(tmp)
			for arg in args.iterator() {
				let built_arg = .codegenExpr(builder, expr: arg, llvm_func, cleanup_list)!
				built_args.push(built_arg)
				cleanup_list.last()!.push(arg)
			}
			let _ = cleanup_list.pop()!

			if .debug_info.has_value() {
				LLVMSetCurrentDebugLocation2(builder, .getSourceLocationMetadata(span))
			}
			let result = .codegenCall(builder, func, args: built_args)

			if cleanup.has_value() and result.has_value() {
				let var = cleanup!.0
				LLVMBuildStore(builder, result!, llvm_func.variables[var.id])
			}

			for i in args.size()..0 {
				.codegenExprCleanup(builder, expr: args[i - 1], llvm_func)
			}

			yield result
		}
		MemberAccess(span, object, var) => {
			let type = .types[object.type.id]
			let index = var.id
			let var_type = .types[.program.types[object.type.id].member_variables[index].type.id]

			if LLVMStoreSizeOfType(.data_layout, var_type) == 0 {
				return LLVMConstNull(LLVMPointerTypeInContext(.llvm_context, 0))
			}

			let built_object = .codegenExpr(builder, expr: object, llvm_func, cleanup_list)!

			if .debug_info.has_value() {
				LLVMSetCurrentDebugLocation2(builder, .getSourceLocationMetadata(span))
			}

			let offset = match .program.types[object.type.id].kind {
				Variant => index + 2
				else => index
			} as! u32

			if LLVMTypeOf(built_object) == LLVMPointerTypeInContext(.llvm_context, 0) {
				return LLVMBuildStructGEP2(builder, type, built_object, offset, "".c_string())
			} else {
				return LLVMBuildExtractValue(builder, built_object, offset, "".c_string())
			}
		}
		Dereference(span, type, value) => {
			let built_value = .codegenExpr(builder, expr: value, llvm_func, cleanup_list)!
			let type_impl = .types[type.id]

			if .debug_info.has_value() {
				LLVMSetCurrentDebugLocation2(builder, .getSourceLocationMetadata(span))
			}
			if LLVMStoreSizeOfType(.data_layout, type_impl) == 0 {
				return LLVMConstNull(type_impl)
			}
			yield LLVMBuildLoad2(builder, type_impl, built_value, "".c_string())
		}
		VarInvoke(var) => llvm_func.variables[var.id]
		ReferenceVarInit(var, value) => {
			let built_value = .codegenExpr(builder, expr: value, llvm_func, cleanup_list)!
			yield LLVMBuildStore(builder, built_value, llvm_func.variables[var.id])
		}
		ReferenceVarInvoke(var) => LLVMBuildLoad2(builder, LLVMPointerTypeInContext(.llvm_context, 0), llvm_func.variables[var.id], "".c_string())
		ReferenceMemberInit(span, object, member, value) => {
			let built_object = .codegenExpr(builder, expr: object, llvm_func, cleanup_list)!
			let built_value = .codegenExpr(builder, expr: value, llvm_func, cleanup_list)!
			let type = .types[object.type.id]
			let index = member.id as! u32

			if .debug_info.has_value() {
				LLVMSetCurrentDebugLocation2(builder, .getSourceLocationMetadata(span))
			}

			let member_addr = LLVMBuildStructGEP2(builder, type, built_object, index, "".c_string())
			yield LLVMBuildStore(builder, built_value, member_addr)
		}
		ReferenceMemberInvoke(span, object, member) => {
			let built_object = .codegenExpr(builder, expr: object, llvm_func, cleanup_list)!
			let type = .types[object.type.id]
			let index = member.id as! u32

			if .debug_info.has_value() {
				LLVMSetCurrentDebugLocation2(builder, .getSourceLocationMetadata(span))
			}

			let member_addr = LLVMBuildStructGEP2(builder, type, built_object, index, "".c_string())
			yield LLVMBuildLoad2(builder, LLVMPointerTypeInContext(.llvm_context, 0), member_addr, "".c_string())
		}
		Validate(span, var, check_call, value_call, error_body) => {
			let _ = .codegenExpr(builder, expr: var, llvm_func, cleanup_list)

			let ok_branch = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "ok".c_string())
			let error_branch = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "error".c_string())
			let condition = .codegenExpr(builder, expr: check_call, llvm_func, cleanup_list)!
			LLVMBuildCondBr(builder, condition, ok_branch, error_branch)

			LLVMPositionBuilderAtEnd(builder, error_branch)
			.codegenCompoundStmt(builder, stmt: error_body, llvm_func, break_target: None, continue_target: None, cleanup_list)

			LLVMPositionBuilderAtEnd(builder, ok_branch)
			yield .codegenExpr(builder, expr: value_call, llvm_func, cleanup_list)
		}
		TempVariable(constructor_call, var) => {
			let _ = .codegenExpr(builder, expr: constructor_call, llvm_func, cleanup_list)
			yield llvm_func.variables[var.id]
		}
		ShallowCopyInit(var, value) => {
			let built_value = .codegenExpr(builder, expr: value, llvm_func, cleanup_list)!
			// don't build expr cleanup, the destructor of the variable should do that
			yield LLVMBuildStore(builder, built_value, llvm_func.variables[var.id])
		}
		InlineIf(true_value, condition, false_value, result_var) => {
			let built_condition = .codegenExpr(builder, expr: condition, llvm_func, cleanup_list)!
			let true_branch = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "true".c_string())
			let false_branch = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "false".c_string())
			let continue_branch = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "continue".c_string())

			LLVMBuildCondBr(builder, built_condition, true_branch, false_branch)

			LLVMPositionBuilderAtEnd(builder, true_branch)
			let built_true_value = .codegenExpr(builder, expr: true_value, llvm_func, cleanup_list)!
			LLVMBuildBr(builder, continue_branch)

			LLVMPositionBuilderAtEnd(builder, false_branch)
			let built_false_value = .codegenExpr(builder, expr: false_value, llvm_func, cleanup_list)!
			LLVMBuildBr(builder, continue_branch)

			LLVMPositionBuilderAtEnd(builder, continue_branch)
			let result_type = .getType(true_value.type)
			let phi = LLVMBuildPhi(builder, result_type, "".c_string())

			let incoming_values = [built_true_value, built_false_value]
			let incoming_blocks = [true_branch, false_branch]

			LLVMAddIncoming(phi, &raw incoming_values[0], &raw incoming_blocks[0], incoming_blocks.size() as! u32)
			LLVMBuildStore(builder, phi, llvm_func.variables[result_var.id])

			yield phi
		}
		Garbage => {
			panic("garbage in codegen")
		}
	}

	fn codegenExprCleanup(mut this, builder: LLVMBuilderRef, expr: Expr, llvm_func: LLVMFunction) throws {
		match expr {
			ArrayLiteral(values) => {
				for val in values {
					.codegenExprCleanup(builder, expr: val, llvm_func)
				}
			}
			Call(cleanup) => {
				if cleanup.has_value() {
					let (var, call) = cleanup!
					let _ = .codegenExpr(builder, expr: call, llvm_func, cleanup_list: [])
				}
			}
			MemberAccess(object) => {
				.codegenExprCleanup(builder, expr: object, llvm_func)
			}
			TempVariable(destructor_call) => {
				if destructor_call.has_value() {
					let _ = .codegenExpr(builder, expr: destructor_call!, llvm_func, cleanup_list: [])
				}
			}
			Dereference(value) => {
				.codegenExprCleanup(builder, expr: value, llvm_func)
			}
			Validate(var, value_call) => {
				.codegenExprCleanup(builder, expr: value_call, llvm_func)
				.codegenExprCleanup(builder, expr: var, llvm_func)
			}
			InlineIf(cleanup_call) => {
				let _ = .codegenExpr(builder, expr: cleanup_call, llvm_func, cleanup_list: [])
			}
			else => {
				// do nothing
			}
		}
	}

	fn codegenCall(mut this, builder: LLVMBuilderRef, func: Function, args: [LLVMValueRef]) throws -> LLVMValueRef? {
		let decl = .program.functions[func.id]

		if decl.kind is InlineBuiltin(builtin) {
			return .codegenInlineBuiltinFunction(builder, func_id: func.id, args, builtin)
		}

		let tmp = match args.size() {
			0 => null<LLVMValueRef>()
			else => &raw args[0]
		}

		if .options.codegen_only_reachable and not .functions.contains(func.id) {
			.codegenFunctionDeclaration(func: .program.functions[func.id])
			.functions_to_build.push(func.id)
		}

		guard .functions.contains(func.id) else {
			panic("fn decl not built for " + .program.formatFunctionSignature(func))
		}

		let result = LLVMBuildCall2(builder, .functions[func.id].type, .functions[func.id].impl, tmp, args.size() as! u64, "".c_string())
		if .program.functions[func.id].type.return_type.equals(other: .program.void_type) {
			return None
		} else {
			return result
		}
	}

	fn codegenInlineBuiltinFunction(mut this, builder: LLVMBuilderRef, func_id: u64, args: [LLVMValueRef], builtin: InlineBuiltinFunction) throws -> LLVMValueRef? => match builtin {
		PrimitiveNullConstructor(type) => {
			LLVMBuildStore(builder, LLVMConstNull(.types[type.id]), args[0])
			yield None
		}
		PrimitiveCopyConstructor => {
			LLVMBuildStore(builder, args[1], args[0])
			yield None
		}
		PrimitiveOpAssign => {
			LLVMBuildStore(builder, args[1], args[0])
			yield None
		}
		// do nothing
		PrimitiveDestructor => None
		BitOpEQ => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntEQ.v(), args[0], args[1], "".c_string())
		BitOpNE => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntNE.v(), args[0], args[1], "".c_string())
		BitOpAnd => LLVMBuildAnd(builder, args[0], args[1], "".c_string())
		BitOpOr => LLVMBuildOr(builder, args[0], args[1], "".c_string())
		BitOpXOr => LLVMBuildXor(builder, args[0], args[1], "".c_string())
		BitOpNot => LLVMBuildNot(builder, args[0], "".c_string())
		BitOpShl => LLVMBuildShl(builder, args[0], args[1], "".c_string())
		BitOpLShr => LLVMBuildLShr(builder, args[0], args[1], "".c_string())
		BitOpAShr => LLVMBuildAShr(builder, args[0], args[1], "".c_string())
		BitOpAndAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildAnd(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		BitOpOrAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildOr(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		BitOpXOrAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildXor(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		BitOpShlAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildShl(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		BitOpLShrAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildLShr(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		BitOpAShrAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildAShr(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		SIntOpEQ => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntEQ.v(), args[0], args[1], "".c_string())
		SIntOpNE => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntNE.v(), args[0], args[1], "".c_string())
		SIntOpLT => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntSLT.v(), args[0], args[1], "".c_string())
		SIntOpLE => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntSLE.v(), args[0], args[1], "".c_string())
		SIntOpGT => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntSGT.v(), args[0], args[1], "".c_string())
		SIntOpGE => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntSGE.v(), args[0], args[1], "".c_string())
		SIntOpCmp => LLVMBuildSub(builder,
			LLVMBuildZExt(builder, LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntSGT.v(), args[0], args[1], "".c_string()), LLVMIntTypeInContext(.llvm_context, 64), "".c_string()),
			LLVMBuildZExt(builder, LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntSLT.v(), args[0], args[1], "".c_string()), LLVMIntTypeInContext(.llvm_context, 64), "".c_string()),
			"".c_string()
		)
		SIntOpAdd => LLVMBuildAdd(builder, args[0], args[1], "".c_string())
		SIntOpSub => LLVMBuildSub(builder, args[0], args[1], "".c_string())
		SIntOpMul => LLVMBuildMul(builder, args[0], args[1], "".c_string())
		SIntOpDiv => LLVMBuildSDiv(builder, args[0], args[1], "".c_string())
		SIntOpMod => LLVMBuildSRem(builder, args[0], args[1], "".c_string())
		SIntOpNeg => LLVMBuildNeg(builder, args[0], "".c_string())
		SIntOpInc(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildAdd(builder, obj, LLVMConstInt(.types[type.id], 1, true), "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		SIntOpDec(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildSub(builder, obj, LLVMConstInt(.types[type.id], 1, true), "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		SIntOpAddAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildAdd(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		SIntOpSubAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildSub(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		SIntOpMulAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildMul(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		SIntOpDivAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildSDiv(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		SIntOpModAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildSRem(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		UIntOpEQ => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntEQ.v(), args[0], args[1], "".c_string())
		UIntOpNE => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntNE.v(), args[0], args[1], "".c_string())
		UIntOpLT => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntULT.v(), args[0], args[1], "".c_string())
		UIntOpLE => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntULE.v(), args[0], args[1], "".c_string())
		UIntOpGT => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntUGT.v(), args[0], args[1], "".c_string())
		UIntOpGE => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntUGE.v(), args[0], args[1], "".c_string())
		UIntOpCmp => LLVMBuildSub(builder,
			LLVMBuildZExt(builder, LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntUGT.v(), args[0], args[1], "".c_string()), LLVMIntTypeInContext(.llvm_context, 64), "".c_string()),
			LLVMBuildZExt(builder, LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntULT.v(), args[0], args[1], "".c_string()), LLVMIntTypeInContext(.llvm_context, 64), "".c_string()),
			"".c_string()
		)
		UIntOpAdd => LLVMBuildAdd(builder, args[0], args[1], "".c_string())
		UIntOpSub => LLVMBuildSub(builder, args[0], args[1], "".c_string())
		UIntOpMul => LLVMBuildMul(builder, args[0], args[1], "".c_string())
		UIntOpDiv => LLVMBuildUDiv(builder, args[0], args[1], "".c_string())
		UIntOpMod => LLVMBuildURem(builder, args[0], args[1], "".c_string())
		UIntOpInc(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildAdd(builder, obj, LLVMConstInt(.types[type.id], 1, true), "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		UIntOpDec(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildSub(builder, obj, LLVMConstInt(.types[type.id], 1, true), "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		UIntOpAddAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildAdd(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		UIntOpSubAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildSub(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		UIntOpMulAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildMul(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		UIntOpDivAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildUDiv(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		UIntOpModAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildURem(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		FloatOpEQ => LLVMBuildFCmp(builder, _LLVMRealPredicate::LLVMRealOEQ.v(), args[0], args[1], "".c_string())
		FloatOpNE => LLVMBuildFCmp(builder, _LLVMRealPredicate::LLVMRealONE.v(), args[0], args[1], "".c_string())
		FloatOpLT => LLVMBuildFCmp(builder, _LLVMRealPredicate::LLVMRealOLT.v(), args[0], args[1], "".c_string())
		FloatOpLE => LLVMBuildFCmp(builder, _LLVMRealPredicate::LLVMRealOLE.v(), args[0], args[1], "".c_string())
		FloatOpGT => LLVMBuildFCmp(builder, _LLVMRealPredicate::LLVMRealOGT.v(), args[0], args[1], "".c_string())
		FloatOpGE => LLVMBuildFCmp(builder, _LLVMRealPredicate::LLVMRealOGE.v(), args[0], args[1], "".c_string())
		FloatOpCmp => LLVMBuildSub(builder,
			LLVMBuildZExt(builder, LLVMBuildFCmp(builder, _LLVMRealPredicate::LLVMRealOGT.v(), args[0], args[1], "".c_string()), LLVMIntTypeInContext(.llvm_context, 64), "".c_string()),
			LLVMBuildZExt(builder, LLVMBuildFCmp(builder, _LLVMRealPredicate::LLVMRealOLT.v(), args[0], args[1], "".c_string()), LLVMIntTypeInContext(.llvm_context, 64), "".c_string()),
			"".c_string()
		)
		FloatOpAdd => LLVMBuildFAdd(builder, args[0], args[1], "".c_string())
		FloatOpSub => LLVMBuildFSub(builder, args[0], args[1], "".c_string())
		FloatOpMul => LLVMBuildFMul(builder, args[0], args[1], "".c_string())
		FloatOpDiv => LLVMBuildFDiv(builder, args[0], args[1], "".c_string())
		FloatOpMod => LLVMBuildFRem(builder, args[0], args[1], "".c_string())
		FloatOpNeg(type) => LLVMBuildFSub(builder, LLVMConstReal(.types[type.id], 0.0), args[0], "".c_string())
		FloatOpAddAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildFAdd(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		FloatOpSubAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildFSub(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		FloatOpMulAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildFMul(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		FloatOpDivAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildFDiv(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		FloatOpModAssign(type) => {
			let obj = LLVMBuildLoad2(builder, .types[type.id], args[0], "".c_string())
			let result = LLVMBuildFRem(builder, obj, args[1], "".c_string())
			LLVMBuildStore(builder, result, args[0])
			yield None
		}
		PointerOpEQ => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntEQ.v(), args[0], args[1], "".c_string())
		PointerOpNE => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntNE.v(), args[0], args[1], "".c_string())
		PointerOpLT => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntULT.v(), args[0], args[1], "".c_string())
		PointerOpLE => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntULE.v(), args[0], args[1], "".c_string())
		PointerOpGT => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntUGT.v(), args[0], args[1], "".c_string())
		PointerOpGE => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntUGE.v(), args[0], args[1], "".c_string())
		PointerOpCmp => LLVMBuildSub(builder,
			LLVMBuildZExt(builder, LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntUGT.v(), args[0], args[1], "".c_string()), LLVMIntTypeInContext(.llvm_context, 64), "".c_string()),
			LLVMBuildZExt(builder, LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntULT.v(), args[0], args[1], "".c_string()), LLVMIntTypeInContext(.llvm_context, 64), "".c_string()),
			"".c_string()
		)
		PointerGetNull => LLVMConstNull(LLVMPointerTypeInContext(.llvm_context, 0))
		// does nothing, because pointer & reference are the same internally
		PointerToRef => args[0]
		RefToPointer => args[0]
		// does nothing, because in llvm-ir all pointer types are the same
		PointerCast => args[0]
		PointerDiff(element_type) => LLVMBuildPtrDiff2(builder, .types[element_type.id], args[0], args[1], "".c_string())
		PointerOffset(element_type) => LLVMBuildGEP2(builder, .types[element_type.id], args[0], &raw args[1], 1, "".c_string())
		// equivalent to PointerToRef(PointerOffset(args))
		PointerOpIndex(element_type) => LLVMBuildGEP2(builder, .types[element_type.id], args[0], &raw args[1], 1, "".c_string())
		IntCast(target, source) => {
			let source_width = LLVMGetIntTypeWidth(.types[source!.id])
			let target_width = LLVMGetIntTypeWidth(.types[target!.id])
			let is_signed = .program.isSigned(type: source!) and .program.isSigned(type: target!)

			if source_width < target_width {
				if is_signed {
					return LLVMBuildSExt(builder, args[0], .types[target!.id], "".c_string())
				} else {
					return LLVMBuildZExt(builder, args[0], .types[target!.id], "".c_string())
				}
			} else if source_width > target_width {
				return LLVMBuildTrunc(builder, args[0], .types[target!.id], "".c_string())
			} else {
				return args[0]
			}
		}
		FloatCast(target, source) => {
			let source_width = LLVMSizeOfTypeInBits(.data_layout, .types[source!.id])
			let target_width = LLVMSizeOfTypeInBits(.data_layout, .types[target!.id])

			if source_width < target_width {
				return LLVMBuildFPExt(builder, args[0], .types[target!.id], "".c_string())
			} else if source_width > target_width {
				return LLVMBuildFPTrunc(builder, args[0], .types[target!.id], "".c_string())
			} else {
				return args[0]
			}
		}
		IntToFloat(target, source) => {
			if .program.isSigned(type: source!) {
				return LLVMBuildSIToFP(builder, args[0], .types[target!.id], "".c_string())
			} else {
				return LLVMBuildUIToFP(builder, args[0], .types[target!.id], "".c_string())
			}
		}
		FloatToInt(target, source) => {
			if .program.isSigned(type: target!) {
				return LLVMBuildFPToSI(builder, args[0], .types[target!.id], "".c_string())
			} else {
				return LLVMBuildFPToUI(builder, args[0], .types[target!.id], "".c_string())
			}
		}
		SizeOf(type) => .codegenSizeOf(builder, type: .types[type!.id])
		AlignmentOf(type) => LLVMConstInt(LLVMIntTypeInContext(.llvm_context, 64), LLVMPreferredAlignmentOfType(.data_layout, .types[type!.id]) as! i64, false)
		ReferenceKindOf(type) => match type! {
			Base => LLVMConstInt(.getType(.program.functions[func_id].type.return_type), 0, false)
			ConstRef => LLVMConstInt(.getType(.program.functions[func_id].type.return_type), 1, false)
			VarRef => LLVMConstInt(.getType(.program.functions[func_id].type.return_type), 2, false)
		}
		Memset(type) => {
			let size = LLVMBuildMul(
				builder, args[2],
				.codegenSizeOf(builder, type: .types[type!.id]),
				"".c_string()
			)
			LLVMBuildMemSet(builder, args[0], args[1], size, 0)
			yield None
		}
		Memcpy(type) => {
			let alignment = LLVMPreferredAlignmentOfType(.data_layout, .types[type!.id])
			let size = LLVMBuildMul(
				builder, args[2],
				.codegenSizeOf(builder, type: .types[type!.id]),
				"".c_string()
			)
			LLVMBuildMemCpy(builder, args[0], alignment, args[1], alignment, size)
			yield None
		}
		Memmove(type) => {
			let alignment = LLVMPreferredAlignmentOfType(.data_layout, .types[type!.id])
			let size = LLVMBuildMul(
				builder, args[2],
				.codegenSizeOf(builder, type: .types[type!.id]),
				"".c_string()
			)
			LLVMBuildMemMove(builder, args[0], alignment, args[1], alignment, size)
			yield None
		}
		VariantOpIs(type, id) => {
			let obj = args[0];
			let obj_id = LLVMBuildExtractValue(builder, obj, 0, "".c_string())
			yield LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntEQ.v(), obj_id,
				LLVMConstInt(LLVMTypeOf(obj_id), id as! i64, false), "".c_string()
			)
		}
		VariantOpUnsafeAs(type, id) => {
			// due to llvm opaque pointers no casts required
			guard .program.types[type.id].kind is Variant(cases) else {
				panic("invalid type for variant-op-unsafe-as")
			}

			mut case_type: Type? = None
			for c in cases {
				if c.id == id {
					case_type = c.type
				}
			}

			guard case_type.has_value() else {
				panic("invalid type for variant-op-unsafe-as 2")
			}

			let element_ptr = LLVMBuildStructGEP2(builder, .types[type.id], args[0], 1, "".c_string())
			yield match case_type! {
				Base => element_ptr
				else => LLVMBuildLoad2(builder, LLVMPointerTypeInContext(.llvm_context, 0), element_ptr, "".c_string())
			}
		}
		ArrayGetSize(size) => LLVMConstInt(LLVMIntTypeInContext(.llvm_context, 64), size as! i64, false)
		ArrayGetDataPointer(instance) => args[0]
	}

	fn codegenBuiltinFunction(mut this, builder: LLVMBuilderRef, llvm_func: LLVMFunction, builtin: BuiltinFunction, noreturn: bool = false) throws {
		match builtin {
			StructDefaultConstructor(type) => {
				for v in .program.types[type.id].member_variables {
					guard v.type is Base else {
						panic("can't generate default constructor for struct with reference member variable")
					}

					let this_member_ptr = LLVMBuildStructGEP2(builder, .types[type.id], llvm_func.args[0], v.id as! u32, "".c_string())
					let _ = .codegenCall(builder, func: v.type_default_constructor!, args: [this_member_ptr])
				}
				LLVMBuildRetVoid(builder)
			}
			StructCopyConstructor(type) => {
				for v in .program.types[type.id].member_variables {
					let this_member_ptr = LLVMBuildStructGEP2(builder, .types[type.id], llvm_func.args[0], v.id as! u32, "".c_string())
					mut other_member = LLVMBuildExtractValue(builder, llvm_func.args[1], v.id as! u32, "".c_string())

					if v.type is Base {
						if .program.functions[v.type_copy_constructor!.id].type.param_types[1].id != v.type.id {
							other_member = .codegenCall(builder, func: v.type_op_unwrap!, args: [other_member])!
						}
						let _ = .codegenCall(builder, func: v.type_copy_constructor!, args: [this_member_ptr, other_member])
					} else {
						LLVMBuildStore(builder, other_member, this_member_ptr)
					}
				}
				LLVMBuildRetVoid(builder)
			}
			StructDestructor(type) => {
				for v in .program.types[type.id].member_variables {
					if v.type is Base {
						let this_member_ptr = LLVMBuildStructGEP2(builder, .types[type.id], llvm_func.args[0], v.id as! u32, "".c_string())
						let _ = .codegenCall(builder, func: v.type_destructor!, args: [this_member_ptr])
					}
				}
				LLVMBuildRetVoid(builder)
			}
			StructOpAssign(type) => {
				for v in .program.types[type.id].member_variables {
					let this_member_ptr = LLVMBuildStructGEP2(builder, .types[type.id], llvm_func.args[0], v.id as! u32, "".c_string())
					mut other_member = LLVMBuildExtractValue(builder, llvm_func.args[1], v.id as! u32, "".c_string())

					if v.type is Base {
						if .program.functions[v.type_op_assign!.id].type.param_types[1].id != v.type.id {
							other_member = .codegenCall(builder, func: v.type_op_unwrap!, args: [other_member])!
						}

						let _ = .codegenCall(builder, func: v.type_op_assign!, args: [this_member_ptr, other_member])
					} else {
						LLVMBuildStore(builder, other_member, this_member_ptr)
					}
				}
				LLVMBuildRetVoid(builder)
			}
			StructOpEqual(type) => {
				mut acc = LLVMConstInt(.types[.program.bool_type.id], 1, false)
				for v in .program.types[type.id].member_variables {
					let this_member = LLVMBuildExtractValue(builder, llvm_func.args[0], v.id as! u32, "".c_string())
					let other_member = LLVMBuildExtractValue(builder, llvm_func.args[1], v.id as! u32, "".c_string())
					mut r = .codegenCall(builder, func: v.type_op_equal!, args: [this_member, other_member])!

					if .program.functions[v.type_op_equal!.id].name == "operator <=>" {
						r = LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntEQ.v(), r, LLVMConstInt(LLVMTypeOf(r), 0, false), "".c_string())
					}

					acc = LLVMBuildAnd(builder, acc, r, "".c_string())
				}
				LLVMBuildRet(builder, acc)
			}
			VariantCaseConstructor(type, id) => {
				let type_decl = .program.types[type.id]
				guard type_decl.kind is Variant(id_type, cases) else {
					panic("invalid case type impl")
				}

				let id_type_impl = .types[id_type.id]

				mut case_decl: VariantCaseDecl? = None
				for c in cases {
					if c.id == id {
						case_decl = c
						break
					}
				}

				guard case_decl.has_value() else {
					panic("enum case not found")
				}

				let obj = llvm_func.args[0]

				let id_ptr = LLVMBuildStructGEP2(builder, .types[type.id], obj, 0, "".c_string())
				LLVMBuildStore(builder, LLVMConstInt(id_type_impl, id, false), id_ptr)

				if not case_decl!.type.equals(other: .program.void_type) {
					let value_ptr = LLVMBuildStructGEP2(builder, .types[type.id], obj, 1, "".c_string())
					mut other_value = llvm_func.args[1]

					if case_decl!.type is Base {
						if .program.functions[case_decl!.type_copy_constructor!.id].type.param_types[1].id != case_decl!.type.id {
							other_value = .codegenCall(builder, func: case_decl!.type_op_unwrap!, args: [other_value])!
						}

						let _ = .codegenCall(builder, func: case_decl!.type_copy_constructor!, args: [value_ptr, other_value])
					} else {
						LLVMBuildStore(builder, llvm_func.args[1], value_ptr)
					}
				}

				let member_init_offset = 2 - case_decl!.type.equals(other: .program.void_type) as! usize
				for i in 0..type_decl.member_variables.size() {
					let var_decl = type_decl.member_variables[i]
					mut other_value = llvm_func.args[i + member_init_offset]

					let var_ptr = LLVMBuildStructGEP2(builder, .types[type.id], obj, i as! u32 + 2, "".c_string())

					if var_decl.type is Base {
						if .program.functions[var_decl.type_copy_constructor!.id].type.param_types[1].id != var_decl.type.id {
							other_value = .codegenCall(builder, func: var_decl.type_op_unwrap!, args: [other_value])!
						}

						let _ = .codegenCall(builder, func: var_decl.type_copy_constructor!, args: [var_ptr, other_value])
					} else {
						LLVMBuildStore(builder, other_value, var_ptr)
					}
				}

				LLVMBuildRetVoid(builder)
			}
			VariantCopyConstructor(type) => {
				let type_decl = .program.types[type.id]
				guard type_decl.kind is Variant(id_type, cases) else {
					panic("invalid case type impl")
				}

				let id_type_impl = .types[id_type.id]

				let obj = llvm_func.args[0]
				let other = LLVMBuildAlloca(builder, .types[type.id], "".c_string())
				LLVMBuildStore(builder, llvm_func.args[1], other)

				let id = LLVMBuildExtractValue(builder, llvm_func.args[1], 0, "".c_string())
				let id_ptr = LLVMBuildStructGEP2(builder, .types[type.id], obj, 0, "".c_string())
				LLVMBuildStore(builder, id, id_ptr)

				let else_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "continue".c_string())

				let switch_instr = LLVMBuildSwitch(builder, id, else_block, cases.size() as! u32)

				for c in cases {
					if c.type.equals(other: .program.void_type) {
						continue
					}

					let case_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "case".c_string())
					LLVMAddCase(switch_instr, LLVMConstInt(id_type_impl, c.id, false), case_block)
					LLVMPositionBuilderAtEnd(builder, case_block)

					let value_type = .getType(c.type)
					let this_value_ptr = LLVMBuildStructGEP2(builder, .types[type.id], obj, 1, "".c_string())
					let other_value_ptr = LLVMBuildStructGEP2(builder, .types[type.id], other, 1, "".c_string())
					mut other_value = LLVMBuildLoad2(builder, value_type, other_value_ptr, "".c_string())

					if c.type is Base {
						if .program.functions[c.type_copy_constructor!.id].type.param_types[1].id != c.type.id {
							other_value = .codegenCall(builder, func: c.type_op_unwrap!, args: [other_value])!
						}

						let _ = .codegenCall(builder, func: c.type_copy_constructor!, args: [this_value_ptr, other_value])
					} else {
						LLVMBuildStore(builder, other_value, this_value_ptr)
					}
					LLVMBuildBr(builder, else_block)
				}

				LLVMPositionBuilderAtEnd(builder, else_block)

				for i in 0..type_decl.member_variables.size() {
					let var_decl = type_decl.member_variables[i]
					let var_type = .getType(var_decl.type)

					let this_var_ptr = LLVMBuildStructGEP2(builder, .types[type.id], obj, i as! u32 + 2, "".c_string())
					let other_var_ptr = LLVMBuildStructGEP2(builder, .types[type.id], other, i as! u32 + 2, "".c_string())
					mut other_value = LLVMBuildLoad2(builder, var_type, other_var_ptr, "".c_string())

					if var_decl.type is Base {
						if .program.functions[var_decl.type_copy_constructor!.id].type.param_types[1].id != var_decl.type.id {
							other_value = .codegenCall(builder, func: var_decl.type_op_unwrap!, args: [other_value])!
						}

						let _ = .codegenCall(builder, func: var_decl.type_copy_constructor!, args: [this_var_ptr, other_value])
					} else {
						LLVMBuildStore(builder, other_value, this_var_ptr)
					}
				}

				if not noreturn {
					LLVMBuildRetVoid(builder)
				}
			}
			VariantOpAssign(type) => {
				.codegenBuiltinFunction(builder, llvm_func, builtin: BuiltinFunction::VariantDestructor(type), noreturn: true)
				.codegenBuiltinFunction(builder, llvm_func, builtin: BuiltinFunction::VariantCopyConstructor(type), noreturn: true)
				LLVMBuildRetVoid(builder)
			}
			VariantDestructor(type) => {
				let type_decl = .program.types[type.id]
				guard type_decl.kind is Variant(id_type, cases) else {
					panic("invalid case type impl")
				}

				let id_type_impl = .types[id_type.id]

				let obj = llvm_func.args[0]

				let id_ptr = LLVMBuildStructGEP2(builder, .types[type.id], obj, 0, "".c_string())
				let id = LLVMBuildLoad2(builder, id_type_impl, id_ptr, "".c_string())

				let else_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "continue".c_string())

				let switch_instr = LLVMBuildSwitch(builder, id, else_block, cases.size() as! u32)

				for c in cases {
					if c.type.equals(other: .program.void_type) or not c.type is Base {
						continue
					}

					let case_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "case".c_string())
					LLVMAddCase(switch_instr, LLVMConstInt(id_type_impl, c.id, false), case_block)
					LLVMPositionBuilderAtEnd(builder, case_block)

					let value_ptr = LLVMBuildStructGEP2(builder, .types[type.id], obj, 1, "".c_string())

					let _ = .codegenCall(builder, func: c.type_destructor!, args: [value_ptr])

					LLVMBuildBr(builder, else_block)
				}

				LLVMPositionBuilderAtEnd(builder, else_block)

				for i in 0..type_decl.member_variables.size() {
					let var_decl = type_decl.member_variables[i]
					let var_ptr = LLVMBuildStructGEP2(builder, .types[type.id], obj, i as! u32 + 2, "".c_string())
					if var_decl.type is Base {
						let _ = .codegenCall(builder, func: var_decl.type_destructor!, args: [var_ptr])
					}
				}

				if not noreturn {
					LLVMBuildRetVoid(builder)
				}
			}
			VariantOpSafeAs(type, id, optional_type, some_constructor, none_constructor) => {
				let type_decl = .program.types[type.id]
				guard type_decl.kind is Variant(id_type, cases) else {
					panic("invalid case type impl")
				}

				mut case_decl: VariantCaseDecl? = None
				for c in cases {
					if c.id == id {
						case_decl = c
						break
					}
				}

				guard case_decl.has_value() else {
					panic("enum case not found")
				}

				mut obj_ptr = match type {
					Base => {
						let tmp = LLVMBuildAlloca(builder, .types[type.id], "".c_string())
						LLVMBuildStore(builder, llvm_func.args[0], tmp)
						yield tmp
					}
					else => llvm_func.args[0]
				}

				let id_type_impl = .types[id_type.id]

				let result = LLVMBuildAlloca(builder, .types[optional_type.id], "".c_string())

				let some_branch = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "some".c_string())
				let none_branch = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "none".c_string())
				let continue_branch = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "continue".c_string())

				let id_ptr = LLVMBuildStructGEP2(builder, .types[type.id], obj_ptr, 0, "".c_string())
				let id_val = LLVMBuildLoad2(builder, .types[id_type.id], id_ptr, "".c_string())

				let same_id = LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntEQ.v(), id_val, LLVMConstInt(.types[id_type.id], id, false), "".c_string())
				LLVMBuildCondBr(builder, same_id, some_branch, none_branch)

				LLVMPositionBuilderAtEnd(builder, some_branch)
				let value_ptr = LLVMBuildStructGEP2(builder, .types[type.id], obj_ptr, 1, "".c_string())
				let value = match type {
					Base => LLVMBuildLoad2(builder, .types[case_decl!.type.id], value_ptr, "".c_string())
					else => value_ptr
				}

				let a = .codegenCall(builder, func: some_constructor, args: [result, value])
				LLVMBuildBr(builder, continue_branch)

				LLVMPositionBuilderAtEnd(builder, none_branch)
				let b = .codegenCall(builder, func: none_constructor, args: [result])
				LLVMBuildBr(builder, continue_branch)

				LLVMPositionBuilderAtEnd(builder, continue_branch)
				LLVMBuildRet(builder, LLVMBuildLoad2(builder, .types[optional_type.id], result, "".c_string()))
			}
			VariantOpEqual(type) => {
				let type_decl = .program.types[type.id]
				guard type_decl.kind is Variant(id_type, cases) else {
					panic("invalid case type impl")
				}
				let id_type_impl = .types[id_type.id]

				let this_id = LLVMBuildExtractValue(builder, llvm_func.args[0], 0, "".c_string())
				let other_id = LLVMBuildExtractValue(builder, llvm_func.args[1], 0, "".c_string())

				let this_ptr = LLVMBuildAlloca(builder, .types[type.id], "".c_string())
				LLVMBuildStore(builder, llvm_func.args[0], this_ptr)
				let other_ptr = LLVMBuildAlloca(builder, .types[type.id], "".c_string())
				LLVMBuildStore(builder, llvm_func.args[1], other_ptr)

				let check_attached_value_branch = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "check_attached_value".c_string())
				let check_member_variables_branch = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "check_member_variables".c_string())
				let unequal_branch = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "unequal".c_string())

				let equal_id = LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntEQ.v(), this_id, other_id, "".c_string())
				LLVMBuildCondBr(builder, equal_id, check_attached_value_branch, unequal_branch)

				LLVMPositionBuilderAtEnd(builder, check_attached_value_branch)

				let switch_instr = LLVMBuildSwitch(builder, this_id, check_member_variables_branch, cases.size() as! u32)

				for c in cases {
					if c.type.equals(other: .program.void_type) {
						continue
					}

					let case_block = LLVMAppendBasicBlockInContext(.llvm_context, llvm_func.impl, "case".c_string())
					LLVMAddCase(switch_instr, LLVMConstInt(id_type_impl, c.id, false), case_block)
					LLVMPositionBuilderAtEnd(builder, case_block)

					let this_value_ptr = LLVMBuildStructGEP2(builder, .types[type.id], this_ptr, 1, "".c_string())
					let other_value_ptr = LLVMBuildStructGEP2(builder, .types[type.id], other_ptr, 1, "".c_string())

					let this_value = LLVMBuildLoad2(builder, .getType(c.type), this_value_ptr, "".c_string())
					let other_value = LLVMBuildLoad2(builder, .getType(c.type), other_value_ptr, "".c_string())

					let equal_value = match c.type {
						Base => {
							mut r = .codegenCall(builder, func: c.type_op_equal!, args: [
								LLVMBuildLoad2(builder, .types[c.type.id], this_value_ptr, "".c_string())
								LLVMBuildLoad2(builder, .types[c.type.id], other_value_ptr, "".c_string())
							])!

							if .program.functions[c.type_op_equal!.id].name == "operator <=>" {
								r = LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntEQ.v(), r, LLVMConstInt(LLVMTypeOf(r), 0, false), "".c_string())
							}

							yield r
						}
						else => LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntEQ.v(), this_value, other_value, "".c_string())
					}

					LLVMBuildCondBr(builder, equal_value, check_member_variables_branch, unequal_branch)
				}

				LLVMPositionBuilderAtEnd(builder, check_member_variables_branch)
				mut acc = LLVMConstInt(.types[.program.bool_type.id], 1, false)
				for v in .program.types[type.id].member_variables {
					let this_member = LLVMBuildExtractValue(builder, llvm_func.args[0], v.id as! u32 + 2, "".c_string())
					let other_member = LLVMBuildExtractValue(builder, llvm_func.args[1], v.id as! u32 + 2, "".c_string())
					mut r = .codegenCall(builder, func: v.type_op_equal!, args: [this_member, other_member])!

					if .program.functions[v.type_op_equal!.id].name == "operator <=>" {
						r = LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntEQ.v(), r, LLVMConstInt(LLVMTypeOf(r), 0, false), "".c_string())
					}

					acc = LLVMBuildAnd(builder, acc, r, "".c_string())
				}
				LLVMBuildRet(builder, acc)

				LLVMPositionBuilderAtEnd(builder, unequal_branch)
				LLVMBuildRet(builder, LLVMConstInt(.types[.program.bool_type.id], 0, false))
			}
			ArrayDefaultConstructor(instance, element_type, size, element_default_constructor) => {
				let obj = llvm_func.args[0]
				for i in 0..size {
					mut indices = [
						LLVMConstInt(LLVMIntTypeInContext(.llvm_context, 64), 0, false),
						LLVMConstInt(LLVMIntTypeInContext(.llvm_context, 64), i as! i64, false),
					]
					let elementPtr = LLVMBuildInBoundsGEP2(builder, .types[instance.id], obj, &raw indices[0], indices.size() as! u32, "".c_string())

					let _ = .codegenCall(builder, func: element_default_constructor, args: [elementPtr])
				}
				LLVMBuildRetVoid(builder)
			}
			ArrayCopyConstructor(instance, element_type, size, element_copy_constructor) => {
				let obj = llvm_func.args[0]
				let other = llvm_func.args[1]
				for i in 0..size {
					mut indices = [
						LLVMConstInt(LLVMIntTypeInContext(.llvm_context, 64), 0, false),
						LLVMConstInt(LLVMIntTypeInContext(.llvm_context, 64), i as! i64, false),
					]
					let elementPtr = LLVMBuildInBoundsGEP2(builder, .types[instance.id], obj, &raw indices[0], indices.size() as! u32, "".c_string())

					let _ = .codegenCall(builder, func: element_copy_constructor, args: [
						elementPtr,
						LLVMBuildExtractValue(builder, other, i as! u32, "".c_string())
					])
				}
				LLVMBuildRetVoid(builder)
			}
			ArrayValueConstructor(instance, element_type, size, element_copy_constructor) => {
				let obj = llvm_func.args[0]
				for i in 0..size {
					mut indices = [
						LLVMConstInt(LLVMIntTypeInContext(.llvm_context, 64), 0, false),
						LLVMConstInt(LLVMIntTypeInContext(.llvm_context, 64), i as! i64, false),
					]
					let elementPtr = LLVMBuildInBoundsGEP2(builder, .types[instance.id], obj, &raw indices[0], indices.size() as! u32, "".c_string())

					let _ = .codegenCall(builder, func: element_copy_constructor, args: [
						elementPtr, llvm_func.args[i + 1]
					])
				}
				LLVMBuildRetVoid(builder)
			}
			ArrayOpAssign(instance, element_type, size, element_op_assign) => {
				let obj = llvm_func.args[0]
				let other = llvm_func.args[1]
				for i in 0..size {
					mut indices = [
						LLVMConstInt(LLVMIntTypeInContext(.llvm_context, 64), 0, false),
						LLVMConstInt(LLVMIntTypeInContext(.llvm_context, 64), i as! i64, false),
					]
					let elementPtr = LLVMBuildInBoundsGEP2(builder, .types[instance.id], obj, &raw indices[0], indices.size() as! u32, "".c_string())

					let _ = .codegenCall(builder, func: element_op_assign, args: [
						elementPtr,
						LLVMBuildExtractValue(builder, other, i as! u32, "".c_string())
					])
				}
				LLVMBuildRetVoid(builder)
			}
			ArrayDestructor(instance, element_type, size, element_destructor) => {
				let obj = llvm_func.args[0]
				for i in 0..size {
					mut indices = [
						LLVMConstInt(LLVMIntTypeInContext(.llvm_context, 64), 0, false),
						LLVMConstInt(LLVMIntTypeInContext(.llvm_context, 64), i as! i64, false),
					]
					let elementPtr = LLVMBuildInBoundsGEP2(builder, .types[instance.id], obj, &raw indices[0], indices.size() as! u32, "".c_string())

					let _ = .codegenCall(builder, func: element_destructor, args: [elementPtr])
				}
				LLVMBuildRetVoid(builder)
			}
		}
	}

	// LLVMStoreSizeOfType only consideres a single value, in case of an array there might be padding after each element
	fn codegenSizeOf(mut this, builder: LLVMBuilderRef, type: LLVMTypeRef) throws -> LLVMValueRef {
		mut size = LLVMConstNull(LLVMPointerTypeInContext(.llvm_context, 0))
		try {
			let indices = [LLVMConstInt(.types[.program.int_type.id], 1, false)]
			size = LLVMBuildGEP2(builder, type, LLVMConstNull(LLVMPointerTypeInContext(.llvm_context, 0)), &raw indices[0], indices.size() as! u32, "".c_string())
		} catch {
			abort()
		}

		return LLVMBuildPtrToInt(builder, size, .types[.program.int_type.id], "".c_string())
	}

	fn codegenMainFunction(mut this, main: Function) throws -> void {
		let isize_type = LLVMIntTypeInContext(.llvm_context, 64)

		let parameter_types = [
			LLVMIntTypeInContext(.llvm_context, 64)
			LLVMPointerTypeInContext(.llvm_context, 0)
		]

		let c_main_type = LLVMFunctionType(isize_type, &raw parameter_types[0], parameter_types.size() as! u32, false)
		let c_main = LLVMAddFunction(.llvm_module, "main".c_string(), c_main_type)

		let argc = LLVMGetParam(c_main, 0)
		let argv = LLVMGetParam(c_main, 1)

		let entry_block = LLVMAppendBasicBlockInContext(.llvm_context, c_main, "entry".c_string())
		let builder = LLVMCreateBuilderInContext(.llvm_context)
		LLVMPositionBuilderAtEnd(builder, entry_block)

		mut main_args: [LLVMValueRef] = []

		if .program.functions[main.id].type.param_types.size() != 0 {
			let strlen_parameter_types = [
				LLVMPointerTypeInContext(.llvm_context, 0)
			]

			let strlen_type = LLVMFunctionType(isize_type, &raw strlen_parameter_types[0], strlen_parameter_types.size() as! u32, false)
			let strlen = match LLVMHelper::LLVMHasNamedFunction(.llvm_module, "strlen") {
				true => LLVMGetNamedFunction(.llvm_module, "strlen".c_string())
				else => LLVMAddFunction(.llvm_module, "strlen".c_string(), strlen_type)
			}

			let arg_list_type_id = .program.functions[main.id].type.param_types[0].id
			guard .program.types[arg_list_type_id].template_parameters[0] is Type(value) else {
				panic("main has invalid arg type")
			}
			let arg_type_id = value!.id

			let arg_list_type = .types[arg_list_type_id]
			let stringview_type = .types[arg_type_id]

			let loop_block = LLVMAppendBasicBlockInContext(.llvm_context, c_main, "loop".c_string())
			let continue_block = LLVMAppendBasicBlockInContext(.llvm_context, c_main, "continue".c_string())

			let args_data = LLVMBuildArrayAlloca(builder, stringview_type, argc, "".c_string())
			LLVMBuildBr(builder, loop_block)
			LLVMPositionBuilderAtEnd(builder, loop_block)

			let index = LLVMBuildPhi(builder, isize_type, "".c_string())
			let next_index = LLVMBuildAdd(builder, index, LLVMConstInt(isize_type, 1, false), "".c_string())

			let incoming_values = [
				LLVMConstInt(LLVMIntTypeInContext(.llvm_context, 64), 0, false)
				next_index
			]

			let incoming_blocks = [
				entry_block, loop_block
			]

			LLVMAddIncoming(index, &raw incoming_values[0], &raw incoming_blocks[0], incoming_values.size() as! u32)

			let indices = [index]
			let arg_c_string_addr = LLVMBuildGEP2(builder, LLVMPointerTypeInContext(.llvm_context, 0), argv, &raw indices[0], indices.size() as! u32, "".c_string())
			let arg_dst = LLVMBuildGEP2(builder, stringview_type, args_data, &raw indices[0], indices.size() as! u32, "".c_string())
			let arg_c_string = LLVMBuildLoad2(builder, LLVMPointerTypeInContext(.llvm_context, 0), arg_c_string_addr, "".c_string())

			let strlen_args = [arg_c_string]
			let arg_lenth = LLVMBuildCall2(builder, strlen_type, strlen, &raw strlen_args[0], strlen_args.size() as! u64, "".c_string())

			mut arg = LLVMConstNull(stringview_type)
			arg = LLVMBuildInsertValue(builder, arg, arg_c_string, 0, "".c_string())
			arg = LLVMBuildInsertValue(builder, arg, arg_lenth, 1, "".c_string())
			LLVMBuildStore(builder, arg, arg_dst)

			LLVMBuildCondBr(builder,
				LLVMBuildICmp(builder, _LLVMIntPredicate::LLVMIntSLT.v(), next_index, argc, "".c_string())
				loop_block, continue_block
			)

			LLVMPositionBuilderAtEnd(builder, continue_block)
			mut args = LLVMConstNull(arg_list_type)
			args = LLVMBuildInsertValue(builder, args, args_data, 0, "".c_string())
			args = LLVMBuildInsertValue(builder, args, argc, 1, "".c_string())
			main_args.push(args)
		}

		let result = .codegenCall(builder, func: main, args: main_args)
		if result.has_value() {
			LLVMBuildRet(builder, result!)
		} else {
			LLVMBuildRet(builder, LLVMConstInt(LLVMIntTypeInContext(.llvm_context, 64), 0, false))
		}

		LLVMDisposeBuilder(builder)
	}

	fn finalize(mut this, options: CompilerOptions, mut module: Module) throws -> String {
		if module == .program.functions[.program.main!.id].module! {
			.codegenMainFunction(main: .program.main!)
		}

		for file in options.additional_llvm_ir_files {
			mut buffer = LLVMHelper::LLVMNullMemoryBuffer()
			mut message = null<c_char>()
			if LLVMCreateMemoryBufferWithContentsOfFile(file.c_string(), &raw buffer, &raw message) {
				println("couldn't load additional llvm-ir file {}:", file)
				println("{}", message)
				module.has_errors = true
				continue
			}
			LLVMDisposeMessage(message)

			mut other_module = LLVMHelper::LLVMNullModule()
			if LLVMParseIRInContext(.llvm_context, buffer, &raw other_module, &raw message) {
				println("couldn't load additional llvm-ir file {}:", file)
				println("{}", message)
				module.has_errors = true
				continue
			}
			LLVMDisposeMessage(message)

			LLVMLinkModules2(.llvm_module, other_module)
		}

		if .debug_info.has_value() {
			LLVMDIBuilderFinalize(.debug_info!.builder)
		}

		let file_name = options.build_dir + "/" + module.name.replace(replace: "/", with: "_") + match options.codegen_bitcode {
			true => ".bc"
			else => ".ll"
		}

		// verify
		mut message = null<c_char>()
		if LLVMVerifyModule(.llvm_module, _LLVMVerifierFailureAction::LLVMReturnStatusAction.v(), &raw message) {
			println("{}", file_name)
			println("{}", message)
			module.has_errors = true
		}
		LLVMDisposeMessage(message)

		// output
		if options.codegen_bitcode {
			if LLVMWriteBitcodeToFile(.llvm_module, file_name.c_string()) != 0 {
				module.has_errors = true
			}
		} else {
			mut message = null<c_char>()
			if LLVMPrintModuleToFile(.llvm_module, file_name.c_string(), &raw message) {
				println("{}", message)
				module.has_errors = true
			}
			LLVMDisposeMessage(message)
		}

		return file_name
	}
}
