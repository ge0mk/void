import std/core;
import std/box;
import std/io;
import std/list;
import std/map;
import std/shared;
import std/string;

import error;
import lexer;
import operators;
import program;
import span;
import syntax_tree;

enum ParserScope {
	case Root;
	case Namespace;
	case TypeDecl;
	case FunctionDecl;
	case CompoundStmt;
	case IfStmt;
	case IfVarStmt;
	case VarElseStmt;
	case WhileStmt;
	case DoWhileStmt;
	case ForStmt;
	case MatchExpr;
	case CaseStmt;
}

struct Parser {
	var program: &&Program;

	var tokens: &List!<Token>;
	var strings: &List!<String>;
	var numbers: &List!<ParsedNumber>;

	var index: uint;

	var scope_stack: List!<ParserScope>;

	func constructor(this: &&Parser, program: &&Program, tokens: &List!<Token>, strings: &List!<String>, numbers: &List!<ParsedNumber>) -> void {
		this.program := &&program;
		this.tokens := &tokens;
		this.strings := &strings;
		this.numbers := &numbers;
	}

	func constructor(this: &&Parser, other: Parser) -> void = default;
	func destructor(this: &&Parser) -> void = default;

	func pushScope(this: &&Parser, scope: ParserScope) -> void {
		this.scope_stack.append(scope);
	}

	func popScope(this: &&Parser) -> void {
		this.scope_stack.removeLast();
	}

	func countScope(this: &Parser, scope: ParserScope) -> uint {
		var result = 0u;
		for current in this.scope_stack {
			if current == scope {
				result++;
			}
		}
		return result;
	}

	func error(this: &Parser, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Error, ErrorStage::Parser, span));
	}

	func hint(this: &Parser, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Hint, ErrorStage::Parser, span));
	}

	func eof(this: &Parser) -> bool {
		return this.index >= this.tokens.size();
	}

	func next(this: &&Parser) -> void {
		if this.index < this.tokens.size() {
			this.index++;
		}
	}

	func getEofSpan(this: &Parser) -> Span {
		if const last = this.tokens.last() {
			return Span(
				last.span.end,
				last.span.end,
				last.span.line,
				(last.span.column as uint + last.span.end - last.span.start) as u16,
				last.span.file
			);
		}

		return Span();
	}

	func current(this: &Parser) -> TokenType {
		if this.index >= this.tokens.size() {
			return TokenType::EndOfFile;
		}

		return this.tokens[this.index].type();
	}

	func currentSpan(this: &Parser) -> Span {
		if this.index >= this.tokens.size() {
			return this.getEofSpan();
		}

		return this.tokens[this.index].span;
	}

	func peek(this: &Parser) -> TokenType {
		if this.index + 1 >= this.tokens.size() {
			return TokenType::EndOfFile;
		}

		return this.tokens[this.index + 1].type();
	}

	func previousSpan(this: &Parser) -> Span {
		if this.index == 0 && !this.tokens.isEmpty() {
			return this.tokens[0u].span;
		}

		if this.index - 1 >= this.tokens.size() {
			return this.getEofSpan();
		}

		return this.tokens[this.index - 1].span;
	}

	func accept(this: &&Parser, token: TokenType) -> bool {
		if this.current() == token {
			this.index++;
			return true;
		} else {
			return false;
		}
	}

	func expect(this: &&Parser, token: TokenType) -> bool {
		if this.index >= this.tokens.size() {
			this.error("unexpected end of file", this.getEofSpan());
		}

		if this.accept(token) {
			return true;
		} else {
			const current = this.tokens[this.index];
			this.error("unexpected token " + current.toString() + ", expected " + token.toString(), current.span);
			return false;
		}
	}

	func expectIdentifier(this: &&Parser) -> String {
		if this.index >= this.tokens.size() {
			this.error("unexpected end of file", this.getEofSpan());
			return "";
		}

		const current = this.tokens[this.index];
		if current.type() != Identifier {
			this.error("unexpected token " + current.toString() + ", expected identifier", current.span);
			return "";
		}

		this.index++;

		return this.strings[current.data()];
	}

	func recover(this: &&Parser, token: TokenType) -> void {
		while !(this.current() == token) && this.index < this.tokens.size() {
			this.index++;
		}
		this.index++;
	}

	func parseStmt(this: &&Parser) -> ParsedStmt {
		match this.current() {
			case KeywordPragma -> return this.parsePragma();
			case KeywordImport -> return this.parseImport();
			case KeywordFunc
			| KeywordOperator
			| KeywordNamespace
			| KeywordStruct
			| KeywordEnum
			| KeywordVariant
			| KeywordTemplate
			| AtSign -> return this.parseDecl();
			case KeywordAlias -> return this.parseAlias();
			case LCurly -> {
				const compound = this.parseCompoundStmt();
				return ParsedStmt::Compound(compound, compound.span, false);
			}
			case KeywordVar
			| KeywordConst -> return this.parseVarDeclStmt();
			case KeywordCase -> if this.countScope(ParserScope::MatchExpr) != this.countScope(ParserScope::CaseStmt) {
				return this.parseCaseStmt();
			} else {
				return this.parseCaseDecl();
			}
			case KeywordIf -> match this.peek() {
				case KeywordVar
				| KeywordConst -> return this.parseIfVarStmt();
				else -> return this.parseIfStmt();
			}
			case KeywordElse -> if this.peek() is Arrow
								&& this.countScope(ParserScope::MatchExpr) != this.countScope(ParserScope::CaseStmt) {
				const start = this.currentSpan();
				this.index += 2;

				this.pushScope(ParserScope::CaseStmt);
				const body = this.parseStmt();
				this.popScope();

				return ParsedStmt::ElseCase(Box!<ParsedStmt>(body), start..body.span, false);
			} else {
				this.next();
				return ParsedStmt::Garbage(this.previousSpan(), false);
			}
			case KeywordComptime -> match this.peek() {
				case KeywordFunc
				| KeywordOperator -> return this.parseDecl();
				case KeywordIf -> return this.parseIfStmt();
				case KeywordWhile -> return this.parseWhileStmt();
				case KeywordDo -> return this.parseDoWhileStmt();
				case KeywordFor -> return this.parseForStmt();
				case KeywordVar
				| KeywordConst -> return this.parseVarDeclStmt();
				case LCurly -> {
					this.next();
					const compound = this.parseCompoundStmt();
					return ParsedStmt::Compound(compound, compound.span, true);
				}
				else -> {
					this.next();
					this.error("invalid comptime stmt", this.previousSpan());
					return ParsedStmt::Garbage(this.previousSpan(), false);
				}
			}
			case KeywordWhile -> return this.parseWhileStmt();
			case KeywordDo -> return this.parseDoWhileStmt();
			case KeywordFor -> return this.parseForStmt();
			case KeywordBreak -> {
				const start = this.currentSpan();
				this.next();
				discard this.accept(TokenType::Semicolon);
				return ParsedStmt::Break(start..this.previousSpan(), false);
			}
			case KeywordContinue -> {
				const start = this.currentSpan();
				this.next();
				discard this.accept(TokenType::Semicolon);
				return ParsedStmt::Continue(start..this.previousSpan(), false);
			}
			case KeywordThrow -> {
				const start = this.currentSpan();
				this.next();

				var value = this.parseExpr();
				discard this.accept(TokenType::Semicolon);

				const end = this.previousSpan();
				return ParsedStmt::Throw(value, start..end, false);
			}
			case KeywordReturn -> {
				const start = this.currentSpan();
				this.next();

				var value = ParsedExpr::Empty(start);
				if !(this.current() is Semicolon || this.current() is RCurly) {
					value = this.parseExpr();
				}
				discard this.accept(TokenType::Semicolon);

				const end = this.previousSpan();
				return ParsedStmt::Return(value, start..end, false);
			}
			case KeywordYield -> {
				const start = this.currentSpan();
				this.next();

				var value = ParsedExpr::Empty(start);
				if !(this.current() is Semicolon || this.current() is RCurly) {
					value = this.parseExpr();
				}
				discard this.accept(TokenType::Semicolon);

				const end = this.previousSpan();
				return ParsedStmt::Yield(value, start..end, false);
			}
			case KeywordDiscard -> {
				const start = this.currentSpan();
				this.next();

				var value = this.parseExpr();
				discard this.accept(TokenType::Semicolon);

				const end = this.previousSpan();
				return ParsedStmt::Discard(value, start..end, false);
			}
			else -> {
				const expr = this.parseExpr();
				discard this.accept(TokenType::Semicolon);
				return ParsedStmt::Expr(expr, expr.span, false);
			}
		}
	}

	func parsePragma(this: &&Parser) -> ParsedStmt {
		const start = this.currentSpan();
		if !this.expect(TokenType::KeywordPragma) {
			return ParsedStmt::Garbage(start..this.currentSpan(), false);
		}

		const name = this.expectIdentifier();
		if name.isEmpty() {
			return ParsedStmt::Garbage(start..this.currentSpan(), false);
		}

		discard this.accept(TokenType::Semicolon);

		const end = this.previousSpan();

		return ParsedStmt::Pragma(name, start..end, true);
	}

	func parseImport(this: &&Parser) -> ParsedStmt {
		const start = this.currentSpan();
		if !this.expect(TokenType::KeywordImport) {
			return ParsedStmt::Garbage(start..this.currentSpan(), false);
		}

		var name = this.expectIdentifier();
		if name.isEmpty() {
			return ParsedStmt::Garbage(start..this.currentSpan(), false);
		}

		while this.current() is Slash {
			this.next();
			const segment = this.expectIdentifier();
			if name.isEmpty() {
				return ParsedStmt::Garbage(start..this.currentSpan(), false);
			}

			name += "/" + segment;
		}

		discard this.accept(TokenType::Semicolon);

		const end = this.previousSpan();

		return ParsedStmt::Import(name, start..end, true);
	}

	func parseDecl(this: &&Parser) -> ParsedStmt {
		const start = this.currentSpan();

		var annotations = this.parseAnnotations();
		var template_parameters = this.parseTemplateParameterDecl();

		var result = ParsedStmt::Garbage(start..this.currentSpan(), false);
		match this.current() {
			case KeywordNamespace -> result = this.parseNamespace(start, annotations, template_parameters);
			case KeywordStruct
			| KeywordEnum
			| KeywordVariant -> result = this.parseTypeDecl(start, annotations, template_parameters);
			case KeywordFunc
			| KeywordOperator
			| KeywordComptime -> result = this.parseFunctionDecl(start, annotations, template_parameters);
			else -> {}
		}

		return result;
	}

	func parseAnnotations(this: &&Parser) -> List!<ParsedAnnotation> {
		var annotations: List!<ParsedAnnotation>;

		if !this.accept(TokenType::AtSign) {
			return annotations;
		}

		if !this.expect(TokenType::LSquare) {
			return annotations;
		}

		var error = false;
		while !this.accept(TokenType::RSquare) {
			const start = this.currentSpan();
			const name = this.expectIdentifier();
			if name.isEmpty() {
				error = true;
				break;
			}

			if this.accept(TokenType::Colon) {
				if this.index >= this.tokens.size() {
					error = true;
					break;
				}

				match this.current() {
					case StringLiteral -> {
						const end = this.currentSpan();
						const value = this.strings[this.tokens[this.index].data()];
						this.next();
						annotations.append(ParsedAnnotation::String(value, start..end, name));
					}
					case NumberLiteral -> {
						const end = this.currentSpan();
						const value = this.numbers[this.tokens[this.index].data()];
						this.next();
						annotations.append(ParsedAnnotation::Number(value, start..end, name));
					}
					else -> {
						error = true;
						break;
					}
				}
			} else {
				annotations.append(ParsedAnnotation::Flag(start, name));
			}

			if !(this.current() is RSquare) {
				if !this.expect(TokenType::Comma) {
					error = true;
					break;
				}
			}
		}

		if error {
			this.recover(TokenType::RSquare);
		}

		return annotations;
	}

	func parseTemplateParameterDecl(this: &&Parser) -> List!<ParsedTemplateParameterDecl> {
		var template_parameters: List!<ParsedTemplateParameterDecl>;

		if !this.accept(TokenType::KeywordTemplate) {
			return template_parameters;
		}

		if !this.expect(TokenType::LessThan) {
			return template_parameters;
		}

		var error = false;
		while !this.accept(TokenType::GreaterThan) {
			const start = this.currentSpan();
			const name = this.expectIdentifier();
			if name.isEmpty() {
				error = true;
				break;
			}

			if !this.expect(TokenType::Colon) {
				error = true;
				break;
			}

			const concept = this.expectIdentifier();
			if concept.isEmpty() {
				error = true;
				break;
			}

			var value = ParsedExpr::Empty(this.previousSpan());
			if this.accept(TokenType::Assign) {
				value = this.parseHighPrecedenceExpr();
			}

			const end = this.previousSpan();
			template_parameters.append(ParsedTemplateParameterDecl(start..end, name, concept, value));

			if !(this.current() is GreaterThan) {
				if !this.expect(TokenType::Comma) {
					error = true;
					break;
				}
			}
		}

		if error {
			this.recover(TokenType::GreaterThan);
		}

		return template_parameters;
	}

	func parseNamespace(this: &&Parser, start: Span, annotations: List!<ParsedAnnotation>, template_parameters: List!<ParsedTemplateParameterDecl>) -> ParsedStmt {
		if !this.expect(TokenType::KeywordNamespace) {
			return ParsedStmt::Garbage(start..this.previousSpan(), false);
		}

		const name = this.expectIdentifier();
		if name.isEmpty() {
			return ParsedStmt::Garbage(start..this.previousSpan(), false);
		}

		var decl = ParsedNamespace(start, this.previousSpan(), annotations, template_parameters, name, SharedPtr!<List!<ParsedStmt>>(List!<ParsedStmt>()));

		if !this.expect(TokenType::LCurly) {
			return ParsedStmt::Garbage(start..this.previousSpan(), false);
		}

		this.pushScope(ParserScope::Namespace);

		while !this.accept(TokenType::RCurly) {
			const child = this.parseStmt();
			if !(child is Garbage) {
				decl.children.append(child);
			}
		}

		this.popScope();

		decl.span = start..this.previousSpan();
		return ParsedStmt::Namespace(decl, decl.span, false);
	}

	func parseTypeDecl(this: &&Parser, start: Span, annotations: List!<ParsedAnnotation>, template_parameters: List!<ParsedTemplateParameterDecl>) -> ParsedStmt {
		const kind = match this.current() {
			case KeywordStruct -> yield TypeDeclKind::Struct;
			case KeywordEnum -> yield TypeDeclKind::Enum;
			case KeywordVariant -> yield TypeDeclKind::Variant;
			else -> {
				return ParsedStmt::Garbage(start..this.previousSpan(), false);
			}
		}

		this.next();

		const name = this.expectIdentifier();
		if name.isEmpty() {
			return ParsedStmt::Garbage(start..this.previousSpan(), false);
		}
		const name_span = this.previousSpan();

		var id_type = ParsedType::Empty(Span());
		if kind == Enum || kind == Variant {
			if this.accept(TokenType::Colon) {
				id_type = this.parseType();
			}
		}

		if !this.expect(TokenType::LCurly) {
			return ParsedStmt::Garbage(start..this.previousSpan(), false);
		}

		this.pushScope(ParserScope::TypeDecl);

		var children: SharedPtr!<List!<ParsedStmt>> = List!<ParsedStmt>();
		while !this.accept(TokenType::RCurly) {
			const child = this.parseStmt();
			if !(child is Garbage) {
				children.append(child);
			}
		}

		this.popScope();

		const span = start..this.previousSpan();
		return ParsedStmt::TypeDecl(ParsedTypeDecl(
			span, name_span,
			annotations,
			template_parameters,
			kind,
			name,
			id_type,
			children
		), span, false);
	}

	func parseFunctionDecl(this: &&Parser, start: Span, annotations: List!<ParsedAnnotation>, template_parameters: List!<ParsedTemplateParameterDecl>) -> ParsedStmt {
		const is_comptime = this.accept(TokenType::KeywordComptime);

		const signature = this.parseFunctionSignature() else {
			return ParsedStmt::Garbage(this.currentSpan(), false);
		}

		var body = ParsedStmt::Garbage(start, false);
		if this.accept(TokenType::Assign) {
			if this.accept(TokenType::KeywordExtern) {
				body = ParsedStmt::ExternFunctionBody(this.previousSpan(), false);
			} else if this.expect(TokenType::KeywordDefault) {
				body = ParsedStmt::DefaultFunctionBody(this.previousSpan(), false);
			}

			discard this.accept(TokenType::Semicolon);
		} else {
			this.pushScope(ParserScope::FunctionDecl);
			const compound_stmt = this.parseCompoundStmt();
			body = ParsedStmt::Compound(compound_stmt, compound_stmt.span, false);
			this.popScope();
		}

		const span = start..this.previousSpan();
		return ParsedStmt::FunctionDecl(Box!<ParsedFunctionDecl>(ParsedFunctionDecl(
			span,
			annotations,
			template_parameters,
			is_comptime,
			signature,
			body
		)), span, true);
	}

	func parseFunctionSignature(this: &&Parser) -> Optional!<ParsedFunctionSignature> {
		const start = this.currentSpan();

		var name = "";
		match this.current() {
			case KeywordFunc -> {
				this.next();
				name = this.expectIdentifier();
			}
			case KeywordOperator -> name = this.parseOperatorName();
			else -> return None;
		}

		return this.parseFunctionSignature(name, start);
	}

	func parseFunctionSignature(this: &&Parser, name: String, start: Span) -> Optional!<ParsedFunctionSignature> {
		if !this.expect(TokenType::LParen) {
			return None;
		}

		var parameters: List!<ParsedParameterDecl>;
		var error = false;
		while !this.accept(TokenType::RParen) {
			const parameter_start = this.currentSpan();

			const annotations = this.parseAnnotations();
			const parameter_name = this.expectIdentifier();
			if parameter_name.isEmpty() {
				error = true;
				break;
			}

			if !this.expect(TokenType::Colon) {
				error = true;
				break;
			}

			const param_type = this.parseType();
			var initializer = ParsedExpr::Empty(this.previousSpan());
			if this.accept(TokenType::Assign) {
				initializer = this.parseExpr();
			}

			parameters.append(ParsedParameterDecl(
				parameter_start..this.previousSpan(),
				annotations,
				parameter_name,
				param_type,
				initializer
			));

			if !(this.current() is RParen) {
				if !this.expect(TokenType::Comma) {
					error = true;
					break;
				}
			}
		}

		if error {
			this.recover(TokenType::RParen);
		}

		if !this.expect(TokenType::Arrow) {
			this.error("expected function return type", this.currentSpan());
			return Some(ParsedFunctionSignature(start..this.previousSpan(), name, parameters, ParsedType::Garbage(this.currentSpan())));
		}

		const return_type = this.parseType();
		return Some(ParsedFunctionSignature(start..this.previousSpan(), name, parameters, return_type));
	}

	func parseVarDecl(this: &&Parser) -> Optional!<ParsedVarDecl> {
		const start = this.currentSpan();
		const is_const = this.accept(TokenType::KeywordConst);
		if !is_const {
			if !this.expect(TokenType::KeywordVar) {
				return None;
			}
		}

		const name = this.expectIdentifier();
		if name.isEmpty() {
			return None;
		}

		var var_type = ParsedType::Empty(this.previousSpan());
		if this.accept(TokenType::Colon) {
			var_type = this.parseType();
		}

		if var_type is Empty && !(this.current() is Assign) {
			this.error("variable must be declared with a type or an initializer", start..this.previousSpan());
			return None;
		}

		var initializer = ParsedExpr::Empty(this.previousSpan());
		if this.accept(TokenType::Assign) {
			initializer = this.parseExpr();
		}

		return Some(ParsedVarDecl(start..this.previousSpan(), name, is_const, var_type, initializer));
	}

	func parseCaseDecl(this: &&Parser) -> ParsedStmt {
		const start = this.currentSpan();
		if !this.expect(TokenType::KeywordCase) {
			return ParsedStmt::Garbage(start, false);
		}

		const name = this.expectIdentifier();
		if name.isEmpty() {
			return ParsedStmt::Garbage(start, false);
		}

		var payload = ParsedType::Empty(this.previousSpan());
		if this.accept(TokenType::Colon) {
			payload = this.parseType();
		}

		var id = ParsedExpr::Empty(this.previousSpan());
		if this.accept(TokenType::Assign) {
			id = this.parseExpr();
		}

		discard this.accept(TokenType::Semicolon);
		const decl = ParsedCaseDecl(start..this.previousSpan(), name, payload, id);
		return ParsedStmt::CaseDecl(decl, decl.span, true);
	}

	func parseAlias(this: &&Parser) -> ParsedStmt {
		const start = this.currentSpan();
		if !this.expect(TokenType::KeywordAlias) {
			return ParsedStmt::Garbage(start, false);
		}

		const name = this.expectIdentifier();
		if name.isEmpty() {
			return ParsedStmt::Garbage(start..this.previousSpan(), false);
		}

		if !this.expect(TokenType::Assign) {
			return ParsedStmt::Garbage(start..this.previousSpan(), false);
		}

		const type = this.parseType();

		discard this.accept(TokenType::Semicolon);
		return ParsedStmt::Alias(ParsedTypeAlias(name, type), start..this.previousSpan(), true);
	}

	func parseCompoundStmt(this: &&Parser) -> ParsedCompoundStmt {
		var stmt = ParsedCompoundStmt(this.currentSpan(), SharedPtr!<List!<ParsedStmt>>(List!<ParsedStmt>()));

		if !this.expect(TokenType::LCurly) {
			return stmt;
		}

		this.pushScope(ParserScope::CompoundStmt);

		while !this.accept(TokenType::RCurly) {
			const child = this.parseStmt();
			if !(child is Garbage) {
				stmt.children.append(child);
			}
		}

		this.popScope();

		stmt.span = stmt.span..this.previousSpan();
		return stmt;
	}

	func parseVarDeclStmt(this: &&Parser) -> ParsedStmt {
		const start = this.currentSpan();

		const is_comptime = this.accept(TokenType::KeywordComptime);

		const decl = this.parseVarDecl() else {
			return ParsedStmt::Garbage(start..this.previousSpan(), false);
		}

		if this.accept(TokenType::KeywordElse) {
			var capture_name = "";
			var capture_kind = ReferenceKind::None;
			if this.accept(TokenType::Colon) {
				if this.accept(TokenType::Ampersand) {
					capture_kind = ReferenceKind::Const;
				} else if this.accept(TokenType::DoubleAmpersand) {
					capture_kind = ReferenceKind::Var;
				}

				capture_name = this.expectIdentifier();
			}

			this.pushScope(ParserScope::VarElseStmt);
			const body = this.parseCompoundStmt();
			this.popScope();

			return ParsedStmt::VarElse(
				ParsedVarElseStmt(decl, body, capture_name, capture_kind),
				start..this.previousSpan(), is_comptime
			);
		} else {
			discard this.accept(TokenType::Semicolon);
			return ParsedStmt::VarDecl(decl, decl.span, is_comptime);
		}
	}

	func parseIfStmt(this: &&Parser) -> ParsedStmt {
		const start = this.currentSpan();

		const is_comptime = this.accept(TokenType::KeywordComptime);

		if !this.expect(TokenType::KeywordIf) {
			return ParsedStmt::Garbage(start..this.currentSpan(), is_comptime);
		}

		const condition = this.parseExpr();

		this.pushScope(ParserScope::IfStmt);
		const then_branch = this.parseCompoundStmt();

		var else_branch = ParsedStmt::Empty(Span(), false);
		if this.accept(TokenType::KeywordElse) {
			else_branch = this.parseStmt();
			else_branch.is_comptime = is_comptime;
		}

		this.popScope();

		return ParsedStmt::If(
			Box!<ParsedIfStmt>(ParsedIfStmt(condition, ParsedStmt::Compound(then_branch, then_branch.span, false), else_branch)),
			start..this.previousSpan(), is_comptime
		);
	}

	func parseIfVarStmt(this: &&Parser) -> ParsedStmt {
		const start = this.currentSpan();
		if !this.expect(TokenType::KeywordIf) {
			return ParsedStmt::Garbage(start, false);
		}

		const var_decl = this.parseVarDecl() else {
			return ParsedStmt::Garbage(start..this.previousSpan(), false);
		}

		this.pushScope(ParserScope::IfVarStmt);
		const body = this.parseCompoundStmt();
		this.popScope();

		return ParsedStmt::IfVar(
			ParsedIfVarStmt(var_decl, body),
			start..this.previousSpan(), false
		);
	}

	func parseWhileStmt(this: &&Parser) -> ParsedStmt {
		const start = this.currentSpan();

		const is_comptime = this.accept(TokenType::KeywordComptime);

		if !this.expect(TokenType::KeywordWhile) {
			return ParsedStmt::Garbage(start..this.previousSpan(), false);
		}

		const condition = this.parseExpr();

		this.pushScope(ParserScope::WhileStmt);
		const body = this.parseCompoundStmt();
		this.popScope();

		return ParsedStmt::While(
			ParsedWhileStmt(condition, body),
			start..this.previousSpan(), is_comptime
		);
	}

	func parseDoWhileStmt(this: &&Parser) -> ParsedStmt {
		const start = this.currentSpan();

		const is_comptime = this.accept(TokenType::KeywordComptime);

		if !this.expect(TokenType::KeywordDo) {
			return ParsedStmt::Garbage(start..this.previousSpan(), false);
		}

		this.pushScope(ParserScope::DoWhileStmt);
		const body = this.parseCompoundStmt();
		this.popScope();

		if !this.expect(TokenType::KeywordWhile) {
			return ParsedStmt::Garbage(start..this.previousSpan(), false);
		}

		const condition = this.parseExpr();
		discard this.accept(TokenType::Semicolon);

		return ParsedStmt::DoWhile(
			ParsedDoWhileStmt(body, condition),
			start..this.previousSpan(), is_comptime
		);
	}

	func parseForStmt(this: &&Parser) -> ParsedStmt {
		const start = this.currentSpan();
		const is_comptime = this.accept(TokenType::KeywordComptime);

		if !this.expect(TokenType::KeywordFor) {
			return ParsedStmt::Garbage(start..this.previousSpan(), false);
		}

		var capture_kind = ReferenceKind::None;
		if this.accept(TokenType::Ampersand) {
			capture_kind = ReferenceKind::Const;
		} else if this.accept(TokenType::DoubleAmpersand) {
			capture_kind = ReferenceKind::Var;
		}

		const capture_name = this.expectIdentifier();
		if capture_name.isEmpty() {
			return ParsedStmt::Garbage(start..this.previousSpan(), false);
		}
		const capture_span = this.previousSpan();

		if !this.expect(TokenType::KeywordIn) {
			return ParsedStmt::Garbage(start..this.previousSpan(), false);
		}

		const range = this.parseExpr();

		this.pushScope(ParserScope::ForStmt);
		const body = this.parseCompoundStmt();
		this.popScope();

		return ParsedStmt::For(
			ParsedForStmt(capture_name, capture_kind, capture_span, range, body),
			start..this.previousSpan(), is_comptime
		);
	}

	func parseCaseStmt(this: &&Parser) -> ParsedStmt {
		const start = this.currentSpan();
		if !this.expect(TokenType::KeywordCase) {
			return ParsedStmt::Garbage(start, false);
		}

		var patterns: List!<ParsedExpr>;
		do {
			patterns.append(this.parseOperand());
		} while this.accept(TokenType::Pipe);

		var capture_name = "";
		var capture_kind = ReferenceKind::None;
		if this.accept(TokenType::Colon) {
			if this.accept(TokenType::Ampersand) {
				capture_kind = ReferenceKind::Const;
			} else if this.accept(TokenType::DoubleAmpersand) {
				capture_kind = ReferenceKind::Var;
			}

			capture_name = this.expectIdentifier();
		}

		if !this.expect(TokenType::Arrow) {
			return ParsedStmt::Garbage(this.previousSpan(), false);
		}

		this.pushScope(ParserScope::CaseStmt);
		const body = this.parseStmt();
		this.popScope();

		return ParsedStmt::Case(
			Box!<ParsedCaseStmt>(ParsedCaseStmt(patterns, capture_name, capture_kind, body)),
			start..this.previousSpan(), false
		);
	}

	func parseType(this: &&Parser) -> ParsedType {
		const start = this.currentSpan();
		match this.current() {
			case Identifier -> {
				const name = this.parseName();
				return ParsedType::Name(name, name.span);
			}
			case Ampersand -> {
				this.next();
				const base = this.parseType();
				return ParsedType::ConstReference(Box!<ParsedType>(base), start..base.span);
			}
			case DoubleAmpersand -> {
				this.next();
				const base = this.parseType();
				return ParsedType::VarReference(Box!<ParsedType>(base), start..base.span);
			}
			case QuestionMark -> {
				this.next();
				const base = this.parseType();
				return ParsedType::Optional(Box!<ParsedType>(base), start..base.span);
			}
			case LParen -> {
				this.next();
				var is_named = false;
				var types: List!<ParsedType>;
				var elements: List!<ParsedTupleTypeElement>;

				while !this.accept(TokenType::RParen) {
					var name = "";
					if this.peek() is Colon {
						is_named = true;
						name = this.expectIdentifier();
						if name.isEmpty() {
							this.next();
						}
						discard this.expect(TokenType::Colon);
					}

					const type = this.parseType();
					types.append(type);
					elements.append(ParsedTupleTypeElement(name, type));

					if !(this.current() is RParen) {
						if !this.expect(TokenType::Comma) {
							this.recover(TokenType::RParen);
							break;
						}
					}
				}

				if this.accept(TokenType::Arrow) {
					const return_type = Box!<ParsedType>(this.parseType());
					return ParsedType::Function(ParsedFunctionType(types, return_type), start..this.previousSpan());
				} else {
					return ParsedType::Tuple(elements, start..this.previousSpan());
				}
			}
			case LSquare -> {
				this.next();
				const element_type = Box!<ParsedType>(this.parseType());

				if this.accept(TokenType::Comma) {
					const size = Box!<ParsedExpr>(this.parseExpr());
					discard this.expect(TokenType::RSquare);
					return ParsedType::Array(ParsedArrayType(element_type, size), start..this.previousSpan());
				} else {
					discard this.expect(TokenType::RSquare);
					return ParsedType::List(element_type, start..this.previousSpan());
				}
			}
			case LCurly -> {
				this.next();
				const key_type = Box!<ParsedType>(this.parseType());
				discard this.expect(TokenType::Comma);
				const value_type = Box!<ParsedType>(this.parseType());
				discard this.expect(TokenType::RCurly);
				return ParsedType::Dict(ParsedDictType(key_type, value_type), start..this.previousSpan());
			}
			else -> {
				this.next();
				this.error("invalid type", start);
				return ParsedType::Garbage(start);
			}
		}
	}

	func parseName(this: &&Parser) -> ParsedName {
		const start = this.currentSpan();

		var segments: List!<ParsedNameSegment>;

		match this.parseNameSegment() {
			case Some: segment -> segments.append(segment);
			else -> return ParsedName(start, segments);
		}

		while this.current() is DoubleColon {
			this.next();
			match this.parseNameSegment() {
				case Some: segment -> segments.append(segment);
				else -> break;
			}
		}

		const span = start..this.previousSpan();
		return ParsedName(span, segments);
	}

	func parseNameSegment(this: &&Parser) -> Optional!<ParsedNameSegment> {
		const start = this.currentSpan();
		var name = "";
		if this.current() is Identifier {
			name = this.expectIdentifier();
		} else if this.current() is KeywordOperator {
			name = this.parseOperatorName();
		} else {
			return None;
		}

		const template_parameters = this.parseTemplateParameters();
		return Some(ParsedNameSegment(start..this.previousSpan(), name, template_parameters));
	}

	func parseOperatorName(this: &&Parser) -> String {
		const start = this.currentSpan();
		if !this.expect(TokenType::KeywordOperator) {
			return "";
		}

		if this.accept(TokenType::KeywordUnwrap) {
			return "operator unwrap";
		}

		const op = this.parseOperator() else {
			this.error("invalid operator name is not an operator", start);
			return "";
		}

		if op == Call {
			discard this.expect(TokenType::RParen);
		} else if op == Index {
			discard this.expect(TokenType::RSquare);
		} else if op == VarRef || op >= Try {
			this.error("invalid operator name \"" + op.toString() + "\"", start..this.previousSpan());
		}

		return "operator " + op.toString();
	}

	func parseTemplateParameters(this: &&Parser) -> List!<ParsedExpr> {
		var template_parameters: List!<ParsedExpr>;

		if !this.accept(TokenType::ExclamationMark) {
			return template_parameters;
		}

		if !this.expect(TokenType::LessThan) {
			return template_parameters;
		}

		while !this.accept(TokenType::GreaterThan) {
			template_parameters.append(this.parseHighPrecedenceExpr());

			if !(this.current() is GreaterThan) {
				if !this.expect(TokenType::Comma) {
					this.recover(TokenType::GreaterThan);
					break;
				}
			}
		}

		return template_parameters;
	}

	func parseExpr(this: &&Parser) -> ParsedExpr {
		return this.parseExpr(-1);
	}

	func parseHighPrecedenceExpr(this: &&Parser) -> ParsedExpr {
		return this.parseExpr(16);
	}

	func parseExpr(this: &&Parser, min_precedence: int) -> ParsedExpr {
		var lhs = ParsedExpr::Garbage(this.currentSpan());
		var start = this.currentSpan();

		match this.parsePrefixOperator() {
			case Some: op -> {
				const rhs = this.parseExpr(op.precedence());
				var operands: SharedPtr!<List!<ParsedExpr>> = List!<ParsedExpr>(1u, rhs);
				lhs = ParsedExpr::Operator(ParsedOperatorExpr(op, operands), start..rhs.span);
			}
			else -> lhs = this.parseOperand();
		}

		while true {
			const prev_index = this.index;
			var op = this.parsePostfixOrInfixOperator() else {
				this.index = prev_index;
				break;
			}

			if op.precedence() <= min_precedence {
				this.index = prev_index;
				break;
			}

			var operands: SharedPtr!<List!<ParsedExpr>> = List!<ParsedExpr>(1u, lhs);
			if op == Call {
				while !this.accept(TokenType::RParen) {
					operands.append(this.parseExpr());

					if !(this.current() is RParen) {
						if !this.expect(TokenType::Comma) {
							this.recover(TokenType::RParen);
							break;
						}
					}
				}
			} else if op == Index {
				while !this.accept(TokenType::RSquare) {
					operands.append(this.parseExpr());

					if !(this.current() is RSquare) {
						if !this.expect(TokenType::Comma) {
							this.recover(TokenType::RSquare);
							break;
						}
					}
				}
			} else if op == InlineIf {
				if this.accept(TokenType::KeywordVar) || this.accept(TokenType::KeywordConst) {
					// expression followed by an if-var stmt
					this.index = prev_index;
					break;
				}

				operands.append(this.parseExpr());

				if !this.accept(TokenType::KeywordElse) {
					// expression followed by an if stmt
					this.index = prev_index;
					break;
				}

				operands.append(this.parseExpr());
			} else if op == MemberAccess {
				operands.append(this.parseOperand());
			} else if op.isBinaryOperator() {
				operands.append(this.parseExpr(op.precedence()));
			} else if !op.isUnaryOperator() {
				this.error("unknown operator " + op.toString(), this.previousSpan());
				continue;
			}

			lhs = ParsedExpr::Operator(
				ParsedOperatorExpr(op, operands),
				start..this.previousSpan()
			);
		}

		return lhs;
	}

	func parsePrefixOperator(this: &&Parser) -> Optional!<Operator> {
		match this.current() {
			case Minus -> {
				this.next();
				return Some(Operator::Negate);
			}
			case Tilde -> {
				this.next();
				return Some(Operator::BitwiseNot);
			}
			case ExclamationMark -> {
				this.next();
				return Some(Operator::LogicalNot);
			}
			case Ampersand -> {
				this.next();
				return Some(Operator::ConstRef);
			}
			case DoubleAmpersand -> {
				this.next();
				return Some(Operator::VarRef);
			}
			case KeywordTry -> {
				this.next();
				return Some(Operator::Try);
			}
			case KeywordMust -> {
				this.next();
				return Some(Operator::Must);
			}
			else -> return None;
		}
	}

	func parsePostfixOperator(this: &&Parser) -> Optional!<Operator> {
		match this.current() {
			case DoublePlus -> {
				this.next();
				return Some(Operator::Increment);
			}
			case DoubleMinus -> {
				this.next();
				return Some(Operator::Decrement);
			}
			case LParen -> {
				this.next();
				return Some(Operator::Call);
			}
			case LSquare -> {
				this.next();
				return Some(Operator::Index);
			}
			else -> return None;
		}
	}

	func parseInfixOperator(this: &&Parser) -> Optional!<Operator> {
		match this.current() {
			case Plus -> {
				this.next();
				return Some(Operator::Add);
			}
			case Minus -> {
				this.next();
				return Some(Operator::Sub);
			}
			case Asterisk -> {
				this.next();
				return Some(Operator::Mul);
			}
			case Slash -> {
				this.next();
				return Some(Operator::Div);
			}
			case Percent -> {
				this.next();
				return Some(Operator::Mod);
			}
			case Ampersand -> {
				this.next();
				return Some(Operator::BitwiseAnd);
			}
			case Pipe -> {
				this.next();
				return Some(Operator::BitwiseOr);
			}
			case Caret -> {
				this.next();
				return Some(Operator::BitwiseXOr);
			}
			case DoubleAmpersand -> {
				this.next();
				return Some(Operator::LogicalAnd);
			}
			case DoublePipe -> {
				this.next();
				return Some(Operator::LogicalOr);
			}
			case DoubleQuestionMark -> {
				this.next();
				return Some(Operator::Coalescing);
			}
			case Assign -> {
				this.next();
				return Some(Operator::Assign);
			}
			case ColonAssign -> {
				this.next();
				return Some(Operator::Initialize);
			}
			case PlusAssign -> {
				this.next();
				return Some(Operator::AddAssign);
			}
			case MinusAssign -> {
				this.next();
				return Some(Operator::SubAssign);
			}
			case AsteriskAssign -> {
				this.next();
				return Some(Operator::MulAssign);
			}
			case SlashAssign -> {
				this.next();
				return Some(Operator::DivAssign);
			}
			case PercentAssign -> {
				this.next();
				return Some(Operator::ModAssign);
			}
			case AmpersandAssign -> {
				this.next();
				return Some(Operator::BitwiseAndAssign);
			}
			case PipeAssign -> {
				this.next();
				return Some(Operator::BitwiseOrAssign);
			}
			case CaretAssign -> {
				this.next();
				return Some(Operator::BitwiseXOrAssign);
			}
			case DoubleQuestionMarkAssign -> {
				this.next();
				return Some(Operator::CoalescingAssign);
			}
			case Equal -> {
				this.next();
				return Some(Operator::Equal);
			}
			case NotEqual -> {
				this.next();
				return Some(Operator::NotEqual);
			}
			case Spaceship -> {
				this.next();
				return Some(Operator::Spaceship);
			}
			case DoubleDot -> {
				this.next();
				return Some(Operator::Range);
			}
			case KeywordIs -> {
				this.next();
				return Some(Operator::Is);
			}
			case KeywordAs -> {
				this.next();
				return Some(Operator::As);
			}
			case KeywordIf -> {
				this.next();
				return Some(Operator::InlineIf);
			}
			case Dot -> {
				this.next();
				return Some(Operator::MemberAccess);
			}
			case LessThan -> {
				this.next();
				if this.current() is LessEqual {
					this.next();
					return Some(Operator::ShiftLeftAssign);
				} else if this.current() is LessThan {
					this.next();
					return Some(Operator::ShiftLeft);
				} else {
					return Some(Operator::LessThan);
				}
			}
			case LessEqual -> {
				this.next();
				return Some(Operator::LessEqual);
			}
			case GreaterThan -> {
				this.next();
				if this.current() is GreaterEqual {
					this.next();
					return Some(Operator::ShiftRightAssign);
				} else if this.current() is GreaterThan {
					this.next();
					return Some(Operator::ShiftRight);
				} else {
					return Some(Operator::GreaterThan);
				}
			}
			case GreaterEqual -> {
				this.next();
				return Some(Operator::GreaterEqual);
			}
			else -> return None;
		}
	}

	func parsePostfixOrInfixOperator(this: &&Parser) -> Optional!<Operator> {
		if const op = this.parsePostfixOperator() {
			return Some(op);
		}

		if const op = this.parseInfixOperator() {
			return Some(op);
		}

		return None;
	}

	func parseOperator(this: &&Parser) -> Optional!<Operator> {
		if const op = this.parsePrefixOperator() {
			return Some(op);
		}

		if const op = this.parsePostfixOrInfixOperator() {
			return Some(op);
		}

		return None;
	}

	func parseArrayExpr(this: &&Parser) -> ParsedExpr {
		const start = this.currentSpan();

		if !this.expect(TokenType::LSquare) {
			return ParsedExpr::Garbage(start);
		}

		var values: List!<ParsedExpr>;

		var error = false;
		while !this.accept(TokenType::RSquare) {
			values.append(this.parseExpr());

			if !(this.current() is RSquare) {
				if !this.expect(TokenType::Comma) {
					error = true;
					break;
				}
			}
		}

		if error {
			this.recover(TokenType::RSquare);
		}

		const end = this.previousSpan();
		return ParsedExpr::Array(values, start..end);
	}

	func parseTupleExpr(this: &&Parser) -> ParsedExpr {
		const start = this.currentSpan();

		if !this.expect(TokenType::LParen) {
			return ParsedExpr::Garbage(start);
		}

		var elements: List!<ParsedTupleElement>;
		var is_named = false;
		while !this.accept(TokenType::RParen) {
			const element_start = this.currentSpan();

			var name = "";
			if this.current() is Identifier && this.peek() is Colon {
				name = this.strings[this.tokens[this.index].data()];
				is_named = true;
				this.index += 2;
			}

			const value = this.parseExpr();

			elements.append(ParsedTupleElement(element_start..value.span, name, value));

			if !(this.current() is RParen) {
				if !this.expect(TokenType::Comma) {
					this.recover(TokenType::RParen);
					break;
				}
			}
		}

		if !is_named {
			if this.accept(TokenType::Arrow) {
				var is_valid_function_type = true;

				var parameter_types: List!<ParsedType>;
				for e in elements {
					const t = e.value.toType();
					if t is Garbage {
						is_valid_function_type = false;
						break;
					}

					parameter_types.append(t);
				}

				const return_type = Box!<ParsedType>(this.parseType());
				const function_type = ParsedType::Function(
					ParsedFunctionType(parameter_types, return_type),
					start..this.previousSpan()
				);
				return ParsedExpr::Type(function_type, start..this.previousSpan());
			}
		}

		const end = this.previousSpan();
		if elements.size() == 1 && !is_named {
			return ParsedExpr::Paren(Box!<ParsedExpr>(elements[0u].value), start..end);
		}

		return ParsedExpr::Tuple(elements, start..end);
	}

	func parseDictExpr(this: &&Parser) -> ParsedExpr {
		const start = this.currentSpan();

		if !this.expect(TokenType::LCurly) {
			return ParsedExpr::Garbage(start);
		}

		var elements: List!<ParsedDictElement>;

		var error = false;
		while !this.accept(TokenType::RCurly) {
			const element_start = this.currentSpan();

			const key = this.parseExpr();

			if !this.expect(TokenType::Colon) {
				error = true;
				break;
			}

			const value = this.parseExpr();

			elements.append(ParsedDictElement(element_start..this.previousSpan(), key, value));

			if !(this.current() is RCurly) {
				if !this.expect(TokenType::Comma) {
					error = true;
					break;
				}
			}
		}

		if error {
			this.recover(TokenType::RCurly);
		}

		const end = this.previousSpan();
		return ParsedExpr::Dict(elements, start..end);
	}

	func parseMatchExpr(this: &&Parser) -> ParsedExpr {
		const start = this.currentSpan();

		if !this.expect(TokenType::KeywordMatch) {
			return ParsedExpr::Garbage(start);
		}

		const value = this.parseExpr();

		this.pushScope(ParserScope::MatchExpr);
		const body = this.parseCompoundStmt();
		this.popScope();

		return ParsedExpr::Match(
			Box!<ParsedMatchExpr>(ParsedMatchExpr(value, body)),
			start..this.previousSpan()
		);
	}

	func parseFunctionExpr(this: &&Parser) -> ParsedExpr {
		const start = this.currentSpan();

		if !this.expect(TokenType::KeywordFunc) {
			return ParsedExpr::Garbage(start);
		}

		if this.current() is LParen {
			const signature = this.parseFunctionSignature("", this.currentSpan()) else {
				return ParsedExpr::Garbage(this.currentSpan());
			}

			this.pushScope(ParserScope::FunctionDecl);
			const compound_stmt = this.parseCompoundStmt();
			const body = ParsedStmt::Compound(compound_stmt, compound_stmt.span, false);
			this.popScope();

			const span = start..this.previousSpan();
			return ParsedExpr::AnonymousFunction(Box!<ParsedFunctionDecl>(ParsedFunctionDecl(
				span,
				List!<ParsedAnnotation>(),
				List!<ParsedTemplateParameterDecl>(),
				false,
				signature,
				body
			)), span);
		} else {
			const name = this.parseName();

			var parameter_types: List!<ParsedType>;

			if !this.expect(TokenType::LParen) {
				return ParsedExpr::Garbage(start);
			}

			while !this.accept(TokenType::RParen) {
				parameter_types.append(this.parseType());

				if !(this.current() is RParen) {
					if !this.expect(TokenType::Comma) {
						this.recover(TokenType::RParen);
						break;
					}
				}
			}

			return ParsedExpr::FunctionRef(
				ParsedFunctionRefExpr(name, parameter_types),
				start..this.previousSpan()
			);
		}
	}

	func parseOperand(this: &&Parser) -> ParsedExpr {
		const start = this.currentSpan();
		match this.current() {
			case Identifier
			| KeywordOperator -> {
				const name = this.parseName();
				return ParsedExpr::Name(name, name.span)
			}
			case CharLiteral -> {
				const value = this.tokens[this.index].data() as byte;
				this.next();
				return ParsedExpr::Char((value: value, postfix: this.acceptLiteralPostfix()), start);
			}
			case StringLiteral -> {
				const value = this.strings[this.tokens[this.index].data()];
				this.next();
				return ParsedExpr::String((value: value, postfix: this.acceptLiteralPostfix()), start);
			}
			case NumberLiteral -> {
				const value = this.numbers[this.tokens[this.index].data()];
				this.next();
				return ParsedExpr::Number((value: value, postfix: this.acceptLiteralPostfix()), start);
			}
			case KeywordTrue -> {
				this.next();
				return ParsedExpr::Bool(true, start);
			}
			case KeywordFalse -> {
				this.next();
				return ParsedExpr::Bool(false, start);
			}
			case LParen -> return this.parseTupleExpr();
			case LSquare -> return this.parseArrayExpr();
			case LCurly -> return this.parseDictExpr();
			case KeywordMatch -> return this.parseMatchExpr();
			case KeywordFunc -> return this.parseFunctionExpr();
			else -> {
				this.index++;
				this.error("invalid expr operand", start);
				return ParsedExpr::Garbage(start);
			}
		}
	}

	func acceptLiteralPostfix(this: &&Parser) -> String {
		if this.current() is LiteralPostfix {
			const postfix = this.strings[this.tokens[this.index].data()];
			this.next();
			return postfix;
		}

		return "";
	}
}
