import std/core;
import std/box;
import std/list;
import std/shared_list;
import std/string;

import error;
import lexer;
import operators;
import program;
import span;

enum ParserScope {
	case Root;
	case Namespace;
	case TypeDecl;
	case FunctionDecl;
	case CompoundStmt;
	case IfStmt;
	case IfVarStmt;
	case VarElseStmt;
	case WhileStmt;
	case DoWhileStmt;
	case ForStmt;
	case MatchExpr;
	case CaseStmt;
}

struct Parser {
	var program: &&Program;
	var file: SharedHandle!<CompilationUnit>;

	var tokens: &List!<Token>;
	var strings: &List!<String>;
	var numbers: &List!<ParsedNumber>;

	var index: uint;

	var scope_stack: List!<ParserScope>;

	func constructor(this: &&Parser, program: &&Program, file: SharedHandle!<CompilationUnit>, tokens: &List!<Token>, strings: &List!<String>, numbers: &List!<ParsedNumber>) -> void {
		this.program := &&program;
		this.file := file;

		this.tokens := &tokens;
		this.strings := &strings;
		this.numbers := &numbers;
	}

	func constructor(this: &&Parser, other: Parser) -> void = default;
	func destructor(this: &&Parser) -> void = default;

	func pushScope(this: &&Parser, scope: ParserScope) -> void {
		this.scope_stack.append(scope);
	}

	func popScope(this: &&Parser) -> void {
		this.scope_stack.removeLast();
	}

	func countScope(this: &Parser, scope: ParserScope) -> uint {
		var result = 0u;
		for current in this.scope_stack {
			if current == scope {
				result++;
			}
		}
		return result;
	}

	func error(this: &Parser, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Error, ErrorStage::Parser, span));
	}

	func hint(this: &Parser, message: String, span: Span) -> void {
		this.program.printError(CompilationError(message, ErrorType::Hint, ErrorStage::Parser, span));
	}

	func eof(this: &Parser) -> bool {
		return this.index >= this.tokens.size();
	}

	func next(this: &&Parser) -> void {
		if this.index < this.tokens.size() {
			this.index++;
		}
	}

	func getEofSpan(this: &Parser) -> Span {
		if const last = this.tokens.last() {
			return Span(
				last.span.end,
				last.span.end,
				last.span.line,
				(last.span.column as uint + last.span.end - last.span.start) as u16,
				last.span.file
			);
		}

		return Span();
	}

	func current(this: &Parser) -> TokenType {
		if this.index >= this.tokens.size() {
			return TokenType::EndOfFile;
		}

		return this.tokens[this.index].type();
	}

	func currentSpan(this: &Parser) -> Span {
		if this.index >= this.tokens.size() {
			return this.getEofSpan();
		}

		return this.tokens[this.index].span;
	}

	func peek(this: &Parser) -> TokenType {
		if this.index + 1 >= this.tokens.size() {
			return TokenType::EndOfFile;
		}

		return this.tokens[this.index + 1].type();
	}

	func previousSpan(this: &Parser) -> Span {
		if this.index == 0 && !this.tokens.isEmpty() {
			return this.tokens[0u].span;
		}

		if this.index - 1 >= this.tokens.size() {
			return this.getEofSpan();
		}

		return this.tokens[this.index - 1].span;
	}

	func accept(this: &&Parser, token: TokenType) -> bool {
		if this.current() == token {
			this.index++;
			return true;
		} else {
			return false;
		}
	}

	func expect(this: &&Parser, token: TokenType) -> bool {
		if this.index >= this.tokens.size() {
			this.error("unexpected end of file", this.getEofSpan());
		}

		if this.accept(token) {
			return true;
		} else {
			const current = this.tokens[this.index];
			this.error("unexpected token " + current.toString() + ", expected " + token.toString(), current.span);
			return false;
		}
	}

	func expectIdentifier(this: &&Parser) -> String {
		if this.index >= this.tokens.size() {
			this.error("unexpected end of file", this.getEofSpan());
			return "";
		}

		const current = this.tokens[this.index];
		if current.type() != Identifier {
			this.error("unexpected token " + current.toString() + ", expected identifier", current.span);
			return "";
		}

		this.index++;

		return this.strings[current.data()];
	}

	func recover(this: &&Parser, token: TokenType) -> void {
		while !(this.current() == token) && this.index < this.tokens.size() {
			this.index++;
		}
		this.index++;
	}

	func parseStmt(this: &&Parser) -> uint {
		defer discard this.accept(TokenType::Semicolon);
		const start = this.currentSpan();

		match this.current() {
			case KeywordPragma -> return this.parsePragma();
			case KeywordImport -> return this.parseImport();
			case KeywordFunc
			| KeywordOperator
			| KeywordNamespace
			| KeywordStruct
			| KeywordEnum
			| KeywordVariant
			| KeywordTemplate
			| AtSign -> return this.parseDecl();
			case KeywordAlias -> return this.parseAlias();
			case LCurly -> return this.parseCompoundStmt();
			case KeywordVar
			| KeywordConst -> return this.parseVarDeclStmt();
			case KeywordCase -> if this.countScope(ParserScope::MatchExpr) != this.countScope(ParserScope::CaseStmt) {
				return this.parseCaseStmt();
			} else {
				return this.parseCaseDecl();
			}
			case KeywordElse -> if this.peek() is Arrow
								&& this.countScope(ParserScope::MatchExpr) != this.countScope(ParserScope::CaseStmt) {
				this.index += 2;

				this.pushScope(ParserScope::CaseStmt);
				const body = this.parseStmt();
				this.popScope();

				return this.file.addNode(Node::ElseCaseStmt(body, start..this.previousSpan(), false));
			} else {
				this.next();
				return this.file.garbageNode();
			}
			case KeywordIf -> match this.peek() {
				case KeywordVar
				| KeywordConst -> return this.parseIfVarStmt();
				else -> return this.parseIfStmt();
			}
			case KeywordWhile -> return this.parseWhileStmt();
			case KeywordDo -> return this.parseDoWhileStmt();
			case KeywordFor -> return this.parseForStmt();
			case KeywordBreak -> {
				this.next();
				return this.file.addNode(Node::BreakStmt(start..this.previousSpan(), false));
			}
			case KeywordContinue -> {
				this.next();
				return this.file.addNode(Node::ContinueStmt(start..this.previousSpan(), false));
			}
			case KeywordDefer -> {
				this.next();
				const body = this.parseStmt();
				return this.file.addNode(Node::DeferStmt(body, start..this.previousSpan(), false));
			}
			case KeywordThrow -> {
				this.next();
				const value = this.parseExpr();
				return this.file.addNode(Node::ThrowStmt(value, start..this.previousSpan(), false));
			}
			case KeywordReturn -> {
				this.next();

				var value = this.file.emptyNode();
				if !(this.current() is Semicolon || this.current() is RCurly) {
					value = this.parseExpr();
				}

				return this.file.addNode(Node::ReturnStmt(value, start..this.previousSpan(), false));
			}
			case KeywordYield -> {
				this.next();

				var value = this.file.emptyNode();
				if !(this.current() is Semicolon || this.current() is RCurly) {
					value = this.parseExpr();
				}

				return this.file.addNode(Node::YieldStmt(value, start..this.previousSpan(), false));
			}
			case KeywordDiscard -> {
				this.next();
				const value = this.parseExpr();
				return this.file.addNode(Node::DiscardStmt(value, start..this.previousSpan(), false));
			}
			case KeywordComptime -> match this.peek() {
				case KeywordFunc
				| KeywordOperator -> return this.parseDecl();
				case KeywordIf -> return this.parseIfStmt();
				case KeywordWhile -> return this.parseWhileStmt();
				case KeywordDo -> return this.parseDoWhileStmt();
				case KeywordFor -> return this.parseForStmt();
				case KeywordVar | KeywordConst -> return this.parseVarDecl(false);
				else -> {
					this.next();
					this.error("invalid comptime stmt", this.previousSpan());
					return this.file.garbageNode();
				}
			}
			else -> return this.parseExpr();
		}
	}

	func parsePragma(this: &&Parser) -> uint {
		const start = this.currentSpan();
		if !this.expect(TokenType::KeywordPragma) {
			return this.file.garbageNode();
		}

		const name = this.expectIdentifier();
		if name.isEmpty() {
			return this.file.garbageNode();
		}

		return this.file.addNode(Node::Pragma(name, start..this.previousSpan(), true));
	}

	func parseImport(this: &&Parser) -> uint {
		const start = this.currentSpan();
		if !this.expect(TokenType::KeywordImport) {
			return this.file.garbageNode();
		}

		var name = this.expectIdentifier();
		if name.isEmpty() {
			return this.file.garbageNode();
		}

		while this.accept(TokenType::Slash) {
			const segment = this.expectIdentifier();
			if name.isEmpty() {
				return this.file.garbageNode();
			}

			name += "/" + segment;
		}

		return this.file.addNode(Node::Import(name, start..this.previousSpan(), true));
	}

	func parseDecl(this: &&Parser) -> uint {
		const start = this.currentSpan();

		var annotations = this.parseAnnotations();
		var template_parameters = this.parseTemplateParameterDecl();

		match this.current() {
			case KeywordNamespace -> return this.parseNamespace(start, annotations, template_parameters);
			case KeywordStruct
			| KeywordEnum
			| KeywordVariant -> return this.parseTypeDecl(start, annotations, template_parameters);
			case KeywordFunc
			| KeywordOperator
			| KeywordComptime -> return this.parseFunctionDecl(start, annotations, template_parameters);
			else -> {
				this.error("expected decl", this.currentSpan());
				return this.file.garbageNode();
			}
		}
	}

	func parseAnnotations(this: &&Parser) -> List!<ParsedAnnotation> {
		var annotations: List!<ParsedAnnotation>;

		if !this.accept(TokenType::AtSign) {
			return annotations;
		}

		if !this.expect(TokenType::LSquare) {
			return annotations;
		}

		var error = false;
		while !this.accept(TokenType::RSquare) {
			const start = this.currentSpan();
			const name = this.expectIdentifier();
			if name.isEmpty() {
				error = true;
				break;
			}

			if this.accept(TokenType::Colon) {
				if this.index >= this.tokens.size() {
					error = true;
					break;
				}

				match this.current() {
					case StringLiteral -> {
						const end = this.currentSpan();
						const value = this.strings[this.tokens[this.index].data()];
						this.next();
						annotations.append(ParsedAnnotation::String(value, start..end, name));
					}
					case NumberLiteral -> {
						const end = this.currentSpan();
						const value = this.numbers[this.tokens[this.index].data()];
						this.next();
						annotations.append(ParsedAnnotation::Number(value, start..end, name));
					}
					else -> {
						error = true;
						break;
					}
				}
			} else {
				annotations.append(ParsedAnnotation::Flag(start, name));
			}

			if !(this.current() is RSquare) {
				if !this.expect(TokenType::Comma) {
					error = true;
					break;
				}
			}
		}

		if error {
			this.recover(TokenType::RSquare);
		}

		return annotations;
	}

	func parseTemplateParameterDecl(this: &&Parser) -> List!<ParsedTemplateParameterDecl> {
		var template_parameters: List!<ParsedTemplateParameterDecl>;

		if !this.accept(TokenType::KeywordTemplate) {
			return template_parameters;
		}

		if !this.expect(TokenType::LessThan) {
			return template_parameters;
		}

		var error = false;
		while !this.accept(TokenType::GreaterThan) {
			const start = this.currentSpan();
			const name = this.expectIdentifier();
			if name.isEmpty() {
				error = true;
				break;
			}

			if !this.expect(TokenType::Colon) {
				error = true;
				break;
			}

			const concept = this.expectIdentifier();
			if concept.isEmpty() {
				error = true;
				break;
			}

			var value = this.file.emptyNode();
			if this.accept(TokenType::Assign) {
				value = this.parseHighPrecedenceExpr();
			}

			const end = this.previousSpan();
			template_parameters.append(ParsedTemplateParameterDecl(start..end, name, concept, value));

			if !(this.current() is GreaterThan) {
				if !this.expect(TokenType::Comma) {
					error = true;
					break;
				}
			}
		}

		if error {
			this.recover(TokenType::GreaterThan);
		}

		return template_parameters;
	}

	func parseNamespace(this: &&Parser, start: Span, annotations: List!<ParsedAnnotation>, template_parameters: List!<ParsedTemplateParameterDecl>) -> uint {
		if !this.expect(TokenType::KeywordNamespace) {
			return this.file.garbageNode();
		}

		const name = this.expectIdentifier();
		if name.isEmpty() {
			return this.file.garbageNode();
		}
		const name_span = this.previousSpan();

		this.pushScope(ParserScope::Namespace);
		const body = this.parseCompoundStmt();
		this.popScope();

		return this.file.addNode(Node::NamespaceDecl(
			ParsedNamespaceDecl(name_span, annotations, template_parameters, name, body),
			start..this.previousSpan(), false
		));
	}

	func parseTypeDecl(this: &&Parser, start: Span, annotations: List!<ParsedAnnotation>, template_parameters: List!<ParsedTemplateParameterDecl>) -> uint {
		const kind = match this.current() {
			case KeywordStruct -> yield TypeDeclKind::Struct;
			case KeywordEnum -> yield TypeDeclKind::Enum;
			case KeywordVariant -> yield TypeDeclKind::Variant;
			else -> {
				return this.file.garbageNode();
			}
		}

		this.next();

		const name = this.expectIdentifier();
		if name.isEmpty() {
			return this.file.garbageNode();
		}
		const name_span = this.previousSpan();

		var id_type = this.file.emptyNode();
		if kind == Enum || kind == Variant {
			if this.accept(TokenType::Colon) {
				id_type = this.parseHighPrecedenceExpr();
			}
		}

		this.pushScope(ParserScope::TypeDecl);
		const body = this.parseCompoundStmt();
		this.popScope();

		return this.file.addNode(Node::TypeDecl(
			ParsedTypeDecl(name_span, annotations, template_parameters, kind, name, id_type, body),
			start..this.previousSpan(), false
		));
	}

	func parseFunctionDecl(this: &&Parser, start: Span, annotations: List!<ParsedAnnotation>, template_parameters: List!<ParsedTemplateParameterDecl>) -> uint {
		const is_comptime = this.accept(TokenType::KeywordComptime);

		const signature = this.parseFunctionSignature() else {
			return this.file.garbageNode();
		}

		var body = this.file.emptyNode();
		if this.accept(TokenType::Assign) {
			if this.accept(TokenType::KeywordExtern) {
				body = this.file.addNode(Node::ExternFunctionBody(this.previousSpan(), false));
			} else if this.expect(TokenType::KeywordDefault) {
				body = this.file.addNode(Node::DefaultFunctionBody(this.previousSpan(), false));
			}

			discard this.accept(TokenType::Semicolon);
		} else {
			this.pushScope(ParserScope::FunctionDecl);
			body = this.parseCompoundStmt();
			this.popScope();
		}

		const span = start..this.previousSpan();
		return this.file.addNode(Node::FunctionDecl(
			ParsedFunctionDecl(span, annotations, template_parameters, is_comptime, signature, body),
			span, true
		));
	}

	func parseFunctionSignature(this: &&Parser) -> Optional!<ParsedFunctionSignature> {
		const start = this.currentSpan();

		var name = "";
		match this.current() {
			case KeywordFunc -> {
				this.next();
				name = this.expectIdentifier();
			}
			case KeywordOperator -> name = this.parseOperatorName();
			else -> return None;
		}

		return this.parseFunctionSignature(name, start);
	}

	func parseFunctionSignature(this: &&Parser, name: String, start: Span) -> Optional!<ParsedFunctionSignature> {
		if !this.expect(TokenType::LParen) {
			return None;
		}

		var parameters: List!<uint>;
		var error = false;
		while !this.accept(TokenType::RParen) {
			parameters.append(this.parseVarDecl(true));

			if !(this.current() is RParen) {
				if !this.expect(TokenType::Comma) {
					error = true;
					break;
				}
			}
		}

		if error {
			this.recover(TokenType::RParen);
		}

		if !this.expect(TokenType::Arrow) {
			this.error("expected function return type", this.currentSpan());
			return Some(ParsedFunctionSignature(start..this.previousSpan(), name, parameters, this.file.garbageNode()));
		}

		const return_type = this.parseHighPrecedenceExpr();
		return Some(ParsedFunctionSignature(start..this.previousSpan(), name, parameters, return_type));
	}

	func parseVarDecl(this: &&Parser, is_parameter: bool) -> uint {
		const start = this.currentSpan();
		var is_comptime = false;
		var is_const = false;

		const annotations = this.parseAnnotations();

		if !is_parameter {
			is_comptime = this.accept(TokenType::KeywordComptime);
			is_const = this.accept(TokenType::KeywordConst);
			if !is_const {
				if !this.expect(TokenType::KeywordVar) {
					return this.file.garbageNode();
				}
			}
		}

		const name = this.expectIdentifier();
		if name.isEmpty() {
			return this.file.garbageNode();
		}

		var type = this.file.emptyNode();
		if this.accept(TokenType::Colon) {
			type = this.parseHighPrecedenceExpr();
		}

		if type == this.file.emptyNode() && !(this.current() is Assign) {
			this.error("variable must be declared with a type or an initializer", start..this.previousSpan());
			return this.file.garbageNode();
		}

		var initializer = this.file.emptyNode();
		if this.accept(TokenType::Assign) {
			initializer = this.parseExpr();
		}

		const variable = ParsedVarDecl(annotations, name, type, initializer, is_const, is_parameter);
		return this.file.addNode(Node::VarDecl(variable, start..this.previousSpan(), is_comptime));
	}

	func parseCaseDecl(this: &&Parser) -> uint {
		const start = this.currentSpan();
		if !this.expect(TokenType::KeywordCase) {
			return this.file.garbageNode();
		}

		const name = this.expectIdentifier();
		if name.isEmpty() {
			return this.file.garbageNode();
		}

		var payload = this.file.emptyNode();
		if this.accept(TokenType::Colon) {
			payload = this.parseHighPrecedenceExpr();
		}

		var id = this.file.emptyNode();
		if this.accept(TokenType::Assign) {
			id = this.parseExpr();
		}

		return this.file.addNode(Node::CaseDecl(ParsedCaseDecl(name, payload, id), start..this.previousSpan(), true));
	}

	func parseAlias(this: &&Parser) -> uint {
		const start = this.currentSpan();
		if !this.expect(TokenType::KeywordAlias) {
			return this.file.garbageNode();
		}

		const name = this.expectIdentifier();
		if name.isEmpty() {
			return this.file.garbageNode();
		}

		if !this.expect(TokenType::Assign) {
			return this.file.garbageNode();
		}

		const type = this.parseHighPrecedenceExpr();
		return this.file.addNode(Node::AliasDecl(ParsedAliasDecl(name, type), start..this.previousSpan(), true));
	}

	func parseCompoundStmt(this: &&Parser) -> uint {
		const start = this.currentSpan();

		if !this.expect(TokenType::LCurly) {
			return this.file.garbageNode();
		}

		this.pushScope(ParserScope::CompoundStmt);

		var children: List!<uint>;
		while !this.accept(TokenType::RCurly) {
			const child = this.parseStmt();
			if child != this.file.garbageNode() && child != this.file.emptyNode() {
				children.append(child);
			}
		}

		this.popScope();

		return this.file.addNode(Node::CompoundStmt(children, start..this.previousSpan(), false));
	}

	func parseVarDeclStmt(this: &&Parser) -> uint {
		const start = this.currentSpan();
		const decl = this.parseVarDecl(false);

		if !this.accept(TokenType::KeywordElse) {
			return decl;
		}

		// var else stmt
		var capture_name = "";
		var capture_kind = ReferenceKind::None;
		if this.accept(TokenType::Colon) {
			if this.accept(TokenType::Ampersand) {
				capture_kind = ReferenceKind::Const;
			} else if this.accept(TokenType::DoubleAmpersand) {
				capture_kind = ReferenceKind::Var;
			}

			capture_name = this.expectIdentifier();
		}

		this.pushScope(ParserScope::VarElseStmt);
		const body = this.parseCompoundStmt();
		this.popScope();

		return this.file.addNode(Node::VarElseStmt(
			ParsedVarElseStmt(decl, body, capture_name, capture_kind),
			start..this.previousSpan(), this.file.nodes[decl].is_comptime
		));
	}

	func parseIfStmt(this: &&Parser) -> uint {
		const start = this.currentSpan();

		const is_comptime = this.accept(TokenType::KeywordComptime);

		if !this.expect(TokenType::KeywordIf) {
			return this.file.garbageNode();
		}

		const condition = this.parseExpr();

		this.pushScope(ParserScope::IfStmt);
		const then_branch = this.parseCompoundStmt();

		var else_branch = this.file.emptyNode();
		if this.accept(TokenType::KeywordElse) {
			else_branch = this.parseStmt();
			this.file.nodes[else_branch].is_comptime = is_comptime;
		}

		this.popScope();

		return this.file.addNode(Node::IfStmt(
			ParsedIfStmt(condition, then_branch, else_branch),
			start..this.previousSpan(), is_comptime
		));
	}

	func parseIfVarStmt(this: &&Parser) -> uint {
		const start = this.currentSpan();
		if !this.expect(TokenType::KeywordIf) {
			return this.file.garbageNode();
		}

		const var_decl = this.parseVarDecl(false);

		this.pushScope(ParserScope::IfVarStmt);
		const body = this.parseCompoundStmt();
		this.popScope();

		return this.file.addNode(Node::IfVarStmt(
			ParsedIfVarStmt(var_decl, body),
			start..this.previousSpan(), false
		));
	}

	func parseWhileStmt(this: &&Parser) -> uint {
		const start = this.currentSpan();

		const is_comptime = this.accept(TokenType::KeywordComptime);

		if !this.expect(TokenType::KeywordWhile) {
			return this.file.garbageNode();
		}

		const condition = this.parseExpr();

		this.pushScope(ParserScope::WhileStmt);
		const body = this.parseCompoundStmt();
		this.popScope();

		return this.file.addNode(Node::WhileStmt(
			ParsedWhileStmt(condition, body),
			start..this.previousSpan(), is_comptime
		));
	}

	func parseDoWhileStmt(this: &&Parser) -> uint {
		const start = this.currentSpan();

		const is_comptime = this.accept(TokenType::KeywordComptime);

		if !this.expect(TokenType::KeywordDo) {
			return this.file.garbageNode();
		}

		this.pushScope(ParserScope::DoWhileStmt);
		const body = this.parseCompoundStmt();
		this.popScope();

		if !this.expect(TokenType::KeywordWhile) {
			return this.file.garbageNode();
		}

		const condition = this.parseExpr();
		discard this.accept(TokenType::Semicolon);

		return this.file.addNode(Node::DoWhileStmt(
			ParsedDoWhileStmt(body, condition),
			start..this.previousSpan(), is_comptime
		));
	}

	func parseForStmt(this: &&Parser) -> uint {
		const start = this.currentSpan();
		const is_comptime = this.accept(TokenType::KeywordComptime);

		if !this.expect(TokenType::KeywordFor) {
			return this.file.garbageNode();
		}

		var capture_kind = ReferenceKind::None;
		if this.accept(TokenType::Ampersand) {
			capture_kind = ReferenceKind::Const;
		} else if this.accept(TokenType::DoubleAmpersand) {
			capture_kind = ReferenceKind::Var;
		}

		const capture_name = this.expectIdentifier();
		if capture_name.isEmpty() {
			return this.file.garbageNode();
		}
		const capture_span = this.previousSpan();

		if !this.expect(TokenType::KeywordIn) {
			return this.file.garbageNode();
		}

		const range = this.parseExpr();

		this.pushScope(ParserScope::ForStmt);
		const body = this.parseCompoundStmt();
		this.popScope();

		return this.file.addNode(Node::ForStmt(
			ParsedForStmt(capture_name, capture_kind, capture_span, range, body),
			start..this.previousSpan(), is_comptime
		));
	}

	func parseCaseStmt(this: &&Parser) -> uint {
		const start = this.currentSpan();
		if !this.expect(TokenType::KeywordCase) {
			return this.file.garbageNode();
		}

		var patterns: List!<uint>;
		do {
			patterns.append(this.parseHighPrecedenceExpr());
		} while this.accept(TokenType::Pipe);

		var capture_name = "";
		var capture_kind = ReferenceKind::None;
		if this.accept(TokenType::Colon) {
			if this.accept(TokenType::Ampersand) {
				capture_kind = ReferenceKind::Const;
			} else if this.accept(TokenType::DoubleAmpersand) {
				capture_kind = ReferenceKind::Var;
			}

			capture_name = this.expectIdentifier();
		}

		if !this.expect(TokenType::Arrow) {
			return this.file.garbageNode();
		}

		this.pushScope(ParserScope::CaseStmt);
		const body = this.parseStmt();
		this.popScope();

		return this.file.addNode(Node::CaseStmt(
			ParsedCaseStmt(patterns, capture_name, capture_kind, body),
			start..this.previousSpan(), false
		));
	}

	func parseName(this: &&Parser) -> uint {
		const start = this.currentSpan();
		var name = "";
		if this.current() is Identifier {
			name = this.expectIdentifier();
		} else if this.current() is KeywordOperator {
			name = this.parseOperatorName();
		} else {
			return this.file.emptyNode();
		}

		const template_parameters = this.parseTemplateParameters();
		return this.file.addNode(Node::Name(ParsedName(name, template_parameters), start..this.previousSpan(), false));
	}

	func parseOperatorName(this: &&Parser) -> String {
		const start = this.currentSpan();
		if !this.expect(TokenType::KeywordOperator) {
			return "";
		}

		if this.accept(TokenType::KeywordUnwrap) {
			return "operator unwrap";
		}

		const op = this.parseOperator() else {
			this.error("invalid operator name is not an operator", start);
			return "";
		}

		if op == Call {
			discard this.expect(TokenType::RParen);
		} else if op == Index {
			discard this.expect(TokenType::RSquare);
		} else if op == VarRef || op >= Try {
			this.error("invalid operator name \"" + op.toString() + "\"", start..this.previousSpan());
		}

		return "operator " + op.toString();
	}

	func parseTemplateParameters(this: &&Parser) -> List!<uint> {
		var template_parameters: List!<uint>;

		if !this.accept(TokenType::ExclamationMark) {
			return template_parameters;
		}

		if !this.expect(TokenType::LessThan) {
			return template_parameters;
		}

		while !this.accept(TokenType::GreaterThan) {
			template_parameters.append(this.parseHighPrecedenceExpr());

			if !(this.current() is GreaterThan) {
				if !this.expect(TokenType::Comma) {
					this.recover(TokenType::GreaterThan);
					break;
				}
			}
		}

		return template_parameters;
	}

	func parseExpr(this: &&Parser) -> uint {
		return this.parseExpr(-1);
	}

	func parseHighPrecedenceExpr(this: &&Parser) -> uint {
		return this.parseExpr(16);
	}

	func parseExpr(this: &&Parser, min_precedence: int) -> uint {
		var lhs = this.file.emptyNode();
		var start = this.currentSpan();

		match this.parsePrefixOperator() {
			case Some: op -> {
				const rhs = this.parseExpr(op.precedence());
				lhs = this.file.addNode(Node::UnaryOperatorExpr(ParsedUnaryOperatorExpr(op, rhs), start..this.previousSpan(), false));
			}
			else -> lhs = this.parseOperand();
		}

		while true {
			const prev_index = this.index;

			const op = this.parsePostfixOrInfixOperator() else {
				this.index = prev_index;
				break;
			}

			if op.precedence() <= min_precedence {
				this.index = prev_index;
				break;
			}

			if op == Call {
				var operands = List!<uint>(1u, lhs);
				while !this.accept(TokenType::RParen) {
					operands.append(this.parseExpr());

					if !(this.current() is RParen) {
						if !this.expect(TokenType::Comma) {
							this.recover(TokenType::RParen);
							break;
						}
					}
				}
				lhs = this.file.addNode(Node::CallExpr(operands, start..this.previousSpan(), false));
			} else if op == Index {
				var operands = List!<uint>(1u, lhs);
				while !this.accept(TokenType::RSquare) {
					operands.append(this.parseExpr());

					if !(this.current() is RSquare) {
						if !this.expect(TokenType::Comma) {
							this.recover(TokenType::RSquare);
							break;
						}
					}
				}
				lhs = this.file.addNode(Node::IndexExpr(operands, start..this.previousSpan(), false));
			} else if op == InlineIf {
				if this.accept(TokenType::KeywordVar) || this.accept(TokenType::KeywordConst) {
					// expression followed by an if-var stmt
					this.index = prev_index;
					break;
				}

				const prev_node_count = this.file.nodes.size();
				const condition = this.parseExpr();

				if !this.accept(TokenType::KeywordElse) {
					// expression followed by an if stmt
					this.index = prev_index;
					this.file.nodes.remove(prev_node_count..this.file.nodes.size());
					break;
				}

				const else_value = this.parseExpr();
				lhs = this.file.addNode(Node::InlineIfExpr(ParsedInlineIfExpr(condition, lhs, else_value), start..this.previousSpan(), false));
			} else if op.isBinaryOperator() {
				const rhs = this.parseExpr(op.precedence());
				lhs = this.file.addNode(Node::BinaryOperatorExpr(
					ParsedBinaryOperatorExpr(op, lhs, rhs),
					start..this.previousSpan(), false
				));
			} else if op.isUnaryOperator() {
				lhs = this.file.addNode(Node::UnaryOperatorExpr(
					ParsedUnaryOperatorExpr(op, lhs),
					start..this.previousSpan(), false
				));
			} else {
				this.error("unknown operator " + op.toString(), this.previousSpan());
				continue;
			}
		}

		return lhs;
	}

	func parsePrefixOperator(this: &&Parser) -> Optional!<Operator> {
		match this.current() {
			case Minus -> {
				this.next();
				return Some(Operator::Negate);
			}
			case Tilde -> {
				this.next();
				return Some(Operator::BitwiseNot);
			}
			case ExclamationMark -> {
				this.next();
				return Some(Operator::LogicalNot);
			}
			case Ampersand -> {
				this.next();
				return Some(Operator::ConstRef);
			}
			case DoubleAmpersand -> {
				this.next();
				return Some(Operator::VarRef);
			}
			case KeywordTry -> {
				this.next();
				return Some(Operator::Try);
			}
			case KeywordMust -> {
				this.next();
				return Some(Operator::Must);
			}
			else -> return None;
		}
	}

	func parsePostfixOperator(this: &&Parser) -> Optional!<Operator> {
		match this.current() {
			case DoublePlus -> {
				this.next();
				return Some(Operator::Increment);
			}
			case DoubleMinus -> {
				this.next();
				return Some(Operator::Decrement);
			}
			case LParen -> {
				this.next();
				return Some(Operator::Call);
			}
			case LSquare -> {
				this.next();
				return Some(Operator::Index);
			}
			else -> return None;
		}
	}

	func parseInfixOperator(this: &&Parser) -> Optional!<Operator> {
		match this.current() {
			case Plus -> {
				this.next();
				return Some(Operator::Add);
			}
			case Minus -> {
				this.next();
				return Some(Operator::Sub);
			}
			case Asterisk -> {
				this.next();
				return Some(Operator::Mul);
			}
			case Slash -> {
				this.next();
				return Some(Operator::Div);
			}
			case Percent -> {
				this.next();
				return Some(Operator::Mod);
			}
			case Ampersand -> {
				this.next();
				return Some(Operator::BitwiseAnd);
			}
			case Pipe -> {
				this.next();
				return Some(Operator::BitwiseOr);
			}
			case Caret -> {
				this.next();
				return Some(Operator::BitwiseXOr);
			}
			case DoubleAmpersand -> {
				this.next();
				return Some(Operator::LogicalAnd);
			}
			case DoublePipe -> {
				this.next();
				return Some(Operator::LogicalOr);
			}
			case DoubleQuestionMark -> {
				this.next();
				return Some(Operator::Coalescing);
			}
			case Assign -> {
				this.next();
				return Some(Operator::Assign);
			}
			case ColonAssign -> {
				this.next();
				return Some(Operator::Initialize);
			}
			case PlusAssign -> {
				this.next();
				return Some(Operator::AddAssign);
			}
			case MinusAssign -> {
				this.next();
				return Some(Operator::SubAssign);
			}
			case AsteriskAssign -> {
				this.next();
				return Some(Operator::MulAssign);
			}
			case SlashAssign -> {
				this.next();
				return Some(Operator::DivAssign);
			}
			case PercentAssign -> {
				this.next();
				return Some(Operator::ModAssign);
			}
			case AmpersandAssign -> {
				this.next();
				return Some(Operator::BitwiseAndAssign);
			}
			case PipeAssign -> {
				this.next();
				return Some(Operator::BitwiseOrAssign);
			}
			case CaretAssign -> {
				this.next();
				return Some(Operator::BitwiseXOrAssign);
			}
			case DoubleQuestionMarkAssign -> {
				this.next();
				return Some(Operator::CoalescingAssign);
			}
			case Equal -> {
				this.next();
				return Some(Operator::Equal);
			}
			case NotEqual -> {
				this.next();
				return Some(Operator::NotEqual);
			}
			case Spaceship -> {
				this.next();
				return Some(Operator::Spaceship);
			}
			case DoubleDot -> {
				this.next();
				return Some(Operator::Range);
			}
			case KeywordIs -> {
				this.next();
				return Some(Operator::Is);
			}
			case KeywordAs -> {
				this.next();
				return Some(Operator::As);
			}
			case KeywordIf -> {
				this.next();
				return Some(Operator::InlineIf);
			}
			case Dot -> {
				this.next();
				return Some(Operator::MemberAccess);
			}
			case LessThan -> {
				this.next();
				if this.current() is LessEqual {
					this.next();
					return Some(Operator::ShiftLeftAssign);
				} else if this.current() is LessThan {
					this.next();
					return Some(Operator::ShiftLeft);
				} else {
					return Some(Operator::LessThan);
				}
			}
			case LessEqual -> {
				this.next();
				return Some(Operator::LessEqual);
			}
			case GreaterThan -> {
				this.next();
				if this.current() is GreaterEqual {
					this.next();
					return Some(Operator::ShiftRightAssign);
				} else if this.current() is GreaterThan {
					this.next();
					return Some(Operator::ShiftRight);
				} else {
					return Some(Operator::GreaterThan);
				}
			}
			case GreaterEqual -> {
				this.next();
				return Some(Operator::GreaterEqual);
			}
			case DoubleColon -> {
				this.next();
				return Some(Operator::Namespace);
			}
			else -> return None;
		}
	}

	func parsePostfixOrInfixOperator(this: &&Parser) -> Optional!<Operator> {
		if const op = this.parsePostfixOperator() {
			return Some(op);
		}

		if const op = this.parseInfixOperator() {
			return Some(op);
		}

		return None;
	}

	func parseOperator(this: &&Parser) -> Optional!<Operator> {
		if const op = this.parsePrefixOperator() {
			return Some(op);
		}

		if const op = this.parsePostfixOrInfixOperator() {
			return Some(op);
		}

		return None;
	}

	func parseTupleExpr(this: &&Parser) -> uint {
		const start = this.currentSpan();

		if !this.expect(TokenType::LParen) {
			return this.file.garbageNode();
		}

		var elements: List!<ParsedTupleElement>;
		var is_named = false;
		while !this.accept(TokenType::RParen) {
			const element_start = this.currentSpan();

			var name = "";
			if this.current() is Identifier && this.peek() is Colon {
				name = this.strings[this.tokens[this.index].data()];
				is_named = true;
				this.index += 2;
			}

			const value = this.parseExpr();
			elements.append(ParsedTupleElement(element_start..this.previousSpan(), name, value));

			if !(this.current() is RParen) {
				if !this.expect(TokenType::Comma) {
					this.recover(TokenType::RParen);
					break;
				}
			}
		}

		if !is_named {
			if this.accept(TokenType::Arrow) {
				var parameter_types: List!<uint>;
				for e in elements {
					parameter_types.append(e.value);
				}

				return this.file.addNode(Node::FunctionType(
					ParsedFunctionType(parameter_types, this.parseHighPrecedenceExpr()),
					start..this.previousSpan(), false
				));
			}
		}

		const end = this.previousSpan();
		if elements.size() == 1 && !is_named {
			return this.file.addNode(Node::ParenExpr(elements[0u].value, start..end, false));
		}

		return this.file.addNode(Node::TupleExpr(elements, start..end, false));
	}

	func parseArrayExpr(this: &&Parser) -> uint {
		const start = this.currentSpan();

		if !this.expect(TokenType::LSquare) {
			return this.file.garbageNode();
		}

		var values: List!<uint>;

		var error = false;
		while !this.accept(TokenType::RSquare) {
			values.append(this.parseExpr());

			if !(this.current() is RSquare) {
				if !this.expect(TokenType::Comma) {
					error = true;
					break;
				}
			}
		}

		if error {
			this.recover(TokenType::RSquare);
		}

		const end = this.previousSpan();
		return this.file.addNode(Node::ArrayExpr(values, start..end, false));
	}

	func parseDictExpr(this: &&Parser) -> uint {
		const start = this.currentSpan();

		if !this.expect(TokenType::LCurly) {
			return this.file.garbageNode();
		}

		var elements: List!<ParsedDictElement>;

		var error = false;
		while !this.accept(TokenType::RCurly) {
			const element_start = this.currentSpan();

			const key = this.parseExpr();

			if !this.expect(TokenType::Colon) {
				error = true;
				break;
			}

			const value = this.parseExpr();

			elements.append(ParsedDictElement(element_start..this.previousSpan(), key, value));

			if !(this.current() is RCurly) {
				if !this.expect(TokenType::Comma) {
					error = true;
					break;
				}
			}
		}

		if error {
			this.recover(TokenType::RCurly);
		}

		return this.file.addNode(Node::DictExpr(elements, start..this.previousSpan(), false));
	}

	func parseMatchExpr(this: &&Parser) -> uint {
		const start = this.currentSpan();

		if !this.expect(TokenType::KeywordMatch) {
			return this.file.garbageNode();
		}

		const value = this.parseExpr();

		this.pushScope(ParserScope::MatchExpr);
		const body = this.parseCompoundStmt();
		this.popScope();

		return this.file.addNode(Node::MatchExpr(
			ParsedMatchExpr(value, body),
			start..this.previousSpan(), false
		));
	}

	func parseFunctionExpr(this: &&Parser) -> uint {
		const start = this.currentSpan();

		if this.peek() is LParen {
			if !this.expect(TokenType::KeywordFunc) {
				return this.file.garbageNode();
			}

			const signature = this.parseFunctionSignature("", this.currentSpan()) else {
				return this.file.garbageNode();
			}

			this.pushScope(ParserScope::FunctionDecl);
			const body = this.parseCompoundStmt();
			this.popScope();

			const span = start..this.previousSpan();
			const function = this.file.addNode(Node::FunctionDecl(ParsedFunctionDecl(
				span,
				List!<ParsedAnnotation>(),
				List!<ParsedTemplateParameterDecl>(),
				false,
				signature,
				body
			), span, false));

			return this.file.addNode(Node::AnonymousFunctionExpr(function, span, false));
		} else {
			if this.current() != TokenType::KeywordOperator {
				if !this.expect(TokenType::KeywordFunc) {
					return this.file.garbageNode();
				}
			}

			const name = this.parseExpr(19);

			var parameter_types: List!<uint>;
			if !this.expect(TokenType::LParen) {
				return this.file.garbageNode();
			}

			while !this.accept(TokenType::RParen) {
				parameter_types.append(this.parseExpr());

				if !(this.current() is RParen) {
					if !this.expect(TokenType::Comma) {
						this.recover(TokenType::RParen);
						break;
					}
				}
			}

			return this.file.addNode(Node::FunctionRefExpr(
				ParsedFunctionRefExpr(name, parameter_types),
				start..this.previousSpan(), false
			));
		}
	}

	func parseOperand(this: &&Parser) -> uint {
		const start = this.currentSpan();
		match this.current() {
			case Identifier | KeywordOperator -> return this.parseName();
			case CharLiteral -> {
				const value = this.tokens[this.index].data() as byte;
				this.next();
				return this.file.addNode(Node::CharLiteralExpr((value: value, postfix: this.acceptLiteralPostfix()), start, false));
			}
			case StringLiteral -> {
				const value = this.strings[this.tokens[this.index].data()];
				this.next();
				return this.file.addNode(Node::StringLiteralExpr((value: value, postfix: this.acceptLiteralPostfix()), start, false));
			}
			case NumberLiteral -> {
				const value = this.numbers[this.tokens[this.index].data()];
				this.next();
				return this.file.addNode(Node::NumberLiteralExpr((value: value, postfix: this.acceptLiteralPostfix()), start, false));
			}
			case KeywordTrue -> {
				this.next();
				return this.file.addNode(Node::BoolLiteralExpr(true, start, false));
			}
			case KeywordFalse -> {
				this.next();
				return this.file.addNode(Node::BoolLiteralExpr(false, start, false));
			}
			case LParen -> return this.parseTupleExpr();
			case LSquare -> return this.parseArrayExpr();
			case LCurly -> return this.parseDictExpr();
			case KeywordMatch -> return this.parseMatchExpr();
			case KeywordFunc -> return this.parseFunctionExpr();
			else -> {
				this.index++;
				this.error("invalid expr operand", start);
				return this.file.garbageNode();
			}
		}
	}

	func acceptLiteralPostfix(this: &&Parser) -> String {
		if this.current() is LiteralPostfix {
			const postfix = this.strings[this.tokens[this.index].data()];
			this.next();
			return postfix;
		}

		return "";
	}
}
