import std/core;
import std/box;
import std/format;
import std/io;
import std/list;
import std/map;
import std/math;
import std/set;
import std/shared;
import std/shared_list;
import std/string;

import llvm_c;
import llvm_util;

import error;
import options;
import span;
import syntax_tree;
import tree_formatter;

struct SourceFile {
	var name: String;
	var path: String;
	var source: String;
	var line_spans: List!<Span>;

	var llvm_di_file: LLVMMetadataRef;
	var llvm_di_module: LLVMMetadataRef;

	func constructor(this: &&SourceFile, name: String, path: String, source: String, line_spans: &List!<Span>) -> void {
		this.name := name;
		this.path := path;
		this.source := source;
		this.line_spans := line_spans;
	}

	func constructor(this: &&SourceFile, other: SourceFile) -> void = default;
	func destructor(this: &&SourceFile) -> void = default;

	operator =(this: &&SourceFile, other: SourceFile) -> void = default;
	operator ==(this: SourceFile, other: SourceFile) -> bool = default;
}

struct Program {
	var name: String;
	var options: CompilerOptions;

	var has_errors: bool;

	var files: List!<SourceFile>;

	// namespaces
	var namespaces: SharedList!<Namespace>;
	var top_level_namespaces: List!<SharedHandle!<Namespace>>;
	var modules_by_path: Map!<String, SharedHandle!<Namespace>>;

	var core_namespace: SharedHandle!<Namespace>;

	// concepts
	var concepts: SharedList!<Concept>;
	var concepts_by_name: Map!<String, SharedHandle!<Concept>>;

	var any_concept: SharedHandle!<Concept>;
	var bool_concept: SharedHandle!<Concept>;
	var int_concept: SharedHandle!<Concept>;
	var uint_concept: SharedHandle!<Concept>;
	var string_concept: SharedHandle!<Concept>;

	// types
	var types: SharedList!<TypeDecl>;

	var void_type: Type;
	var never_type: Type;

	var bool_type: Type;

	var int_type: Type;
	var uint_type: Type;

	var byte_type: Type;

	var cptr_type: Type;
	var vptr_type: Type;

	// functions
	var functions: SharedList!<FunctionDecl>;

	var main_function: SharedHandle!<FunctionDecl>;

	// llvm
	var llvm_context: LLVMContextRef;
	var llvm_module: LLVMModuleRef;
	var llvm_execution_engine: LLVMExecutionEngineRef;
	var data_layout: LLVMTargetDataRef;

	var string_globals: Map!<String, LLVMValueRef>;

	var di_builder: LLVMDIBuilderRef;
	var di_compile_unit: LLVMMetadataRef;

	func constructor(this: &&Program, options: CompilerOptions) -> void {
		this.name := options.program_name;
		this.options := options;

		this.has_errors := false;

		this.files := ();
		this.files.append(SourceFile("unknown", "unknown", "", List!<Span>()));

		this.namespaces := ();
		this.top_level_namespaces := ();

		this.llvm_context := LLVMContextCreate();
		this.llvm_module := LLVMModuleCreateWithNameInContext(this.name, this.llvm_context);
		LLVMSetSourceFileName(this.llvm_module, options.root_module_path);
		LLVMSetTarget(this.llvm_module, options.target_triple);
		LLVMSetDataLayout(this.llvm_module, options.target_data_layout);

		this.data_layout := LLVMGetModuleDataLayout(this.llvm_module);

		this.di_builder := ();
		if options.generate_debug_info {
			const int_type = LLVMIntTypeInContext(this.llvm_context, 64u);
			LLVMAddModuleFlag(this.llvm_module, LLVMModuleFlagBehavior::LLVMModuleFlagBehaviorError, "Dwarf Version", LLVMValueAsMetadata(LLVMConstInt(int_type, 5, false)));
			LLVMAddModuleFlag(this.llvm_module, LLVMModuleFlagBehavior::LLVMModuleFlagBehaviorWarning, "Debug Info Version", LLVMValueAsMetadata(LLVMConstInt(int_type, 3, false)));
			this.di_builder = LLVMCreateDIBuilder(this.llvm_module);

			this.files[0u].llvm_di_file = LLVMDIBuilderCreateFile(this.di_builder, "unknown", ".");

			this.di_compile_unit = LLVMDIBuilderCreateCompileUnit(
				this.di_builder,
				LLVMDWARFSourceLanguage::LLVMDWARFSourceLanguageC,
				this.files[0u].llvm_di_file,
				"",			// producer
				this.options.optimization_level != 0,
				"",			// flags
				0u,			// runtime version
				"",			// split name
				LLVMDWARFEmissionKind::LLVMDWARFEmissionFull,
				0u,			// dwo-id
				false,		// split debug inlining
				false,		// debug info for profiling
				"",			// sys-root
				"",			// sdk
			);

			this.files[0u].llvm_di_module = LLVMDIBuilderCreateModule(
				this.di_builder,
				this.di_compile_unit,
				this.files[0u].name,
				"",		// config macros
				"",		// include path
				"", 	// api notes file
			);
		}

		for i in 0u..options.import_search_paths.size() {
			var ns = this.namespaces.append(Namespace(format(i), List!<TemplateParameterDecl>(), SharedHandle!<Namespace>()));

			if this.di_builder != LLVMDIBuilderRef::null() {
				ns.llvm_di = LLVMDIBuilderCreateNameSpace(this.di_builder, this.files[0u].llvm_di_module, ns.name, true);
			}

			this.top_level_namespaces.append(ns);
		}

		this.llvm_execution_engine := ();

		LLVMLinkInMCJIT();
		LLVMInitializeX86TargetInfo();
		LLVMInitializeX86Target();
		LLVMInitializeX86TargetMC();
		LLVMInitializeX86AsmPrinter();

		match createJITCompilerForModule(this.llvm_module, 0u) {
			case Ok: ee -> this.llvm_execution_engine = ee;
			case Error: error -> panic(error);
		}
	}

	func destructor(this: &&Program) -> void {
		if this.di_builder != LLVMDIBuilderRef::null() {
			LLVMDisposeDIBuilder(this.di_builder);
		}

		LLVMDisposeExecutionEngine(this.llvm_execution_engine);
		LLVMContextDispose(this.llvm_context);

		LLVMShutdown();
	}

	func printError(this: &&Program, error: CompilationError) -> void {
		if error.type == Error {
			this.has_errors = true;
		}

		if this.options.hide_errors {
			return;
		}

		const span = error.span;
		const file = &this.files[span.file as uint];

		println(error.toString(file.path));

		if span.start == span.end {
			return;
		}

		var first_line = max!<int>(span.line as int - 1, 0) as uint;
		var last_line = span.line as uint + 1;
		while span.end > file.line_spans[last_line - 1].end && last_line < file.line_spans.size() {
			last_line++;
		}
		last_line = min!<uint>(last_line + 1, file.line_spans.size());

		const last_line_number = format(last_line);
		const max_line_number_width = last_line_number.size();

		for line in first_line..last_line {
			const line_span = file.line_spans[line];

			const line_number_str = format(line + 1);
			print(String(max_line_number_width - line_number_str.size() + 1, ' 'b) + line_number_str + " | ");

			const error_start = clamp!<uint>(span.start, line_span.start, line_span.end);
			const error_end = clamp!<uint>(span.end, line_span.start, line_span.end);

			print(file.source.substring(line_span.start..error_start));
			print("\e[31m");
			print(file.source.substring(error_start..error_end));
			print("\e[0m");
			print(file.source.substring(error_end..line_span.end));

			print("\n");
		}
	}

	func printErrors(this: &&Program, errors: &List!<CompilationError>) -> void {
		for e in errors {
			this.printError(e);
		}
	}

	func dump(this: &Program) -> String {
		var out: TreeFormatter = ("Program");
		out.attribute(this.name);
		if this.main_function.isAlive() {
			out.text(" main:");
			out.value(this.main_function.signature());
		}

		for concept in this.concepts {
			concept.dump(&&out, false);
		}

		for i in 0u..this.top_level_namespaces.size() {
			this.top_level_namespaces[i].dump(&&out, i == this.top_level_namespaces.size() - 1);
		}

		return out.finalize();
	}

	func createConcept(this: &&Program, concept: Concept) -> SharedHandle!<Concept> {
		const instance = this.concepts.append(concept);
		this.concepts_by_name[concept.name] = instance;
		return instance;
	}

	func getConcept(this: &Program, name: String) -> Optional!<SharedHandle!<Concept>> {
		return this.concepts_by_name.get(name);
	}

	func getOrCreateChildNamespace(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: &List!<TemplateParameterDecl>, is_file: bool) -> SharedHandle!<Namespace> {
		for child in parent_namespace.children {
			if child.name != name {
				continue;
			}

			if child.template_parameters != template_parameters {
				continue;
			}

			return child;
		}

		var child = this.namespaces.append(Namespace(name, template_parameters, parent_namespace));

		// initialize file namespace
		if is_file {
			child.file_namespace = child;
		} else {
			child.file_namespace = parent_namespace.file_namespace;
		}

		// add child to parent namespace
		parent_namespace.children.append(child);
		parent_namespace.children_by_name[name].append(child);
		parent_namespace.updateMinState(NamespaceState::Unchecked);

		// initialize visible namespaces
		child.visible_namespaces.add(child);
		if !is_file {
			child.visible_namespaces.add(parent_namespace.visible_namespaces);
		}

		// initialize llvm debug info
		if this.di_builder != LLVMDIBuilderRef::null() {
			child.llvm_di = LLVMDIBuilderCreateNameSpace(this.di_builder, parent_namespace.llvm_di, child.name, true);
		}

		return child;
	}

	func createModule(this: &&Program, imported_module: ImportedModule) -> SharedHandle!<Namespace> {
		const namespaces = imported_module.name.split("/");

		var module = this.top_level_namespaces[imported_module.group];
		for i in 0u..namespaces.size() {
			module = this.getOrCreateChildNamespace(module, namespaces[i], List!<TemplateParameterDecl>(), i <= namespaces.size() - 1);
		}

		this.modules_by_path.set(imported_module.path, module);
		return module;
	}

	func getModule(this: &&Program, path: String) -> Optional!<SharedHandle!<Namespace>> {
		return this.modules_by_path.get(path);
	}

	func createType(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: &List!<TemplateParameterDecl>, body: TypeBody) -> SharedHandle!<TypeDecl> {
		var linked_namespace = this.getOrCreateChildNamespace(parent_namespace, name, template_parameters, false);
		var type_decl = this.types.append(TypeDecl(name, linked_namespace.template_parameters, body));

		type_decl.parent_namespace = linked_namespace.parent;
		type_decl.linked_namespace = linked_namespace;

		linked_namespace.linked_type = type_decl;

		parent_namespace.types.append(type_decl);
		parent_namespace.types_by_name[name].append(type_decl);

		return type_decl;
	}

	func createType(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, body: TypeBody) -> SharedHandle!<TypeDecl> {
		return this.createType(parent_namespace, name, List!<TemplateParameterDecl>(), body);
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: &List!<TemplateParameterDecl>, parameter_types: &List!<Type>, return_type: Type, body: FunctionBody) -> SharedHandle!<FunctionDecl> {
		var function = this.functions.append(FunctionDecl(name, template_parameters, body));

		function.parent_namespace = parent_namespace;
		function.parameter_types = parameter_types;
		function.return_type = return_type;

		parent_namespace.functions.append(function);
		parent_namespace.functions_by_name[name].append(function);

		if !(body is Unchecked) {
			parent_namespace.addUncheckedFunction(function);
		}

		return function;
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: &List!<TemplateParameterDecl>, parameter_types: &List!<Type>, return_type: Type, body: BuiltinFunction) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, template_parameters, parameter_types, return_type, FunctionBody::Builtin(body));
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: &List!<TemplateParameterDecl>, body: FunctionBody) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, template_parameters, List!<Type>(), Type::unknown(), body);
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: &List!<TemplateParameterDecl>, body: BuiltinFunction) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, template_parameters, List!<Type>(), Type::unknown(), FunctionBody::Builtin(body));
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, parameter_types: &List!<Type>, return_type: Type, body: FunctionBody) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, List!<TemplateParameterDecl>(), parameter_types, return_type, body);
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, parameter_types: &List!<Type>, return_type: Type, body: BuiltinFunction) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, List!<TemplateParameterDecl>(), parameter_types, return_type, FunctionBody::Builtin(body));
	}

	func printLLVMIRToFile(this: &Program) -> Optional!<String> {
		const output_path = this.options.getOutputCodePath(".ll");
		if printModuleToFile(this.llvm_module, output_path) {
			return Some(output_path);
		} else {
			return None;
		}
	}

	func writeLLVMBitcodeToFile(this: &Program) -> Optional!<String> {
		const output_path = this.options.getOutputCodePath(".bc");
		if LLVMWriteBitcodeToFile(this.llvm_module, output_path) == 0 {
			return Some(output_path);
		} else {
			return None;
		}
	}

	func printLLVMIRString(this: &Program) -> String {
		return printModuleToString(this.llvm_module);
	}

	func finalizeDI(this: &Program) -> void {
		if this.di_builder != LLVMDIBuilderRef::null() {
			LLVMDIBuilderFinalize(this.di_builder);
		}
	}

	func runFunction(this: &Program, function: SharedHandle!<FunctionDecl>, args: &List!<LLVMGenericValueRef>) -> LLVMGenericValueRef {
		return LLVMRunFunction(this.llvm_execution_engine, function.llvm_func, args);
	}

	func runMainFunction(this: &Program, args: &List!<String>, env: &List!<String>) -> int {
		return LLVMRunFunctionAsMain(this.llvm_execution_engine, LLVMGetNamedFunction(this.llvm_module, "main"), args, env);
	}
}

variant Concept {
	var name: String;

	case Any;
	case Boolean;
	case Integer: bool;
	case String;

	func dump(this: &Concept, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("Concept", is_last);
		out.attribute(this.name);

		match this {
			case Any -> out.value("Any");
			case Boolean -> out.value("Boolean");
			case Integer: is_signed -> out.value("Integer " + ("signed" if is_signed else "unsigned"));
			case String -> out.value("String");
		}

		out.pop();
	}
}

struct TemplateParameterDecl {
	var name: String;

	var concept: SharedHandle!<Concept>;
	var is_variadic: bool;

	var value: TemplateParameter;

	func constructor(this: &&TemplateParameterDecl, name: String, concept: SharedHandle!<Concept>, is_variadic: bool) -> void {
		this.name := name;
		this.concept := concept;
		this.is_variadic := is_variadic;
		this.value := None;
	}

	func constructor(this: &&TemplateParameterDecl, name: String, concept: SharedHandle!<Concept>, is_variadic: bool, value: TemplateParameter) -> void {
		this.name := name;
		this.concept := concept;
		this.is_variadic := is_variadic;
		this.value := value;
	}

	func constructor(this: &&TemplateParameterDecl, other: TemplateParameterDecl) -> void = default;
	func destructor(this: &&TemplateParameterDecl) -> void = default;

	operator =(this: &&TemplateParameterDecl, other: TemplateParameterDecl) -> void = default;

	operator ==(this: TemplateParameterDecl, other: TemplateParameterDecl) -> bool = default;

	func signature(this: &TemplateParameterDecl) -> String {
		var result = this.name + ": ";
		result += ("..." if this.is_variadic else "");
		result += this.concept.name;

		if !(this.value is None) {
			result += " = ";
			result += format(this.value);
		}

		return result;
	}

	func dump(this: &TemplateParameterDecl, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("TemplateParameterDecl", is_last);
		out.attribute(this.name);
		out.text(":");
		out.attribute(this.concept.name);

		if !(this.value is None) {
			out.text(" =");
			out.value(format(this.value));
		}

		out.pop();
	}
}

variant TemplateParameter {
	case None;
	case Type: Type;
	case Boolean: bool;
	case Integer: int;
	case String: String;
	case Garbage;
}

struct Name {
	var span: Span;
	var segments: List!<NameSegment>;

	func constructor(this: &&Name) -> void = default;

	func constructor(this: &&Name, span: Span) -> void {
		this.span := span;
	}

	func constructor(this: &&Name, name: String) -> void {
		this.segments := (1u, NameSegment(name, List!<TemplateParameter>()));
	}

	func constructor(this: &&Name, name: String, template_parameters: &List!<TemplateParameter>) -> void {
		this.segments := (1u, NameSegment(name, template_parameters));
	}

	func constructor(this: &&Name, other: Name) -> void = default;
	func destructor(this: &&Name) -> void = default;

	operator =(this: &&Name, other: Name) -> void = default;
	operator ==(@[shallow] this: Name, @[shallow] other: Name) -> bool = default;

	operator +(@[shallow] this: Name, @[shallow] segment: NameSegment) -> Name {
		var result = this;
		result.segments.append(segment);
		return result;
	}

	func intersection(this: &Name, segments: &List!<NameSegment>) -> uint {
		for offset in 0u..this.segments.size() {
			if segments.startsWith(this.segments[offset..this.segments.size()]) {
				return this.segments.size() - offset;
			}
		}

		return 0u;
	}
}

enum NamespaceState {
	case IncompleteTemplate;
	case Unchecked;
	case UncheckedTypeBodies;
	case UncheckedFunctionSignatures;
	case UncheckedFunctionBodies;
	case Done;

	operator +(this: NamespaceState, delta: uint) -> NamespaceState {
		return (this as uint + delta) as NamespaceState;
	}
}

struct Namespace {
	var span: Span;
	var name_span: Span;
	var has_errors: bool;

	var name: String;
	var full_name: Name;
	var template_parameters: List!<TemplateParameterDecl>;

	var parent: SharedHandle!<Namespace>;
	var children: List!<SharedHandle!<Namespace>>;
	var children_by_name: Map!<String, List!<SharedHandle!<Namespace>>>;
	var aliases: Map!<String, SharedHandle!<Namespace>>;

	var imported_namespaces: Set!<SharedHandle!<Namespace>>;
	var visible_namespaces: Set!<SharedHandle!<Namespace>>;
	var file_namespace: SharedHandle!<Namespace>;

	var template_instances: List!<SharedHandle!<Namespace>>;

	var linked_type: SharedHandle!<TypeDecl>;

	var types: List!<SharedHandle!<TypeDecl>>;
	var types_by_name: Map!<String, List!<SharedHandle!<TypeDecl>>>;

	var functions: List!<SharedHandle!<FunctionDecl>>;
	var functions_by_name: Map!<String, List!<SharedHandle!<FunctionDecl>>>;

	var comptime_variables: SharedList!<VarDecl>;
	var comptime_variables_by_name: Map!<String, SharedHandle!<VarDecl>>;

	var state: NamespaceState;
	var unchecked_children: List!<ParsedStmt>;
	var unchecked_types: List!<SharedHandle!<TypeDecl>>;
	var unchecked_functions: List!<SharedHandle!<FunctionDecl>>;
	var unchecked_function_bodies: List!<SharedHandle!<FunctionDecl>>;

	var llvm_di: LLVMMetadataRef;

	func constructor(this: &&Namespace, name: String, template_parameters: &List!<TemplateParameterDecl>, parent: SharedHandle!<Namespace>) -> void {
		this.name := name;
		this.template_parameters := template_parameters;
		this.parent := parent;
		this.state := Unchecked;

		var template_parameter_values: List!<TemplateParameter>;
		for p in template_parameters {
			if p.value is None {
				this.state = IncompleteTemplate;
			} else {
				template_parameter_values.append(p.value);
			}
		}

		var full_name: Name;
		if this.parent.isAlive() {
			full_name = this.parent.full_name + NameSegment(name, template_parameter_values);
		} else {
			full_name = Name(name, template_parameter_values);
		}

		this.full_name := full_name;
	}

	func constructor(this: &&Namespace, other: Namespace) -> void {
		this.name := other.name;
		this.full_name := other.full_name;
		this.template_parameters := other.template_parameters;

		this.parent := other.parent;

		this.state := other.state;
	}

	func destructor(this: &&Namespace) -> void = default;

	func signature(this: &Namespace) -> String {
		if this.parent.isAlive() {
			var result = this.parent.signature();
			result += "::";
			result += this.name;
			result += format(this.template_parameters);
			return result;
		}

		return this.name + format(this.template_parameters);
	}

	func dump(this: &Namespace, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("Namespace", is_last);
		out.attribute(this.signature());
		out.value(format(this.state));

		for parameter in this.template_parameters {
			parameter.dump(&&out, false);
		}

		for i in 0u..this.children.size() {
			this.children[i].dump(&&out, (i == this.children.size() - 1) && this.types.isEmpty() && this.functions.isEmpty()&& this.comptime_variables.isEmpty());
		}

		for i in 0u..this.types.size() {
			this.types[i].dump(&&out, (i == this.types.size() - 1) && this.functions.isEmpty()&& this.comptime_variables.isEmpty());
		}

		for i in 0u..this.functions.size() {
			this.functions[i].dump(&&out, (i == this.functions.size() - 1) && this.comptime_variables.isEmpty());
		}

		for i in 0u..this.comptime_variables.size() {
			this.comptime_variables[i].dump(&&out, i == this.comptime_variables.size() - 1);
		}

		out.pop();
	}

	func isIncompleteTemplate(this: &Namespace) -> bool {
		return this.state == IncompleteTemplate
	}

	func updateState(this: &&Namespace, new_state: NamespaceState) -> void {
		if this.state == IncompleteTemplate {
			return;
		}

		this.state = new_state;

		if this.parent.isAlive() {
			this.parent.updateMinState(new_state);
		}
	}

	func updateMinState(this: &&Namespace, min_state: NamespaceState) -> void {
		if this.state == IncompleteTemplate {
			return;
		}

		if this.state <= min_state {
			return;
		}

		this.state = min_state;

		if this.parent.isAlive() {
			this.parent.updateMinState(min_state);
		}
	}

	func addImportedNamespace(this: &&Namespace, other: SharedHandle!<Namespace>) -> void {
		this.imported_namespaces.add(other);
		this.addVisibleNamespace(other);
	}

	func addVisibleNamespace(this: &&Namespace, other: SharedHandle!<Namespace>) -> void {
		this.visible_namespaces.add(other);
		for c in this.children {
			c.addVisibleNamespace(other);
		}
	}

	func addUncheckedChildren(this: &&Namespace, children: &List!<ParsedStmt>) -> void {
		this.unchecked_children.append(children);
		this.updateMinState(NamespaceState::Unchecked);

		for instance in this.template_instances {
			instance.addUncheckedChildren(children);
		}
	}

	func addUncheckedType(this: &&Namespace, type: SharedHandle!<TypeDecl>) -> void {
		this.unchecked_types.append(type);
		this.updateMinState(NamespaceState::UncheckedTypeBodies);
	}

	func addUncheckedFunction(this: &&Namespace, function: SharedHandle!<FunctionDecl>) -> void {
		this.unchecked_functions.append(function);
		this.updateMinState(NamespaceState::UncheckedFunctionSignatures);
	}

	func addUncheckedFunctionBody(this: &&Namespace, function: SharedHandle!<FunctionDecl>) -> void {
		this.unchecked_function_bodies.append(function);
		this.updateMinState(NamespaceState::UncheckedFunctionBodies);
	}

	func createComptimeVariable(this: &&Namespace, span: Span, name: String, type: Type, is_const: bool) -> SharedHandle!<VarDecl> {
		const variable = this.comptime_variables.append(VarDecl(span, 0u, name, type, is_const, false, true));
		this.comptime_variables_by_name.set(name, variable);
		return variable;
	}
}

struct TypeDecl {
	var span: Span;
	var name_span: Span;

	var name: String;
	var template_parameters: List!<TemplateParameterDecl>;
	var body: TypeBody;

	var parent_namespace: SharedHandle!<Namespace>;
	var linked_namespace: SharedHandle!<Namespace>;

	var unwrapped_type: SharedHandle!<TypeDecl>;

	var default_constructor: SharedHandle!<FunctionDecl>;
	var copy_constructor: SharedHandle!<FunctionDecl>;
	var destructor: SharedHandle!<FunctionDecl>;
	var op_assign: SharedHandle!<FunctionDecl>;
	var op_equal: SharedHandle!<FunctionDecl>;
	var op_compare: SharedHandle!<FunctionDecl>;

	var contained_types: Set!<SharedHandle!<TypeDecl>>;

	var parsed_annotations: List!<ParsedAnnotation>;

	// struct & variant
	var member_variables: List!<MemberVarDecl>;
	var member_variables_by_name: Map!<String, uint>;

	// enum & variant
	var parsed_id_type: ParsedType;
	var id_type: Type;

	// only enum
	var enum_cases: List!<EnumCaseDecl>;
	var enum_cases_by_name: Map!<String, uint>;

	// only variant
	var variant_cases: List!<VariantCaseDecl>;
	var variant_cases_by_id: Map!<int, uint>;
	var variant_cases_by_name: Map!<String, uint>;

	// flags for codegen
	var is_packed: bool;

	// llvm
	var llvm_type: LLVMTypeRef;
	var llvm_di: LLVMMetadataRef;

	func constructor(this: &&TypeDecl, name: String, template_parameters: &List!<TemplateParameterDecl>, body: TypeBody) -> void {
		this.name := name;
		this.template_parameters := template_parameters;
		this.body := body;
		this.parsed_id_type := Empty(Span());
	}

	func constructor(this: &&TypeDecl, other: TypeDecl) -> void = default;
	func destructor(this: &&TypeDecl) -> void = default;

	func dump(this: &TypeDecl, out: &&TreeFormatter, is_last: bool) -> void {
		match this.body {
			case Empty -> out.push("EmptyTypeDecl", is_last);
			case Void -> out.push("VoidTypeDecl", is_last);
			case Bool -> out.push("BoolTypeDecl", is_last);
			case Byte -> out.push("ByteTypeDecl", is_last);
			case Int: size -> {
				out.push("IntTypeDecl", is_last);
				out.value(format(size));
			}
			case UInt: size -> {
				out.push("UIntTypeDecl", is_last);
				out.value(format(size));
			}
			case Float: size -> {
				out.push("FloatTypeDecl", is_last);
				out.value(format(size));
			}
			case Pointer: pointer_type -> {
				out.push("PointerTypeDecl", is_last);
				out.attribute("var" if pointer_type.is_mutable else "const");
				out.value(pointer_type.pointee_type.signature());
			}
			case Function -> {
				out.push("FunctionTypeDecl", is_last);
			}
			case Tuple -> {
				out.push("TupleTypeDecl", is_last);
			}
			case Array: array_type -> {
				out.push("ArrayTypeDecl", is_last);
				out.value(array_type.element_type.signature());
				out.value(format(array_type.size));
			}
			case Range: type -> {
				out.push("Range", is_last);
				out.value(type.signature());
			}
			case RangeIterator: type -> {
				out.push("RangeIterator", is_last);
				out.value(type.signature());
			}
			case NumericRange: type -> {
				out.push("NumericRange", is_last);
				out.value(type.signature());
			}
			case NumericIterator: type -> {
				out.push("NumericIterator", is_last);
				out.value(type.signature());
			}
			case Enum -> {
				out.push("EnumTypeDecl", is_last);
			}
			case Struct -> {
				out.push("StructTypeDecl", is_last);
			}
			case Variant -> {
				out.push("VariantTypeDecl", is_last);
			}
		}

		out.attribute(this.signature());

		for i in 0u..this.template_parameters.size() {
			this.template_parameters[i].dump(&&out, (i == this.template_parameters.size() - 1) && this.member_variables.isEmpty() && this.enum_cases.isEmpty() && this.variant_cases.isEmpty());
		}

		for i in 0u..this.member_variables.size() {
			this.member_variables[i].dump(&&out, (i == this.member_variables.size() - 1) && this.enum_cases.isEmpty() && this.variant_cases.isEmpty());
		}

		for i in 0u..this.enum_cases.size() {
			this.enum_cases[i].dump(&&out, i == this.enum_cases.size() - 1);
		}

		for i in 0u..this.variant_cases.size() {
			this.variant_cases[i].dump(&&out, i == this.variant_cases.size() - 1);
		}

		out.pop();
	}

	func signature(this: &TypeDecl) -> String {
		return this.linked_namespace.signature();
	}

	func isIncompleteTemplate(this: &TypeDecl) -> bool {
		for parameter in this.template_parameters {
			if parameter.value is None {
				return true;
			}
		}

		return false;
	}

	func addContainedType(this: &&TypeDecl, type: Type) -> void {
		if type.isUnknown() {
			return;
		}

		if type.reference_kind == None {
			this.contained_types.add(type.decl);
		}
	}

	func createMemberVariable(this: &&TypeDecl, span: Span, name: String, type: Type, initializer: &Expr) -> void {
		if this.member_variables_by_name.contains(name) {
			return;
		}

		this.member_variables_by_name.set(name, this.member_variables.size());
		this.member_variables.append(MemberVarDecl(span, this.member_variables.size(), name, type, initializer));

		this.addContainedType(type);
	}

	func getMemberVariable(this: &TypeDecl, name: String) -> Optional!<MemberVarDecl> {
		for v in this.member_variables {
			if v.name == name {
				return Some(v);
			}
		}

		return None;
	}

	func getNextCaseId(this: &TypeDecl) -> int {
		if this.body is Enum {
			if const prev_case = this.enum_cases.last() {
				return prev_case.id + 1;
			}
		} else if this.body is Variant {
			if const prev_case = this.variant_cases.last() {
				return prev_case.id + 1;
			}
		}
		return 0;
	}

	func createEnumCase(this: &&TypeDecl, span: Span, id: int, name: String) -> void {
		this.enum_cases_by_name.set(name, this.enum_cases.size());
		this.enum_cases.append(EnumCaseDecl(span, id, name));
	}

	func getEnumCase(this: &TypeDecl, name: String) -> Optional!<EnumCaseDecl> {
		const index = this.enum_cases_by_name.get(name) else {
			return None;
		}

		return Some(this.enum_cases[index]);
	}

	func createVariantCase(this: &&TypeDecl, span: Span, id: int, name: String, payload: Type) -> void {
		this.variant_cases_by_name.set(name, this.variant_cases.size());
		this.variant_cases_by_id.set(id, this.variant_cases.size());
		this.variant_cases.append(VariantCaseDecl(span, id, name, payload));
		this.addContainedType(payload);
	}

	func getVariantCase(this: &TypeDecl, name: String) -> Optional!<VariantCaseDecl> {
		const index = this.variant_cases_by_name.get(name) else {
			return None;
		}

		return Some(this.variant_cases[index]);
	}

	func getVariantCase(this: &TypeDecl, id: int) -> Optional!<VariantCaseDecl> {
		const index = this.variant_cases_by_id.get(id) else {
			return None;
		}

		return Some(this.variant_cases[index]);
	}
}

struct Type {
	var decl: SharedHandle!<TypeDecl>;
	var reference_kind: ReferenceKind;

	func constructor(this: &&Type, decl: SharedHandle!<TypeDecl>) -> void {
		this.decl := decl;
		this.reference_kind := None;
	}

	func constructor(this: &&Type, decl: SharedHandle!<TypeDecl>, reference_kind: ReferenceKind) -> void {
		this.decl := decl;
		this.reference_kind := reference_kind;
	}

	func constructor(this: &&Type) -> void = default;
	func constructor(this: &&Type, other: Type) -> void = default;
	func destructor(this: &&Type) -> void = default;

	operator =(this: &&Type, other: Type) -> void = default;

	operator ==(this: Type, other: Type) -> bool = default;
	operator <=>(this: Type, other: Type) -> int = default;

	func unknown() -> Type {
		return Type(SharedHandle!<TypeDecl>(), ReferenceKind::None);
	}

	func isUnknown(this: &Type) -> bool {
		return this.decl.isEmpty();
	}

	func isAlive(this: &Type) -> bool {
		return this.decl.isAlive();
	}

	func signature(this: &Type) -> String {
		if this.decl.isAlive() {
			return this.reference_kind.toString() + this.decl.signature();
		}

		return "unknown";
	}

	func base(this: &Type) -> Type {
		return Type(this.decl, ReferenceKind::None);
	}

	func constRef(this: &Type) -> Type {
		return Type(this.decl, ReferenceKind::Const);
	}

	func varRef(this: &Type) -> Type {
		return Type(this.decl, ReferenceKind::Var);
	}

	func isIncompleteTemplate(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		return this.decl.isIncompleteTemplate();
	}

	func isIntType(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Bool
			| Byte
			| Int
			| UInt
			| Enum -> return true;
			else -> return false;
		}
	}

	func isSigned(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Int
			| Float -> return true;
			else -> return false;
		}
	}

	func isFloatType(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Float -> return true;
			else -> return false;
		}
	}

	func isPtrType(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Pointer -> return true;
			else -> return false;
		}
	}

	func isConstPtrType(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Pointer: pointer_type -> return !pointer_type.is_mutable;
			else -> return false;
		}
	}

	func isPrimitive(this: &Type) -> bool {
		if this.reference_kind != None {
			return true; // reference types are always primitive
		}

		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Void
			| Bool
			| Byte
			| Int
			| UInt
			| Float
			| Pointer
			| Function
			| Enum -> return true;
			else -> return false;
		}
	}

	func isVariant(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Variant -> return true;
			else -> return false;
		}
	}

	func getPrimitiveSizeInBits(this: &Type) -> uint {
		if this.reference_kind != None {
			return sizeOf!<ptr!<false>>() * 8;
		}

		if this.decl.isEmpty() {
			return 0;
		}

		match this.decl.body {
			case Void -> return 0;
			case Bool -> return 1;
			case Byte -> return 8;
			case Int: bits -> return bits;
			case UInt: bits -> return bits;
			case Float: bits -> return bits;
			case Pointer -> return sizeOf!<ptr!<false>>() * 8;
			case Enum -> return this.decl.id_type.getPrimitiveSizeInBits();
			else -> return 0;
		}
	}

	func getBitMask(this: &Type) -> int {
		return -1 >> (sizeOf!<uint>() * 8 - this.getPrimitiveSizeInBits()) as int;
	}
}

struct FunctionDecl {
	var span: Span;
	var signature_span: Span;
	var has_errors: bool;

	var name: String;
	var template_parameters: List!<TemplateParameterDecl>;
	var body: FunctionBody;

	var parent_namespace: SharedHandle!<Namespace>;

	var extern_name: String;

	var parameter_types: List!<Type>;
	var return_type: Type;

	var variables: SharedList!<VarDecl>;
	var parameters: List!<SharedHandle!<VarDecl>>;

	var is_copy_constructor: bool;

	// llvm
	var llvm_func: LLVMValueRef;
	var llvm_type: LLVMTypeRef;
	var llvm_di: LLVMMetadataRef;

	func constructor(this: &&FunctionDecl, name: String, template_parameters: &List!<TemplateParameterDecl>, body: FunctionBody) -> void {
		this.name := name;
		this.template_parameters := template_parameters;
		this.body := body;
	}

	func constructor(this: &&FunctionDecl, other: FunctionDecl) -> void {
		this.name := other.name;
		this.template_parameters := other.template_parameters;
		this.body := other.body;
	}

	func destructor(this: &&FunctionDecl) -> void = default;

	func dump(this: &FunctionDecl, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("FunctionDecl", is_last);
		out.attribute(this.signature());
		out.span(this.span);

		for parameter in this.template_parameters {
			parameter.dump(&&out, false);
		}

		for variable in this.variables {
			if variable.is_parameter {
				variable.dump(&&out, false);
			}
		}

		match this.body {
			case Empty -> {
				out.push("EmptyFunction", true);
				out.pop();
			}
			case Extern -> {
				out.push("ExternFunction", true);
				out.pop();
			}
			case Builtin: f -> {
				out.push("BuiltinFunction", true);
				out.pop();
			}
			case Stmt: stmt -> stmt.dump(&&out, true);
			case Unchecked -> {
				out.push("UncheckedFunction", true);
				out.pop();
			}
		}

		out.pop();
	}

	func signature(this: &FunctionDecl) -> String {
		var result = this.parent_namespace.signature();

		result += "::";
		result += this.name;
		result += this.template_parameters.format();
		result += "(";

		for i in 0u..this.parameter_types.size() {
			if i != 0 {
				result += ", ";
			}
			result += this.parameter_types[i].signature();
		}

		result += ") -> ";
		result += this.return_type.signature();
		return result;
	}

	func createParameter(this: &&FunctionDecl, span: Span, name: String, type: Type) -> void {
		const variable = this.variables.append(VarDecl(span, this.variables.size(), name, type, type.reference_kind != Var, true, false));
		this.parameters.append(variable);
	}

	func createVariable(this: &&FunctionDecl, span: Span, name: String, type: Type, is_const: bool, is_comptime: bool) -> SharedHandle!<VarDecl> {
		return this.variables.append(VarDecl(span, this.variables.size(), name, type, is_const, false, is_comptime));
	}

	func isIncompleteTemplate(this: &FunctionDecl) -> bool {
		for parameter in this.template_parameters {
			if parameter.value is None {
				return true;
			}
		}

		return false;
	}
}

variant TypeBody {
	case Empty;

	case Void;
	case Bool;
	case Byte;

	// size in bits attached, 0 -> pointer sized
	case Int: uint;
	case UInt: uint;

	// size in bits attached
	case Float: uint;

	case Pointer: (pointee_type: Type, is_mutable: bool);
	case Function: (parameter_types: List!<Type>, return_type: Type);

	case Tuple;

	case Array: (element_type: Type, size: uint);

	case Range: Type;
	case RangeIterator: Type;

	case NumericRange: Type;
	case NumericIterator: Type;

	case Struct;
	case Enum;
	case Variant;
}

variant FunctionBody {
	case Empty;
	case Extern;
	case Builtin: BuiltinFunction;
	case Stmt: Stmt;
	case Unchecked: ParsedFunctionDecl;
}

struct VarDecl {
	var span: Span;

	var id: uint;
	var name: String;
	var type: Type;

	var is_const: bool;
	var is_parameter: bool;
	var is_comptime: bool;
	var is_unused: bool;

	var constructor_call: Expr;
	var destructor_call: Expr;

	// comptime only
	var value: Expr;

	// parameters only
	var is_shallow_parameter: bool;

	func constructor(this: &&VarDecl, span: Span, id: uint, name: String, type: Type, is_const: bool, is_parameter: bool, is_comptime: bool) -> void {
		this.span := span;

		this.id := id;
		this.name := name;
		this.type := type;

		this.is_const := is_const;
		this.is_parameter := is_parameter;
		this.is_comptime := is_comptime;

		this.constructor_call := Expr::Undefined(Span(), Type::unknown());
		this.destructor_call := Expr::Undefined(Span(), Type::unknown());

		this.value := Expr::Undefined(Span(), Type::unknown());

		this.is_shallow_parameter = false;
	}

	func constructor(this: &&VarDecl, other: VarDecl) -> void = default;
	func destructor(this: &&VarDecl) -> void = default;

	operator =(this: &&VarDecl, other: VarDecl) -> void = default;

	operator ==(@[shallow] this: VarDecl, @[shallow] other: VarDecl) -> bool {
		return this.id == other.id;
	}

	func dump(this: &VarDecl, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("ParameterDecl" if this.is_parameter else "VarDecl", is_last);

		out.attribute(("#" if this.is_parameter else "") + this.name);
		out.value(format(this.id));
		out.text(" :");
		out.value(this.type.signature());

		if this.is_comptime {
			out.value("comptime");
		}

		out.value("const" if this.is_const else "var");
		out.span(this.span);

		this.constructor_call.dump(&&out, false);
		this.destructor_call.dump(&&out, !this.is_comptime);

		if this.is_comptime {
			this.value.dump(&&out, true);
		}

		out.pop();
	}

	func signature(this: &VarDecl) -> String {
		return ("const " if this.is_const else "var ") + this.name + ": " + this.type.signature();
	}
}

enum PrimitiveOp {
	case NoOp;
	case ConstNull;
	case Copy;

	case BitwiseEQ;
	case BitwiseNE;

	case BitwiseAnd;
	case BitwiseOr;
	case BitwiseXOr;
	case BitwiseNot;
	case BitwiseShl;
	case BitwiseLShr;
	case BitwiseAShr;

	case IntAdd;
	case IntSub;
	case IntMul;
	case IntNeg;
	case IntInc;
	case IntDec;

	case SIntLT;
	case SIntLE;
	case SIntGT;
	case SIntGE;
	case SIntCmp;

	case SIntDiv;
	case SIntMod;

	case UIntLT;
	case UIntLE;
	case UIntGT;
	case UIntGE;
	case UIntCmp;

	case UIntDiv;
	case UIntMod;

	case FloatEQ;
	case FloatNE;
	case FloatLT;
	case FloatLE;
	case FloatGT;
	case FloatGE;
	case FloatCmp;

	case FloatAdd;
	case FloatSub;
	case FloatMul;
	case FloatDiv;
	case FloatMod;
	case FloatNeg;

	case Assign = 64;

	operator |(lhs: PrimitiveOp, rhs: PrimitiveOp) -> PrimitiveOp = default;

	func isAssignment(op: PrimitiveOp) -> bool {
		return ((op as uint) & 64) != 0;
	}

	func getOp(op: PrimitiveOp) -> PrimitiveOp {
		return ((op as uint) & ~64u) as PrimitiveOp;
	}
}

variant BuiltinFunction {
	var base_type: Type;

	case Empty;
	case PrimitiveOp: PrimitiveOp;

	case PointerToRef;
	case RefToPointer;
	case PointerCast;

	case PointerDiff;
	case PointerOffset;
	case PointerOpIndex;

	case FunctionPointerCall;

	// base type is source type, attached type target
	case IntCast: Type;
	case FloatCast: Type;
	case IntToFloat: Type;
	case FloatToInt: Type;

	// base type is first template parameter
	case SizeOf;
	case AlignmentOf;
	case ReferenceKindOf;

	// attached type is range type
	case NumericTypeRangeOperator: Type;

	// attached type is numeric type
	case NumericRangeConstructor: Type;
	case NumericRangeSetStep: Type;

	// attached type is iterator type
	case NumericRangeGetIterator: Type;

	// attached type is numeric type
	case NumericIteratorHasNext: Type;
	case NumericIteratorGetNext: Type;

	// attached value is id of target case
	case VariantOpUnsafeAs: int;
	case VariantOpIs: int;

	case ArrayGetSize;
	case ArrayGetDataPointer;

	case StructValueConstructor;
	case StructDefaultConstructor;
	case StructCopyConstructor;
	case StructDestructor;
	case StructOpAssign;
	case StructOpEqual;
	case StructOpCmp;

	case VariantCaseConstructor: int;
	case VariantCopyConstructor;
	case VariantDestructor;
	case VariantOpAssign;
	case VariantOpEqual;

	case ArrayDefaultConstructor;
	case ArrayCopyConstructor;
	case ArrayDestructor;
	case ArrayOpAssign;
	case ArrayOpEqual;

	func isInlineable(this: &BuiltinFunction) -> bool {
		match this {
			case PrimitiveOp
			| PointerToRef
			| RefToPointer
			| PointerCast
			| PointerDiff
			| PointerOffset
			| PointerOpIndex
			| FunctionPointerCall
			| IntCast
			| FloatCast
			| IntToFloat
			| FloatToInt
			| SizeOf
			| AlignmentOf
			| ReferenceKindOf
			| NumericTypeRangeOperator
			| NumericRangeConstructor
			| NumericRangeSetStep
			| NumericRangeGetIterator
			| NumericIteratorHasNext
			| NumericIteratorGetNext
			| VariantOpUnsafeAs
			| VariantOpIs
			| ArrayGetSize
			| ArrayGetDataPointer -> return true;
			else -> return false;
		}
	}
}

variant Stmt {
	var span: Span;

	case Empty;

	case Compound: CompoundStmt;

	case Expr: Expr;

	case If: Box!<IfStmt>;
	case While: Box!<WhileStmt>;

	case Case: Box!<CaseStmt>;
	case ElseCase: Box!<Stmt>;

	case Break;
	case Continue;
	case Yield;

	case Return: Expr;

	case LifeTimeStart: SharedHandle!<VarDecl>;
	case LifeTimeEnd: SharedHandle!<VarDecl>;

	func dump(this: &Stmt, out: &&TreeFormatter, is_last: bool) -> void {
		match this {
			case Empty -> {
				out.push("EmptyStmt", is_last);
				out.span(this.span);
				out.pop();
			}
			case Compound: compound_stmt -> compound_stmt.dump(&&out, is_last);
			case Expr: expr -> expr.dump(&&out, is_last);
			case If: if_stmt -> {
				out.push("IfStmt", is_last);
				out.span(this.span);

				if_stmt.condition.dump(&&out, false);
				if_stmt.then_branch.dump(&&out, false);
				if_stmt.else_branch.dump(&&out, true);

				out.pop();
			}
			case While: while_stmt -> {
				match while_stmt.kind {
					case While -> out.push("WhileStmt", is_last);
					case DoWhile -> out.push("DoWhileStmt", is_last);
				}
				out.span(this.span);

				while_stmt.condition.dump(&&out, false);
				while_stmt.body.dump(&&out, false);

				out.pop();
			}
			case Case -> {}
			case ElseCase -> {}
			case Break -> {
				out.push("BreakStmt", is_last);
				out.span(this.span);
				out.pop();
			}
			case Continue -> {
				out.push("ContinueStmt", is_last);
				out.span(this.span);
				out.pop();
			}
			case Yield -> {
				out.push("YieldStmt", is_last);
				out.span(this.span);
				out.pop();
			}
			case Return: value -> {
				out.push("ReturnStmt", is_last);
				out.span(this.span);
				value.dump(&&out, true);
				out.pop();
			}
			case LifeTimeStart: variable -> {
				variable.dump(&&out, is_last);
			}
			case LifeTimeEnd: variable -> {
				out.push("LifeTimeEnd", is_last);
				out.value(variable.name);
				out.span(variable.span);
				out.pop();
			}
		}
	}

	func isTerminator(this: &Stmt, never_type: Type, yield_is_terminator: bool) -> bool {
		match this {
			case Empty -> return false;
			case Compound: compound_stmt -> return compound_stmt.isTerminator(never_type, yield_is_terminator);
			case Expr: expr -> return expr.type == never_type;
			case If: if_stmt -> return if_stmt.then_branch.isTerminator(never_type, yield_is_terminator) && if_stmt.else_branch.isTerminator(never_type, yield_is_terminator);
			case While: while_stmt -> return while_stmt.kind == DoWhile && while_stmt.body.isTerminator(never_type, yield_is_terminator);
			case Case: case_stmt -> return case_stmt.body.isTerminator(never_type, yield_is_terminator);
			case ElseCase: body -> return body.isTerminator(never_type, yield_is_terminator);
			case Break
			| Continue
			| Return -> return true;
			case Yield -> return yield_is_terminator;
			case LifeTimeStart
			| LifeTimeEnd -> return false;
		}
	}
}

struct CompoundStmt {
	var span: Span;
	var children: SharedPtr!<List!<Stmt>>;

	func constructor(this: &&CompoundStmt, span: Span) -> void {
		this.span := span;
		this.children := List!<Stmt>();
	}

	func constructor(this: &&CompoundStmt, other: CompoundStmt) -> void = default;
	func destructor(this: &&CompoundStmt) -> void = default;

	operator =(this: &&CompoundStmt, other: CompoundStmt) -> void = default;

	operator ==(@[shallow] this: CompoundStmt, @[shallow] other: CompoundStmt) -> bool {
		return this.children.data == other.children.data;
	}

	func dump(this: &CompoundStmt, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("CompoundStmt", is_last);
		out.span(this.span);

		for i in 0u..this.children.size() {
			this.children[i].dump(&&out, i == this.children.size() - 1);
		}

		out.pop();
	}

	func isTerminator(this: &CompoundStmt, never_type: Type, yield_is_terminator: bool) -> bool {
		if const last = this.children.last() {
			return last.isTerminator(never_type, yield_is_terminator);
		}
		return false;
	}
}

variant Expr {
	var span: Span;
	var type: Type;

	case Undefined;

	case Void;
	case Integer: int;
	case Float: f64;
	case String: String;

	case ConstAggregate: List!<Expr>;

	case Call: CallExpr;
	case Match: Box!<MatchExpr>;

	case VarInvoke: SharedHandle!<VarDecl>;
	case MemberVarInvoke: Box!<MemberVarInvokeExpr>;

	case Dereference: Box!<Expr>;

	case ShallowCopy: Box!<ShallowCopyExpr>;

	case TypeRef: Type;
	case FunctionRef: SharedHandle!<FunctionDecl>;

	func constructor(this: &&Expr) -> void {
		this.constructor!<0>(Span(), Type::unknown());
	}

	template <Id: int = 11>
	func constructor(this: &&Expr, data: &ShallowCopyExpr, span: Span, type: Type) -> void {
		this.constructor!<11>(Box!<ShallowCopyExpr>(data), span, type);
	}

	func toBool(this: &Expr) -> bool {
		match this {
			case Integer: val -> return (val & this.type.getBitMask()) as bool;
			else -> return false;
		}
	}

	func toInt(this: &Expr) -> int {
		match this {
			case Integer: val -> return (val & this.type.getBitMask());
			else -> return 0;
		}
	}

	func toUInt(this: &Expr) -> uint {
		match this {
			case Integer: val -> return (val & this.type.getBitMask()) as uint;
			else -> return 0u;
		}
	}

	func toFloat(this: &Expr) -> f64 {
		match this {
			case Float: val -> return val;
			else -> return 0.0;
		}
	}
}

alias NameSegment = (name: String, template_parameters: List!<TemplateParameter>);

alias MemberVarDecl = (span: Span, id: uint, name: String, type: Type, initializer: Expr);
alias EnumCaseDecl = (span: Span, id: int, name: String);
alias VariantCaseDecl = (span: Span, id: int, name: String, type: Type);

alias IfStmt = (condition: Expr, condition_cleanup: List!<Stmt>, then_branch: Stmt, else_branch: Stmt);

enum WhileStmtKind {
	case While;
	case DoWhile;
}

alias WhileStmt = (condition: Expr, condition_cleanup: List!<Stmt>, body: Stmt, kind: WhileStmtKind);
alias CaseStmt = (span: Span, patterns: List!<Expr>, body: Stmt);

enum ReturnKind {
	case None;		// function returns void or never
	case Value;		// most basic, no memory management
	case Variable;	// result gets stored in variable allocated by caller
	case Parameter;	// callee initializes variable allocated by caller, passed by reference as first parameter
	case VariableButYieldNone;	// same as variable, but result gets discarded. Used when initializing a variable with the result of a call (optimized)
}

alias CallExpr = (
	function: SharedHandle!<FunctionDecl>,
	parameters: SharedPtr!<List!<Expr>>,
	result_var: SharedHandle!<VarDecl>,
	return_kind: ReturnKind
);

alias MatchExpr = (value: Expr, cases: List!<CaseStmt>, else_case: Stmt, yield_var: SharedHandle!<VarDecl>);
alias MemberVarInvokeExpr = (object: Expr, id: uint);
alias ShallowCopyExpr = (destination: Expr, value: Expr);

func dump(this: &MemberVarDecl, out: &&TreeFormatter, is_last: bool) -> void {
	out.push("MemberVarDecl", is_last);
	out.attribute(this.name);
	out.value(this.type.signature());
	out.span(this.span);
	this.initializer.dump(&&out, true);
	out.pop();
}

func dump(this: &EnumCaseDecl, out: &&TreeFormatter, is_last: bool) -> void {
	out.push("EnumCaseDecl", is_last);
	out.attribute(this.name);
	out.value(format(this.id));
	out.span(this.span);
	out.pop();
}

func dump(this: &VariantCaseDecl, out: &&TreeFormatter, is_last: bool) -> void {
	out.push("VariantCaseDecl", is_last);
	out.attribute(this.name);
	out.value(format(this.id));
	out.value(this.type.signature());
	out.span(this.span);
	out.pop();
}

func dump(this: &Expr, out: &&TreeFormatter, is_last: bool) -> void {
	match this {
		case Undefined -> {
			out.push("UndefinedExpr", is_last);
			out.span(this.span);
			out.pop();
		}
		case Void -> {
			out.push("VoidExpr", is_last);
			out.span(this.span);
			out.pop();
		}
		case Integer: value -> {
			out.push("IntegerExpr", is_last);
			out.value(format(value));
			out.attribute(this.type.signature());
			out.span(this.span);
			out.pop();
		}
		case Float: value -> {
			out.push("FloatExpr", is_last);
			//out.value(format(value));
			out.attribute(this.type.signature());
			out.span(this.span);
			out.pop();
		}
		case String: value -> {
			out.push("StringExpr", is_last);
			out.value("\"" + value + "\"");
			out.attribute(this.type.signature());
			out.span(this.span);
			out.pop();
		}
		case ConstAggregate -> {}
		case Call: call_expr -> {
			out.push("CallExpr", is_last);
			out.value(call_expr.function.signature());
			out.attribute(format(call_expr.return_kind));
			out.span(this.span);

			if call_expr.result_var.isAlive() {
				call_expr.result_var.dump(&&out, call_expr.parameters.isEmpty());
			}

			for i in 0u..call_expr.parameters.size() {
				call_expr.parameters[i].dump(&&out, i == call_expr.parameters.size() - 1);
			}

			out.pop();
		}
		case Match: match_expr -> {
			out.push("MatchExpr", is_last);
			out.attribute(this.type.signature());
			out.span(this.span);

			match_expr.value.dump(&&out, false);
			if match_expr.yield_var.isAlive() {
				match_expr.yield_var.dump(&&out, false);
			}

			for c in match_expr.cases {
				out.push("CaseStmt", is_last);
				out.span(c.span);

				for pattern in c.patterns {
					pattern.dump(&&out, false);
				}

				c.body.dump(&&out, true);
				out.pop();
			}

			match_expr.else_case.dump(&&out, true);

			out.pop();
		}
		case VarInvoke: variable -> {
			out.push("VarInvokeExpr", is_last);
			out.value(("#" if variable.is_parameter else "") + variable.name);
			out.attribute(this.type.signature());
			out.span(this.span);
			out.pop();
		}
		case MemberVarInvoke: member_var_invoke_expr -> {
			out.push("MemberVarInvokeExpr", is_last);
			out.value(format(member_var_invoke_expr.id));
			out.attribute(this.type.signature());
			out.span(this.span);
			member_var_invoke_expr.object.dump(&&out, true);
			out.pop();
		}
		case Dereference: base -> {
			out.push("DereferenceExpr", is_last);
			out.attribute(this.type.signature());
			out.span(this.span);
			base.dump(&&out, true);
			out.pop();
		}
		case ShallowCopy: shallow_copy_expr -> {
			out.push("ShallowCopyExpr", is_last);
			out.span(this.span);
			shallow_copy_expr.destination.dump(&&out, false);
			shallow_copy_expr.value.dump(&&out, true);
			out.pop();
		}
		case TypeRef: type -> {
			out.push("TypeRefExpr", is_last);
			out.span(this.span);
			out.value(type.signature());
			out.pop();
		}
		case FunctionRef: function -> {
			out.push("FunctionRefExpr", is_last);
			out.span(this.span);
			out.value(function.signature());
			out.pop();
		}
	}
}

func addDereference(this: &Expr) -> Expr {
	match this.type.reference_kind {
		case None -> return this;
		else -> return Expr::Dereference(Box!<Expr>(this), this.span, this.type.base());
	}
}

func removeDereference(this: &Expr) -> Expr {
	match this {
		case Dereference: &base -> return base.operator unwrap();
		else -> return this;
	}
}

func format(template_parameter: &TemplateParameter) -> String {
	match template_parameter {
		case None -> return "<none>";
		case Type: t -> return t.signature();
		case Boolean: v -> return format(v);
		case Integer: v -> return format(v);
		case String: s -> return "\"" + s + "\"";
		case Garbage -> return "<garbage>";
	}
}

func format(template_parameters: &List!<TemplateParameterDecl>) -> String {
	if template_parameters.isEmpty() {
		return "";
	}

	var result = "!<";
	for i in 0u..template_parameters.size() {
		if i != 0 {
			result += ", ";
		}

		result += template_parameters[i].signature();
	}

	return result + ">";
}

func format(template_parameters: &List!<TemplateParameter>) -> String {
	if template_parameters.isEmpty() {
		return "";
	}

	var result = "!<";
	for i in 0u..template_parameters.size() {
		if i != 0 {
			result += ", ";
		}

		result += format(template_parameters[i]);
	}

	return result + ">";
}

func format(state: NamespaceState) -> String {
	assert(state >= IncompleteTemplate && state <= Done);

	match state {
		case IncompleteTemplate -> return "IncompleteTemplate";
		case Unchecked -> return "Unchecked";
		case UncheckedTypeBodies -> return "UncheckedTypeBodies";
		case UncheckedFunctionSignatures -> return "UncheckedFunctionSignatures";
		case UncheckedFunctionBodies -> return "UncheckedFunctionBodies";
		case Done -> return "Done";
	}
}

func format(this: &Name) -> String {
	var result = "";
	var first = true;
	for i in 0u..this.segments.size() {
		if i != 0 {
			result += "::";
		}
		result += this.segments[i].name;
		result += format(this.segments[i].template_parameters);
	}

	return result;
}

func format(types: &List!<Type>) -> String {
	var result = "(";
	for i in 0u..types.size() {
		if i != 0 {
			result += ", ";
		}

		result += types[i].signature();
	}

	return result + ")";
}

func format(return_kind: ReturnKind) -> String {
	match return_kind {
		case None -> return "None";
		case Value -> return "Value";
		case Variable -> return "Variable";
		case Parameter -> return "Parameter";
		case VariableButYieldNone -> return "VariableButYieldNone";
	}
}
