import std/core;
import std/box;
import std/format;
import std/io;
import std/list;
import std/map;
import std/set;
import std/shared;
import std/string;

import error;
import options;
import span;
import syntax_tree;
import tree_formatter;

struct Program {
	var name: String;
	var options: CompilerOptions;
	var modules: List!<SharedPtr!<Module>>;

	var has_errors: bool;
	var main_function: FunctionRef;

	var concepts: List!<SharedPtr!<Concept>>;
	var any_concept: WeakPtr!<Concept>;
	var int_concept: WeakPtr!<Concept>;
	var uint_concept: WeakPtr!<Concept>;

	// often used builtin types
	var void_type: TypeRef;
	var never_type: TypeRef;

	var bool_type: TypeRef;

	var int_type: TypeRef;
	var uint_type: TypeRef;

	var byte_type: TypeRef;

	var cptr_type: TypeRef;
	var vptr_type: TypeRef;

	func constructor(this: &&Program, options: CompilerOptions) -> void {
		this.name := options.program_name;
		this.options := options;
		this.has_errors := false;
	}

	func destructor(this: &&Program) -> void = default;

	func printError(this: &&Program, error: CompilationError) -> void {
		if error.type == Error {
			this.has_errors = true;
		}

		if this.options.hide_errors {
			return;
		}

		const span = error.span;
		const module = this.modules[span.module as uint];

		println(error.toString(module.path));

		if span.start == span.end {
			return;
		}

		var first_line = max(span.line as int - 1, 0) as uint;
		var last_line = span.line as uint + 1;
		while span.end > module.line_spans[last_line - 1].end && last_line < module.line_spans.size() {
			last_line++;
		}
		last_line = min(last_line + 1, module.line_spans.size());

		const last_line_number = format(last_line);
		const max_line_number_width = last_line_number.size();

		for line in first_line..last_line {
			const line_span = module.line_spans[line];

			const line_number_str = format(line + 1);
			print(String(max_line_number_width - line_number_str.size() + 1, ' 'b) + line_number_str + " | ");

			const error_start = max(line_span.start, min(span.start, line_span.end));
			const error_end = max(line_span.start, min(span.end, line_span.end));

			print(module.source.substring(line_span.start..error_start));
			print("\e[31m");
			print(module.source.substring(error_start..error_end));
			print("\e[0m");
			print(module.source.substring(error_end..line_span.end));

			print("\n");
		}
	}

	func printErrors(this: &&Program, errors: List!<CompilationError>) -> void {
		for e in errors {
			this.printError(e);
		}
	}

	func dump(this: &Program) -> String {
		var out: TreeFormatter = ("Program");
		out.attribute(this.name);
		out.text(" main:");
		out.value(this.main_function.signature());

		for concept in this.concepts {
			concept.dump(&&out, false);
		}

		for i in 0u..this.modules.size() {
			this.modules[i].dump(&&out, i == this.modules.size() - 1);
		}

		return out.finalize();
	}

	func dumpImportTree(this: &Program) -> String {
		var out: TreeFormatter = ("Program");
		out.attribute(this.name);

		this.modules[0u].dumpImportTree(&&out, true);

		return out.finalize();
	}

	func addConcept(this: &&Program, concept: Concept) -> WeakPtr!<Concept> {
		const concept_decl = SharedPtr!<Concept>::new(concept);
		this.concepts.append(concept_decl);
		return WeakPtr!<Concept>(concept_decl);
	}

	func getConcept(this: &Program, name: String) -> Optional!<WeakPtr!<Concept>> {
		for concept in this.concepts {
			if concept.name == name {
				return Some(WeakPtr!<Concept>(concept));
			}
		}

		return None;
	}

	func collectTypes(this: &Program) -> Set!<TypeRef> {
		var result: Set!<TypeRef>;

		for module in this.modules {
			for type in module.types {
				if !type.isIncompleteTemplate() {
					result.add(type.getRef());
				}
			}
		}

		return result;
	}

	func collectFunctions(this: &Program) -> Set!<FunctionRef> {
		var result: Set!<FunctionRef>;

		for module in this.modules {
			for function in module.functions {
				if !function.isIncompleteTemplate() {
					result.add(function.getRef());
				}
			}

			for type in module.types {
				for function in type.member_functions {
					if !function.isIncompleteTemplate() {
						result.add(function.getRef());
					}
				}
			}
		}

		return result;
	}
}

struct Module {
	var id: uint;
	var name: String;
	var program: &&Program;

	var path: String;
	var source: String;
	var line_spans: List!<Span>;
	var syntax_tree: ParsedModule;

	var namespace: List!<String>;
	var imports: List!<uint>;

	var types: List!<SharedPtr!<TypeDecl>>;
	var types_by_name: Map!<String, List!<TypeRef>>;

	var functions: List!<SharedPtr!<FunctionDecl>>;
	var functions_by_name: Map!<String, List!<FunctionRef>>;

	func constructor(this: &&Module, id: uint, name: String, program: &&Program, path: String, source: String) -> void {
		this.id := id;
		this.name := name;
		this.program := &&program;
		this.path := path;
		this.source := source;
		this.namespace := this.name.split('/'b);
	}

	func constructor(this: &&Module, other: Module) -> void = default;
	func destructor(this: &&Module) -> void = default;

	operator ==(this: Module, other: Module) -> bool {
		return this.id == other.id;
	}

	func getHandle(this: &Module) -> SharedPtr!<Module> {
		return this.program.modules[this.id];
	}

	func getWeakHandle(this: &Module) -> WeakPtr!<Module> {
		return WeakPtr!<Module>(this.getHandle());
	}

	func dump(this: &Module, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("Module", is_last);
		out.attribute(this.name);
		out.value(format(this.id));

		out.push("Imports", this.types.isEmpty() && this.functions.isEmpty());

		var imports: String;
		var first = true;
		for id in this.imports {
			if !first {
				imports += ", ";
			}

			imports += format(id);

			first = false;
		}

		out.value("[" + imports + "]");
		out.pop();

		var contains_free_functions = false;
		var last_free_function_index = 0u;
		for i in 0u..this.functions.size() {
			if this.functions[i].isFreeFunction() {
				contains_free_functions = true;
				last_free_function_index = i;
			}
		}

		for i in 0u..this.types.size() {
			this.types[i].dump(&&out, (i == this.types.size() - 1) && !contains_free_functions);
		}

		for i in 0u..this.functions.size() {
			if !this.functions[i].isFreeFunction() {
				continue;
			}

			this.functions[i].dump(&&out, i == last_free_function_index);
		}

		out.pop();
	}

	func dumpImportTree(this: &Module, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("Module", is_last);
		out.attribute(this.name);
		out.value(format(this.id));

		for i in 0u..this.imports.size() {
			const other = this.program.modules[this.imports[i]];
			other.dumpImportTree(&&out, i == this.imports.size() - 1);
		}

		out.pop();
	}

	func createType(this: &&Module, name: String, body: TypeBody) -> TypeRef {
		const id = this.types.size();
		var decl = SharedPtr!<TypeDecl>::new(TypeDecl(Span(this.id as u16), id, name, this.getWeakHandle()));
		this.types.append(decl);

		decl.namespace = this.namespace;
		decl.body = body;

		const ref = TypeRef(WeakPtr!<TypeDecl>(decl), ReferenceKind::None);
		this.types_by_name[name].append(ref);
		return ref;
	}

	func createFunction(this: &&Module, name: String) -> FunctionRef {
		const id = this.functions.size();
		var decl = SharedPtr!<FunctionDecl>::new(FunctionDecl(Span(this.id as u16), id, name, this.getWeakHandle()));
		this.functions.append(decl);

		decl.namespace = this.namespace;

		const ref = FunctionRef(WeakPtr!<FunctionDecl>(decl));
		this.functions_by_name[name].append(ref);
		return ref;
	}

	func createFunction(this: &&Module, name: String, parameter_types: List!<TypeRef>, return_type: TypeRef, body: FunctionBody) -> FunctionRef {
		const f = this.createFunction(name);
		if var decl = f.lock() {
			decl.parameter_types = List!<TypeRef>(parameter_types);
			decl.return_type = return_type;
			decl.body = body;
		}

		return f;
	}

	func createFunction(this: &&Module, name: String, parameter_types: List!<TypeRef>, return_type: TypeRef, builtin: BuiltinFunction) -> FunctionRef {
		return this.createFunction(name, parameter_types, return_type, FunctionBody::Builtin(builtin));
	}

	func createFunction(this: &&Module, name: String, parameter_types: List!<TypeRef>, return_type: TypeRef, builtin: InlineBuiltinFunction) -> FunctionRef {
		return this.createFunction(name, parameter_types, return_type, FunctionBody::InlineBuiltin(builtin));
	}

	func getTypeByName(this: &&Module, namespace: List!<String>, name: String) -> List!<TypeRef> {
		var result: List!<TypeRef>;

		for id in this.imports + this.id {
			var module = this.program.modules[id];

			if !module.namespace.endsWith(namespace.range()) {
				continue;
			}

			result.append(module.types_by_name[name]);
		}

		return result;
	}

	func getFunctionsByName(this: &&Module, namespace: List!<String>, name: String, parent_type: TypeRef) -> List!<FunctionRef> {
		var result: List!<FunctionRef>;

		for id in this.imports + this.id {
			var module = this.program.modules[id];
			if !module.functions_by_name.contains(name) {
				continue;
			}

			for function in module.functions_by_name[name] {
				const function_decl = function.lock().value();
				if function_decl.namespace.endsWith(namespace.range()) {
					result.append(function);
				}
			}
		}

		if var type = parent_type.lock() {
			if type.member_functions_by_name.contains(name) {
				for function in type.member_functions_by_name[name] {
					const function_decl = function.lock().value();
					if function_decl.namespace.endsWith(namespace.range()) && !result.contains(function) {
						result.append(function);
					}
				}
			}
		}

		return result;
	}

	func getTypeDecl(this: &Module, name: String, template_parameters: List!<TemplateParameterDecl>) -> Optional!<SharedPtr!<TypeDecl>> {
		for type in this.types {
			if type.name != name {
				continue;
			}

			if type.template_parameters != template_parameters {
				continue;
			}

			return Some(type);
		}

		return None;
	}
}

variant TemplateParameter {
	case Type: TypeRef;
	case Integer: int;
	case Garbage;

	func toString(this: TemplateParameter) -> String {
		match this {
			case Type: t -> return t.signature();
			case Integer: i -> return format(i);
			case Garbage -> return "<garbage>";
		}
	}
}

variant Concept {
	var name: String;

	case Any;
	case IntLiteral: TypeRef; // for template parameters, that accept int literals

	func dump(this: &Concept, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("Concept", is_last);
		out.attribute(this.name);

		match this {
			case IntLiteral: type -> out.value(type.signature());
			else -> {}
		}

		out.pop();
	}
}

struct TemplateParameterDecl {
	var name: String;

	var concept: WeakPtr!<Concept>;
	var is_variadic: bool;

	var value: Optional!<TemplateParameter>;

	func constructor(this: &&TemplateParameterDecl, name: String, concept: WeakPtr!<Concept>, is_variadic: bool) -> void {
		this.name := name;
		this.concept := concept;
		this.is_variadic := is_variadic;
		this.value := None;
	}

	func constructor(this: &&TemplateParameterDecl, name: String, concept: WeakPtr!<Concept>, is_variadic: bool, value: TemplateParameter) -> void {
		this.name := name;
		this.concept := concept;
		this.is_variadic := is_variadic;
		this.value := Some(value);
	}

	func constructor(this: &&TemplateParameterDecl, other: TemplateParameterDecl) -> void = default;
	func destructor(this: &&TemplateParameterDecl) -> void = default;

	operator =(this: &&TemplateParameterDecl, other: TemplateParameterDecl) -> void = default;

	operator ==(this: TemplateParameterDecl, other: TemplateParameterDecl) -> bool = default;

	func signature(this: &TemplateParameterDecl) -> String {
		var result = this.name + ": ";
		result += ("..." if this.is_variadic else "") + this.concept.lock().value().name;
		if const value = this.value {
			result += " = " + value.toString();
		}
		return result;
	}

	func dump(this: &TemplateParameterDecl, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("TemplateParameterDecl", is_last);
		out.attribute(this.name);
		out.text(":");
		out.attribute(this.concept.lock().value().name);

		if const value = this.value {
			out.text(" =");
			out.value(value.toString());
		}

		out.pop();
	}
}

func format(template_parameters: List!<TemplateParameterDecl>) -> String {
	if template_parameters.isEmpty() {
		return "";
	}

	var result = "!<";
	for i in 0u..template_parameters.size() {
		if i != 0 {
			result += ", ";
		}

		result += template_parameters[i].signature();
	}

	return result + ">";
}

func format(types: List!<TypeRef>) -> String {
	var result = "(";
	for i in 0u..types.size() {
		if i != 0 {
			result += ", ";
		}

		result += types[i].signature();
	}

	return result + ")";
}

func isVariadic(template_parameters: &List!<TemplateParameterDecl>) -> bool {
	if template_parameters.isEmpty() {
		return false;
	}

	return template_parameters[template_parameters.size() - 1].is_variadic;
}

struct TypeDecl {
	var span: Span;
	var name_span: Span;

	var id: uint;
	var name: String;
	var namespace: List!<String>;
	var module: WeakPtr!<Module>;

	var template_parameters: List!<TemplateParameterDecl>;

	var member_functions: List!<SharedPtr!<FunctionDecl>>;
	var member_functions_by_name: Map!<String, List!<FunctionRef>>;

	var extensions: List!<ParsedStmt>;
	var body: TypeBody;

	var unwrapped_type: TypeRef;

	var default_constructor: FunctionRef;
	var copy_constructor: FunctionRef;
	var destructor: FunctionRef;
	var op_assign: FunctionRef;
	var op_equal: FunctionRef;
	var op_compare: FunctionRef;

	var contained_types: Set!<TypeRef>;

	// struct & variant
	var member_variables: List!<MemberVarDecl>;

	// enum & variant
	var id_type: TypeRef;

	// only enum
	var enum_cases: List!<EnumCaseDecl>;

	// only variant
	var variant_cases: List!<VariantCaseDecl>;

	func constructor(this: &&TypeDecl, span: Span, id: uint, name: String, module: WeakPtr!<Module>) -> void {
		this.span := span;
		this.name_span := 0u16;

		this.id := id;
		this.name := name;
		this.module := module;
	}

	func constructor(this: &&TypeDecl, other: TypeDecl) -> void = default;
	func destructor(this: &&TypeDecl) -> void = default;

	operator =(this: &&TypeDecl, other: TypeDecl) -> void = default;

	operator ==(this: TypeDecl, other: TypeDecl) -> bool {
		return this.id == other.id;
	}

	func getHandle(this: &TypeDecl) -> SharedPtr!<TypeDecl> {
		const module = this.module.lock().value();
		return module.types[this.id];
	}

	func getWeakHandle(this: &TypeDecl) -> WeakPtr!<TypeDecl> {
		return WeakPtr!<TypeDecl>(this.getHandle());
	}

	func getRef(this: &TypeDecl) -> TypeRef {
		return TypeRef(this.getWeakHandle(), ReferenceKind::None);
	}

	func getModuleRef(this: &TypeDecl) -> &&Module {
		var module = this.module.lock().value();
		return &&module.operator unwrap();
	}

	func getProgramRef(this: &TypeDecl) -> &&Program {
		return &&this.getModuleRef().program;
	}

	func dump(this: &TypeDecl, out: &&TreeFormatter, is_last: bool) -> void {
		match this.body {
			case Empty -> out.push("EmptyTypeDecl", is_last);
			case Void -> out.push("VoidTypeDecl", is_last);
			case Bool -> out.push("BoolTypeDecl", is_last);
			case Byte -> out.push("ByteTypeDecl", is_last);
			case Int: size -> {
				out.push("IntTypeDecl", is_last);
				out.value(format(size));
			}
			case UInt: size -> {
				out.push("UIntTypeDecl", is_last);
				out.value(format(size));
			}
			case Float: size -> {
				out.push("FloatTypeDecl", is_last);
				out.value(format(size));
			}
			case Pointer: pointer_type -> {
				out.push("PointerTypeDecl", is_last);
				out.attribute("const" if pointer_type.is_const else "var");
				out.value(pointer_type.base_type.signature());
			}
			case Array: array_type -> {
				out.push("ArrayTypeDecl", is_last);
			}
			case Enum -> {
				out.push("EnumTypeDecl", is_last);
			}
			case Struct -> {
				out.push("StructTypeDecl", is_last);
			}
			case Variant -> {
				out.push("VariantTypeDecl", is_last);
			}
			case Unchecked -> {
				out.push("UncheckedTypeDecl", is_last);
			}
		}

		out.attribute(this.signature());

		for parameter in this.template_parameters {
			parameter.dump(&&out, false);
		}

		for i in 0u..this.member_functions.size() {
			this.member_functions[i].dump(&&out, i == this.member_functions.size() - 1);
		}

		for i in 0u..this.member_variables.size() {
			this.member_variables[i].dump(&&out, i == this.member_variables.size() - 1);
		}

		for i in 0u..this.enum_cases.size() {
			this.enum_cases[i].dump(&&out, i == this.enum_cases.size() - 1);
		}

		for i in 0u..this.variant_cases.size() {
			this.variant_cases[i].dump(&&out, i == this.variant_cases.size() - 1);
		}

		out.pop();
	}

	func createMemberFunction(this: &&TypeDecl, name: String) -> FunctionRef {
		var module = this.module.lock().value();

		const id = module.functions.size();
		var decl = SharedPtr!<FunctionDecl>::new(FunctionDecl(Span(this.span.module), id, name, module.getWeakHandle()));

		module.functions.append(decl);
		this.member_functions.append(decl);

		decl.namespace = this.namespace + this.name;
		decl.parent_type = TypeRef(this.getWeakHandle(), ReferenceKind::None);

		const ref = FunctionRef(WeakPtr!<FunctionDecl>(decl));
		module.functions_by_name[name].append(ref);
		this.member_functions_by_name[name].append(ref);
		return ref;
	}

	func createMemberFunction(this: &&TypeDecl, name: String, parameter_types: List!<TypeRef>, return_type: TypeRef) -> FunctionRef {
		const f = this.createMemberFunction(name);
		if var decl = f.lock() {
			decl.parameter_types = parameter_types;
			decl.return_type = return_type;
		}

		return f;
	}

	func createMemberFunction(this: &&TypeDecl, name: String, parameter_types: List!<TypeRef>, return_type: TypeRef, body: FunctionBody) -> FunctionRef {
		const f = this.createMemberFunction(name);
		if var decl = f.lock() {
			decl.parameter_types = parameter_types;
			decl.return_type = return_type;
			decl.body = body;
		}

		return f;
	}

	func createMemberFunction(this: &&TypeDecl, name: String, parameter_types: List!<TypeRef>, return_type: TypeRef, builtin: BuiltinFunction) -> FunctionRef {
		return this.createMemberFunction(name, parameter_types, return_type, FunctionBody::Builtin(builtin));
	}

	func createMemberFunction(this: &&TypeDecl, name: String, parameter_types: List!<TypeRef>, return_type: TypeRef, builtin: InlineBuiltinFunction) -> FunctionRef {
		return this.createMemberFunction(name, parameter_types, return_type, FunctionBody::InlineBuiltin(builtin));
	}

	func signature(this: &TypeDecl) -> String {
		return "::".join(this.namespace) + "::" + this.name + this.template_parameters.format();
	}

	func isIncompleteTemplate(this: &TypeDecl) -> bool {
		for parameter in this.template_parameters {
			if parameter.value is None {
				return true;
			}
		}

		return false;
	}

	func addContainedType(this: &&TypeDecl, type: TypeRef) -> void {
		if type.isUnknown() {
			return;
		}

		if type.kind == ReferenceKind::None {
			this.contained_types.add(type);
		}
	}

	func getMemberVariable(this: &TypeDecl, name: String) -> Optional!<MemberVarDecl> {
		for v in this.member_variables {
			if v.name == name {
				return Some(v);
			}
		}

		return None;
	}

	func getNextCaseId(this: &TypeDecl) -> int {
		if this.body is Enum {
			if const prev_case = this.enum_cases.last() {
				return prev_case.id + 1;
			}
		} else if this.body is Variant {
			if const prev_case = this.variant_cases.last() {
				return prev_case.id + 1;
			}
		}
		return 0;
	}

	func createEnumCase(this: &&TypeDecl, span: Span, id: int, name: String) -> void {
		this.enum_cases.append(EnumCaseDecl(span, id, name));
	}

	func getEnumCase(this: &TypeDecl, name: String) -> Optional!<EnumCaseDecl> {
		for c in this.enum_cases {
			if c.name == name {
				return Some(c);
			}
		}

		return None;
	}

	func createVariantCase(this: &&TypeDecl, span: Span, id: int, name: String, payload: TypeRef) -> void {
		this.variant_cases.append(VariantCaseDecl(span, id, name, payload));
	}

	func getVariantCase(this: &TypeDecl, name: String) -> Optional!<VariantCaseDecl> {
		for c in this.variant_cases {
			if c.name == name {
				return Some(c);
			}
		}

		return None;
	}

	func getVariantCase(this: &TypeDecl, id: int) -> Optional!<VariantCaseDecl> {
		for c in this.variant_cases {
			if c.id == id {
				return Some(c);
			}
		}

		return None;
	}

	func createDefaultFunctions(this: &&TypeDecl) {
		const module = this.module.lock().value();
		const type = this.getRef();

		if this.body is Enum || this.body is Variant {
			if this.copy_constructor.isUnknown() {
				var parameter_types: List!<TypeRef>;
				parameter_types.append(type.varRef());
				parameter_types.append(type);

				this.copy_constructor = this.createMemberFunction("constructor", parameter_types, module.program.void_type);
				var func_decl = this.copy_constructor.lock().value();
				func_decl.signature_span = this.name_span;
				func_decl.body = func_decl.getDefaultFunctionBody();
			}

			if this.destructor.isUnknown() {
				var parameter_types: List!<TypeRef>;
				parameter_types.append(type.varRef());

				this.destructor = this.createMemberFunction("destructor", parameter_types, module.program.void_type);
				var func_decl = this.destructor.lock().value();
				func_decl.signature_span = this.name_span;
				func_decl.body = func_decl.getDefaultFunctionBody();
			}

			if this.op_assign.isUnknown() {
				var parameter_types: List!<TypeRef>;
				parameter_types.append(type.varRef());
				parameter_types.append(type);

				this.op_assign = this.createMemberFunction("operator =", parameter_types, module.program.void_type);
				var func_decl = this.op_assign.lock().value();
				func_decl.signature_span = this.name_span;
				func_decl.body = func_decl.getDefaultFunctionBody();
			}

			if this.op_equal.isUnknown() {
				var parameter_types: List!<TypeRef>;
				parameter_types.append(type);
				parameter_types.append(type);

				this.op_equal = this.createMemberFunction("operator ==", parameter_types, module.program.bool_type);
				var func_decl = this.op_equal.lock().value();
				func_decl.signature_span = this.name_span;
				func_decl.body = func_decl.getDefaultFunctionBody();
			}
		}

		if this.body is Enum && this.op_compare.isUnknown() {
			var parameter_types: List!<TypeRef>;
			parameter_types.append(type);
			parameter_types.append(type);

			this.op_compare = this.createMemberFunction("operator <=>", parameter_types, module.program.int_type);
			var func_decl = this.op_compare.lock().value();
			func_decl.signature_span = this.name_span;
			func_decl.body = func_decl.getDefaultFunctionBody();
		}
	}

	func createVariantCaseConstructor(this: &&TypeDecl, case_id: int, payload: TypeRef) -> void {
		var parameter_types: List!<TypeRef>;
		parameter_types.append(this.getRef().varRef());

		var module = this.module.lock().value();

		if !payload.isUnknown() && payload != module.program.void_type {
			parameter_types.append(payload);
		}

		for member_variable in this.member_variables {
			parameter_types.append(member_variable.type);
		}

		var constructor = this.createMemberFunction(
			"constructor",
			parameter_types,
			module.program.void_type,
			FunctionBody::Builtin(BuiltinFunction::VariantCaseConstructor(case_id, this.getRef()))
		).lock().value();

		constructor.template_parameters.append(
			TemplateParameterDecl("Id", module.program.int_concept, false, TemplateParameter::Integer(case_id))
		);
	}

	func createVariantOpUnsafeAs(this: &&TypeDecl, this_type: TypeRef, case_id: int) -> void {
		var operator_as_parameter_types: List!<TypeRef>;
		operator_as_parameter_types.append(this_type);

		var case_decl = this.getVariantCase(case_id).value();
		var result_type = case_decl.type;
		if result_type.kind == ReferenceKind::None {
			result_type.kind = this_type.kind;
		}

		var operator_as = this.createMemberFunction(
			"operator unsafe as",
			operator_as_parameter_types,
			result_type,
			FunctionBody::InlineBuiltin(InlineBuiltinFunction::VariantOpUnsafeAs(case_id, this.getRef()))
		).lock().value();

		var module = this.module.lock().value();

		operator_as.template_parameters.append(
			TemplateParameterDecl("Id", module.program.int_concept, false, TemplateParameter::Integer(case_id))
		);
	}
}

struct TypeRef {
	var decl: WeakPtr!<TypeDecl>;
	var kind: ReferenceKind;

	func constructor(this: &&TypeRef, decl: WeakPtr!<TypeDecl>, kind: ReferenceKind) -> void {
		this.decl := decl;
		this.kind := kind;
	}

	func constructor(this: &&TypeRef) -> void = default;
	func constructor(this: &&TypeRef, other: TypeRef) -> void = default;
	func destructor(this: &&TypeRef) -> void = default;

	operator =(this: &&TypeRef, other: TypeRef) -> void = default;

	func unknown() -> TypeRef {
		return TypeRef(WeakPtr!<TypeDecl>(), ReferenceKind::None);
	}

	operator ==(this: TypeRef, other: TypeRef) -> bool {
		if this.decl.data != other.decl.data {
			return false;
		} else {
			return this.kind == other.kind;
		}
	}

	operator <=>(this: TypeRef, other: TypeRef) -> int {
		if this.decl.data != other.decl.data {
			return this.decl.data <=> other.decl.data;
		} else {
			return this.kind <=> other.kind;
		}
	}

	func hasSameBaseTypeAs(this: &TypeRef, other: TypeRef) -> bool {
		return this.decl == other.decl;
	}

	func isUnknown(this: &TypeRef) -> bool {
		return this.decl.data == vptr::null();
	}

	func isAlive(this: &TypeRef) -> bool {
		return this.decl.isAlive();
	}

	func lock(this: &TypeRef) -> Optional!<SharedPtr!<TypeDecl>> {
		return this.decl.lock();
	}

	func signature(this: &TypeRef) -> String {
		match this.decl.lock() {
			case Some: decl -> return this.kind.toString() + decl.signature();
			case None -> return "unknown";
		}
	}

	func base(this: &TypeRef) -> TypeRef {
		return TypeRef(this.decl, ReferenceKind::None);
	}

	func constRef(this: &TypeRef) -> TypeRef {
		return TypeRef(this.decl, ReferenceKind::Const);
	}

	func varRef(this: &TypeRef) -> TypeRef {
		return TypeRef(this.decl, ReferenceKind::Var);
	}

	func isIncompleteTemplate(this: &TypeRef) -> bool {
		const decl = this.lock() else {
			return false;
		}

		return decl.isIncompleteTemplate();
	}

	func isIntType(this: &TypeRef) -> bool {
		const decl = this.lock() else {
			return false;
		}

		match decl.body {
			case Bool
			| Byte
			| Int
			| UInt
			| Enum -> return true;
			else -> return false;
		}
	}

	func isSigned(this: &TypeRef) -> bool {
		const decl = this.lock() else {
			return false;
		}

		match decl.body {
			case Int
			| Float -> return true;
			else -> return false;
		}
	}

	func isFloatType(this: &TypeRef) -> bool {
		const decl = this.lock() else {
			return false;
		}

		match decl.body {
			case Float -> return true;
			else -> return false;
		}
	}

	func isPtrType(this: &TypeRef) -> bool {
		const decl = this.lock() else {
			return false;
		}

		match decl.body {
			case Pointer -> return true;
			else -> return false;
		}
	}

	func isConstPtrType(this: &TypeRef) -> bool {
		const decl = this.lock() else {
			return false;
		}

		match decl.body {
			case Pointer: pointer_type -> return pointer_type.is_const;
			else -> return false;
		}
	}

	func isPrimitive(this: &TypeRef) -> bool {
		const decl = this.lock() else {
			return false;
		}

		if this.kind != ReferenceKind::None {
			return true; // reference types are always primitive
		}

		match decl.body {
			case Void
			| Bool
			| Byte
			| Int
			| UInt
			| Float
			| Pointer
			| Enum -> return true;
			else -> return false;
		}
	}

	func isVariant(this: &TypeRef) -> bool {
		const decl = this.lock() else {
			return false;
		}

		match decl.body {
			case Variant -> return true;
			else -> return false;
		}
	}

	func getMemberFunctionsByName(this: &TypeRef, name: String) -> List!<FunctionRef> {
		var result: List!<FunctionRef>;

		const decl = this.lock() else {
			return result;
		}

		for function in decl.member_functions {
			if function.name == name {
				result.append(function.getRef());
			}
		}

		return result;
	}
}

struct FunctionDecl {
	var span: Span;
	var signature_span: Span;

	var id: uint;
	var name: String;
	var namespace: List!<String>;
	var module: WeakPtr!<Module>;

	var extern_name: String;

	var parent_type: TypeRef;

	var template_parameters: List!<TemplateParameterDecl>;

	var parameter_types: List!<TypeRef>;
	var return_type: TypeRef;

	var body: FunctionBody;

	var variables: List!<SharedPtr!<VarDecl>>;
	var parameters: List!<SharedPtr!<VarDecl>>;

	func constructor(this: &&FunctionDecl, span: Span, id: uint, name: String, module: WeakPtr!<Module>) -> void {
		this.span := span;
		this.signature_span := span;
		this.id := id;
		this.name := name;
		this.module := module;
	}

	func constructor(this: &&FunctionDecl, other: FunctionDecl) -> void = default;
	func destructor(this: &&FunctionDecl) -> void = default;

	operator =(this: &&FunctionDecl, other: FunctionDecl) -> void = default;

	operator ==(this: FunctionDecl, other: FunctionDecl) -> bool {
		return this.id == other.id;
	}

	func getHandle(this: &FunctionDecl) -> SharedPtr!<FunctionDecl> {
		const module = this.module.lock().value();
		return module.functions[this.id];
	}

	func getWeakHandle(this: &FunctionDecl) -> WeakPtr!<FunctionDecl> {
		return WeakPtr!<FunctionDecl>(this.getHandle());
	}

	func getRef(this: &FunctionDecl) -> FunctionRef {
		return FunctionRef(this.getWeakHandle());
	}

	func getModuleRef(this: &FunctionDecl) -> &&Module {
		var module = this.module.lock().value();
		return &&module.operator unwrap();
	}

	func getProgramRef(this: &FunctionDecl) -> &&Program {
		return &&this.getModuleRef().program;
	}

	func isFreeFunction(this: &FunctionDecl) -> bool {
		return this.parent_type.isUnknown();
	}

	func dump(this: &FunctionDecl, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("FunctionDecl", is_last);

		out.attribute(this.signature());

		for parameter in this.template_parameters {
			parameter.dump(&&out, false);
		}

		for variable in this.variables {
			if variable.is_parameter {
				variable.dump(&&out, false);
			}
		}

		this.body.dump(&&out, true);

		out.pop();
	}

	func signature(this: &FunctionDecl) -> String {
		var result = "::".join(this.namespace);
		if const parent_type = this.parent_type.lock() {
			result = parent_type.signature();
		}

		result += "::" + this.name + this.template_parameters.format();
		result += "(";

		for i in 0u..this.parameter_types.size() {
			if i != 0 {
				result += ", ";
			}
			result += this.parameter_types[i].signature();
		}

		result += ") -> " + this.return_type.signature();
		return result;
	}

	func createParameter(this: &&FunctionDecl, span: Span, name: String, type: TypeRef) -> void {
		const decl = SharedPtr!<VarDecl>::new(VarDecl(span, this.variables.size(), name, type, type.kind != ReferenceKind::Var, true));
		this.variables.append(decl);
		this.parameters.append(decl);
	}

	func createVariable(this: &&FunctionDecl, span: Span, name: String, type: TypeRef, is_const: bool) -> WeakPtr!<VarDecl> {
		const decl = SharedPtr!<VarDecl>::new(VarDecl(span, this.variables.size(), name, type, is_const, false));
		this.variables.append(decl);
		return WeakPtr!<VarDecl>(decl);
	}

	func isIncompleteTemplate(this: &FunctionDecl) -> bool {
		for parameter in this.template_parameters {
			if parameter.value is None {
				return true;
			}
		}

		return false;
	}

	func getParsedSignature(this: &FunctionDecl) -> Optional!<ParsedFunctionSignature> {
		if const parsed_function = this.body as Unchecked {
			return Some(parsed_function.signature);
		}

		return None;
	}

	func isCopyConstructor(this: &FunctionDecl) -> bool {
		if const parent_type = this.parent_type.lock() {
			return parent_type.copy_constructor == this.getRef();
		}

		return false;
	}

	func getDefaultFunctionBody(this: &FunctionDecl) -> FunctionBody {
		const parent_type = this.parent_type;
		const parent_type_decl = parent_type.lock() else {
			return FunctionBody::Empty;
		}

		if this.name == "constructor" && this.parameter_types.size() == 1 {
			if this.parameter_types[0u] == parent_type.varRef() {
				match parent_type_decl.body {
					case Struct -> return FunctionBody::Builtin(BuiltinFunction::StructDefaultConstructor(parent_type));
					else -> {}
				}
			}
		} else if this.name == "constructor" && this.parameter_types.size() == 2 {
			if this.parameter_types[0u] == parent_type.varRef() && this.parameter_types[1u] == parent_type {
				match parent_type_decl.body {
					case Struct -> return FunctionBody::Builtin(BuiltinFunction::StructCopyConstructor(parent_type));
					case Enum -> return FunctionBody::InlineBuiltin(InlineBuiltinFunction::BitStoreValue(parent_type));
					case Variant -> return FunctionBody::Builtin(BuiltinFunction::VariantCopyConstructor(parent_type));
					else -> {}
				}
			}
		} else if this.name == "destructor" && this.parameter_types.size() == 1 {
			if this.parameter_types[0u] == parent_type.varRef() {
				match parent_type_decl.body {
					case Struct -> return FunctionBody::Builtin(BuiltinFunction::StructDestructor(parent_type));
					case Enum -> return FunctionBody::InlineBuiltin(InlineBuiltinFunction::NoOp(parent_type));
					case Variant -> return FunctionBody::Builtin(BuiltinFunction::VariantDestructor(parent_type));
					else -> {}
				}
			}
		} else if this.name == "operator =" && this.parameter_types.size() == 2 {
			if this.parameter_types[0u] == parent_type.varRef() && this.parameter_types[1u] == parent_type {
				match parent_type_decl.body {
					case Struct -> return FunctionBody::Builtin(BuiltinFunction::StructOpAssign(parent_type));
					case Enum -> return FunctionBody::InlineBuiltin(InlineBuiltinFunction::BitStoreValue(parent_type));
					case Variant -> return FunctionBody::Builtin(BuiltinFunction::VariantOpAssign(parent_type));
					else -> {}
				}
			}
		} else if this.name == "operator ==" && this.parameter_types.size() == 2 {
			if this.parameter_types[0u] == parent_type && this.parameter_types[1u] == parent_type {
				match parent_type_decl.body {
					case Struct -> return FunctionBody::Builtin(BuiltinFunction::StructOpEqual(parent_type));
					case Enum -> return FunctionBody::InlineBuiltin(InlineBuiltinFunction::BitOpEQ(parent_type));
					case Variant -> return FunctionBody::Builtin(BuiltinFunction::VariantOpEqual(parent_type));
					else -> {}
				}
			}
		} else if this.name == "operator <=>" && this.parameter_types.size() == 2 {
			if this.parameter_types[0u] == parent_type && this.parameter_types[1u] == parent_type {
				match parent_type_decl.body {
					case Struct -> return FunctionBody::Builtin(BuiltinFunction::StructOpCmp(parent_type));
					case Enum -> return FunctionBody::InlineBuiltin(InlineBuiltinFunction::UIntOpCmp(parent_type));
					else -> {}
				}
			}
		} else if this.name == "operator &" && this.parameter_types.size() == 2 {
			if this.parameter_types[0u] == parent_type && this.parameter_types[1u] == parent_type {
				match parent_type_decl.body {
					case Enum -> return FunctionBody::InlineBuiltin(InlineBuiltinFunction::BitOpAnd(parent_type));
					else -> {}
				}
			}
		} else if this.name == "operator |" && this.parameter_types.size() == 2 {
			if this.parameter_types[0u] == parent_type && this.parameter_types[1u] == parent_type {
				match parent_type_decl.body {
					case Enum -> return FunctionBody::InlineBuiltin(InlineBuiltinFunction::BitOpOr(parent_type));
					else -> {}
				}
			}
		} else if this.name == "operator &=" && this.parameter_types.size() == 2 {
			if this.parameter_types[0u] == parent_type.varRef() && this.parameter_types[1u] == parent_type {
				match parent_type_decl.body {
					case Enum -> return FunctionBody::InlineBuiltin(InlineBuiltinFunction::BitOpAndAssign(parent_type));
					else -> {}
				}
			}
		} else if this.name == "operator |=" && this.parameter_types.size() == 2 {
			if this.parameter_types[0u] == parent_type.varRef() && this.parameter_types[1u] == parent_type {
				match parent_type_decl.body {
					case Enum -> return FunctionBody::InlineBuiltin(InlineBuiltinFunction::BitOpOrAssign(parent_type));
					else -> {}
				}
			}
		}

		return FunctionBody::Empty;
	}
}

struct FunctionRef {
	var decl: WeakPtr!<FunctionDecl>;

	func constructor(this: &&FunctionRef, decl: WeakPtr!<FunctionDecl>) -> void {
		this.decl := decl;
	}

	func constructor(this: &&FunctionRef) -> void = default;
	func constructor(this: &&FunctionRef, other: FunctionRef) -> void = default;
	func destructor(this: &&FunctionRef) -> void = default;

	operator =(this: &&FunctionRef, other: FunctionRef) -> void = default;

	func unknown() -> FunctionRef {
		return FunctionRef(WeakPtr!<FunctionDecl>());
	}

	operator ==(this: FunctionRef, other: FunctionRef) -> bool {
		return this.decl.data == other.decl.data;
	}

	operator <=>(this: FunctionRef, other: FunctionRef) -> int {
		return this.decl.data <=> other.decl.data;
	}

	func isUnknown(this: &FunctionRef) -> bool {
		return this.decl.data == vptr::null();
	}

	func isAlive(this: &FunctionRef) -> bool {
		return this.decl.isAlive();
	}

	func lock(this: &FunctionRef) -> Optional!<SharedPtr!<FunctionDecl>> {
		return this.decl.lock();
	}

	func signature(this: &FunctionRef) -> String {
		match this.decl.lock() {
			case Some: decl -> return decl.signature();
			case None -> return "unknown()";
		}
	}

	func isIncompleteTemplate(this: &FunctionRef) -> bool {
		const decl = this.lock() else {
			return false;
		}

		return decl.isIncompleteTemplate();
	}
}

variant TypeBody {
	case Empty;

	case Void;
	case Bool;
	case Byte;

	// size in bits attached, 0 -> pointer sized
	case Int: uint;
	case UInt: uint;

	// size in bits attached
	case Float: uint;

	case Pointer: PointerType;
	case Array: ArrayType;

	case Struct;
	case Enum;
	case Variant;

	case Unchecked: ParsedTypeDecl;

	func constructor(this: &&TypeBody) -> void {
		this.constructor!<0>();
	}
}

struct PointerType {
	var base_type: TypeRef;
	var is_const: bool;

	func constructor(this: &&PointerType, is_const: bool) -> void {
		this.is_const := is_const;
	}

	func constructor(this: &&PointerType, base_type: TypeRef, is_const: bool) -> void {
		this.base_type := base_type;
		this.is_const := is_const;
	}

	func constructor(this: &&PointerType, other: PointerType) -> void = default;
	func destructor(this: &&PointerType) -> void = default;

	operator =(this: &&PointerType, other: PointerType) -> void = default;
	operator ==(this: PointerType, other: PointerType) -> bool = default;

	func isOpaque(this: PointerType) -> bool {
		return this.base_type.isUnknown();
	}
}

struct ArrayType {
	var element_type: TypeRef;
	var size: uint;

	func constructor(this: &&ArrayType, element_type: TypeRef, size: uint) -> void {
		this.element_type := element_type;
		this.size := size;
	}

	func constructor(this: &&ArrayType, other: ArrayType) -> void = default;
	func destructor(this: &&ArrayType) -> void = default;

	operator =(this: &&ArrayType, other: ArrayType) -> void = default;
	operator ==(this: ArrayType, other: ArrayType) -> bool = default;
}

struct MemberVarDecl {
	var span: Span;

	var id: uint;
	var name: String;
	var type: TypeRef;

	var initializer: Expr;

	func constructor(this: &&MemberVarDecl, span: Span, id: uint, name: String, type: TypeRef, initializer: Expr) -> void {
		this.span := span;

		this.id := id;
		this.name := name;
		this.type := type;

		this.initializer := initializer;
	}

	func constructor(this: &&MemberVarDecl, other: MemberVarDecl) -> void = default;
	func destructor(this: &&MemberVarDecl) -> void = default;

	operator =(this: &&MemberVarDecl, other: MemberVarDecl) -> void = default;

	operator ==(this: MemberVarDecl, other: MemberVarDecl) -> bool {
		return this.id == other.id;
	}

	operator <=>(this: MemberVarDecl, other: MemberVarDecl) -> int {
		return this.id <=> other.id;
	}

	func dump(this: &MemberVarDecl, out: &&TreeFormatter, is_last: bool) -> void {}
}

struct EnumCaseDecl {
	var span: Span;

	var id: int;
	var name: String;

	func constructor(this: &&EnumCaseDecl, span: Span, id: int, name: String) -> void {
		this.span := span;
		this.id := id;
		this.name := name;
	}

	func constructor(this: &&EnumCaseDecl, other: EnumCaseDecl) -> void = default;
	func destructor(this: &&EnumCaseDecl) -> void = default;

	operator =(this: &&EnumCaseDecl, other: EnumCaseDecl) -> void = default;

	operator ==(this: EnumCaseDecl, other: EnumCaseDecl) -> bool {
		return this.id == other.id;
	}

	operator <=>(this: EnumCaseDecl, other: EnumCaseDecl) -> int {
		return this.id <=> other.id;
	}

	func dump(this: &EnumCaseDecl, out: &&TreeFormatter, is_last: bool) -> void {}
}

struct VariantCaseDecl {
	var span: Span;

	var id: int;
	var name: String;
	var type: TypeRef;

	func constructor(this: &&VariantCaseDecl, span: Span, id: int, name: String, type: TypeRef) -> void {
		this.span := span;
		this.id := id;
		this.name := name;
		this.type := type;
	}

	func constructor(this: &&VariantCaseDecl, other: VariantCaseDecl) -> void = default;
	func destructor(this: &&VariantCaseDecl) -> void = default;

	operator =(this: &&VariantCaseDecl, other: VariantCaseDecl) -> void = default;

	operator ==(this: VariantCaseDecl, other: VariantCaseDecl) -> bool {
		return this.id == other.id;
	}

	operator <=>(this: VariantCaseDecl, other: VariantCaseDecl) -> int {
		return this.id <=> other.id;
	}

	func dump(this: &VariantCaseDecl, out: &&TreeFormatter, is_last: bool) -> void {}
}

variant FunctionBody {
	case Empty;
	case Extern;
	case InlineBuiltin: InlineBuiltinFunction;
	case Builtin: BuiltinFunction;
	case Stmt: Stmt;
	case Unchecked: ParsedFunctionDecl;

	func constructor(this: &&FunctionBody) -> void {
		this.constructor!<0>();
	}

	func dump(this: &FunctionBody, out: &&TreeFormatter, is_last: bool) -> void {
		match this {
			case Empty -> {
				out.push("EmptyFunction", is_last);
				out.pop();
			}
			case Extern -> {
				out.push("ExternFunction", is_last);
				out.pop();
			}
			case InlineBuiltin: f -> {
				out.push("InlineBuiltinFunction", is_last);
				f.dump(&&out);
				out.pop();
			}
			case Builtin: f -> {
				out.push("BuiltinFunction", is_last);
				f.dump(&&out);
				out.pop();
			}
			case Stmt: stmt -> stmt.dump(&&out, is_last);
			case Unchecked -> {
				out.push("UncheckedFunction", is_last);
				out.pop();
			}
		}
	}
}

struct VarDecl {
	var span: Span;

	var id: uint;
	var name: String;
	var type: TypeRef;

	var is_const: bool;
	var is_parameter: bool;
	var is_unused: bool;

	var constructor_call: Expr;
	var destructor_call: Expr;

	func constructor(this: &&VarDecl, span: Span, id: uint, name: String, type: TypeRef, is_const: bool, is_parameter: bool) -> void {
		this.span := span;

		this.id := id;
		this.name := name;
		this.type := type;

		this.is_const := is_const;
		this.is_parameter := is_parameter;

		this.constructor_call := Expr::Empty(Span(0u16), TypeRef::unknown());
		this.destructor_call := Expr::Empty(Span(0u16), TypeRef::unknown());
	}

	func constructor(this: &&VarDecl, other: VarDecl) -> void = default;
	func destructor(this: &&VarDecl) -> void = default;

	operator =(this: &&VarDecl, other: VarDecl) -> void = default;

	operator ==(this: VarDecl, other: VarDecl) -> bool {
		return this.id == other.id;
	}

	operator <=>(this: VarDecl, other: VarDecl) -> int {
		return this.id <=> other.id;
	}

	func dump(this: &VarDecl, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("ParameterDecl" if this.is_parameter else "VarDecl", is_last);

		out.attribute(("#" if this.is_parameter else "") + this.name);
		out.value(format(this.id));
		out.text(" :");
		out.value(this.type.signature());
		out.value("const" if this.is_const else "var");
		out.span(this.span);

		this.constructor_call.dump(&&out, false);
		this.destructor_call.dump(&&out, true);

		out.pop();
	}
}

variant InlineBuiltinFunction {
	var base_type: TypeRef;

	case NoOp;

	case BitStoreNull;
	case BitStoreValue;

	case BitOpEQ;
	case BitOpNE;

	case BitOpAnd;
	case BitOpOr;
	case BitOpXOr;
	case BitOpNot;
	case BitOpShl;
	case BitOpLShr;
	case BitOpAShr;
	case BitOpAndAssign;
	case BitOpOrAssign;
	case BitOpXOrAssign;
	case BitOpShlAssign;
	case BitOpLShrAssign;
	case BitOpAShrAssign;

	case IntOpAdd;
	case IntOpSub;
	case IntOpMul;
	case IntOpNeg;
	case IntOpInc;
	case IntOpDec;

	case IntOpAddAssign;
	case IntOpSubAssign;
	case IntOpMulAssign;

	case SIntOpLT;
	case SIntOpLE;
	case SIntOpGT;
	case SIntOpGE;
	case SIntOpCmp;

	case SIntOpDiv;
	case SIntOpMod;

	case SIntOpDivAssign;
	case SIntOpModAssign;

	case UIntOpLT;
	case UIntOpLE;
	case UIntOpGT;
	case UIntOpGE;
	case UIntOpCmp;

	case UIntOpDiv;
	case UIntOpMod;

	case UIntOpDivAssign;
	case UIntOpModAssign;

	case FloatOpEQ;
	case FloatOpNE;
	case FloatOpLT;
	case FloatOpLE;
	case FloatOpGT;
	case FloatOpGE;
	case FloatOpCmp;

	case FloatOpAdd;
	case FloatOpSub;
	case FloatOpMul;
	case FloatOpDiv;
	case FloatOpMod;
	case FloatOpNeg;

	case FloatOpAddAssign;
	case FloatOpSubAssign;
	case FloatOpMulAssign;
	case FloatOpDivAssign;
	case FloatOpModAssign;

	case PointerGetNull;
	case PointerToRef;
	case RefToPointer;
	case PointerCast;

	case PointerDiff;
	case PointerOffset;
	case PointerOpIndex;

	// base type is source type, attached type target
	case IntCast: TypeRef;
	case FloatCast: TypeRef;
	case IntToFloat: TypeRef;
	case FloatToInt: TypeRef;

	// base type is first template parameter
	case SizeOf;
	case AlignmentOf;
	case ReferenceKindOf;

	// attached value is id of target case
	case VariantOpUnsafeAs: int;
	case VariantOpIs: int;

	case ArrayGetSize;
	case ArrayGetDataPointer;

	func name(this: &InlineBuiltinFunction) -> String {
		match this {
			case NoOp -> return "NoOp";
			case BitStoreNull -> return "BitStoreNull";
			case BitStoreValue -> return "BitStoreValue";
			case BitOpEQ -> return "BitOpEQ";
			case BitOpNE -> return "BitOpNE";
			case BitOpAnd -> return "BitOpAnd";
			case BitOpOr -> return "BitOpOr";
			case BitOpXOr -> return "BitOpXOr";
			case BitOpNot -> return "BitOpNot";
			case BitOpShl -> return "BitOpShl";
			case BitOpLShr -> return "BitOpLShr";
			case BitOpAShr -> return "BitOpAShr";
			case BitOpAndAssign -> return "BitOpAndAssign";
			case BitOpOrAssign -> return "BitOpOrAssign";
			case BitOpXOrAssign -> return "BitOpXOrAssign";
			case BitOpShlAssign -> return "BitOpShlAssign";
			case BitOpLShrAssign -> return "BitOpLShrAssign";
			case BitOpAShrAssign -> return "BitOpAShrAssign";
			case IntOpAdd -> return "IntOpAdd";
			case IntOpSub -> return "IntOpSub";
			case IntOpMul -> return "IntOpMul";
			case IntOpNeg -> return "IntOpNeg";
			case IntOpInc -> return "IntOpInc";
			case IntOpDec -> return "IntOpDec";
			case IntOpAddAssign -> return "IntOpAddAssign";
			case IntOpSubAssign -> return "IntOpSubAssign";
			case IntOpMulAssign -> return "IntOpMulAssign";
			case SIntOpLT -> return "SIntOpLT";
			case SIntOpLE -> return "SIntOpLE";
			case SIntOpGT -> return "SIntOpGT";
			case SIntOpGE -> return "SIntOpGE";
			case SIntOpCmp -> return "SIntOpCmp";
			case SIntOpDiv -> return "SIntOpDiv";
			case SIntOpMod -> return "SIntOpMod";
			case SIntOpDivAssign -> return "SIntOpDivAssign";
			case SIntOpModAssign -> return "SIntOpModAssign";
			case UIntOpLT -> return "UIntOpLT";
			case UIntOpLE -> return "UIntOpLE";
			case UIntOpGT -> return "UIntOpGT";
			case UIntOpGE -> return "UIntOpGE";
			case UIntOpCmp -> return "UIntOpCmp";
			case UIntOpDiv -> return "UIntOpDiv";
			case UIntOpMod -> return "UIntOpMod";
			case UIntOpDivAssign -> return "UIntOpDivAssign";
			case UIntOpModAssign -> return "UIntOpModAssign";
			case FloatOpEQ -> return "FloatOpEQ";
			case FloatOpNE -> return "FloatOpNE";
			case FloatOpLT -> return "FloatOpLT";
			case FloatOpLE -> return "FloatOpLE";
			case FloatOpGT -> return "FloatOpGT";
			case FloatOpGE -> return "FloatOpGE";
			case FloatOpCmp -> return "FloatOpCmp";
			case FloatOpAdd -> return "FloatOpAdd";
			case FloatOpSub -> return "FloatOpSub";
			case FloatOpMul -> return "FloatOpMul";
			case FloatOpDiv -> return "FloatOpDiv";
			case FloatOpMod -> return "FloatOpMod";
			case FloatOpNeg -> return "FloatOpNeg";
			case FloatOpAddAssign -> return "FloatOpAddAssign";
			case FloatOpSubAssign -> return "FloatOpSubAssign";
			case FloatOpMulAssign -> return "FloatOpMulAssign";
			case FloatOpDivAssign -> return "FloatOpDivAssign";
			case FloatOpModAssign -> return "FloatOpModAssign";
			case PointerGetNull -> return "PointerGetNull";
			case PointerToRef -> return "PointerToRef";
			case RefToPointer -> return "RefToPointer";
			case PointerCast -> return "PointerCast";
			case PointerDiff -> return "PointerDiff";
			case PointerOffset -> return "PointerOffset";
			case PointerOpIndex -> return "PointerOpIndex";
			case IntCast -> return "IntCast";
			case FloatCast -> return "FloatCast";
			case IntToFloat -> return "IntToFloat";
			case FloatToInt -> return "FloatToInt";
			case SizeOf -> return "SizeOf";
			case AlignmentOf -> return "AlignmentOf";
			case ReferenceKindOf -> return "ReferenceKindOf";
			case VariantOpIs -> return "VariantOpIs";
			case VariantOpUnsafeAs -> return "VariantOpUnsafeAs";
			case ArrayGetSize -> return "ArrayGetSize";
			case ArrayGetDataPointer -> return "ArrayGetDataPointer";
		}
	}

	func dump(this: &InlineBuiltinFunction, out: &&TreeFormatter) -> void {
		out.attribute(this.name());
		out.value(this.base_type.signature());

		match this {
			case IntCast: type -> out.value(type.signature());
			case FloatCast: type -> out.value(type.signature());
			case IntToFloat: type -> out.value(type.signature());
			case FloatToInt: type -> out.value(type.signature());
			case VariantOpUnsafeAs: id -> out.value(format(id));
			case VariantOpIs: id -> out.value(format(id));
			else -> {}
		}
	}
}

variant BuiltinFunction {
	var base_type: TypeRef;

	case StructDefaultConstructor;
	case StructCopyConstructor;
	case StructDestructor;
	case StructOpAssign;
	case StructOpEqual;
	case StructOpCmp;

	case VariantCaseConstructor: int;
	case VariantCopyConstructor;
	case VariantDestructor;
	case VariantOpAssign;
	case VariantOpEqual;

	case ArrayDefaultConstructor;
	case ArrayCopyConstructor;
	case ArrayDestructor;
	case ArrayOpAssign;
	case ArrayOpEqual;

	func dump(this: &BuiltinFunction, out: &&TreeFormatter) -> void {}
}

variant Stmt {
	var span: Span;

	case Empty;

	case Compound: CompoundStmt;

	case Expr: Expr;

	case If: IfStmt;
	case While: WhileStmt;

	case Case: CaseStmt;
	case ElseCase: Box!<Stmt>;

	case Break;
	case Continue;
	case Yield;

	case Return: Expr;

	case LifeTimeStart: WeakPtr!<VarDecl>;
	case LifeTimeEnd: WeakPtr!<VarDecl>;

	func dump(this: &Stmt, out: &&TreeFormatter, is_last: bool) -> void {
		match this {
			case Empty -> {
				out.push("EmptyStmt", is_last);
				out.span(this.span);
				out.pop();
			}
			case Compound: compound_stmt -> compound_stmt.dump(&&out, is_last);
			case Expr: expr -> expr.dump(&&out, is_last);
			case If: if_stmt -> {
				out.push("IfStmt", is_last);
				out.span(this.span);

				if_stmt.condition.dump(&&out, false);
				if_stmt.then_branch.dump(&&out, false);
				if_stmt.else_branch.dump(&&out, true);

				out.pop();
			}
			case While: while_stmt -> {
				match while_stmt.kind {
					case While -> out.push("WhileStmt", is_last);
					case DoWhile -> out.push("DoWhileStmt", is_last);
				}
				out.span(this.span);

				while_stmt.condition.dump(&&out, false);
				while_stmt.body.dump(&&out, false);

				out.pop();
			}
			case Case -> {}
			case ElseCase -> {}
			case Break -> {
				out.push("BreakStmt", is_last);
				out.span(this.span);
				out.pop();
			}
			case Continue -> {
				out.push("ContinueStmt", is_last);
				out.span(this.span);
				out.pop();
			}
			case Yield -> {
				out.push("YieldStmt", is_last);
				out.span(this.span);
				out.pop();
			}
			case Return: value -> {
				out.push("ReturnStmt", is_last);
				out.span(this.span);

				if !(value is Empty) {
					value.dump(&&out, true);
				}

				out.pop();
			}
			case LifeTimeStart: variable -> {
				const decl = variable.lock().value();
				decl.dump(&&out, is_last);
			}
			case LifeTimeEnd: variable -> {
				out.push("LifeTimeEnd", is_last);
				const decl = variable.lock().value();
				out.value(decl.name);
				out.span(decl.span);
				out.pop();
			}
		}
	}

	func isTerminator(this: &Stmt, never_type: TypeRef) -> bool {
		return this.isTerminator(never_type, true);
	}

	func isTerminator(this: &Stmt, never_type: TypeRef, yield_is_terminator: bool) -> bool {
		match this {
			case Empty -> return false;
			case Compound: compound_stmt -> return compound_stmt.isTerminator(never_type);
			case Expr: expr -> return expr.type == never_type;
			case If: if_stmt -> return if_stmt.then_branch.isTerminator(never_type) && if_stmt.else_branch.isTerminator(never_type);
			case While: while_stmt -> return while_stmt.kind == DoWhile && while_stmt.body.isTerminator(never_type);
			case Case: case_stmt -> return case_stmt.body.isTerminator(never_type);
			case ElseCase: body -> return body.isTerminator(never_type);
			case Break
			| Continue
			| Return -> return true;
			case Yield -> return yield_is_terminator;
			case LifeTimeStart
			| LifeTimeEnd -> return false;
		}
	}
}

struct CompoundStmt {
	var span: Span;
	var children: SharedPtr!<List!<Stmt>>;

	func constructor(this: &&CompoundStmt, span: Span) -> void {
		this.span := span;
		this.children := SharedPtr!<List!<Stmt>>::new(List!<Stmt>());
	}

	func constructor(this: &&CompoundStmt, other: CompoundStmt) -> void = default;
	func destructor(this: &&CompoundStmt) -> void = default;

	operator =(this: &&CompoundStmt, other: CompoundStmt) -> void = default;

	operator ==(this: CompoundStmt, other: CompoundStmt) -> bool {
		return this.children.data == other.children.data;
	}

	func dump(this: &CompoundStmt, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("CompoundStmt", is_last);
		out.span(this.span);

		for i in 0u..this.children.size() {
			this.children[i].dump(&&out, i == this.children.size() - 1);
		}

		out.pop();
	}

	func isTerminator(this: &CompoundStmt, never_type: TypeRef) -> bool {
		if const last = this.children.last() {
			return last.isTerminator(never_type);
		}
		return false;
	}
}

struct IfStmt {
	var condition: Expr;
	var condition_cleanup: List!<Stmt>;
	var then_branch: Box!<Stmt>;
	var else_branch: Box!<Stmt>;

	func constructor(this: &&IfStmt, condition: Expr, condition_cleanup: List!<Stmt>, then_branch: Stmt, else_branch: Stmt) -> void {
		this.condition := condition;
		this.condition_cleanup := condition_cleanup;
		this.then_branch := then_branch;
		this.else_branch := else_branch;
	}

	func constructor(this: &&IfStmt, other: IfStmt) -> void = default;
	func destructor(this: &&IfStmt) -> void = default;

	operator =(this: &&IfStmt, other: IfStmt) -> void = default;

	operator ==(this: IfStmt, other: IfStmt) -> bool = default;
}

struct WhileStmt {
	var condition: Expr;
	var condition_cleanup: List!<Stmt>;
	var body: Box!<Stmt>;
	var kind: WhileStmtKind;

	func constructor(this: &&WhileStmt, condition: Expr, condition_cleanup: List!<Stmt>, body: Stmt, kind: WhileStmtKind) -> void {
		this.condition := condition;
		this.condition_cleanup := condition_cleanup;
		this.body := body;
		this.kind := kind;
	}

	func constructor(this: &&WhileStmt, other: WhileStmt) -> void = default;
	func destructor(this: &&WhileStmt) -> void = default;

	operator =(this: &&WhileStmt, other: WhileStmt) -> void = default;

	operator ==(this: WhileStmt, other: WhileStmt) -> bool = default;
}

enum WhileStmtKind {
	case While;
	case DoWhile;
}

struct CaseStmt {
	var span: Span;
	var patterns: List!<Expr>;
	var body: Box!<Stmt>;

	func constructor(this: &&CaseStmt, span: Span, patterns: List!<Expr>, body: Stmt) -> void {
		this.span := span;
		this.patterns := patterns;
		this.body := body;
	}

	func constructor(this: &&CaseStmt, other: CaseStmt) -> void = default;
	func destructor(this: &&CaseStmt) -> void = default;

	operator =(this: &&CaseStmt, other: CaseStmt) -> void = default;

	operator ==(this: CaseStmt, other: CaseStmt) -> bool = default;

	func dump(this: &CaseStmt, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("CaseStmt", is_last);
		out.span(this.span);

		for pattern in this.patterns {
			pattern.dump(&&out, false);
		}

		this.body.dump(&&out, true);
		out.pop();
	}
}

variant Expr {
	var span: Span;
	var type: TypeRef;

	case Empty;

	case Integer: int;
	case Float: f64;
	case String: String;

	case Array: List!<Expr>;

	case Call: CallExpr;
	case Match: MatchExpr;

	case VarInvoke: WeakPtr!<VarDecl>;
	case MemberVarInvoke: MemberVarInvokeExpr;

	case Dereference: Box!<Expr>;

	case ShallowCopy: ShallowCopyExpr;

	func addDereference(this: Expr) -> Expr {
		match this.type.kind {
			case None -> return this;
			else -> return Expr::Dereference(Box!<Expr>(this), this.span, this.type.base());
		}
	}

	func removeDereference(this: Expr) -> Expr {
		match this {
			case Dereference: base -> return base.operator unwrap();
			else -> return this;
		}
	}

	func getTypes(expressions: &List!<Expr>) -> List!<TypeRef> {
		var types: List!<TypeRef>;
		for expr in expressions {
			types.append(expr.type);
		}
		return types;
	}

	func dump(this: &Expr, out: &&TreeFormatter, is_last: bool) -> void {
		match this {
			case Empty -> {
				out.push("EmptyExpr", is_last);
				out.span(this.span);
				out.pop();
			}
			case Integer: value -> {
				out.push("IntegerExpr", is_last);
				out.value(format(value));
				out.attribute(this.type.signature());
				out.span(this.span);
				out.pop();
			}
			case Float: value -> {
				out.push("FloatExpr", is_last);
				//out.value(format(value));
				out.attribute(this.type.signature());
				out.span(this.span);
				out.pop();
			}
			case String: value -> {
				out.push("StringExpr", is_last);
				out.value("\"" + value + "\"");
				out.attribute(this.type.signature());
				out.span(this.span);
				out.pop();
			}
			case Array -> {}
			case Call: call_expr -> {
				out.push("CallExpr", is_last);
				out.value(call_expr.function.signature());
				out.attribute(call_expr.return_kind.toString());
				out.span(this.span);

				if const result_var = call_expr.result_var.lock() {
					result_var.dump(&&out, call_expr.parameters.isEmpty());
				}

				for i in 0u..call_expr.parameters.size() {
					call_expr.parameters[i].dump(&&out, i == call_expr.parameters.size() - 1);
				}

				out.pop();
			}
			case Match: match_expr -> {
				out.push("MatchExpr", is_last);
				out.attribute(this.type.signature());
				out.span(this.span);

				match_expr.value.dump(&&out, false);
				if const yield_var = match_expr.yield_var.lock() {
					yield_var.dump(&&out, false);
				}

				for i in 0u..match_expr.cases.size() {
					match_expr.cases[i].dump(&&out, i == match_expr.cases.size() - 1 && match_expr.else_case is None);
				}

				if const else_case = match_expr.else_case {
					else_case.dump(&&out, true);
				}

				out.pop();
			}
			case VarInvoke: variable -> {
				out.push("VarInvokeExpr", is_last);
				const decl = variable.lock().value();
				out.value(("#" if decl.is_parameter else "") + decl.name);
				out.attribute(this.type.signature());
				out.span(this.span);
				out.pop();
			}
			case MemberVarInvoke: member_var_invoke_expr -> {
				out.push("MemberVarInvokeExpr", is_last);
				out.value(format(member_var_invoke_expr.id));
				out.attribute(this.type.signature());
				out.span(this.span);
				member_var_invoke_expr.object.dump(&&out, true);
				out.pop();
			}
			case Dereference: base -> {
				out.push("DereferenceExpr", is_last);
				out.attribute(this.type.signature());
				out.span(this.span);
				base.dump(&&out, true);
				out.pop();
			}
			case ShallowCopy: shallow_copy_expr -> {
				out.push("ShallowCopyExpr", is_last);
				out.span(this.span);
				shallow_copy_expr.destination.dump(&&out, false);
				shallow_copy_expr.value.dump(&&out, true);
				out.pop();
			}
		}
	}
}

enum ReturnKind {
	case None;		// function returns void or never
	case Value;		// most basic, no memory management
	case Variable;	// result gets stored in variable allocated by caller
	case Parameter;	// callee initializes variable allocated by caller, passed by reference as first parameter
	case VariableButYieldNone;	// same as variable, but result gets discarded. Used when initializing a variable with the result of a call (optimized)

	func toString(this: ReturnKind) -> String {
		match this {
			case None -> return "None";
			case Value -> return "Value";
			case Variable -> return "Variable";
			case Parameter -> return "Parameter";
			case VariableButYieldNone -> return "VariableButYieldNone";
		}
	}
}

struct CallExpr {
	var function: FunctionRef;
	var parameters: List!<Expr>;
	var result_var: WeakPtr!<VarDecl>;
	var return_kind: ReturnKind;
	var is_copy_constructor_call: bool;

	func constructor(this: &&CallExpr, function: FunctionRef, parameters: List!<Expr>, result_var: WeakPtr!<VarDecl>, return_kind: ReturnKind, is_copy_constructor_call: bool) -> void {
		this.function := function;
		this.parameters := parameters;
		this.result_var := result_var;
		this.return_kind := return_kind;
		this.is_copy_constructor_call := is_copy_constructor_call;
	}

	func constructor(this: &&CallExpr, other: CallExpr) -> void = default;
	func destructor(this: &&CallExpr) -> void = default;

	operator =(this: &&CallExpr, other: CallExpr) -> void = default;

	operator ==(this: CallExpr, other: CallExpr) -> bool = default;
}

struct MatchExpr {
	var value: Box!<Expr>;
	var cases: List!<CaseStmt>;
	var else_case: Optional!<Box!<Stmt>>;
	var yield_var: WeakPtr!<VarDecl>;

	func constructor(this: &&MatchExpr) -> void {
		this.value := Expr::Empty(Span(0u16), TypeRef::unknown());
	}

	func constructor(this: &&MatchExpr, value: Expr) -> void {
		this.value := value;
	}

	func constructor(this: &&MatchExpr, other: MatchExpr) -> void = default;
	func destructor(this: &&MatchExpr) -> void = default;

	operator =(this: &&MatchExpr, other: MatchExpr) -> void = default;

	operator ==(this: MatchExpr, other: MatchExpr) -> bool = default;
}

struct MemberVarInvokeExpr {
	var object: Box!<Expr>;
	var id: uint;

	func constructor(this: &&MemberVarInvokeExpr, object: Expr, id: uint) -> void {
		this.object := object;
		this.id := id;
	}

	func constructor(this: &&MemberVarInvokeExpr, other: MemberVarInvokeExpr) -> void = default;
	func destructor(this: &&MemberVarInvokeExpr) -> void = default;

	operator =(this: &&MemberVarInvokeExpr, other: MemberVarInvokeExpr) -> void = default;

	operator ==(this: MemberVarInvokeExpr, other: MemberVarInvokeExpr) -> bool = default;
}

struct ShallowCopyExpr {
	var destination: Box!<Expr>;
	var value: Box!<Expr>;

	func constructor(this: &&ShallowCopyExpr, destination: Expr, value: Expr) -> void {
		this.destination := destination;
		this.value := value;
	}

	func constructor(this: &&ShallowCopyExpr, other: ShallowCopyExpr) -> void = default;
	func destructor(this: &&ShallowCopyExpr) -> void = default;

	operator =(this: &&ShallowCopyExpr, other: ShallowCopyExpr) -> void = default;

	operator ==(this: ShallowCopyExpr, other: ShallowCopyExpr) -> bool = default;
}
