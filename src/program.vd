import std/core;
import std/box;
import std/format;
import std/io;
import std/list;
import std/map;
import std/set;
import std/shared;
import std/shared_list;
import std/string;

import error;
import options;
import span;
import syntax_tree;
import tree_formatter;

struct SourceFile {
	var name: String;
	var path: String;
	var source: String;
	var line_spans: List!<Span>;

	func constructor(this: &&SourceFile, name: String, path: String, source: String, line_spans: List!<Span>) -> void {
		this.name := name;
		this.path := path;
		this.source := source;
		this.line_spans := line_spans;
	}

	func constructor(this: &&SourceFile, other: SourceFile) -> void = default;
	func destructor(this: &&SourceFile) -> void = default;

	operator =(this: &&SourceFile, other: SourceFile) -> void = default;
	operator ==(this: SourceFile, other: SourceFile) -> bool = default;
}

struct Program {
	var name: String;
	var options: CompilerOptions;

	var has_errors: bool;

	var files: List!<SourceFile>;

	// namespaces
	var namespaces: SharedList!<Namespace>;
	var top_level_namespaces: List!<SharedHandle!<Namespace>>;
	var modules: Map!<String, SharedHandle!<Namespace>>;

	var core_namespace: SharedHandle!<Namespace>;

	// concepts
	var concepts: SharedList!<Concept>;
	var concepts_by_name: Map!<String, SharedHandle!<Concept>>;

	var any_concept: SharedHandle!<Concept>;
	var int_concept: SharedHandle!<Concept>;
	var uint_concept: SharedHandle!<Concept>;

	// types
	var types: SharedList!<TypeDecl>;

	var void_type: Type;
	var never_type: Type;

	var bool_type: Type;

	var int_type: Type;
	var uint_type: Type;

	var byte_type: Type;

	var cptr_type: Type;
	var vptr_type: Type;

	// functions
	var functions: SharedList!<FunctionDecl>;

	var main_function: SharedHandle!<FunctionDecl>;

	func constructor(this: &&Program, options: CompilerOptions) -> void {
		this.name := options.program_name;
		this.options := options;

		this.has_errors := false;

		this.files := ();
		this.files.append(SourceFile("unknown", "unknown", "", List!<Span>(1u, Span())));

		this.namespaces := ();
		this.top_level_namespaces := ();
		for i in 0u..options.import_search_paths.size() {
			const ns = this.namespaces.append(Namespace(format(i), List!<TemplateParameterDecl>(), SharedHandle!<Namespace>()));
			this.top_level_namespaces.append(ns);
		}
	}

	func destructor(this: &&Program) -> void = default;

	func printError(this: &&Program, error: CompilationError) -> void {
		if error.type == Error {
			this.has_errors = true;
		}

		if this.options.hide_errors {
			return;
		}

		const span = error.span;
		const file = &this.files[span.file as uint];

		println(error.toString(file.path));

		if span.start == span.end {
			return;
		}

		var first_line = int::max(span.line as int - 1, 0) as uint;
		var last_line = span.line as uint + 1;
		while span.end > file.line_spans[last_line - 1].end && last_line < file.line_spans.size() {
			last_line++;
		}
		last_line = uint::min(last_line + 1, file.line_spans.size());

		const last_line_number = format(last_line);
		const max_line_number_width = last_line_number.size();

		for line in first_line..last_line {
			const line_span = file.line_spans[line];

			const line_number_str = format(line + 1);
			print(String(max_line_number_width - line_number_str.size() + 1, ' 'b) + line_number_str + " | ");

			const error_start = uint::max(line_span.start, uint::min(span.start, line_span.end));
			const error_end = uint::max(line_span.start, uint::min(span.end, line_span.end));

			print(file.source.substring(line_span.start..error_start));
			print("\e[31m");
			print(file.source.substring(error_start..error_end));
			print("\e[0m");
			print(file.source.substring(error_end..line_span.end));

			print("\n");
		}
	}

	func printErrors(this: &&Program, errors: List!<CompilationError>) -> void {
		for e in errors {
			this.printError(e);
		}
	}

	func dump(this: &Program) -> String {
		var out: TreeFormatter = ("Program");
		out.attribute(this.name);
		if this.main_function.isAlive() {
			out.text(" main:");
			out.value(this.main_function.signature());
		}

		for concept in this.concepts {
			concept.dump(&&out, false);
		}

		for i in 0u..this.top_level_namespaces.size() {
			this.top_level_namespaces[i].dump(&&out, i == this.top_level_namespaces.size() - 1);
		}

		return out.finalize();
	}

	func createConcept(this: &&Program, concept: Concept) -> SharedHandle!<Concept> {
		const instance = this.concepts.append(concept);
		this.concepts_by_name[concept.name] = instance;
		return instance;
	}

	func getConcept(this: &Program, name: String) -> Optional!<SharedHandle!<Concept>> {
		return this.concepts_by_name.get(name);
	}

	func getOrCreateChildNamespace(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: List!<TemplateParameterDecl>, is_file: bool) -> SharedHandle!<Namespace> {
		for child in parent_namespace.children {
			if child.name != name {
				continue;
			}

			if child.template_parameters != template_parameters {
				continue;
			}

			return child;
		}

		var child = this.namespaces.append(Namespace(name, template_parameters, parent_namespace));

		if is_file {
			child.file_namespace = child;
		} else {
			child.file_namespace = parent_namespace.file_namespace;
		}

		parent_namespace.children.append(child);
		parent_namespace.updateMinState(NamespaceState::Unchecked);

		return child;
	}

	func getVisibleNamespaces(this: &&Program, pov: SharedHandle!<Namespace>) -> Set!<SharedHandle!<Namespace>> {
		var result: Set!<SharedHandle!<Namespace>>;
		result.add(pov);

		for other in pov.imported_namespaces {
			result.add(other);
		}

		var current = pov;
		while current.parent.isAlive() {
			result.add(current.parent);
			current = current.parent;
			for other in current.imported_namespaces {
				result.add(other);
			}

			if current.file_namespace == current {
				break;
			}
		}

		return result;
	}

	func createModule(this: &&Program, imported_module: ImportedModule) -> SharedHandle!<Namespace> {
		const namespaces = imported_module.name.split("/");

		var module = this.top_level_namespaces[imported_module.group];
		for i in 0u..namespaces.size() {
			module = this.getOrCreateChildNamespace(module, namespaces[i], List!<TemplateParameterDecl>(), i <= namespaces.size() - 1);
		}

		this.modules.set(imported_module.path, module);
		return module;
	}

	func getModule(this: &&Program, path: String) -> Optional!<SharedHandle!<Namespace>> {
		return this.modules.get(path);
	}

	func createType(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: List!<TemplateParameterDecl>, body: TypeBody) -> SharedHandle!<TypeDecl> {
		var linked_namespace = this.getOrCreateChildNamespace(parent_namespace, name, template_parameters, false);
		var type_decl = this.types.append(TypeDecl(name, linked_namespace.template_parameters, body));

		type_decl.parent_namespace = linked_namespace.parent;
		type_decl.linked_namespace = linked_namespace;

		linked_namespace.linked_type = type_decl;

		parent_namespace.types.append(type_decl);
		parent_namespace.types_by_name[name].append(type_decl);

		return type_decl;
	}

	func createType(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, body: TypeBody) -> SharedHandle!<TypeDecl> {
		return this.createType(parent_namespace, name, List!<TemplateParameterDecl>(), body);
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: List!<TemplateParameterDecl>, parameter_types: List!<Type>, return_type: Type, body: FunctionBody) -> SharedHandle!<FunctionDecl> {
		var function = this.functions.append(FunctionDecl(name, template_parameters, body));

		function.parent_namespace = parent_namespace;
		function.parameter_types = parameter_types;
		function.return_type = return_type;

		parent_namespace.functions.append(function);
		parent_namespace.functions_by_name[name].append(function);

		return function;
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: List!<TemplateParameterDecl>, parameter_types: List!<Type>, return_type: Type, body: InlineBuiltinFunction) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, template_parameters, parameter_types, return_type, FunctionBody::InlineBuiltin(body));
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: List!<TemplateParameterDecl>, parameter_types: List!<Type>, return_type: Type, body: BuiltinFunction) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, template_parameters, parameter_types, return_type, FunctionBody::Builtin(body));
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: List!<TemplateParameterDecl>, body: FunctionBody) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, template_parameters, List!<Type>(), Type::unknown(), body);
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: List!<TemplateParameterDecl>, body: InlineBuiltinFunction) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, template_parameters, List!<Type>(), Type::unknown(), FunctionBody::InlineBuiltin(body));
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: List!<TemplateParameterDecl>, body: BuiltinFunction) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, template_parameters, List!<Type>(), Type::unknown(), FunctionBody::Builtin(body));
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, parameter_types: List!<Type>, return_type: Type, body: FunctionBody) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, List!<TemplateParameterDecl>(), parameter_types, return_type, body);
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, parameter_types: List!<Type>, return_type: Type, body: InlineBuiltinFunction) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, List!<TemplateParameterDecl>(), parameter_types, return_type, FunctionBody::InlineBuiltin(body));
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, parameter_types: List!<Type>, return_type: Type, body: BuiltinFunction) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, List!<TemplateParameterDecl>(), parameter_types, return_type, FunctionBody::Builtin(body));
	}
}

variant Concept {
	var name: String;

	case Any;
	case IntLiteral: Type; // for template parameters, that accept int literals

	func dump(this: &Concept, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("Concept", is_last);
		out.attribute(this.name);

		match this {
			case IntLiteral: type -> out.value(type.signature());
			else -> {}
		}

		out.pop();
	}
}

struct TemplateParameterDecl {
	var name: String;

	var concept: SharedHandle!<Concept>;
	var is_variadic: bool;

	var value: Optional!<TemplateParameter>;

	func constructor(this: &&TemplateParameterDecl, name: String, concept: SharedHandle!<Concept>, is_variadic: bool) -> void {
		this.name := name;
		this.concept := concept;
		this.is_variadic := is_variadic;
		this.value := None;
	}

	func constructor(this: &&TemplateParameterDecl, name: String, concept: SharedHandle!<Concept>, is_variadic: bool, value: TemplateParameter) -> void {
		this.name := name;
		this.concept := concept;
		this.is_variadic := is_variadic;
		this.value := Some(value);
	}

	func constructor(this: &&TemplateParameterDecl, other: TemplateParameterDecl) -> void = default;
	func destructor(this: &&TemplateParameterDecl) -> void = default;

	operator =(this: &&TemplateParameterDecl, other: TemplateParameterDecl) -> void = default;

	operator ==(this: TemplateParameterDecl, other: TemplateParameterDecl) -> bool = default;

	func signature(this: &TemplateParameterDecl) -> String {
		var result = this.name + ": ";
		result += ("..." if this.is_variadic else "") + this.concept.name;
		if const value = this.value {
			result += " = " + value.toString();
		}
		return result;
	}

	func dump(this: &TemplateParameterDecl, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("TemplateParameterDecl", is_last);
		out.attribute(this.name);
		out.text(":");
		out.attribute(this.concept.name);

		if const value = this.value {
			out.text(" =");
			out.value(value.toString());
		}

		out.pop();
	}
}

variant TemplateParameter {
	case Type: Type;
	case Integer: int;
	case Garbage;

	func toString(this: TemplateParameter) -> String {
		match this {
			case Type: t -> return t.signature();
			case Integer: i -> return format(i);
			case Garbage -> return "<garbage>";
		}
	}
}

struct NameSegment {
	var span: Span;
	var name: String;
	var template_parameters: List!<TemplateParameter>;

	func constructor(this: &&NameSegment, name: String, template_parameters: List!<TemplateParameter>) -> void {
		this.name := name;
		this.template_parameters := template_parameters;
	}

	func constructor(this: &&NameSegment, span: Span, name: String, template_parameters: List!<TemplateParameter>) -> void {
		this.span := span;
		this.name := name;
		this.template_parameters := template_parameters;
	}

	func constructor(this: &&NameSegment, other: NameSegment) -> void = default;
	func destructor(this: &&NameSegment) -> void = default;

	operator =(this: &&NameSegment, other: NameSegment) -> void = default;
	operator ==(this: NameSegment, other: NameSegment) -> bool {
		return this.name == other.name && this.template_parameters == other.template_parameters;
	}

	func toString(this: &NameSegment) -> String {
		return this.name + format(this.template_parameters);
	}
}

struct Name {
	var span: Span;
	var segments: List!<NameSegment>;

	func constructor(this: &&Name) -> void = default;

	func constructor(this: &&Name, span: Span) -> void {
		this.span := span;
	}

	func constructor(this: &&Name, name: String) -> void {
		this.segments := (1u, NameSegment(Span(), name, List!<TemplateParameter>()));
	}

	func constructor(this: &&Name, name: String, template_parameters: List!<TemplateParameter>) -> void {
		this.segments := (1u, NameSegment(Span(), name, template_parameters));
	}

	func constructor(this: &&Name, other: Name) -> void = default;
	func destructor(this: &&Name) -> void = default;

	operator =(this: &&Name, other: Name) -> void = default;
	operator ==(this: Name, other: Name) -> bool = default;

	operator +(this: Name, segment: NameSegment) -> Name {
		var result = this;
		result.segments.append(segment);
		return result;
	}

	func intersection(this: Name, segments: List!<NameSegment>) -> uint {
		for offset in 0u..this.segments.size() {
			if segments.startsWith(this.segments[offset..this.segments.size()]) {
				return this.segments.size() - offset;
			}
		}

		return 0u;
	}

	func toString(this: &Name) -> String {
		var result = "";
		var first = true;
		for i in 0u..this.segments.size() {
			if i != 0 {
				result += "::";
			}
			result += this.segments[i].toString();
		}

		return result;
	}
}

enum NamespaceState {
	case IncompleteTemplate;
	case Unchecked;
	case UncheckedTypeBodies;
	case UncheckedFunctionSignatures;
	case UncheckedFunctionBodies;
	case Done;

	operator +(this: NamespaceState, delta: uint) -> NamespaceState {
		return (this as uint + delta) as NamespaceState;
	}

	func toString(this: NamespaceState) -> String {
		assert(this >= IncompleteTemplate && this <= Done);

		match this {
			case IncompleteTemplate -> return "IncompleteTemplate";
			case Unchecked -> return "Unchecked";
			case UncheckedTypeBodies -> return "UncheckedTypeBodies";
			case UncheckedFunctionSignatures -> return "UncheckedFunctionSignatures";
			case UncheckedFunctionBodies -> return "UncheckedFunctionBodies";
			case Done -> return "Done";
		}
	}
}

struct Namespace {
	var span: Span;
	var name_span: Span;

	var name: String;
	var full_name: Name;
	var template_parameters: List!<TemplateParameterDecl>;

	var parent: SharedHandle!<Namespace>;
	var children: List!<SharedHandle!<Namespace>>;
	var imported_namespaces: List!<SharedHandle!<Namespace>>;
	var file_namespace: SharedHandle!<Namespace>;

	var template_instances: List!<SharedHandle!<Namespace>>;

	var linked_type: SharedHandle!<TypeDecl>;

	var types: List!<SharedHandle!<TypeDecl>>;
	var types_by_name: Map!<String, List!<SharedHandle!<TypeDecl>>>;

	var functions: List!<SharedHandle!<FunctionDecl>>;
	var functions_by_name: Map!<String, List!<SharedHandle!<FunctionDecl>>>;

	var state: NamespaceState;
	var unchecked_children: List!<ParsedStmt>;
	var unchecked_types: List!<SharedHandle!<TypeDecl>>;
	var unchecked_functions: List!<SharedHandle!<FunctionDecl>>;
	var unchecked_function_bodies: List!<SharedHandle!<FunctionDecl>>;

	func constructor(this: &&Namespace, name: String, template_parameters: List!<TemplateParameterDecl>, parent: SharedHandle!<Namespace>) -> void {
		this.name := name;
		this.template_parameters := template_parameters;
		this.parent := parent;
		this.state := Unchecked;

		var template_parameter_values: List!<TemplateParameter>;
		for p in template_parameters {
			if p.value.hasValue() {
				template_parameter_values.append(p.value.value());
			} else {
				this.state = IncompleteTemplate;
			}
		}

		var full_name: Name;
		if this.parent.isAlive() {
			full_name = this.parent.full_name + NameSegment(Span(), name, template_parameter_values);
		} else {
			full_name = Name(name, template_parameter_values);
		}

		this.full_name := full_name;
	}

	func constructor(this: &&Namespace, other: Namespace) -> void = default;
	func destructor(this: &&Namespace) -> void = default;

	operator =(this: &&Namespace, other: Namespace) -> void = default;

	func signature(this: &Namespace) -> String {
		if this.parent.isAlive() {
			return this.parent.signature() + "::" + this.name + format(this.template_parameters);
		}

		return this.name + format(this.template_parameters);
	}

	func dump(this: &Namespace, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("Namespace", is_last);
		out.attribute(this.signature());
		out.value(this.state.toString());

		for parameter in this.template_parameters {
			parameter.dump(&&out, false);
		}

		for i in 0u..this.children.size() {
			this.children[i].dump(&&out, (i == this.children.size() - 1) && this.types.isEmpty() && this.functions.isEmpty());
		}

		for i in 0u..this.types.size() {
			this.types[i].dump(&&out, (i == this.types.size() - 1) && this.functions.isEmpty());
		}

		for i in 0u..this.functions.size() {
			this.functions[i].dump(&&out, i == this.functions.size() - 1);
		}

		out.pop();
	}

	func isIncompleteTemplate(this: &Namespace) -> bool {
		return this.state == IncompleteTemplate
	}

	func updateState(this: &&Namespace, new_state: NamespaceState) -> void {
		if this.state == IncompleteTemplate {
			return;
		}

		this.state = new_state;

		if this.parent.isAlive() {
			this.parent.updateMinState(new_state);
		}
	}

	func updateMinState(this: &&Namespace, min_state: NamespaceState) -> void {
		if this.state == IncompleteTemplate {
			return;
		}

		if this.state <= min_state {
			return;
		}

		this.state = min_state;

		if this.parent.isAlive() {
			this.parent.updateMinState(min_state);
		}
	}

	func addUncheckedChildren(this: &&Namespace, children: List!<ParsedStmt>) -> void {
		this.unchecked_children.append(children);
		this.updateMinState(NamespaceState::Unchecked);

		for instance in this.template_instances {
			instance.addUncheckedChildren(children);
		}
	}

	func addUncheckedType(this: &&Namespace, type: SharedHandle!<TypeDecl>) -> void {
		this.unchecked_types.append(type);
		this.updateMinState(NamespaceState::UncheckedTypeBodies);
	}

	func addUncheckedFunction(this: &&Namespace, function: SharedHandle!<FunctionDecl>) -> void {
		this.unchecked_functions.append(function);
		this.updateMinState(NamespaceState::UncheckedFunctionSignatures);
	}

	func addUncheckedFunctionBody(this: &&Namespace, function: SharedHandle!<FunctionDecl>) -> void {
		this.unchecked_function_bodies.append(function);
		this.updateMinState(NamespaceState::UncheckedFunctionBodies);
	}
}

struct TypeDecl {
	var span: Span;
	var name_span: Span;

	var name: String;
	var template_parameters: List!<TemplateParameterDecl>;
	var body: TypeBody;

	var parent_namespace: SharedHandle!<Namespace>;
	var linked_namespace: SharedHandle!<Namespace>;

	var unwrapped_type: SharedHandle!<TypeDecl>;

	var default_constructor: SharedHandle!<FunctionDecl>;
	var copy_constructor: SharedHandle!<FunctionDecl>;
	var destructor: SharedHandle!<FunctionDecl>;
	var op_assign: SharedHandle!<FunctionDecl>;
	var op_equal: SharedHandle!<FunctionDecl>;
	var op_compare: SharedHandle!<FunctionDecl>;

	var contained_types: Set!<SharedHandle!<TypeDecl>>;

	var parsed_annotations: List!<ParsedAnnotation>;

	// struct & variant
	var member_variables: List!<MemberVarDecl>;
	var member_variables_by_name: Map!<String, uint>;

	// enum & variant
	var parsed_id_type: Optional!<ParsedType>;
	var id_type: Type;

	// only enum
	var enum_cases: List!<EnumCaseDecl>;
	var enum_cases_by_name: Map!<String, uint>;

	// only variant
	var variant_cases: List!<VariantCaseDecl>;
	var variant_cases_by_id: Map!<int, uint>;
	var variant_cases_by_name: Map!<String, uint>;

	func constructor(this: &&TypeDecl, name: String, template_parameters: List!<TemplateParameterDecl>, body: TypeBody) -> void {
		this.name := name;
		this.template_parameters := template_parameters;
		this.body := body;
	}

	func constructor(this: &&TypeDecl, other: TypeDecl) -> void = default;
	func destructor(this: &&TypeDecl) -> void = default;

	operator =(this: &&TypeDecl, other: TypeDecl) -> void = default;

	func dump(this: &TypeDecl, out: &&TreeFormatter, is_last: bool) -> void {
		match this.body {
			case Empty -> out.push("EmptyTypeDecl", is_last);
			case Void -> out.push("VoidTypeDecl", is_last);
			case Bool -> out.push("BoolTypeDecl", is_last);
			case Byte -> out.push("ByteTypeDecl", is_last);
			case Int: size -> {
				out.push("IntTypeDecl", is_last);
				out.value(format(size));
			}
			case UInt: size -> {
				out.push("UIntTypeDecl", is_last);
				out.value(format(size));
			}
			case Float: size -> {
				out.push("FloatTypeDecl", is_last);
				out.value(format(size));
			}
			case Pointer: pointer_type -> {
				out.push("PointerTypeDecl", is_last);
				out.attribute("const" if pointer_type.is_const else "var");
				out.value(pointer_type.base_type.signature());
			}
			case Array: array_type -> {
				out.push("ArrayTypeDecl", is_last);
			}
			case Enum -> {
				out.push("EnumTypeDecl", is_last);
			}
			case Struct -> {
				out.push("StructTypeDecl", is_last);
			}
			case Variant -> {
				out.push("VariantTypeDecl", is_last);
			}
		}

		out.attribute(this.signature());

		for i in 0u..this.template_parameters.size() {
			this.template_parameters[i].dump(&&out, (i == this.template_parameters.size() - 1) && this.member_variables.isEmpty() && this.enum_cases.isEmpty() && this.variant_cases.isEmpty());
		}

		for i in 0u..this.member_variables.size() {
			this.member_variables[i].dump(&&out, (i == this.member_variables.size() - 1) && this.enum_cases.isEmpty() && this.variant_cases.isEmpty());
		}

		for i in 0u..this.enum_cases.size() {
			this.enum_cases[i].dump(&&out, i == this.enum_cases.size() - 1);
		}

		for i in 0u..this.variant_cases.size() {
			this.variant_cases[i].dump(&&out, i == this.variant_cases.size() - 1);
		}

		out.pop();
	}

	func signature(this: &TypeDecl) -> String {
		return this.linked_namespace.signature();
	}

	func isIncompleteTemplate(this: &TypeDecl) -> bool {
		for parameter in this.template_parameters {
			if parameter.value is None {
				return true;
			}
		}

		return false;
	}

	func addContainedType(this: &&TypeDecl, type: Type) -> void {
		if type.isUnknown() {
			return;
		}

		if type.reference_kind == None {
			this.contained_types.add(type.decl);
		}
	}

	func createMemberVariable(this: &&TypeDecl, span: Span, name: String, type: Type, initializer: Expr) -> void {
		if this.member_variables_by_name.contains(name) {
			return;
		}

		this.member_variables_by_name.set(name, this.member_variables.size());
		this.member_variables.append(MemberVarDecl(span, this.member_variables.size(), name, type, initializer));

		this.addContainedType(type);
	}

	func getMemberVariable(this: &TypeDecl, name: String) -> Optional!<MemberVarDecl> {
		for v in this.member_variables {
			if v.name == name {
				return Some(v);
			}
		}

		return None;
	}

	func getNextCaseId(this: &TypeDecl) -> int {
		if this.body is Enum {
			if const prev_case = this.enum_cases.last() {
				return prev_case.id + 1;
			}
		} else if this.body is Variant {
			if const prev_case = this.variant_cases.last() {
				return prev_case.id + 1;
			}
		}
		return 0;
	}

	func createEnumCase(this: &&TypeDecl, span: Span, id: int, name: String) -> void {
		this.enum_cases_by_name.set(name, this.enum_cases.size());
		this.enum_cases.append(EnumCaseDecl(span, id, name));
	}

	func getEnumCase(this: &TypeDecl, name: String) -> Optional!<EnumCaseDecl> {
		const index = this.enum_cases_by_name.get(name) else {
			return None;
		}

		return Some(this.enum_cases[index]);
	}

	func createVariantCase(this: &&TypeDecl, span: Span, id: int, name: String, payload: Type) -> void {
		this.variant_cases_by_name.set(name, this.variant_cases.size());
		this.variant_cases_by_id.set(id, this.variant_cases.size());
		this.variant_cases.append(VariantCaseDecl(span, id, name, payload));
		this.addContainedType(payload);
	}

	func getVariantCase(this: &TypeDecl, name: String) -> Optional!<VariantCaseDecl> {
		const index = this.variant_cases_by_name.get(name) else {
			return None;
		}

		return Some(this.variant_cases[index]);
	}

	func getVariantCase(this: &TypeDecl, id: int) -> Optional!<VariantCaseDecl> {
		const index = this.variant_cases_by_id.get(id) else {
			return None;
		}

		return Some(this.variant_cases[index]);
	}
}

struct Type {
	var decl: SharedHandle!<TypeDecl>;
	var reference_kind: ReferenceKind;

	func constructor(this: &&Type, decl: SharedHandle!<TypeDecl>) -> void {
		this.decl := decl;
		this.reference_kind := None;
	}

	func constructor(this: &&Type, decl: SharedHandle!<TypeDecl>, reference_kind: ReferenceKind) -> void {
		this.decl := decl;
		this.reference_kind := reference_kind;
	}

	func constructor(this: &&Type) -> void = default;
	func constructor(this: &&Type, other: Type) -> void = default;
	func destructor(this: &&Type) -> void = default;

	operator =(this: &&Type, other: Type) -> void = default;

	operator ==(this: Type, other: Type) -> bool = default;
	operator <=>(this: Type, other: Type) -> int = default;

	func unknown() -> Type {
		return Type(SharedHandle!<TypeDecl>(), ReferenceKind::None);
	}

	func hasSameBaseTypeAs(this: &Type, other: Type) -> bool {
		return this.decl == other.decl;
	}

	func isUnknown(this: &Type) -> bool {
		return this.decl.isEmpty();
	}

	func isAlive(this: &Type) -> bool {
		return this.decl.isAlive();
	}

	func signature(this: &Type) -> String {
		if this.decl.isAlive() {
			return this.reference_kind.toString() + this.decl.signature();
		}

		return "unknown";
	}

	func base(this: &Type) -> Type {
		return Type(this.decl, ReferenceKind::None);
	}

	func constRef(this: &Type) -> Type {
		return Type(this.decl, ReferenceKind::Const);
	}

	func varRef(this: &Type) -> Type {
		return Type(this.decl, ReferenceKind::Var);
	}

	func isIncompleteTemplate(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		return this.decl.isIncompleteTemplate();
	}

	func isIntType(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Bool
			| Byte
			| Int
			| UInt
			| Enum -> return true;
			else -> return false;
		}
	}

	func isSigned(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Int
			| Float -> return true;
			else -> return false;
		}
	}

	func isFloatType(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Float -> return true;
			else -> return false;
		}
	}

	func isPtrType(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Pointer -> return true;
			else -> return false;
		}
	}

	func isConstPtrType(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Pointer: pointer_type -> return pointer_type.is_const;
			else -> return false;
		}
	}

	func isPrimitive(this: &Type) -> bool {
		if this.reference_kind != None {
			return true; // reference types are always primitive
		}

		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Void
			| Bool
			| Byte
			| Int
			| UInt
			| Float
			| Pointer
			| Enum -> return true;
			else -> return false;
		}
	}

	func isVariant(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Variant -> return true;
			else -> return false;
		}
	}
}

struct FunctionDecl {
	var span: Span;
	var signature_span: Span;

	var name: String;
	var template_parameters: List!<TemplateParameterDecl>;
	var body: FunctionBody;

	var parent_namespace: SharedHandle!<Namespace>;

	var extern_name: String;

	var parameter_types: List!<Type>;
	var return_type: Type;

	var variables: List!<SharedPtr!<VarDecl>>;
	var parameters: List!<SharedPtr!<VarDecl>>;

	var is_copy_constructor: bool;

	func constructor(this: &&FunctionDecl, name: String, template_parameters: List!<TemplateParameterDecl>, body: FunctionBody) -> void {
		this.name := name;
		this.template_parameters := template_parameters;
		this.body := body;
	}

	func constructor(this: &&FunctionDecl, other: FunctionDecl) -> void = default;
	func destructor(this: &&FunctionDecl) -> void = default;

	operator =(this: &&FunctionDecl, other: FunctionDecl) -> void = default;

	func dump(this: &FunctionDecl, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("FunctionDecl", is_last);
		out.attribute(this.signature());
		out.span(this.span);

		for parameter in this.template_parameters {
			parameter.dump(&&out, false);
		}

		for variable in this.variables {
			if variable.is_parameter {
				variable.dump(&&out, false);
			}
		}

		match this.body {
			case Empty -> {
				out.push("EmptyFunction", true);
				out.pop();
			}
			case Extern -> {
				out.push("ExternFunction", true);
				out.pop();
			}
			case InlineBuiltin: f -> {
				out.push("InlineBuiltinFunction", true);
				f.dump(&&out);
				out.pop();
			}
			case Builtin: f -> {
				out.push("BuiltinFunction", true);
				f.dump(&&out);
				out.pop();
			}
			case Stmt: stmt -> stmt.dump(&&out, true);
			case Unchecked -> {
				out.push("UncheckedFunction", true);
				out.pop();
			}
		}

		out.pop();
	}

	func signature(this: &FunctionDecl) -> String {
		var result = this.parent_namespace.signature();

		result += "::" + this.name + this.template_parameters.format();
		result += "(";

		for i in 0u..this.parameter_types.size() {
			if i != 0 {
				result += ", ";
			}
			result += this.parameter_types[i].signature();
		}

		result += ") -> " + this.return_type.signature();
		return result;
	}

	func createParameter(this: &&FunctionDecl, span: Span, name: String, type: Type) -> void {
		const decl = SharedPtr!<VarDecl>::new(VarDecl(span, this.variables.size(), name, type, type.reference_kind != Var, true));
		this.variables.append(decl);
		this.parameters.append(decl);
	}

	func createVariable(this: &&FunctionDecl, span: Span, name: String, type: Type, is_const: bool) -> WeakPtr!<VarDecl> {
		const decl = SharedPtr!<VarDecl>::new(VarDecl(span, this.variables.size(), name, type, is_const, false));
		this.variables.append(decl);
		return WeakPtr!<VarDecl>(decl);
	}

	func isIncompleteTemplate(this: &FunctionDecl) -> bool {
		for parameter in this.template_parameters {
			if parameter.value is None {
				return true;
			}
		}

		return false;
	}

	func getParsedSignature(this: &FunctionDecl) -> Optional!<ParsedFunctionSignature> {
		if const parsed_function = this.body as Unchecked {
			return Some(parsed_function.signature);
		}

		return None;
	}
}

variant TypeBody {
	case Empty;

	case Void;
	case Bool;
	case Byte;

	// size in bits attached, 0 -> pointer sized
	case Int: uint;
	case UInt: uint;

	// size in bits attached
	case Float: uint;

	case Pointer: PointerType;
	case Array: ArrayType;

	case Struct;
	case Enum;
	case Variant;
}

struct PointerType {
	var base_type: Type;
	var is_const: bool;

	func constructor(this: &&PointerType, is_const: bool) -> void {
		this.is_const := is_const;
	}

	func constructor(this: &&PointerType, base_type: Type, is_const: bool) -> void {
		this.base_type := base_type;
		this.is_const := is_const;
	}

	func constructor(this: &&PointerType, other: PointerType) -> void = default;
	func destructor(this: &&PointerType) -> void = default;

	operator =(this: &&PointerType, other: PointerType) -> void = default;
	operator ==(this: PointerType, other: PointerType) -> bool = default;

	func isOpaque(this: PointerType) -> bool {
		return this.base_type.isUnknown();
	}
}

struct ArrayType {
	var element_type: Type;
	var size: uint;

	func constructor(this: &&ArrayType, element_type: Type, size: uint) -> void {
		this.element_type := element_type;
		this.size := size;
	}

	func constructor(this: &&ArrayType, other: ArrayType) -> void = default;
	func destructor(this: &&ArrayType) -> void = default;

	operator =(this: &&ArrayType, other: ArrayType) -> void = default;
	operator ==(this: ArrayType, other: ArrayType) -> bool = default;
}

struct MemberVarDecl {
	var span: Span;

	var id: uint;
	var name: String;
	var type: Type;

	var initializer: Expr;

	func constructor(this: &&MemberVarDecl, span: Span, id: uint, name: String, type: Type, initializer: Expr) -> void {
		this.span := span;

		this.id := id;
		this.name := name;
		this.type := type;

		this.initializer := initializer;
	}

	func constructor(this: &&MemberVarDecl, other: MemberVarDecl) -> void = default;
	func destructor(this: &&MemberVarDecl) -> void = default;

	operator =(this: &&MemberVarDecl, other: MemberVarDecl) -> void = default;

	operator ==(this: MemberVarDecl, other: MemberVarDecl) -> bool {
		return this.id == other.id;
	}

	operator <=>(this: MemberVarDecl, other: MemberVarDecl) -> int {
		return this.id <=> other.id;
	}

	func dump(this: &MemberVarDecl, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("MemberVarDecl", is_last);
		out.attribute(this.name);
		out.value(this.type.signature());
		out.span(this.span);
		this.initializer.dump(&&out, true);
		out.pop();
	}
}

struct EnumCaseDecl {
	var span: Span;

	var id: int;
	var name: String;

	func constructor(this: &&EnumCaseDecl, span: Span, id: int, name: String) -> void {
		this.span := span;
		this.id := id;
		this.name := name;
	}

	func constructor(this: &&EnumCaseDecl, other: EnumCaseDecl) -> void = default;
	func destructor(this: &&EnumCaseDecl) -> void = default;

	operator =(this: &&EnumCaseDecl, other: EnumCaseDecl) -> void = default;

	operator ==(this: EnumCaseDecl, other: EnumCaseDecl) -> bool {
		return this.id == other.id;
	}

	operator <=>(this: EnumCaseDecl, other: EnumCaseDecl) -> int {
		return this.id <=> other.id;
	}

	func dump(this: &EnumCaseDecl, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("EnumCaseDecl", is_last);
		out.attribute(this.name);
		out.value(format(this.id));
		out.span(this.span);
		out.pop();
	}
}

struct VariantCaseDecl {
	var span: Span;

	var id: int;
	var name: String;
	var type: Type;

	func constructor(this: &&VariantCaseDecl, span: Span, id: int, name: String, type: Type) -> void {
		this.span := span;
		this.id := id;
		this.name := name;
		this.type := type;
	}

	func constructor(this: &&VariantCaseDecl, other: VariantCaseDecl) -> void = default;
	func destructor(this: &&VariantCaseDecl) -> void = default;

	operator =(this: &&VariantCaseDecl, other: VariantCaseDecl) -> void = default;

	operator ==(this: VariantCaseDecl, other: VariantCaseDecl) -> bool {
		return this.id == other.id;
	}

	operator <=>(this: VariantCaseDecl, other: VariantCaseDecl) -> int {
		return this.id <=> other.id;
	}

	func dump(this: &VariantCaseDecl, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("VariantCaseDecl", is_last);
		out.attribute(this.name);
		out.value(format(this.id));
		out.value(this.type.signature());
		out.span(this.span);
		out.pop();
	}
}

variant FunctionBody {
	case Empty;
	case Extern;
	case InlineBuiltin: InlineBuiltinFunction;
	case Builtin: BuiltinFunction;
	case Stmt: Stmt;
	case Unchecked: ParsedFunctionDecl;
}

struct VarDecl {
	var span: Span;

	var id: uint;
	var name: String;
	var type: Type;

	var is_const: bool;
	var is_parameter: bool;
	var is_unused: bool;

	var constructor_call: Expr;
	var destructor_call: Expr;

	func constructor(this: &&VarDecl, span: Span, id: uint, name: String, type: Type, is_const: bool, is_parameter: bool) -> void {
		this.span := span;

		this.id := id;
		this.name := name;
		this.type := type;

		this.is_const := is_const;
		this.is_parameter := is_parameter;

		this.constructor_call := Expr::Undefined(Span(), Type::unknown());
		this.destructor_call := Expr::Undefined(Span(), Type::unknown());
	}

	func constructor(this: &&VarDecl, other: VarDecl) -> void = default;
	func destructor(this: &&VarDecl) -> void = default;

	operator =(this: &&VarDecl, other: VarDecl) -> void = default;

	operator ==(this: VarDecl, other: VarDecl) -> bool {
		return this.id == other.id;
	}

	operator <=>(this: VarDecl, other: VarDecl) -> int {
		return this.id <=> other.id;
	}

	func dump(this: &VarDecl, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("ParameterDecl" if this.is_parameter else "VarDecl", is_last);

		out.attribute(("#" if this.is_parameter else "") + this.name);
		out.value(format(this.id));
		out.text(" :");
		out.value(this.type.signature());
		out.value("const" if this.is_const else "var");
		out.span(this.span);

		this.constructor_call.dump(&&out, false);
		this.destructor_call.dump(&&out, true);

		out.pop();
	}

	func signature(this: &VarDecl) -> String {
		return ("const " if this.is_const else "var ") + this.name + ": " + this.type.signature();
	}
}

variant InlineBuiltinFunction {
	var base_type: Type;

	case NoOp;

	case BitStoreNull;
	case BitStoreValue;

	case BitOpEQ;
	case BitOpNE;

	case BitOpAnd;
	case BitOpOr;
	case BitOpXOr;
	case BitOpNot;
	case BitOpShl;
	case BitOpLShr;
	case BitOpAShr;
	case BitOpAndAssign;
	case BitOpOrAssign;
	case BitOpXOrAssign;
	case BitOpShlAssign;
	case BitOpLShrAssign;
	case BitOpAShrAssign;

	case IntOpAdd;
	case IntOpSub;
	case IntOpMul;
	case IntOpNeg;
	case IntOpInc;
	case IntOpDec;

	case IntOpAddAssign;
	case IntOpSubAssign;
	case IntOpMulAssign;

	case SIntOpLT;
	case SIntOpLE;
	case SIntOpGT;
	case SIntOpGE;
	case SIntOpCmp;

	case SIntOpDiv;
	case SIntOpMod;

	case SIntOpDivAssign;
	case SIntOpModAssign;

	case UIntOpLT;
	case UIntOpLE;
	case UIntOpGT;
	case UIntOpGE;
	case UIntOpCmp;

	case UIntOpDiv;
	case UIntOpMod;

	case UIntOpDivAssign;
	case UIntOpModAssign;

	case FloatOpEQ;
	case FloatOpNE;
	case FloatOpLT;
	case FloatOpLE;
	case FloatOpGT;
	case FloatOpGE;
	case FloatOpCmp;

	case FloatOpAdd;
	case FloatOpSub;
	case FloatOpMul;
	case FloatOpDiv;
	case FloatOpMod;
	case FloatOpNeg;

	case FloatOpAddAssign;
	case FloatOpSubAssign;
	case FloatOpMulAssign;
	case FloatOpDivAssign;
	case FloatOpModAssign;

	case PointerGetNull;
	case PointerToRef;
	case RefToPointer;
	case PointerCast;

	case PointerDiff;
	case PointerOffset;
	case PointerOpIndex;

	// base type is source type, attached type target
	case IntCast: Type;
	case FloatCast: Type;
	case IntToFloat: Type;
	case FloatToInt: Type;

	// base type is first template parameter
	case SizeOf;
	case AlignmentOf;
	case ReferenceKindOf;

	// attached value is id of target case
	case VariantOpUnsafeAs: int;
	case VariantOpIs: int;

	case ArrayGetSize;
	case ArrayGetDataPointer;

	func name(this: &InlineBuiltinFunction) -> String {
		match this {
			case NoOp -> return "NoOp";
			case BitStoreNull -> return "BitStoreNull";
			case BitStoreValue -> return "BitStoreValue";
			case BitOpEQ -> return "BitOpEQ";
			case BitOpNE -> return "BitOpNE";
			case BitOpAnd -> return "BitOpAnd";
			case BitOpOr -> return "BitOpOr";
			case BitOpXOr -> return "BitOpXOr";
			case BitOpNot -> return "BitOpNot";
			case BitOpShl -> return "BitOpShl";
			case BitOpLShr -> return "BitOpLShr";
			case BitOpAShr -> return "BitOpAShr";
			case BitOpAndAssign -> return "BitOpAndAssign";
			case BitOpOrAssign -> return "BitOpOrAssign";
			case BitOpXOrAssign -> return "BitOpXOrAssign";
			case BitOpShlAssign -> return "BitOpShlAssign";
			case BitOpLShrAssign -> return "BitOpLShrAssign";
			case BitOpAShrAssign -> return "BitOpAShrAssign";
			case IntOpAdd -> return "IntOpAdd";
			case IntOpSub -> return "IntOpSub";
			case IntOpMul -> return "IntOpMul";
			case IntOpNeg -> return "IntOpNeg";
			case IntOpInc -> return "IntOpInc";
			case IntOpDec -> return "IntOpDec";
			case IntOpAddAssign -> return "IntOpAddAssign";
			case IntOpSubAssign -> return "IntOpSubAssign";
			case IntOpMulAssign -> return "IntOpMulAssign";
			case SIntOpLT -> return "SIntOpLT";
			case SIntOpLE -> return "SIntOpLE";
			case SIntOpGT -> return "SIntOpGT";
			case SIntOpGE -> return "SIntOpGE";
			case SIntOpCmp -> return "SIntOpCmp";
			case SIntOpDiv -> return "SIntOpDiv";
			case SIntOpMod -> return "SIntOpMod";
			case SIntOpDivAssign -> return "SIntOpDivAssign";
			case SIntOpModAssign -> return "SIntOpModAssign";
			case UIntOpLT -> return "UIntOpLT";
			case UIntOpLE -> return "UIntOpLE";
			case UIntOpGT -> return "UIntOpGT";
			case UIntOpGE -> return "UIntOpGE";
			case UIntOpCmp -> return "UIntOpCmp";
			case UIntOpDiv -> return "UIntOpDiv";
			case UIntOpMod -> return "UIntOpMod";
			case UIntOpDivAssign -> return "UIntOpDivAssign";
			case UIntOpModAssign -> return "UIntOpModAssign";
			case FloatOpEQ -> return "FloatOpEQ";
			case FloatOpNE -> return "FloatOpNE";
			case FloatOpLT -> return "FloatOpLT";
			case FloatOpLE -> return "FloatOpLE";
			case FloatOpGT -> return "FloatOpGT";
			case FloatOpGE -> return "FloatOpGE";
			case FloatOpCmp -> return "FloatOpCmp";
			case FloatOpAdd -> return "FloatOpAdd";
			case FloatOpSub -> return "FloatOpSub";
			case FloatOpMul -> return "FloatOpMul";
			case FloatOpDiv -> return "FloatOpDiv";
			case FloatOpMod -> return "FloatOpMod";
			case FloatOpNeg -> return "FloatOpNeg";
			case FloatOpAddAssign -> return "FloatOpAddAssign";
			case FloatOpSubAssign -> return "FloatOpSubAssign";
			case FloatOpMulAssign -> return "FloatOpMulAssign";
			case FloatOpDivAssign -> return "FloatOpDivAssign";
			case FloatOpModAssign -> return "FloatOpModAssign";
			case PointerGetNull -> return "PointerGetNull";
			case PointerToRef -> return "PointerToRef";
			case RefToPointer -> return "RefToPointer";
			case PointerCast -> return "PointerCast";
			case PointerDiff -> return "PointerDiff";
			case PointerOffset -> return "PointerOffset";
			case PointerOpIndex -> return "PointerOpIndex";
			case IntCast -> return "IntCast";
			case FloatCast -> return "FloatCast";
			case IntToFloat -> return "IntToFloat";
			case FloatToInt -> return "FloatToInt";
			case SizeOf -> return "SizeOf";
			case AlignmentOf -> return "AlignmentOf";
			case ReferenceKindOf -> return "ReferenceKindOf";
			case VariantOpIs -> return "VariantOpIs";
			case VariantOpUnsafeAs -> return "VariantOpUnsafeAs";
			case ArrayGetSize -> return "ArrayGetSize";
			case ArrayGetDataPointer -> return "ArrayGetDataPointer";
		}
	}

	func dump(this: &InlineBuiltinFunction, out: &&TreeFormatter) -> void {
		out.attribute(this.name());

		if this.base_type.isAlive() {
			out.value(this.base_type.signature());
		}

		match this {
			case IntCast: type -> out.value(type.signature());
			case FloatCast: type -> out.value(type.signature());
			case IntToFloat: type -> out.value(type.signature());
			case FloatToInt: type -> out.value(type.signature());
			case VariantOpUnsafeAs: id -> out.value(format(id));
			case VariantOpIs: id -> out.value(format(id));
			else -> {}
		}
	}
}

variant BuiltinFunction {
	var base_type: Type;

	case StructDefaultConstructor;
	case StructCopyConstructor;
	case StructDestructor;
	case StructOpAssign;
	case StructOpEqual;
	case StructOpCmp;

	case VariantCaseConstructor: int;
	case VariantCopyConstructor;
	case VariantDestructor;
	case VariantOpAssign;
	case VariantOpEqual;

	case ArrayDefaultConstructor;
	case ArrayCopyConstructor;
	case ArrayDestructor;
	case ArrayOpAssign;
	case ArrayOpEqual;

	func name(this: &BuiltinFunction) -> String {
		match this {
			case StructDefaultConstructor -> return "StructDefaultConstructor";
			case StructCopyConstructor -> return "StructCopyConstructor";
			case StructDestructor -> return "StructDestructor";
			case StructOpAssign -> return "StructOpAssign";
			case StructOpEqual -> return "StructOpEqual";
			case StructOpCmp -> return "StructOpCmp";
			case VariantCaseConstructor -> return "VariantCaseConstructor";
			case VariantCopyConstructor -> return "VariantCopyConstructor";
			case VariantDestructor -> return "VariantDestructor";
			case VariantOpAssign -> return "VariantOpAssign";
			case VariantOpEqual -> return "VariantOpEqual";
			case ArrayDefaultConstructor -> return "ArrayDefaultConstructor";
			case ArrayCopyConstructor -> return "ArrayCopyConstructor";
			case ArrayDestructor -> return "ArrayDestructor";
			case ArrayOpAssign -> return "ArrayOpAssign";
			case ArrayOpEqual -> return "ArrayOpEqual";
		}
	}

	func dump(this: &BuiltinFunction, out: &&TreeFormatter) -> void {
		out.attribute(this.name());
		out.value(this.base_type.signature());

		match this {
			case VariantCaseConstructor: id -> out.value(format(id));
			else -> {}
		}
	}
}

variant Stmt {
	var span: Span;

	case Empty;

	case Compound: CompoundStmt;

	case Expr: Expr;

	case If: IfStmt;
	case While: WhileStmt;

	case Case: CaseStmt;
	case ElseCase: Box!<Stmt>;

	case Break;
	case Continue;
	case Yield;

	case Return: Expr;

	case LifeTimeStart: WeakPtr!<VarDecl>;
	case LifeTimeEnd: WeakPtr!<VarDecl>;

	func dump(this: &Stmt, out: &&TreeFormatter, is_last: bool) -> void {
		match this {
			case Empty -> {
				out.push("EmptyStmt", is_last);
				out.span(this.span);
				out.pop();
			}
			case Compound: compound_stmt -> compound_stmt.dump(&&out, is_last);
			case Expr: expr -> expr.dump(&&out, is_last);
			case If: if_stmt -> {
				out.push("IfStmt", is_last);
				out.span(this.span);

				if_stmt.condition.dump(&&out, false);
				if_stmt.then_branch.dump(&&out, false);
				if_stmt.else_branch.dump(&&out, true);

				out.pop();
			}
			case While: while_stmt -> {
				match while_stmt.kind {
					case While -> out.push("WhileStmt", is_last);
					case DoWhile -> out.push("DoWhileStmt", is_last);
				}
				out.span(this.span);

				while_stmt.condition.dump(&&out, false);
				while_stmt.body.dump(&&out, false);

				out.pop();
			}
			case Case -> {}
			case ElseCase -> {}
			case Break -> {
				out.push("BreakStmt", is_last);
				out.span(this.span);
				out.pop();
			}
			case Continue -> {
				out.push("ContinueStmt", is_last);
				out.span(this.span);
				out.pop();
			}
			case Yield -> {
				out.push("YieldStmt", is_last);
				out.span(this.span);
				out.pop();
			}
			case Return: value -> {
				out.push("ReturnStmt", is_last);
				out.span(this.span);
				value.dump(&&out, true);
				out.pop();
			}
			case LifeTimeStart: variable -> {
				const decl = variable.forceLock();
				decl.dump(&&out, is_last);
			}
			case LifeTimeEnd: variable -> {
				out.push("LifeTimeEnd", is_last);
				const decl = variable.forceLock();
				out.value(decl.name);
				out.span(decl.span);
				out.pop();
			}
		}
	}

	func isTerminator(this: &Stmt, never_type: Type) -> bool {
		return this.isTerminator(never_type, true);
	}

	func isTerminator(this: &Stmt, never_type: Type, yield_is_terminator: bool) -> bool {
		match this {
			case Empty -> return false;
			case Compound: compound_stmt -> return compound_stmt.isTerminator(never_type);
			case Expr: expr -> return expr.type == never_type;
			case If: if_stmt -> return if_stmt.then_branch.isTerminator(never_type) && if_stmt.else_branch.isTerminator(never_type);
			case While: while_stmt -> return while_stmt.kind == DoWhile && while_stmt.body.isTerminator(never_type);
			case Case: case_stmt -> return case_stmt.body.isTerminator(never_type);
			case ElseCase: body -> return body.isTerminator(never_type);
			case Break
			| Continue
			| Return -> return true;
			case Yield -> return yield_is_terminator;
			case LifeTimeStart
			| LifeTimeEnd -> return false;
		}
	}
}

struct CompoundStmt {
	var span: Span;
	var children: SharedPtr!<List!<Stmt>>;

	func constructor(this: &&CompoundStmt, span: Span) -> void {
		this.span := span;
		this.children := SharedPtr!<List!<Stmt>>::new(List!<Stmt>());
	}

	func constructor(this: &&CompoundStmt, other: CompoundStmt) -> void = default;
	func destructor(this: &&CompoundStmt) -> void = default;

	operator =(this: &&CompoundStmt, other: CompoundStmt) -> void = default;

	operator ==(this: CompoundStmt, other: CompoundStmt) -> bool {
		return this.children.data == other.children.data;
	}

	func dump(this: &CompoundStmt, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("CompoundStmt", is_last);
		out.span(this.span);

		for i in 0u..this.children.size() {
			this.children[i].dump(&&out, i == this.children.size() - 1);
		}

		out.pop();
	}

	func isTerminator(this: &CompoundStmt, never_type: Type) -> bool {
		if const last = this.children.last() {
			return last.isTerminator(never_type);
		}
		return false;
	}
}

struct IfStmt {
	var condition: Expr;
	var condition_cleanup: List!<Stmt>;
	var then_branch: Box!<Stmt>;
	var else_branch: Box!<Stmt>;

	func constructor(this: &&IfStmt, condition: Expr, condition_cleanup: List!<Stmt>, then_branch: Stmt, else_branch: Stmt) -> void {
		this.condition := condition;
		this.condition_cleanup := condition_cleanup;
		this.then_branch := then_branch;
		this.else_branch := else_branch;
	}

	func constructor(this: &&IfStmt, other: IfStmt) -> void = default;
	func destructor(this: &&IfStmt) -> void = default;

	operator =(this: &&IfStmt, other: IfStmt) -> void = default;

	operator ==(this: IfStmt, other: IfStmt) -> bool = default;
}

struct WhileStmt {
	var condition: Expr;
	var condition_cleanup: List!<Stmt>;
	var body: Box!<Stmt>;
	var kind: WhileStmtKind;

	func constructor(this: &&WhileStmt, condition: Expr, condition_cleanup: List!<Stmt>, body: Stmt, kind: WhileStmtKind) -> void {
		this.condition := condition;
		this.condition_cleanup := condition_cleanup;
		this.body := body;
		this.kind := kind;
	}

	func constructor(this: &&WhileStmt, other: WhileStmt) -> void = default;
	func destructor(this: &&WhileStmt) -> void = default;

	operator =(this: &&WhileStmt, other: WhileStmt) -> void = default;

	operator ==(this: WhileStmt, other: WhileStmt) -> bool = default;
}

enum WhileStmtKind {
	case While;
	case DoWhile;
}

struct CaseStmt {
	var span: Span;
	var patterns: List!<Expr>;
	var body: Box!<Stmt>;

	func constructor(this: &&CaseStmt, span: Span, patterns: List!<Expr>, body: Stmt) -> void {
		this.span := span;
		this.patterns := patterns;
		this.body := body;
	}

	func constructor(this: &&CaseStmt, other: CaseStmt) -> void = default;
	func destructor(this: &&CaseStmt) -> void = default;

	operator =(this: &&CaseStmt, other: CaseStmt) -> void = default;

	operator ==(this: CaseStmt, other: CaseStmt) -> bool = default;

	func dump(this: &CaseStmt, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("CaseStmt", is_last);
		out.span(this.span);

		for pattern in this.patterns {
			pattern.dump(&&out, false);
		}

		this.body.dump(&&out, true);
		out.pop();
	}
}

variant Expr {
	var span: Span;
	var type: Type;

	case Undefined;

	case Void;
	case Integer: int;
	case Float: f64;
	case String: String;

	case ConstAggregate: List!<Expr>;

	case Call: CallExpr;
	case Match: MatchExpr;

	case VarInvoke: WeakPtr!<VarDecl>;
	case MemberVarInvoke: MemberVarInvokeExpr;

	case Dereference: Box!<Expr>;

	case ShallowCopy: ShallowCopyExpr;

	case TypeRef: Type;
	case FunctionRef: SharedHandle!<FunctionDecl>;

	func constructor(this: &&Expr) -> void {
		this.constructor!<0>(Span(), Type::unknown());
	}

	func toBool(this: &Expr) -> bool {
		match this {
			case Integer: val -> return val != 0;
			else -> return false;
		}
	}

	func toInt(this: &Expr) -> int {
		match this {
			case Integer: val -> return val;
			else -> return 0;
		}
	}

	func toUInt(this: &Expr) -> uint {
		match this {
			case Integer: val -> return val as uint;
			else -> return 0u;
		}
	}

	func toFloat(this: &Expr) -> f64 {
		match this {
			case Float: val -> return val;
			else -> return 0.0;
		}
	}

	func dump(this: &Expr, out: &&TreeFormatter, is_last: bool) -> void {
		match this {
			case Undefined -> {
				out.push("UndefinedExpr", is_last);
				out.span(this.span);
				out.pop();
			}
			case Void -> {
				out.push("VoidExpr", is_last);
				out.span(this.span);
				out.pop();
			}
			case Integer: value -> {
				out.push("IntegerExpr", is_last);
				out.value(format(value));
				out.attribute(this.type.signature());
				out.span(this.span);
				out.pop();
			}
			case Float: value -> {
				out.push("FloatExpr", is_last);
				//out.value(format(value));
				out.attribute(this.type.signature());
				out.span(this.span);
				out.pop();
			}
			case String: value -> {
				out.push("StringExpr", is_last);
				out.value("\"" + value + "\"");
				out.attribute(this.type.signature());
				out.span(this.span);
				out.pop();
			}
			case ConstAggregate -> {}
			case Call: call_expr -> {
				out.push("CallExpr", is_last);
				out.value(call_expr.function.signature());
				out.attribute(call_expr.return_kind.toString());
				out.span(this.span);

				if const result_var = call_expr.result_var.lock() {
					result_var.dump(&&out, call_expr.parameters.isEmpty());
				}

				for i in 0u..call_expr.parameters.size() {
					call_expr.parameters[i].dump(&&out, i == call_expr.parameters.size() - 1);
				}

				out.pop();
			}
			case Match: match_expr -> {
				out.push("MatchExpr", is_last);
				out.attribute(this.type.signature());
				out.span(this.span);

				match_expr.value.dump(&&out, false);
				if const yield_var = match_expr.yield_var.lock() {
					yield_var.dump(&&out, false);
				}

				for i in 0u..match_expr.cases.size() {
					match_expr.cases[i].dump(&&out, i == match_expr.cases.size() - 1 && match_expr.else_case is None);
				}

				if const else_case = match_expr.else_case {
					else_case.dump(&&out, true);
				}

				out.pop();
			}
			case VarInvoke: variable -> {
				out.push("VarInvokeExpr", is_last);
				const decl = variable.forceLock();
				out.value(("#" if decl.is_parameter else "") + decl.name);
				out.attribute(this.type.signature());
				out.span(this.span);
				out.pop();
			}
			case MemberVarInvoke: member_var_invoke_expr -> {
				out.push("MemberVarInvokeExpr", is_last);
				out.value(format(member_var_invoke_expr.id));
				out.attribute(this.type.signature());
				out.span(this.span);
				member_var_invoke_expr.object.dump(&&out, true);
				out.pop();
			}
			case Dereference: base -> {
				out.push("DereferenceExpr", is_last);
				out.attribute(this.type.signature());
				out.span(this.span);
				base.dump(&&out, true);
				out.pop();
			}
			case ShallowCopy: shallow_copy_expr -> {
				out.push("ShallowCopyExpr", is_last);
				out.span(this.span);
				shallow_copy_expr.destination.dump(&&out, false);
				shallow_copy_expr.value.dump(&&out, true);
				out.pop();
			}
			case TypeRef: type -> {
				out.push("TypeRefExpr", is_last);
				out.span(this.span);
				out.value(type.signature());
				out.pop();
			}
			case FunctionRef: function -> {
				out.push("FunctionRefExpr", is_last);
				out.span(this.span);
				out.value(function.signature());
				out.pop();
			}
		}
	}
}

enum ReturnKind {
	case None;		// function returns void or never
	case Value;		// most basic, no memory management
	case Variable;	// result gets stored in variable allocated by caller
	case Parameter;	// callee initializes variable allocated by caller, passed by reference as first parameter
	case VariableButYieldNone;	// same as variable, but result gets discarded. Used when initializing a variable with the result of a call (optimized)

	func toString(this: ReturnKind) -> String {
		match this {
			case None -> return "None";
			case Value -> return "Value";
			case Variable -> return "Variable";
			case Parameter -> return "Parameter";
			case VariableButYieldNone -> return "VariableButYieldNone";
		}
	}
}

struct CallExpr {
	var function: SharedHandle!<FunctionDecl>;
	var parameters: List!<Expr>;
	var result_var: WeakPtr!<VarDecl>;
	var return_kind: ReturnKind;
	var is_copy_constructor_call: bool;

	func constructor(this: &&CallExpr, function: SharedHandle!<FunctionDecl>, parameters: List!<Expr>, result_var: WeakPtr!<VarDecl>, return_kind: ReturnKind, is_copy_constructor_call: bool) -> void {
		this.function := function;
		this.parameters := parameters;
		this.result_var := result_var;
		this.return_kind := return_kind;
		this.is_copy_constructor_call := is_copy_constructor_call;
	}

	func constructor(this: &&CallExpr, other: CallExpr) -> void = default;
	func destructor(this: &&CallExpr) -> void = default;

	operator =(this: &&CallExpr, other: CallExpr) -> void = default;

	operator ==(this: CallExpr, other: CallExpr) -> bool = default;
}

struct MatchExpr {
	var value: Box!<Expr>;
	var cases: List!<CaseStmt>;
	var else_case: Optional!<Box!<Stmt>>;
	var yield_var: WeakPtr!<VarDecl>;

	func constructor(this: &&MatchExpr) -> void {
		this.value := Expr::Undefined(Span(), Type::unknown());
	}

	func constructor(this: &&MatchExpr, value: Expr) -> void {
		this.value := value;
	}

	func constructor(this: &&MatchExpr, other: MatchExpr) -> void = default;
	func destructor(this: &&MatchExpr) -> void = default;

	operator =(this: &&MatchExpr, other: MatchExpr) -> void = default;

	operator ==(this: MatchExpr, other: MatchExpr) -> bool = default;
}

struct MemberVarInvokeExpr {
	var object: Box!<Expr>;
	var id: uint;

	func constructor(this: &&MemberVarInvokeExpr, object: Expr, id: uint) -> void {
		this.object := object;
		this.id := id;
	}

	func constructor(this: &&MemberVarInvokeExpr, other: MemberVarInvokeExpr) -> void = default;
	func destructor(this: &&MemberVarInvokeExpr) -> void = default;

	operator =(this: &&MemberVarInvokeExpr, other: MemberVarInvokeExpr) -> void = default;

	operator ==(this: MemberVarInvokeExpr, other: MemberVarInvokeExpr) -> bool = default;
}

struct ShallowCopyExpr {
	var destination: Box!<Expr>;
	var value: Box!<Expr>;

	func constructor(this: &&ShallowCopyExpr, destination: Expr, value: Expr) -> void {
		this.destination := destination;
		this.value := value;
	}

	func constructor(this: &&ShallowCopyExpr, other: ShallowCopyExpr) -> void = default;
	func destructor(this: &&ShallowCopyExpr) -> void = default;

	operator =(this: &&ShallowCopyExpr, other: ShallowCopyExpr) -> void = default;

	operator ==(this: ShallowCopyExpr, other: ShallowCopyExpr) -> bool = default;
}

func addDereference(this: Expr) -> Expr {
	match this.type.reference_kind {
		case None -> return this;
		else -> return Expr::Dereference(Box!<Expr>(this), this.span, this.type.base());
	}
}

func removeDereference(this: Expr) -> Expr {
	match this {
		case Dereference: base -> return base.operator unwrap();
		else -> return this;
	}
}

func getExprListTypes(expressions: List!<Expr>) -> List!<Type> {
	var types: List!<Type>;
	for expr in expressions {
		types.append(expr.type);
	}
	return types;
}

func format(template_parameters: List!<TemplateParameterDecl>) -> String {
	if template_parameters.isEmpty() {
		return "";
	}

	var result = "!<";
	for i in 0u..template_parameters.size() {
		if i != 0 {
			result += ", ";
		}

		result += template_parameters[i].signature();
	}

	return result + ">";
}

func format(template_parameters: List!<TemplateParameter>) -> String {
	if template_parameters.isEmpty() {
		return "";
	}

	var result = "!<";
	for i in 0u..template_parameters.size() {
		if i != 0 {
			result += ", ";
		}

		result += template_parameters[i].toString();
	}

	return result + ">";
}

func format(types: List!<Type>) -> String {
	var result = "(";
	for i in 0u..types.size() {
		if i != 0 {
			result += ", ";
		}

		result += types[i].signature();
	}

	return result + ")";
}
