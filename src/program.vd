import std/core;
import std/box;
import std/format;
import std/io;
import std/list;
import std/map;
import std/math;
import std/set;
import std/shared_list;
import std/string;

import llvm_c;
import llvm_util;

import error;
import operators;
import options;
import span;
import tree_formatter;

struct CompilationUnit {
	var id: uint;
	var group: uint;
	var name: String;
	var path: String;
	var source: String;
	var line_spans: List!<Span>;

	var nodes: List!<Node>;
	var top_level_nodes: List!<uint>;

	var llvm_di_file: LLVMMetadataRef;
	var llvm_di_module: LLVMMetadataRef;

	func constructor(this: &&CompilationUnit, id: uint, group: uint, name: String, path: String, source: String, line_spans: &List!<Span>) -> void {
		this.id := id;
		this.group := group;
		this.name := name;
		this.path := path;
		this.source := source;
		this.line_spans := line_spans;

		this.nodes := ();
		this.nodes.append(Node::Empty(Span(), Type::unknown(), false));
		this.nodes.append(Node::Garbage(Span(), Type::unknown(), false));
	}

	func constructor(this: &&CompilationUnit, other: CompilationUnit) -> void = default;
	func destructor(this: &&CompilationUnit) -> void = default;

	operator =(this: &&CompilationUnit, other: CompilationUnit) -> void = default;

	operator ==(this: CompilationUnit, other: CompilationUnit) -> bool {
		return this.path == other.path;
	}

	func getASTNode(this: &CompilationUnit, id: uint) -> &Node {
		return &this.nodes[id];
	}

	func addASTNode(this: &&CompilationUnit, node: &Node) -> uint {
		if node is Empty {
			return this.getEmptyNode();
		} else if node is Garbage {
			return this.getGarbageNode();
		}

		const id = this.nodes.size();
		this.nodes.append(node);
		return id;
	}

	func getEmptyNode(this: &CompilationUnit) -> uint {
		return 0u;
	}

	func getGarbageNode(this: &CompilationUnit) -> uint {
		return 1u;
	}

	func duplicateNodes(this: &&CompilationUnit, start: uint, end: uint) -> uint {
		assert(start <= end, Error::EINVAL);

		const result_start = this.nodes.size();
		const result_end = result_start + (end - start);
		const result_offset = result_start - start;

		this.nodes.grow(end - start);
		for i in start..end {
			this.nodes.append(this.nodes[i]);
			this.nodes[this.nodes.size() - 1].addIdOffset(result_offset);
		}

		return result_offset;
	}

	func isTerminator(this: &CompilationUnit, node_id: uint, never_type: Type, yield_is_terminator: bool) -> bool {
		match this.nodes[node_id] {
			case Empty -> return false;
			case CompoundStmt: children -> {
				if const last = children.last() {
					return this.isTerminator(last, never_type, yield_is_terminator);
				}
				return false;
			}
			case IfStmt: if_stmt -> return this.isTerminator(if_stmt.then_branch, never_type, yield_is_terminator) && this.isTerminator(if_stmt.else_branch, never_type, yield_is_terminator);
			case WhileStmt: while_stmt -> return while_stmt.kind == DoWhile && this.isTerminator(while_stmt.body, never_type, yield_is_terminator);
			case ForStmt: for_stmt -> return false;
			case CaseStmt: case_stmt -> return false;
			case ElseCaseStmt: body -> return this.isTerminator(body, never_type, yield_is_terminator);
			case BreakStmt | ContinueStmt | ReturnStmt -> return true;
			case YieldStmt -> return yield_is_terminator;
			case LifeTimeStart | LifeTimeEnd -> return false;
			else -> return this.nodes[node_id].type == never_type;
		}
	}

	func addDereference(this: &&CompilationUnit, node_id: uint) -> uint {
		match this.nodes[node_id].type.reference_kind {
			case None -> return node_id;
			else -> return this.addASTNode(Node::DereferenceExpr(node_id, this.nodes[node_id].span, this.nodes[node_id].type.base(), false));
		}
	}

	func removeDereference(this: &CompilationUnit, node_id: uint) -> uint {
		match this.nodes[node_id] {
			case DereferenceExpr: base -> return base;
			else -> return node_id;
		}
	}

	func dump(this: &CompilationUnit) -> String {
		var out: TreeFormatter = ("Module");
		out.value(this.name);

		for i in 0u..this.top_level_nodes.size() {
			this.dump(&&out, this.top_level_nodes[i], i == this.top_level_nodes.size() - 1);
		}

		return out.finalize();
	}

	func dump(this: &CompilationUnit, out: &&TreeFormatter, index: uint, is_last: bool) -> void {
		out.push(this.nodes[index].name(), is_last);
		out.span(this.nodes[index].span);
		out.attribute(this.nodes[index].type.signature());

		match this.nodes[index] {
			case Empty
			| Garbage
			| ExternFunctionBody
			| DefaultFunctionBody -> {}
			case Pragma: &name -> out.attribute(name);
			case Import: &name -> out.attribute(name);
			case NamespaceDecl: &decl -> {
				for &annotation in decl.annotations {
					this.dump(&&out, annotation, false);
				}

				for &template_parameter in decl.template_parameters {
					this.dump(&&out, template_parameter, false);
				}

				this.dump(&&out, decl.body, true);
			}
			case TypeDecl: &decl -> {
				match decl.kind {
					case Struct -> out.value("struct");
					case Enum -> out.value("enum");
					case Variant -> out.value("variant");
				}
				out.attribute(decl.name);

				for &annotation in decl.annotations {
					this.dump(&&out, annotation, false);
				}

				for &template_parameter in decl.template_parameters {
					this.dump(&&out, template_parameter, false);
				}

				this.dump(&&out, decl.body, true);
			}
			case FunctionDecl: &decl -> {
				if decl.is_comptime {
					out.value("comptime");
				}

				out.attribute(decl.signature.name);

				for annotation in decl.annotations {
					this.dump(&&out, annotation, false);
				}

				for template_parameter in decl.template_parameters {
					this.dump(&&out, template_parameter, false);
				}

				for parameter in decl.signature.parameters {
					this.dump(&&out, parameter, false);
				}

				this.dump(&&out, decl.signature.return_type, false);

				this.dump(&&out, decl.body, true);
			}
			case AliasDecl: &data -> {
				out.value(data.name);
				this.dump(&&out, data.type, true);
			}
			case VarDecl: &decl -> {
				if !decl.is_parameter {
					out.attribute("const" if decl.is_const else "var");
				}
				out.value(this.name);

				this.dump(&&out, decl.type, false);
				this.dump(&&out, decl.initializer, true);
			}
			case CaseDecl: &decl -> {
				out.attribute(decl.name);
				this.dump(&&out, decl.payload, false);
				this.dump(&&out, decl.id, true);
			}
			case CompoundStmt: &children -> {
				for i in 0u..children.size() {
					this.dump(&&out, children[i], i == children.size() - 1);
				}
			}
			case IfStmt: &if_stmt -> {
				this.dump(&&out, if_stmt.condition, false);
				for c in if_stmt.condition_cleanup {
					this.dump(&&out, c, false);
				}
				this.dump(&&out, if_stmt.then_branch, false);
				this.dump(&&out, if_stmt.else_branch, true);
			}
			case IfVarStmt: &if_var_stmt -> {
				this.dump(&&out, if_var_stmt.var_decl, false);
				this.dump(&&out, if_var_stmt.body, true);
			}
			case VarElseStmt: &var_else_stmt -> {
				out.attribute(format(var_else_stmt.capture_kind) + var_else_stmt.capture_name);
				this.dump(&&out, var_else_stmt.var_decl, false);
				this.dump(&&out, var_else_stmt.body, true);
			}
			case WhileStmt: &while_stmt -> {
				this.dump(&&out, while_stmt.condition, false);
				for c in while_stmt.condition_cleanup {
					this.dump(&&out, c, false);
				}
				this.dump(&&out, while_stmt.body, true);
			}
			case ParsedForStmt: &for_stmt -> {
				out.attribute(format(for_stmt.capture_kind) + for_stmt.capture_name);
				this.dump(&&out, for_stmt.range, false);
				this.dump(&&out, for_stmt.body, true);
			}
			case ForStmt: &for_stmt -> {
				this.dump(&&out, for_stmt.enumerator_variable, false);
				this.dump(&&out, for_stmt.iterator, false);
				this.dump(&&out, for_stmt.body, true);
			}
			case CaseStmt: case_stmt -> {
				out.attribute(format(case_stmt.capture_kind) + case_stmt.capture_name);
				for pattern in case_stmt.patterns {
					this.dump(&&out, pattern, false);
				}
				this.dump(&&out, case_stmt.body, true);
			}
			case ElseCaseStmt: body -> this.dump(&&out, body, true);
			case BreakStmt | ContinueStmt -> {}
			case DeferStmt: body -> this.dump(&&out, body, true);
			case ThrowStmt: expr -> this.dump(&&out, expr, true);
			case ReturnStmt: value -> this.dump(&&out, value, true);
			case YieldStmt: value -> this.dump(&&out, value, true);
			case DiscardStmt: expr -> this.dump(&&out, expr, true);
			case LifeTimeStart: variable -> this.dump(&&out, variable, true);
			case LifeTimeEnd: variable -> out.value(variable.signature());
			case Name: &name -> {
				out.value(name.name);
				for i in 0u..name.template_parameters.size() {
					this.dump(&&out, name.template_parameters[i], i == name.template_parameters.size() - 1);
				}
			}
			case IntegerLiteralExpr: value -> out.value(format(value));
			case FloatLiteralExpr: value -> out.value(format(value as int));
			case BoolLiteralExpr: value -> out.attribute(format(value));
			case NumberLiteralExpr: &literal -> out.attribute(format(literal.value) + literal.postfix);
			case CharLiteralExpr: &literal -> out.attribute("\'" + literal.value + "\'" + literal.postfix);
			case StringLiteralExpr: &literal -> out.attribute("\"" + literal.value + "\"" + literal.postfix);
			case ConstAggregateExpr: elements -> {
				for i in 0u..elements.size() {
					this.dump(&&out, elements[i], i == elements.size());
				}
			}
			case UnaryOperatorExpr: &operator_expr -> {
				out.attribute(format(operator_expr.op));
				this.dump(&&out, operator_expr.operand, true);
			}
			case BinaryOperatorExpr: &operator_expr -> {
				out.attribute(format(operator_expr.op));
				this.dump(&&out, operator_expr.lhs, false);
				this.dump(&&out, operator_expr.rhs, true);
			}
			case CallExpr: &call_expr -> {
				if call_expr.function.isAlive() {
					out.value(call_expr.function.signature());
				} else {
					this.dump(&&out, call_expr.callee, call_expr.parameters.isEmpty());
				}

				for i in 0u..call_expr.parameters.size() {
					this.dump(&&out, call_expr.parameters[i], i == call_expr.parameters.size() - 1);
				}
			}
			case IndexExpr: &operands -> {
				for i in 0u..operands.size() {
					this.dump(&&out, operands[i], i == operands.size() - 1);
				}
			}
			case InlineIfExpr: &inline_if_expr -> {
				this.dump(&&out, inline_if_expr.condition, false);
				this.dump(&&out, inline_if_expr.then_value, false);
				this.dump(&&out, inline_if_expr.else_value, true);
			}
			case ArrayExpr: &elements -> {
				for i in 0u..elements.size() {
					this.dump(&&out, elements[i], i == elements.size() - 1);
				}
			}
			case TupleExpr: &elements -> {
				for i in 0u..elements.size() {
					out.push("TupleElement", i == elements.size() - 1);
					out.attribute(elements[i].name);
					out.span(elements[i].span);
					this.dump(&&out, elements[i].value, true);
					out.pop();
				}
			}
			case DictExpr: &elements -> {
				for i in 0u..elements.size() {
					out.push("DictElement", i == elements.size() - 1);
					out.span(elements[i].span);
					this.dump(&&out, elements[i].key, true);
					this.dump(&&out, elements[i].value, true);
					out.pop();
				}
			}
			case MatchExpr: &match_expr -> {
				this.dump(&&out, match_expr.value, false);
				if match_expr.body > 1 {
					this.dump(&&out, match_expr.body, true);
				} else {
					for c in match_expr.cases {
						this.dump(&&out, c, false);
					}
					this.dump(&&out, match_expr.else_case, true);
				}
			}
			case TypeRefExpr: type -> out.value(type.signature());
			case FunctionRefExpr: function -> out.value(function.signature());
			case VarInvokeExpr: variable -> out.value(variable.signature());
			case ParsedFunctionRefExpr: &function -> {
				this.dump(&&out, function.name, false);
				for i in 0u..function.parameter_types.size() {
					this.dump(&&out, function.parameter_types[i], i == function.parameter_types.size() - 1);
				}
			}
			case AnonymousFunctionExpr: &function_decl -> this.dump(&&out, function_decl, true);
			case FunctionType: type -> {
				for t in type.parameter_types {
					this.dump(&&out, t, false);
				}
				this.dump(&&out, type.return_type, true);
			}
			case DereferenceExpr: target -> this.dump(&&out, target, true);
			case MemberVarInvokeExpr: expr -> {
				out.value(format(expr.id));
				this.dump(&&out, expr.object, true);
			}
			case ShallowCopyExpr: expr -> {
				this.dump(&&out, expr.destination, false);
				this.dump(&&out, expr.value, true);
			}
		}

		out.pop();
	}

	func dump(this: &CompilationUnit, out: &&TreeFormatter, annotation: &Annotation, is_last: bool) -> void {
		out.push("Annotation", is_last);
		out.span(annotation.span);
		out.attribute(annotation.name);

		match annotation {
			case Flag -> {}
			case String: value -> out.value(value);
			case Number: value -> out.value(format(value));
		}

		out.pop();
	}

	func dump(this: &CompilationUnit, out: &&TreeFormatter, template_parameter: &ParsedTemplateParameterDecl, is_last: bool) -> void {
		out.push("TemplateParameterDecl", is_last);
		out.attribute(template_parameter.name);
		out.text(": ");
		out.attribute(template_parameter.concept);
		this.dump(&&out, template_parameter.value, true);
		out.pop();
	}

	func dump(this: &CompilationUnit, out: &&TreeFormatter, variable: SharedHandle!<VarDecl>, is_last: bool) -> void {
		out.push("ParameterDecl" if variable.is_parameter else "VarDecl", is_last);

		if variable.is_comptime {
			out.value("comptime");
		}

		out.value("const" if variable.is_const else "var");
		out.attribute(("#" if variable.is_parameter else "") + variable.name);
		out.value(format(variable.id));
		out.text(" :");
		out.value(variable.type.signature());

		this.dump(&&out, variable.constructor_call, false);
		this.dump(&&out, variable.destructor_call, !variable.is_comptime);

		out.pop();
	}

	func dump(this: &CompilationUnit, out: &&TreeFormatter, decl:  &MemberVarDecl, is_last: bool) -> void {
		out.push("MemberVarDecl", is_last);
		out.attribute(decl.name);
		out.value(decl.type.signature());
		out.span(decl.span);
		this.dump(&&out, decl.initializer, true);
		out.pop();
	}

	func dump(this: &CompilationUnit, out: &&TreeFormatter, decl:  &EnumCaseDecl, is_last: bool) -> void {
		out.push("EnumCaseDecl", is_last);
		out.attribute(decl.name);
		out.value(format(decl.id));
		out.span(decl.span);
		out.pop();
	}

	func dump(this: &CompilationUnit, out: &&TreeFormatter, decl:  &VariantCaseDecl, is_last: bool) -> void {
		out.push("VariantCaseDecl", is_last);
		out.attribute(decl.name);
		out.value(format(decl.id));
		out.value(decl.type.signature());
		out.span(decl.span);
		out.pop();
	}
}

struct Program {
	var name: String;
	var options: CompilerOptions;

	var has_errors: bool;

	var files: SharedList!<CompilationUnit>;

	// namespaces
	var namespaces: SharedList!<Namespace>;
	var top_level_namespaces: List!<SharedHandle!<Namespace>>;
	var modules_by_path: Map!<String, SharedHandle!<Namespace>>;

	var core_namespace: SharedHandle!<Namespace>;

	// concepts
	var concepts: SharedList!<Concept>;
	var concepts_by_name: Map!<String, SharedHandle!<Concept>>;

	var any_concept: SharedHandle!<Concept>;
	var bool_concept: SharedHandle!<Concept>;
	var int_concept: SharedHandle!<Concept>;
	var uint_concept: SharedHandle!<Concept>;
	var string_concept: SharedHandle!<Concept>;

	// types
	var types: SharedList!<TypeDecl>;

	var void_type: Type;
	var never_type: Type;
	var bool_type: Type;
	var typeref_type: Type;
	var int_type: Type;
	var uint_type: Type;
	var byte_type: Type;
	var error_type: Type;

	// functions
	var functions: SharedList!<FunctionDecl>;

	var exit_function: SharedHandle!<FunctionDecl>;
	var abort_function: SharedHandle!<FunctionDecl>;
	var panic_function: SharedHandle!<FunctionDecl>;
	var assert_function: SharedHandle!<FunctionDecl>;
	var assert_error_function: SharedHandle!<FunctionDecl>;
	var main_function: SharedHandle!<FunctionDecl>;

	// llvm
	var llvm_context: LLVMContextRef;
	var llvm_module: LLVMModuleRef;
	var llvm_execution_engine: LLVMExecutionEngineRef;
	var data_layout: LLVMTargetDataRef;

	var string_globals: Map!<String, LLVMValueRef>;

	var di_builder: LLVMDIBuilderRef;
	var di_compile_unit: LLVMMetadataRef;

	func constructor(this: &&Program, options: CompilerOptions) -> void {
		this.name := options.program_name;
		this.options := options;

		this.has_errors := false;

		this.files := ();
		discard this.files.append(CompilationUnit(0u, 0u, "unknown", "unknown", "", List!<Span>()));

		this.namespaces := ();
		this.top_level_namespaces := ();

		this.llvm_context := LLVMContextCreate();
		this.llvm_module := LLVMModuleCreateWithNameInContext(this.name, this.llvm_context);
		LLVMSetSourceFileName(this.llvm_module, options.root_module_path);
		LLVMSetTarget(this.llvm_module, options.target_triple);
		LLVMSetDataLayout(this.llvm_module, options.target_data_layout);

		this.data_layout := LLVMGetModuleDataLayout(this.llvm_module);

		this.di_builder := ();
		if options.generate_debug_info {
			const int_type = LLVMIntTypeInContext(this.llvm_context, 64u);
			LLVMAddModuleFlag(this.llvm_module, LLVMModuleFlagBehavior::LLVMModuleFlagBehaviorError, "Dwarf Version", LLVMValueAsMetadata(LLVMConstInt(int_type, 5, false)));
			LLVMAddModuleFlag(this.llvm_module, LLVMModuleFlagBehavior::LLVMModuleFlagBehaviorWarning, "Debug Info Version", LLVMValueAsMetadata(LLVMConstInt(int_type, 3, false)));
			this.di_builder = LLVMCreateDIBuilder(this.llvm_module);

			this.files[0u].llvm_di_file = LLVMDIBuilderCreateFile(this.di_builder, "unknown", ".");

			this.di_compile_unit = LLVMDIBuilderCreateCompileUnit(
				this.di_builder,
				LLVMDWARFSourceLanguage::LLVMDWARFSourceLanguageC,
				this.files[0u].llvm_di_file,
				"",			// producer
				this.options.optimization_level != 0,
				"",			// flags
				0u,			// runtime version
				"",			// split name
				LLVMDWARFEmissionKind::LLVMDWARFEmissionFull,
				0u,			// dwo-id
				false,		// split debug inlining
				false,		// debug info for profiling
				"",			// sys-root
				"",			// sdk
			);

			this.files[0u].llvm_di_module = LLVMDIBuilderCreateModule(
				this.di_builder,
				this.di_compile_unit,
				this.files[0u].name,
				"",		// config macros
				"",		// include path
				"", 	// api notes file
			);
		}

		for i in 0u..options.import_search_paths.size() {
			var ns = this.namespaces.append(Namespace(format(i), List!<TemplateParameterDecl>(), SharedHandle!<Namespace>(), SharedHandle!<CompilationUnit>()));

			if this.di_builder != LLVMDIBuilderRef::null() {
				ns.llvm_di = LLVMDIBuilderCreateNameSpace(this.di_builder, this.files[0u].llvm_di_module, ns.name, true);
			}

			this.top_level_namespaces.append(ns);
		}

		this.llvm_execution_engine := ();

		LLVMLinkInMCJIT();
		LLVMInitializeX86TargetInfo();
		LLVMInitializeX86Target();
		LLVMInitializeX86TargetMC();
		LLVMInitializeX86AsmPrinter();

		match createJITCompilerForModule(this.llvm_module, min!<uint>(this.options.optimization_level, 3u)) {
			case Ok: ee -> this.llvm_execution_engine = ee;
			case Error: error -> panic(error);
		}
	}

	func destructor(this: &&Program) -> void {
		if this.di_builder != LLVMDIBuilderRef::null() {
			LLVMDisposeDIBuilder(this.di_builder);
		}

		LLVMDisposeExecutionEngine(this.llvm_execution_engine);
		LLVMContextDispose(this.llvm_context);

		LLVMShutdown();
	}

	func printError(this: &&Program, error: CompilationError) -> void {
		if error.type == Error {
			this.has_errors = true;
		}

		if this.options.hide_errors {
			return;
		}

		const span = error.span;
		const file = &this.files[span.file as uint];

		println(error.toString(file.path));

		if span.start == span.end {
			return;
		}

		var first_line = max!<int>(span.line as int - 1, 0) as uint;
		var last_line = span.line as uint + 1;
		while span.end > file.line_spans[last_line - 1].end && last_line < file.line_spans.size() {
			last_line++;
		}
		last_line = min!<uint>(last_line + 1, file.line_spans.size());

		const last_line_number = format(last_line);
		const max_line_number_width = last_line_number.size();

		for line in first_line..last_line {
			const line_span = file.line_spans[line];

			const line_number_str = format(line + 1);
			print(String(max_line_number_width - line_number_str.size() + 1, ' 'b) + line_number_str + " | ");

			const error_start = clamp!<uint>(span.start, line_span.start, line_span.end);
			const error_end = clamp!<uint>(span.end, line_span.start, line_span.end);

			print(file.source.substring(line_span.start..error_start));
			print("\e[31m");
			print(file.source.substring(error_start..error_end));
			print("\e[0m");
			print(file.source.substring(error_end..line_span.end));

			print("\n");
		}
	}

	func printErrors(this: &&Program, errors: &List!<CompilationError>) -> void {
		for e in errors {
			this.printError(e);
		}
	}

	func dump(this: &Program) -> String {
		var out: TreeFormatter = ("Program");
		out.attribute(this.name);
		if this.main_function.isAlive() {
			out.text(" main:");
			out.value(this.main_function.signature());
		}

		for concept in this.concepts {
			concept.dump(&&out, false);
		}

		for i in 0u..this.top_level_namespaces.size() {
			this.top_level_namespaces[i].dump(&&out, i == this.top_level_namespaces.size() - 1);
		}

		return out.finalize();
	}

	func createConcept(this: &&Program, concept: Concept) -> SharedHandle!<Concept> {
		const instance = this.concepts.append(concept);
		this.concepts_by_name[concept.name] = instance;
		return instance;
	}

	func getConcept(this: &Program, name: String) -> Optional!<SharedHandle!<Concept>> {
		return this.concepts_by_name.get(name);
	}

	func getOrCreateChildNamespace(this: &&Program, name: String, template_parameters: &List!<TemplateParameterDecl>, parent_namespace: SharedHandle!<Namespace>, file: SharedHandle!<CompilationUnit>) -> SharedHandle!<Namespace> {
		for child in parent_namespace.children {
			if child.name != name {
				continue;
			}

			if child.template_parameters != template_parameters {
				continue;
			}

			return child;
		}

		var child = this.namespaces.append(Namespace(name, template_parameters, parent_namespace, file));
		for &parameter in template_parameters {
			if const type = parameter.value as Type {
				child.imported_namespaces.add(type.decl.linked_namespace);
			}
		}

		// add child to parent namespace
		parent_namespace.children.append(child);
		parent_namespace.children_by_name[name].append(child);
		parent_namespace.updateMinState(NamespaceState::Unchecked);

		// initialize visible namespaces
		child.visible_namespaces.add(child);
		if file == parent_namespace.file {
			child.visible_namespaces.add(parent_namespace.visible_namespaces);
		}

		// initialize llvm debug info
		if this.di_builder != LLVMDIBuilderRef::null() {
			child.llvm_di = LLVMDIBuilderCreateNameSpace(this.di_builder, parent_namespace.llvm_di, child.name, true);
		}

		return child;
	}

	func createModule(this: &&Program, file: SharedHandle!<CompilationUnit>) -> SharedHandle!<Namespace> {
		const namespaces = file.name.split("/");

		var module = this.top_level_namespaces[file.group];
		for i in 0u..(namespaces.size() - 1) {
			module = this.getOrCreateChildNamespace(namespaces[i], List!<TemplateParameterDecl>(), module, SharedHandle!<CompilationUnit>());
		}
		module = this.getOrCreateChildNamespace(namespaces[namespaces.size() - 1], List!<TemplateParameterDecl>(), module, file);

		this.modules_by_path.set(file.path, module);
		return module;
	}

	func getModule(this: &&Program, path: String) -> Optional!<SharedHandle!<Namespace>> {
		return this.modules_by_path.get(path);
	}

	func createType(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: &List!<TemplateParameterDecl>, body: TypeBody) -> SharedHandle!<TypeDecl> {
		var linked_namespace = this.getOrCreateChildNamespace(name, template_parameters, parent_namespace, parent_namespace.file);
		var type_decl = this.types.append(TypeDecl(name, linked_namespace.template_parameters, body));

		type_decl.parent_namespace = linked_namespace.parent;
		type_decl.linked_namespace = linked_namespace;

		linked_namespace.linked_type = type_decl;

		parent_namespace.types.append(type_decl);
		parent_namespace.types_by_name[name].append(type_decl);

		return type_decl;
	}

	func createType(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, body: TypeBody) -> SharedHandle!<TypeDecl> {
		return this.createType(parent_namespace, name, List!<TemplateParameterDecl>(), body);
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: &List!<TemplateParameterDecl>, parameter_types: &List!<Type>, return_type: Type, body: FunctionBody) -> SharedHandle!<FunctionDecl> {
		var function = this.functions.append(FunctionDecl(name, template_parameters, body));

		function.parent_namespace = parent_namespace;
		function.parameter_types = parameter_types;
		function.return_type = return_type;

		parent_namespace.functions.append(function);
		parent_namespace.functions_by_name[name].append(function);

		if parent_namespace.linked_type.isAlive() {
			function.is_comptime |= parent_namespace.linked_type.is_comptime;
		}

		if !(body is Unchecked) {
			parent_namespace.addUncheckedFunction(function);
		}

		return function;
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: &List!<TemplateParameterDecl>, parameter_types: &List!<Type>, return_type: Type, body: BuiltinFunction) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, template_parameters, parameter_types, return_type, FunctionBody::Builtin(body));
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: &List!<TemplateParameterDecl>, body: FunctionBody) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, template_parameters, List!<Type>(), Type::unknown(), body);
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: &List!<TemplateParameterDecl>, body: BuiltinFunction) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, template_parameters, List!<Type>(), Type::unknown(), FunctionBody::Builtin(body));
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, parameter_types: &List!<Type>, return_type: Type, body: FunctionBody) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, List!<TemplateParameterDecl>(), parameter_types, return_type, body);
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, parameter_types: &List!<Type>, return_type: Type, body: BuiltinFunction) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, List!<TemplateParameterDecl>(), parameter_types, return_type, FunctionBody::Builtin(body));
	}

	func printLLVMIRToFile(this: &Program) -> Optional!<String> {
		const output_path = this.options.getOutputCodePath(".ll");
		if printModuleToFile(this.llvm_module, output_path) {
			return Some(output_path);
		} else {
			return None;
		}
	}

	func writeLLVMBitcodeToFile(this: &Program) -> Optional!<String> {
		const output_path = this.options.getOutputCodePath(".bc");
		if LLVMWriteBitcodeToFile(this.llvm_module, output_path) == 0 {
			return Some(output_path);
		} else {
			return None;
		}
	}

	func printLLVMIRString(this: &Program) -> String {
		return printModuleToString(this.llvm_module);
	}

	func finalizeDI(this: &Program) -> void {
		if this.di_builder != LLVMDIBuilderRef::null() {
			LLVMDIBuilderFinalize(this.di_builder);
		}
	}

	func runFunction(this: &Program, function: SharedHandle!<FunctionDecl>, args: &List!<LLVMGenericValueRef>) -> LLVMGenericValueRef {
		return LLVMRunFunction(this.llvm_execution_engine, function.llvm_func, args);
	}

	func runMainFunction(this: &Program, args: &List!<String>, env: &List!<String>) -> int {
		return LLVMRunFunctionAsMain(this.llvm_execution_engine, LLVMGetNamedFunction(this.llvm_module, "main"), args, env);
	}
}

variant Concept {
	var name: String;

	case Any;
	case Boolean;
	case Integer: bool;
	case String;

	func dump(this: &Concept, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("Concept", is_last);
		out.attribute(this.name);

		match this {
			case Any -> out.value("Any");
			case Boolean -> out.value("Boolean");
			case Integer: is_signed -> out.value("Integer " + ("signed" if is_signed else "unsigned"));
			case String -> out.value("String");
		}

		out.pop();
	}
}

struct TemplateParameterDecl {
	var name: String;

	var concept: SharedHandle!<Concept>;
	var is_variadic: bool;

	var value: TemplateParameter;

	func constructor(this: &&TemplateParameterDecl, name: String, concept: SharedHandle!<Concept>, is_variadic: bool) -> void {
		this.name := name;
		this.concept := concept;
		this.is_variadic := is_variadic;
		this.value := None;
	}

	func constructor(this: &&TemplateParameterDecl, name: String, concept: SharedHandle!<Concept>, is_variadic: bool, value: TemplateParameter) -> void {
		this.name := name;
		this.concept := concept;
		this.is_variadic := is_variadic;
		this.value := value;
	}

	func constructor(this: &&TemplateParameterDecl, other: TemplateParameterDecl) -> void = default;
	func destructor(this: &&TemplateParameterDecl) -> void = default;

	operator =(this: &&TemplateParameterDecl, other: TemplateParameterDecl) -> void = default;

	operator ==(this: TemplateParameterDecl, other: TemplateParameterDecl) -> bool = default;

	func signature(this: &TemplateParameterDecl) -> String {
		var result = this.name + ": ";
		result += ("..." if this.is_variadic else "");
		result += this.concept.name;

		if !(this.value is None) {
			result += " = ";
			result += format(this.value);
		}

		return result;
	}

	func dump(this: &TemplateParameterDecl, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("TemplateParameterDecl", is_last);
		out.attribute(this.name);
		out.text(":");
		out.attribute(this.concept.name);

		if !(this.value is None) {
			out.text(" =");
			out.value(format(this.value));
		}

		out.pop();
	}
}

enum NamespaceState {
	case IncompleteTemplate;
	case Unchecked;
	case UncheckedTypeBodies;
	case UncheckedFunctionSignatures;
	case UncheckedFunctionBodies;
	case Done;

	operator +(this: NamespaceState, delta: uint) -> NamespaceState {
		return (this as uint + delta) as NamespaceState;
	}
}

struct Namespace {
	var span: Span;
	var name_span: Span;
	var has_errors: bool;
	var file: SharedHandle!<CompilationUnit>;

	var name: String;
	var full_name: Name;
	var template_parameters: List!<TemplateParameterDecl>;

	var parent: SharedHandle!<Namespace>;
	var children: List!<SharedHandle!<Namespace>>;
	var children_by_name: Map!<String, List!<SharedHandle!<Namespace>>>;
	var aliases: Map!<String, SharedHandle!<Namespace>>;

	var imported_namespaces: Set!<SharedHandle!<Namespace>>;
	var visible_namespaces: Set!<SharedHandle!<Namespace>>;

	var template_instances: List!<SharedHandle!<Namespace>>;

	var linked_type: SharedHandle!<TypeDecl>;

	var types: List!<SharedHandle!<TypeDecl>>;
	var types_by_name: Map!<String, List!<SharedHandle!<TypeDecl>>>;

	var functions: List!<SharedHandle!<FunctionDecl>>;
	var functions_by_name: Map!<String, List!<SharedHandle!<FunctionDecl>>>;

	var comptime_variables: SharedList!<VarDecl>;
	var comptime_variables_by_name: Map!<String, SharedHandle!<VarDecl>>;

	var state: NamespaceState;
	var unchecked_bodies: List!<ParsedNamespaceDecl>;
	var unchecked_types: List!<SharedHandle!<TypeDecl>>;
	var unchecked_functions: List!<SharedHandle!<FunctionDecl>>;
	var unchecked_function_bodies: List!<SharedHandle!<FunctionDecl>>;

	var llvm_di: LLVMMetadataRef;

	func constructor(this: &&Namespace, name: String, template_parameters: &List!<TemplateParameterDecl>, parent: SharedHandle!<Namespace>, file: SharedHandle!<CompilationUnit>) -> void {
		this.file := file;

		this.name := name;
		this.template_parameters := template_parameters;
		this.parent := parent;
		this.state := Unchecked;

		var template_parameter_values: List!<TemplateParameter>;
		for p in template_parameters {
			if p.value is None {
				this.state = IncompleteTemplate;
			} else {
				template_parameter_values.append(p.value);
			}
		}

		var full_name: Name;
		if this.parent.isAlive() {
			full_name = this.parent.full_name + NameSegment(name, template_parameter_values);
		} else {
			full_name = Name(name, template_parameter_values);
		}

		this.full_name := full_name;
	}

	func constructor(this: &&Namespace, other: Namespace) -> void {
		this.file := other.file;
		this.name := other.name;
		this.full_name := other.full_name;
		this.template_parameters := other.template_parameters;

		this.parent := other.parent;

		this.state := other.state;
	}

	func destructor(this: &&Namespace) -> void = default;

	func signature(this: &Namespace) -> String {
		if this.parent.isAlive() {
			var result = this.parent.signature();
			result += "::";
			result += this.name;
			result += format(this.template_parameters);
			return result;
		}

		return this.name + format(this.template_parameters);
	}

	func dump(this: &Namespace, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("Namespace", is_last);
		out.attribute(this.signature());
		out.value(format(this.state));

		for parameter in this.template_parameters {
			parameter.dump(&&out, false);
		}

		for i in 0u..this.children.size() {
			this.children[i].dump(&&out, (i == this.children.size() - 1) && this.types.isEmpty() && this.functions.isEmpty()&& this.comptime_variables.isEmpty());
		}

		for i in 0u..this.types.size() {
			this.types[i].dump(&&out, (i == this.types.size() - 1) && this.functions.isEmpty()&& this.comptime_variables.isEmpty());
		}

		for i in 0u..this.functions.size() {
			this.functions[i].dump(&&out, (i == this.functions.size() - 1) && this.comptime_variables.isEmpty());
		}

		for i in 0u..this.comptime_variables.size() {
			this.file.dump(&&out, this.comptime_variables[i], i == this.comptime_variables.size() - 1);
		}

		out.pop();
	}

	func isIncompleteTemplate(this: &Namespace) -> bool {
		return this.state == IncompleteTemplate
	}

	func updateState(this: &&Namespace, new_state: NamespaceState) -> void {
		if this.state == IncompleteTemplate {
			return;
		}

		this.state = new_state;

		if this.parent.isAlive() {
			this.parent.updateMinState(new_state);
		}
	}

	func updateMinState(this: &&Namespace, min_state: NamespaceState) -> void {
		if this.state == IncompleteTemplate {
			return;
		}

		if this.state <= min_state {
			return;
		}

		this.state = min_state;

		if this.parent.isAlive() {
			this.parent.updateMinState(min_state);
		}
	}

	func addImportedNamespace(this: &&Namespace, other: SharedHandle!<Namespace>) -> void {
		this.imported_namespaces.add(other);
		this.addVisibleNamespace(other);
	}

	func addVisibleNamespace(this: &&Namespace, other: SharedHandle!<Namespace>) -> void {
		this.visible_namespaces.add(other);
		for c in this.children {
			c.addVisibleNamespace(other);
		}
	}

	func addUncheckedBody(this: &&Namespace, body: &ParsedNamespaceDecl) -> void {
		this.unchecked_bodies.append(body);
		this.updateMinState(NamespaceState::Unchecked);

		for instance in this.template_instances {
			instance.addUncheckedBody(body);
		}
	}

	func addUncheckedType(this: &&Namespace, type: SharedHandle!<TypeDecl>) -> void {
		this.unchecked_types.append(type);
		this.updateMinState(NamespaceState::UncheckedTypeBodies);
	}

	func addUncheckedFunction(this: &&Namespace, function: SharedHandle!<FunctionDecl>) -> void {
		this.unchecked_functions.append(function);
		this.updateMinState(NamespaceState::UncheckedFunctionSignatures);
	}

	func addUncheckedFunctionBody(this: &&Namespace, function: SharedHandle!<FunctionDecl>) -> void {
		this.unchecked_function_bodies.append(function);
		this.updateMinState(NamespaceState::UncheckedFunctionBodies);
	}

	func createComptimeVariable(this: &&Namespace, span: Span, name: String, type: Type, is_const: bool) -> SharedHandle!<VarDecl> {
		const variable = this.comptime_variables.append(VarDecl(span, 0u, name, type, is_const, false, true));
		this.comptime_variables_by_name.set(name, variable);
		return variable;
	}
}

struct TypeDecl {
	var span: Span;
	var name_span: Span;

	var name: String;
	var template_parameters: List!<TemplateParameterDecl>;
	var body: TypeBody;

	var is_comptime: bool;

	var parent_namespace: SharedHandle!<Namespace>;
	var linked_namespace: SharedHandle!<Namespace>;

	var unwrapped_type: SharedHandle!<TypeDecl>;

	var default_constructor: SharedHandle!<FunctionDecl>;
	var copy_constructor: SharedHandle!<FunctionDecl>;
	var destructor: SharedHandle!<FunctionDecl>;
	var op_assign: SharedHandle!<FunctionDecl>;
	var op_equal: SharedHandle!<FunctionDecl>;
	var op_compare: SharedHandle!<FunctionDecl>;

	var contained_types: Set!<SharedHandle!<TypeDecl>>;

	var annotations: List!<Annotation>;

	var parsed_body: uint;

	// struct & variant
	var member_variables: List!<MemberVarDecl>;
	var member_variables_by_name: Map!<String, uint>;

	// enum & variant
	var parsed_id_type: uint;
	var id_type: Type;

	// only enum
	var enum_cases: List!<EnumCaseDecl>;
	var enum_cases_by_name: Map!<String, uint>;

	// only variant
	var variant_cases: List!<VariantCaseDecl>;
	var variant_cases_by_id: Map!<int, uint>;
	var variant_cases_by_name: Map!<String, uint>;

	// flags for codegen
	var is_packed: bool;

	// llvm
	var llvm_type: LLVMTypeRef;
	var llvm_di: LLVMMetadataRef;

	func constructor(this: &&TypeDecl, name: String, template_parameters: &List!<TemplateParameterDecl>, body: TypeBody) -> void {
		this.name := name;
		this.template_parameters := template_parameters;
		this.body := body;
		this.parsed_id_type := 0;
	}

	func constructor(this: &&TypeDecl, other: TypeDecl) -> void = default;
	func destructor(this: &&TypeDecl) -> void = default;

	func dump(this: &TypeDecl, out: &&TreeFormatter, is_last: bool) -> void {
		match this.body {
			case Empty -> out.push("EmptyTypeDecl", is_last);
			case Void -> out.push("VoidTypeDecl", is_last);
			case Bool -> out.push("BoolTypeDecl", is_last);
			case Byte -> out.push("ByteTypeDecl", is_last);
			case Int: size -> {
				out.push("IntTypeDecl", is_last);
				out.value(format(size));
			}
			case UInt: size -> {
				out.push("UIntTypeDecl", is_last);
				out.value(format(size));
			}
			case Float: size -> {
				out.push("FloatTypeDecl", is_last);
				out.value(format(size));
			}
			case Pointer: pointer_type -> {
				out.push("PointerTypeDecl", is_last);
				out.attribute("var" if pointer_type.is_mutable else "const");
				out.value(pointer_type.pointee_type.signature());
			}
			case Function -> out.push("FunctionTypeDecl", is_last);
			case Tuple -> out.push("TupleTypeDecl", is_last);
			case Array: array_type -> {
				out.push("ArrayTypeDecl", is_last);
				out.value(array_type.element_type.signature());
				out.value(format(array_type.size));
			}
			case Range: type -> {
				out.push("Range", is_last);
				out.value(type.element_type.signature());
				out.value(format(type.is_mutable));
			}
			case RangeIterator: type -> {
				out.push("RangeIterator", is_last);
				out.value(type.element_type.signature());
				out.value(format(type.is_mutable));
			}
			case NumericRange: type -> {
				out.push("NumericRange", is_last);
				out.value(type.signature());
			}
			case NumericIterator: type -> {
				out.push("NumericIterator", is_last);
				out.value(type.signature());
			}
			case Enum -> out.push("EnumTypeDecl", is_last);
			case Struct -> out.push("StructTypeDecl", is_last);
			case Variant -> out.push("VariantTypeDecl", is_last);
			case Unchecked -> out.push("UncheckedType", is_last);
		}

		out.attribute(this.signature());

		for i in 0u..this.template_parameters.size() {
			this.template_parameters[i].dump(&&out, (i == this.template_parameters.size() - 1) && this.member_variables.isEmpty() && this.enum_cases.isEmpty() && this.variant_cases.isEmpty());
		}

		for i in 0u..this.member_variables.size() {
			this.linked_namespace.file.dump(&&out, this.member_variables[i], (i == this.member_variables.size() - 1) && this.enum_cases.isEmpty() && this.variant_cases.isEmpty());
		}

		for i in 0u..this.enum_cases.size() {
			this.linked_namespace.file.dump(&&out, this.enum_cases[i], i == this.enum_cases.size() - 1);
		}

		for i in 0u..this.variant_cases.size() {
			this.linked_namespace.file.dump(&&out, this.variant_cases[i], i == this.variant_cases.size() - 1);
		}

		out.pop();
	}

	func signature(this: &TypeDecl) -> String {
		return this.linked_namespace.signature();
	}

	func isIncompleteTemplate(this: &TypeDecl) -> bool {
		for parameter in this.template_parameters {
			if parameter.value is None {
				return true;
			}
		}

		return false;
	}

	func addContainedType(this: &&TypeDecl, type: Type) -> void {
		if type.isUnknown() {
			return;
		}

		if type.reference_kind == None {
			this.contained_types.add(type.decl);
		}
	}

	func createMemberVariable(this: &&TypeDecl, span: Span, name: String, type: Type) -> void {
		return this.createMemberVariable(span, name, type, this.linked_namespace.file.getEmptyNode());
	}

	func createMemberVariable(this: &&TypeDecl, span: Span, name: String, type: Type, initializer: uint) -> void {
		if this.member_variables_by_name.contains(name) {
			return;
		}

		this.member_variables_by_name.set(name, this.member_variables.size());
		this.member_variables.append(MemberVarDecl(span, this.member_variables.size(), name, type, initializer));

		this.addContainedType(type);
	}

	func getMemberVariable(this: &TypeDecl, name: String) -> Optional!<MemberVarDecl> {
		for v in this.member_variables {
			if v.name == name {
				return Some(v);
			}
		}

		return None;
	}

	func getNextCaseId(this: &TypeDecl) -> int {
		if this.body is Enum {
			if const prev_case = this.enum_cases.last() {
				return prev_case.id + 1;
			}
		} else if this.body is Variant {
			if const prev_case = this.variant_cases.last() {
				return prev_case.id + 1;
			}
		}
		return 0;
	}

	func createEnumCase(this: &&TypeDecl, span: Span, id: int, name: String) -> void {
		this.enum_cases_by_name.set(name, this.enum_cases.size());
		this.enum_cases.append(EnumCaseDecl(span, id, name));
	}

	func getEnumCase(this: &TypeDecl, name: String) -> Optional!<EnumCaseDecl> {
		const index = this.enum_cases_by_name.get(name) else {
			return None;
		}

		return Some(this.enum_cases[index]);
	}

	func createVariantCase(this: &&TypeDecl, span: Span, id: int, name: String, payload: Type) -> void {
		this.variant_cases_by_name.set(name, this.variant_cases.size());
		this.variant_cases_by_id.set(id, this.variant_cases.size());
		this.variant_cases.append(VariantCaseDecl(span, id, name, payload));
		this.addContainedType(payload);
	}

	func getVariantCase(this: &TypeDecl, name: String) -> Optional!<VariantCaseDecl> {
		const index = this.variant_cases_by_name.get(name) else {
			return None;
		}

		return Some(this.variant_cases[index]);
	}

	func getVariantCase(this: &TypeDecl, id: int) -> Optional!<VariantCaseDecl> {
		const index = this.variant_cases_by_id.get(id) else {
			return None;
		}

		return Some(this.variant_cases[index]);
	}
}

struct FunctionDecl {
	var span: Span;
	var signature_span: Span;
	var has_errors: bool;

	var name: String;
	var template_parameters: List!<TemplateParameterDecl>;
	var body: FunctionBody;

	var is_comptime: bool;

	var parent_namespace: SharedHandle!<Namespace>;

	var extern_name: String;

	var parameter_types: List!<Type>;
	var return_type: Type;

	var variables: SharedList!<VarDecl>;
	var parameters: List!<SharedHandle!<VarDecl>>;

	var is_copy_constructor: bool;

	// llvm
	var llvm_func: LLVMValueRef;
	var llvm_type: LLVMTypeRef;
	var llvm_di: LLVMMetadataRef;

	func constructor(this: &&FunctionDecl, name: String, template_parameters: &List!<TemplateParameterDecl>, body: FunctionBody) -> void {
		this.name := name;
		this.template_parameters := template_parameters;
		this.body := body;
	}

	func constructor(this: &&FunctionDecl, other: FunctionDecl) -> void {
		this.name := other.name;
		this.template_parameters := other.template_parameters;
		this.body := other.body;
	}

	func destructor(this: &&FunctionDecl) -> void = default;

	func dump(this: &FunctionDecl, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("FunctionDecl", is_last);
		out.attribute(this.signature());
		out.span(this.span);

		for parameter in this.template_parameters {
			parameter.dump(&&out, false);
		}

		for variable in this.variables {
			if variable.is_parameter {
				this.parent_namespace.file.dump(&&out, variable, false);
			}
		}

		match this.body {
			case Empty -> {
				out.push("EmptyFunction", true);
				out.pop();
			}
			case Extern -> {
				out.push("ExternFunction", true);
				out.pop();
			}
			case Builtin: f -> {
				out.push("BuiltinFunction", true);
				out.pop();
			}
			case Stmt: stmt -> this.parent_namespace.file.dump(&&out, stmt, true);
			case Unchecked -> {
				out.push("UncheckedFunction", true);
				out.pop();
			}
		}

		out.pop();
	}

	func signature(this: &FunctionDecl) -> String {
		var result = this.parent_namespace.signature();

		result += "::";
		result += this.name;
		result += this.template_parameters.format();
		result += "(";

		for i in 0u..this.parameter_types.size() {
			if i != 0 {
				result += ", ";
			}
			result += this.parameter_types[i].signature();
		}

		result += ") -> ";
		result += this.return_type.signature();
		return result;
	}

	func createParameter(this: &&FunctionDecl, span: Span, name: String, type: Type) -> void {
		const variable = this.variables.append(VarDecl(span, this.variables.size(), name, type, type.reference_kind != Var, true, false));
		this.parameters.append(variable);
	}

	func createVariable(this: &&FunctionDecl, span: Span, name: String, type: Type, is_const: bool, is_comptime: bool) -> SharedHandle!<VarDecl> {
		return this.variables.append(VarDecl(span, this.variables.size(), name, type, is_const, false, is_comptime));
	}

	func isIncompleteTemplate(this: &FunctionDecl) -> bool {
		for parameter in this.template_parameters {
			if parameter.value is None {
				return true;
			}
		}

		return false;
	}
}

struct VarDecl {
	var span: Span;

	var id: uint;
	var name: String;
	var type: Type;

	var is_const: bool;
	var is_parameter: bool;
	var is_comptime: bool;
	var is_unused: bool;

	var constructor_call: uint;
	var destructor_call: uint;

	// comptime only
	var value: Value;

	// parameters only
	var is_shallow_parameter: bool;

	func constructor(this: &&VarDecl, span: Span, id: uint, name: String, type: Type, is_const: bool, is_parameter: bool, is_comptime: bool) -> void {
		this.span := span;

		this.id := id;
		this.name := name;
		this.type := type;

		this.is_const := is_const;
		this.is_parameter := is_parameter;
		this.is_comptime := is_comptime;

		this.is_shallow_parameter = false;
		this.value := Undefined;
	}

	func constructor(this: &&VarDecl, other: VarDecl) -> void = default;
	func destructor(this: &&VarDecl) -> void = default;

	operator =(this: &&VarDecl, other: VarDecl) -> void = default;

	operator ==(@[shallow] this: VarDecl, @[shallow] other: VarDecl) -> bool {
		return this.id == other.id;
	}

	func signature(this: &VarDecl) -> String {
		return ("const " if this.is_const else "var ") + ("#" if this.is_parameter else "") + this.name + ": " + this.type.signature();
	}
}

struct Type {
	var decl: SharedHandle!<TypeDecl>;
	var reference_kind: ReferenceKind;

	func constructor(this: &&Type, decl: SharedHandle!<TypeDecl>) -> void {
		this.decl := decl;
		this.reference_kind := None;
	}

	func constructor(this: &&Type, decl: SharedHandle!<TypeDecl>, reference_kind: ReferenceKind) -> void {
		this.decl := decl;
		this.reference_kind := reference_kind;
	}

	func constructor(this: &&Type) -> void = default;
	func constructor(this: &&Type, other: Type) -> void = default;
	func destructor(this: &&Type) -> void = default;

	operator =(this: &&Type, other: Type) -> void = default;

	operator ==(this: Type, other: Type) -> bool = default;
	operator <=>(this: Type, other: Type) -> int = default;

	func unknown() -> Type {
		return Type(SharedHandle!<TypeDecl>(), ReferenceKind::None);
	}

	func isUnknown(this: &Type) -> bool {
		return this.decl.isEmpty();
	}

	func isAlive(this: &Type) -> bool {
		return this.decl.isAlive();
	}

	func signature(this: &Type) -> String {
		if this.decl.isAlive() {
			return format(this.reference_kind) + this.decl.signature();
		}

		return "unknown";
	}

	func base(this: &Type) -> Type {
		return Type(this.decl, ReferenceKind::None);
	}

	func constRef(this: &Type) -> Type {
		return Type(this.decl, ReferenceKind::Const);
	}

	func varRef(this: &Type) -> Type {
		return Type(this.decl, ReferenceKind::Var);
	}

	func isIncompleteTemplate(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		return this.decl.isIncompleteTemplate();
	}

	func isIntType(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Bool
			| Byte
			| Int
			| UInt
			| Enum -> return true;
			else -> return false;
		}
	}

	func isSigned(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Int
			| Float -> return true;
			else -> return false;
		}
	}

	func isFloatType(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Float -> return true;
			else -> return false;
		}
	}

	func isPtrType(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Pointer -> return true;
			else -> return false;
		}
	}

	func isConstPtrType(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Pointer: pointer_type -> return !pointer_type.is_mutable;
			else -> return false;
		}
	}

	func isPrimitive(this: &Type) -> bool {
		if this.reference_kind != None {
			return true; // reference types are always primitive
		}

		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Void
			| Bool
			| Byte
			| Int
			| UInt
			| Float
			| Pointer
			| Function
			| Enum -> return true;
			case Array: array_type -> return array_type.element_type.isPrimitive();
			else -> return false;
		}
	}

	func isVariant(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Variant -> return true;
			else -> return false;
		}
	}

	func getPrimitiveSizeInBits(this: &Type) -> uint {
		if this.reference_kind != None {
			return sizeOf!<ptr!<byte, false>>() * 8;
		}

		if this.decl.isEmpty() {
			return 0;
		}

		match this.decl.body {
			case Void -> return 0;
			case Bool -> return 1;
			case Byte -> return 8;
			case Int: bits -> return bits;
			case UInt: bits -> return bits;
			case Float: bits -> return bits;
			case Pointer -> return sizeOf!<ptr!<byte, false>>() * 8;
			case Enum -> return this.decl.id_type.getPrimitiveSizeInBits();
			else -> return 0;
		}
	}

	func getBitMask(this: &Type) -> int {
		if this.getPrimitiveSizeInBits() >= sizeOf!<int>() * 8 {
			return -1;
		}

		return ((-1) as uint >> (sizeOf!<int>() * 8 - this.getPrimitiveSizeInBits())) as int;
	}
}

variant TypeBody {
	case Empty;

	case Void;
	case Bool;
	case Byte;

	// size in bits attached, 0 -> pointer sized
	case Int: uint;
	case UInt: uint;

	// size in bits attached
	case Float: uint;

	case Pointer: (pointee_type: Type, is_mutable: bool);
	case Function: (parameter_types: List!<Type>, return_type: Type);

	case Tuple;

	case Array: (element_type: Type, size: uint);

	case Range: (element_type: Type, is_mutable: bool);
	case RangeIterator: (element_type: Type, is_mutable: bool);

	case NumericRange: Type;
	case NumericIterator: Type;

	case Struct;
	case Enum;
	case Variant;

	case Unchecked: ParsedTypeDecl;
}

variant FunctionBody {
	case Empty;
	case Extern;
	case Builtin: BuiltinFunction;
	case Stmt: uint;
	case Unchecked: ParsedFunctionDecl;
}

enum PrimitiveOp {
	case NoOp = 0;

	case ConstNull;
	case Copy;

	case BitwiseEQ;
	case BitwiseNE;

	case BitwiseAnd;
	case BitwiseOr;
	case BitwiseXOr;
	case BitwiseNot;
	case BitwiseShl;
	case BitwiseLShr;
	case BitwiseAShr;

	case IntAdd;
	case IntSub;
	case IntMul;
	case IntNeg;
	case IntInc;
	case IntDec;

	case SIntLT;
	case SIntLE;
	case SIntGT;
	case SIntGE;
	case SIntCmp;

	case SIntDiv;
	case SIntMod;

	case UIntLT;
	case UIntLE;
	case UIntGT;
	case UIntGE;
	case UIntCmp;

	case UIntDiv;
	case UIntMod;

	case FloatEQ;
	case FloatNE;
	case FloatLT;
	case FloatLE;
	case FloatGT;
	case FloatGE;
	case FloatCmp;

	case FloatAdd;
	case FloatSub;
	case FloatMul;
	case FloatDiv;
	case FloatMod;
	case FloatNeg;

	case Assign = 64;

	operator |(lhs: PrimitiveOp, rhs: PrimitiveOp) -> PrimitiveOp = default;
	operator &(lhs: PrimitiveOp, rhs: PrimitiveOp) -> PrimitiveOp = default;

	func isAssignment(op: PrimitiveOp) -> bool {
		return (op & Assign) != NoOp;
	}

	func getOp(op: PrimitiveOp) -> PrimitiveOp {
		return ((op as uint) & 63u) as PrimitiveOp;
	}
}

variant BuiltinFunction {
	var base_type: Type;

	case Empty;
	case PrimitiveOp: PrimitiveOp;

	case PointerToRef;
	case RefToPointer;
	case PointerCast;

	case PointerDiff;
	case PointerOffset;
	case PointerOpIndex;

	case FunctionPointerCall;

	case Swap;

	// base type is source type, attached type target
	case IntCast: Type;
	case FloatCast: Type;
	case IntToFloat: Type;
	case FloatToInt: Type;

	// base type is first template parameter
	case SizeOf;
	case AlignmentOf;
	case ReferenceKindOf;
	case HasDefaultConstructor;
	case HasCopyConstructor;

	case TypeRefOpEqual;

	case Assert;
	case AssertError;

	case RangeGetData;
	case RangeGetSize;

	// attached type is iterator type
	case RangeGetIterator: Type;

	case RangeIteratorHasNext;
	case RangeIteratorGetNext;

	// attached type is range type
	case NumericTypeRangeOperator: Type;

	// attached type is numeric type
	case NumericRangeSetStep: Type;

	// attached type is iterator type
	case NumericRangeGetIterator: Type;

	// attached type is numeric type
	case NumericIteratorHasNext: Type;
	case NumericIteratorGetNext: Type;

	// attached value is id of target case
	case VariantOpUnsafeAs: int;
	case VariantOpIs: int;

	case ArrayGetSize;
	case ArrayGetDataPointer;

	case StructValueConstructor;
	case StructDefaultConstructor;
	case StructCopyConstructor;
	case StructDestructor;
	case StructOpAssign;
	case StructOpEqual;
	case StructOpCmp;

	case VariantCaseConstructor: int;
	case VariantCopyConstructor;
	case VariantDestructor;
	case VariantOpAssign;
	case VariantOpEqual;

	case ArrayDefaultConstructor;
	case ArrayCopyConstructor;
	case ArrayDestructor;
	case ArrayOpAssign;
	case ArrayOpEqual;

	func isInlineable(this: &BuiltinFunction) -> bool {
		match this {
			case PrimitiveOp
			| PointerToRef
			| RefToPointer
			| PointerCast
			| PointerDiff
			| PointerOffset
			| PointerOpIndex
			| FunctionPointerCall
			| Swap
			| IntCast
			| FloatCast
			| IntToFloat
			| FloatToInt
			| SizeOf
			| AlignmentOf
			| ReferenceKindOf
			| HasDefaultConstructor
			| HasCopyConstructor
			| Assert
			| AssertError
			| RangeGetData
			| RangeGetSize
			| RangeGetIterator
			| RangeIteratorHasNext
			| RangeIteratorGetNext
			| NumericTypeRangeOperator
			| NumericRangeSetStep
			| NumericRangeGetIterator
			| NumericIteratorHasNext
			| NumericIteratorGetNext
			| VariantOpUnsafeAs
			| VariantOpIs
			| ArrayGetSize
			| ArrayGetDataPointer -> return true;
			else -> return false;
		}
	}
}

variant Node {
	var span: Span;
	var type: Type;
	var is_comptime: bool;

	case Empty;
	case Garbage;

	case ExternFunctionBody;
	case DefaultFunctionBody;

	case Pragma: String;
	case Import: String;

	case NamespaceDecl: ParsedNamespaceDecl;
	case TypeDecl: ParsedTypeDecl;
	case FunctionDecl: ParsedFunctionDecl;
	case AliasDecl: ParsedAliasDecl;

	case VarDecl: ParsedVarDecl;
	case CaseDecl: ParsedCaseDecl;

	case CompoundStmt: List!<uint>;

	case IfStmt: IfStmt;
	case IfVarStmt: IfVarStmt;
	case VarElseStmt: VarElseStmt;

	case WhileStmt: WhileStmt;
	case ParsedForStmt: ParsedForStmt;
	case ForStmt: ForStmt;

	case CaseStmt: CaseStmt;
	case ElseCaseStmt: uint;

	case BreakStmt;
	case ContinueStmt;

	case DeferStmt: uint;
	case ThrowStmt: uint;
	case ReturnStmt: uint;
	case YieldStmt: uint;
	case DiscardStmt: uint;

	case LifeTimeStart: SharedHandle!<VarDecl>;
	case LifeTimeEnd: SharedHandle!<VarDecl>;

	case Name: ParsedName;

	case IntegerLiteralExpr: int;
	case FloatLiteralExpr: f64;
	case BoolLiteralExpr: bool;

	case NumberLiteralExpr: NumberLiteralExpr;
	case CharLiteralExpr: CharLiteralExpr;
	case StringLiteralExpr: StringLiteralExpr;

	case ConstAggregateExpr: List!<uint>;

	case UnaryOperatorExpr: UnaryOperatorExpr;
	case BinaryOperatorExpr: BinaryOperatorExpr;
	case CallExpr: CallExpr;
	case IndexExpr: List!<uint>;
	case InlineIfExpr: InlineIfExpr;

	case ArrayExpr: List!<uint>;
	case TupleExpr: List!<TupleElement>;
	case DictExpr: List!<DictElement>;

	case MatchExpr: MatchExpr;

	case TypeRefExpr: Type;
	case FunctionRefExpr: SharedHandle!<FunctionDecl>;
	case VarInvokeExpr: SharedHandle!<VarDecl>;

	case ParsedFunctionRefExpr: ParsedFunctionRefExpr;
	case AnonymousFunctionExpr: uint;
	case FunctionType: FunctionType;

	case DereferenceExpr: uint;
	case MemberVarInvokeExpr: MemberVarInvokeExpr;
	case ShallowCopyExpr: ShallowCopyExpr;

	func name(this: &Node) -> String {
		match this {
			case Empty -> return "Empty";
			case Garbage -> return "Garbage";
			case ExternFunctionBody -> return "ExternFunctionBody";
			case DefaultFunctionBody -> return "DefaultFunctionBody";
			case Pragma -> return "Pragma";
			case Import -> return "Import";
			case NamespaceDecl -> return "NamespaceDecl";
			case TypeDecl -> return "TypeDecl";
			case FunctionDecl -> return "FunctionDecl";
			case AliasDecl -> return "AliasDecl";
			case VarDecl -> return "VarDecl";
			case CaseDecl -> return "CaseDecl";
			case CompoundStmt -> return "CompoundStmt";
			case IfStmt -> return "IfStmt";
			case IfVarStmt -> return "IfVarStmt";
			case VarElseStmt -> return "VarElseStmt";
			case WhileStmt -> return "WhileStmt";
			case ParsedForStmt -> return "ParsedForStmt";
			case ForStmt -> return "ForStmt";
			case CaseStmt -> return "CaseStmt";
			case ElseCaseStmt -> return "ElseCaseStmt";
			case DeferStmt -> return "DeferStmt";
			case BreakStmt -> return "BreakStmt";
			case ContinueStmt -> return "ContinueStmt";
			case ThrowStmt -> return "ThrowStmt";
			case ReturnStmt -> return "ReturnStmt";
			case YieldStmt -> return "YieldStmt";
			case DiscardStmt -> return "DiscardStmt";
			case LifeTimeStart -> return "LifeTimeStart";
			case LifeTimeEnd -> return "LifeTimeEnd";
			case Name -> return "Name";
			case IntegerLiteralExpr -> return "IntegerLiteralExpr";
			case FloatLiteralExpr -> return "FloatLiteralExpr";
			case BoolLiteralExpr -> return "BoolLiteralExpr";
			case NumberLiteralExpr -> return "NumberLiteralExpr";
			case CharLiteralExpr -> return "CharLiteralExpr";
			case StringLiteralExpr -> return "StringLiteralExpr";
			case ConstAggregateExpr -> return "ConstAggregateExpr";
			case UnaryOperatorExpr -> return "UnaryOperatorExpr";
			case BinaryOperatorExpr -> return "BinaryOperatorExpr";
			case CallExpr -> return "CallExpr";
			case IndexExpr -> return "IndexExpr";
			case InlineIfExpr -> return "InlineIfExpr";
			case ArrayExpr -> return "ArrayExpr";
			case TupleExpr -> return "TupleExpr";
			case DictExpr -> return "DictExpr";
			case MatchExpr -> return "MatchExpr";
			case TypeRefExpr -> return "TypeRefExpr";
			case FunctionRefExpr -> return "FunctionRefExpr";
			case VarInvokeExpr -> return "VarInvokeExpr";
			case ParsedFunctionRefExpr -> return "ParsedFunctionRefExpr";
			case AnonymousFunctionExpr -> return "AnonymousFunctionExpr";
			case FunctionType -> return "FunctionType";
			case DereferenceExpr -> return "DereferenceExpr";
			case MemberVarInvokeExpr -> return "MemberVarInvokeExpr";
			case ShallowCopyExpr -> return "ShallowCopyExpr";
		}
	}

	func isAnonymousTuple(this: &Node) -> bool {
		match this {
			case TupleExpr: &elements -> {
				var is_anonymous = true;
				for &element in elements {
					is_anonymous &= element.name == "";
				}
				return is_anonymous;
			}
			else -> return false;
		}
	}

	func addIdOffset(this: &&Node, offset: uint) -> void {
		match this {
			case NamespaceDecl: &&decl -> {
				decl.first_node_id += offset;
				decl.last_node_id += offset;
				for &&p in decl.template_parameters {
					if p.value > 1 { p.value += offset; }
				}
				if decl.body > 1 { decl.body += offset; }
			}
			case TypeDecl: &&decl -> {
				decl.first_node_id += offset;
				decl.last_node_id += offset;
				for &&p in decl.template_parameters {
					if p.value > 1 { p.value += offset; }
				}
				if decl.id_type > 1 { decl.id_type += offset; }
				if decl.body > 1 { decl.body += offset; }
			}
			case FunctionDecl: &&decl -> {
				decl.first_node_id += offset;
				decl.last_node_id += offset;
				for &&p in decl.template_parameters {
					if p.value > 1 { p.value += offset; }
				}
				for &&p in decl.signature.parameters {
					if p > 1 { p += offset; }
				}
				if decl.signature.return_type > 1 { decl.signature.return_type += offset; }
				if decl.body > 1 { decl.body += offset; }
			}
			case AliasDecl: &&decl -> {
				if decl.type > 1 { decl.type += offset; }
			}
			case VarDecl: &&decl -> {
				if decl.type > 1 { decl.type += offset; }
				if decl.initializer > 1 { decl.initializer += offset; }
			}
			case CaseDecl: &&decl -> {
				if decl.payload > 1 { decl.payload += offset; }
				if decl.id > 1 { decl.id += offset; }
			}
			case CompoundStmt: &&children -> {
				for &&c in children {
					if c > 1 { c += offset; }
				}
			}
			case IfStmt: &&stmt -> {
				if stmt.condition > 1 { stmt.condition += offset; }
				for &&c in stmt.condition_cleanup {
					if c > 1 { c += offset; }
				}
				if stmt.then_branch > 1 { stmt.then_branch += offset; }
				if stmt.else_branch > 1 { stmt.else_branch += offset; }
			}
			case IfVarStmt: &&stmt -> {
				if stmt.var_decl > 1 { stmt.var_decl += offset; }
				if stmt.body > 1 { stmt.body += offset; }
			}
			case VarElseStmt: &&stmt -> {
				if stmt.var_decl > 1 { stmt.var_decl += offset; }
				if stmt.body > 1 { stmt.body += offset; }
			}
			case WhileStmt: &&stmt -> {
				if stmt.condition > 1 { stmt.condition += offset; }
				for &&c in stmt.condition_cleanup {
					if c > 1 { c += offset; }
				}
				if stmt.body > 1 { stmt.body += offset; }
			}
			case ParsedForStmt: &&stmt -> {
				if stmt.range > 1 { stmt.range += offset; }
				if stmt.body > 1 { stmt.body += offset; }
			}
			case CaseStmt: &&stmt -> {
				for &&pattern in stmt.patterns {
					if pattern > 1 { pattern += offset; }
				}
				if stmt.body > 1 { stmt.body += offset; }
			}
			case ElseCaseStmt: &&body -> {
				if body > 1 { body += offset; }
			}
			case DeferStmt: &&body -> {
				if body > 1 { body += offset; }
			}
			case ThrowStmt: &&value -> {
				if value > 1 { value += offset; }
			}
			case ReturnStmt: &&value -> {
				if value > 1 { value += offset; }
			}
			case YieldStmt: &&value -> {
				if value > 1 { value += offset; }
			}
			case DiscardStmt: &&value -> {
				if value > 1 { value += offset; }
			}
			case Name: &&name -> {
				for &&p in name.template_parameters {
					if p > 1 { p += offset; }
				}
			}
			case UnaryOperatorExpr: &&expr -> {
				if expr.operand > 1 { expr.operand += offset; }
			}
			case BinaryOperatorExpr: &&expr -> {
				if expr.lhs > 1 { expr.lhs += offset; }
				if expr.rhs > 1 { expr.rhs += offset; }
			}
			case CallExpr: &&call_expr -> {
				if call_expr.callee > 1 { call_expr.callee += offset; }
				for &&arg in call_expr.parameters {
					if arg > 1 { arg += offset; }
				}
			}
			case IndexExpr: &&operands -> {
				for &&arg in operands {
					if arg > 1 { arg += offset; }
				}
			}
			case InlineIfExpr: &&expr -> {
				if expr.condition > 1 { expr.condition += offset; }
				if expr.then_value > 1 { expr.then_value += offset; }
				if expr.else_value > 1 { expr.else_value += offset; }
			}
			case ArrayExpr: &&elements -> {
				for &&e in elements {
					if e > 1 { e += offset; }
				}
			}
			case TupleExpr: &&elements -> {
				for &&e in elements {
					if e.value > 1 { e.value += offset; }
				}
			}
			case DictExpr: &&elements -> {
				for &&e in elements {
					if e.value > 1 { e.value += offset; }
					if e.key > 1 { e.key += offset; }
				}
			}
			case MatchExpr: &&expr -> {
				if expr.value > 1 { expr.value += offset; }
				if expr.body > 1 { expr.body += offset; }
			}
			case ParsedFunctionRefExpr: &&expr -> {
				if expr.name > 1 { expr.name += offset; }
				for &&type in expr.parameter_types {
					if type > 1 { type += offset; }
				}
			}
			case AnonymousFunctionExpr: &&function -> {
				if function > 1 { function += offset; }
			}
			case FunctionType: &&type -> {
				if type.return_type > 1 { type.return_type += offset; }
				for &&parameter in type.parameter_types {
					if parameter > 1 { parameter += offset; }
				}
			}
			else -> {}
		}
	}
}

variant Annotation {
	var span: Span;
	var name: String;

	case Flag;
	case String: String;
	case Number: ParsedNumber;
}

enum TypeDeclKind {
	case Struct;
	case Enum;
	case Variant;
}

enum WhileStmtKind {
	case While;
	case DoWhile;
}

enum ForStmtKind {
	case Count;
	case Range;
}

enum ReturnKind {
	case None;					// function returns void or never
	case Value;					// most basic, no memory management
	case Variable;				// result gets stored in variable allocated by caller
	case Parameter;				// callee initializes variable allocated by caller, passed by reference as first parameter
	case VariableButYieldNone;	// same as variable, but result gets discarded. Used when initializing a variable with the result of a call (optimized)
}

variant TemplateParameter {
	case None;
	case Type: Type;
	case Boolean: bool;
	case Integer: int;
	case String: String;
	case Garbage;
}

alias NameSegment = (name: String, template_parameters: List!<TemplateParameter>);

struct Name {
	var span: Span;
	var segments: List!<NameSegment>;

	func constructor(this: &&Name) -> void = default;

	func constructor(this: &&Name, span: Span) -> void {
		this.span := span;
	}

	func constructor(this: &&Name, name: String) -> void {
		this.segments := (1u, NameSegment(name, List!<TemplateParameter>()));
	}

	func constructor(this: &&Name, span: Span, name: String, template_parameters: &List!<TemplateParameter>) -> void {
		this.span := span;
		this.segments := (1u, NameSegment(name, template_parameters));
	}

	func constructor(this: &&Name, name: String, template_parameters: &List!<TemplateParameter>) -> void {
		this.segments := (1u, NameSegment(name, template_parameters));
	}

	func constructor(this: &&Name, span: Span, segments: List!<NameSegment>) -> void {
		this.span := span;
		this.segments := segments;
	}

	func constructor(this: &&Name, other: Name) -> void = default;
	func destructor(this: &&Name) -> void = default;

	operator =(this: &&Name, other: Name) -> void = default;
	operator ==(@[shallow] this: Name, @[shallow] other: Name) -> bool = default;

	operator +(@[shallow] this: Name, @[shallow] segment: NameSegment) -> Name {
		var result = this;
		result.segments.append(segment);
		return result;
	}

	operator ..(@[shallow] lhs: Name, @[shallow] rhs: Name) -> Name {
		return Name(lhs.span..rhs.span, lhs.segments + rhs.segments);
	}

	func intersection(this: &Name, segments: &List!<NameSegment>) -> uint {
		for offset in 0u..this.segments.size() {
			if segments.startsWith(this.segments[offset..this.segments.size()]) {
				return this.segments.size() - offset;
			}
		}

		return 0u;
	}
}

alias MemberVarDecl = (span: Span, id: uint, name: String, type: Type, initializer: uint);
alias EnumCaseDecl = (span: Span, id: int, name: String);
alias VariantCaseDecl = (span: Span, id: int, name: String, type: Type);

alias ParsedTemplateParameterDecl = (span: Span, name: String, concept: String, value: uint);

alias ParsedNamespaceDecl = (
	first_node_id: uint,
	last_node_id: uint,
	name_span: Span,
	annotations: List!<Annotation>,
	template_parameters: List!<ParsedTemplateParameterDecl>,
	name: String,
	body: uint
);

alias ParsedTypeDecl = (
	first_node_id: uint,
	last_node_id: uint,
	name_span: Span,
	annotations: List!<Annotation>,
	template_parameters: List!<ParsedTemplateParameterDecl>,
	kind: TypeDeclKind,
	name: String,
	id_type: uint,
	body: uint
);

alias ParsedFunctionSignature = (span: Span, name: String, parameters: List!<uint>, return_type: uint);
alias ParsedFunctionDecl = (
	first_node_id: uint,
	last_node_id: uint,
	span: Span,
	annotations: List!<Annotation>,
	template_parameters: List!<ParsedTemplateParameterDecl>,
	is_comptime: bool,
	signature: ParsedFunctionSignature,
	body: uint
);

alias ParsedAliasDecl = (name: String, type: uint);
alias ParsedVarDecl = (annotations: List!<Annotation>, name: String, type: uint, initializer: uint, is_const: bool, is_parameter: bool);
alias ParsedCaseDecl = (name: String, payload: uint, id: uint);

alias IfStmt = (condition: uint, condition_cleanup: List!<uint>, then_branch: uint, else_branch: uint);
alias IfVarStmt = (var_decl: uint, body: uint);
alias VarElseStmt = (var_decl: uint, body: uint, capture_name: String, capture_kind: ReferenceKind);

alias WhileStmt = (
	condition: uint, condition_cleanup: List!<uint>,
	body: uint, body_start: uint, body_end: uint,
	kind: WhileStmtKind
);

alias ParsedForStmt = (
	capture_name: String, capture_kind: ReferenceKind, capture_span: Span,
	range: uint, body: uint, body_start: uint, body_end: uint
);

alias ForStmt = (iterator: uint, enumerator_variable: SharedHandle!<VarDecl>, body: uint, kind: ForStmtKind);
alias CaseStmt = (patterns: List!<uint>, capture_name: String, capture_kind: ReferenceKind, body: uint);

alias ParsedName = (name: String, template_parameters: List!<uint>);

alias NumberLiteralExpr = (value: ParsedNumber, postfix: String);
alias CharLiteralExpr = (value: byte, postfix: String);
alias StringLiteralExpr = (value: String, postfix: String);

alias UnaryOperatorExpr = (op: Operator, operand: uint);
alias BinaryOperatorExpr = (op: Operator, lhs: uint, rhs: uint);
alias CallExpr = (callee: uint, parameters: List!<uint>, result_var: SharedHandle!<VarDecl>, return_kind: ReturnKind, function: SharedHandle!<FunctionDecl>);
alias InlineIfExpr = (condition: uint, then_value: uint, else_value: uint);

alias TupleElement = (span: Span, name: String, value: uint);
alias DictElement = (span: Span, key: uint, value: uint);

alias MatchExpr = (value: uint, body: uint, cases: List!<uint>, else_case: uint, yield_var: SharedHandle!<VarDecl>);
alias ParsedFunctionRefExpr = (name: uint, parameter_types: List!<uint>);

alias FunctionType = (parameter_types: List!<uint>, return_type: uint);
alias MemberVarInvokeExpr = (object: uint, id: uint);
alias ShallowCopyExpr = (destination: uint, value: uint);

variant Value {
	var type: Type;

	case Undefined;
	case Void;
	case Integer: int;
	case Float: f64;
	case String: String;
	case Pointer: ptr!<void, true>;
	case Aggregate: List!<Value>;

	case Type: Type;
	case Function: SharedHandle!<FunctionDecl>;
	case Variable: SharedHandle!<VarDecl>;

	template <Id: uint = 0u>
	func constructor(this: &&Value) -> void {
		this.constructor!<0u>(Type::unknown());
	}

	func constructor(this: &&Value) -> void {
		this.constructor!<0u>(Type::unknown());
	}

	func toBool(this: &Value) -> bool {
		match this {
			case Integer: value -> return (value & this.type.getBitMask()) != 0;
			else -> return false;
		}
	}

	func toInt(this: &Value) -> int {
		match this {
			case Integer: value -> return (value & this.type.getBitMask());
			else -> return 0;
		}
	}

	func toUInt(this: &Value) -> uint {
		match this {
			case Integer: value -> return (value & this.type.getBitMask()) as uint;
			else -> return 0;
		}
	}

	func toFloat(this: &Value) -> f64 {
		match this {
			case Float: value -> return value;
			else -> return 0;
		}
	}

	func toType(this: &Value) -> Type {
		match this {
			case Type: value -> return value;
			else -> return Type::unknown();
		}
	}
}

func format(template_parameter: &TemplateParameter) -> String {
	match template_parameter {
		case None -> return "<none>";
		case Type: t -> return t.signature();
		case Boolean: v -> return format(v);
		case Integer: v -> return format(v);
		case String: s -> return "\"" + s + "\"";
		case Garbage -> return "<garbage>";
	}
}

func format(template_parameters: &List!<TemplateParameterDecl>) -> String {
	if template_parameters.isEmpty() {
		return "";
	}

	var result = "!<";
	for i in 0u..template_parameters.size() {
		if i != 0 {
			result += ", ";
		}

		result += template_parameters[i].signature();
	}

	return result + ">";
}

func format(template_parameters: &List!<TemplateParameter>) -> String {
	if template_parameters.isEmpty() {
		return "";
	}

	var result = "!<";
	for i in 0u..template_parameters.size() {
		if i != 0 {
			result += ", ";
		}

		result += format(template_parameters[i]);
	}

	return result + ">";
}

func format(state: NamespaceState) -> String {
	assert(state >= IncompleteTemplate && state <= Done);

	match state {
		case IncompleteTemplate -> return "IncompleteTemplate";
		case Unchecked -> return "Unchecked";
		case UncheckedTypeBodies -> return "UncheckedTypeBodies";
		case UncheckedFunctionSignatures -> return "UncheckedFunctionSignatures";
		case UncheckedFunctionBodies -> return "UncheckedFunctionBodies";
		case Done -> return "Done";
	}
}

func format(this: &Name) -> String {
	var result = "";
	var first = true;
	for i in 0u..this.segments.size() {
		if i != 0 {
			result += "::";
		}
		result += this.segments[i].name;
		result += format(this.segments[i].template_parameters);
	}

	return result;
}

func format(types: &List!<Type>) -> String {
	var result = "(";
	for i in 0u..types.size() {
		if i != 0 {
			result += ", ";
		}

		result += types[i].signature();
	}

	return result + ")";
}

func format(return_kind: ReturnKind) -> String {
	match return_kind {
		case None -> return "None";
		case Value -> return "Value";
		case Variable -> return "Variable";
		case Parameter -> return "Parameter";
		case VariableButYieldNone -> return "VariableButYieldNone";
	}
}

func format(this: ReferenceKind) -> String {
	match this {
		case None -> return "";
		case Const -> return "&";
		case Var -> return "&&";
	}
}

func format(parsed_number: ParsedNumber) -> String {
	return format(parsed_number.significant) + " * " + format(parsed_number.base) + "^" + format(parsed_number.exponent);
}

func format(this: &Value) -> String {
	match this {
		case Undefined -> return "undefined";
		case Void -> return "void";
		case Integer: v -> return format(v & this.type.getBitMask());
		case Float: v -> return format(v as int);
		case String: str -> return "\"" + str + "\"";
		case Pointer: ptr -> return "ptr";
		case Aggregate: elements -> {
			var result = "[";
			for i in 0u..elements.size() {
				if i > 0 {
					result += ", ";
				}
				result += format(elements[i]);
			}
			return result + "]";
		}
		case Type: type -> return type.signature();
		case Function: function -> return function.signature();
		case Variable: variable -> return variable.signature();
	}
}
