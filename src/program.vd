import std/core;
import std/box;
import std/format;
import std/io;
import std/list;
import std/map;
import std/math;
import std/set;
import std/shared;
import std/shared_list;
import std/string;

import llvm_c;
import llvm_util;

import error;
import operators;
import options;
import span;
import tree_formatter;

struct CompilationUnit {
	var id: uint;
	var group: uint;
	var name: String;
	var path: String;
	var source: String;
	var line_spans: List!<Span>;

	var nodes: List!<Node>;
	var top_level_nodes: List!<uint>;

	var llvm_di_file: LLVMMetadataRef;
	var llvm_di_module: LLVMMetadataRef;

	func constructor(this: &&CompilationUnit, id: uint, group: uint, name: String, path: String, source: String, line_spans: &List!<Span>) -> void {
		this.id := id;
		this.group := group;
		this.name := name;
		this.path := path;
		this.source := source;
		this.line_spans := line_spans;

		this.nodes := ();
		this.nodes.append(Node::Empty(Span(), false));
		this.nodes.append(Node::Garbage(Span(), false));
	}

	func constructor(this: &&CompilationUnit, other: CompilationUnit) -> void = default;
	func destructor(this: &&CompilationUnit) -> void = default;

	operator =(this: &&CompilationUnit, other: CompilationUnit) -> void = default;

	operator ==(this: CompilationUnit, other: CompilationUnit) -> bool {
		return this.path == other.path;
	}

	func addNode(this: &&CompilationUnit, node: &Node) -> uint {
		const id = this.nodes.size();
		this.nodes.append(node);
		return id;
	}

	func emptyNode(this: &&CompilationUnit) -> uint {
		return 0u;
	}

	func garbageNode(this: &&CompilationUnit) -> uint {
		return 1u;
	}

	func duplicateNodes(this: &&CompilationUnit, start: uint, end: uint) -> uint {
		assert(start <= end, Error::EINVAL);

		const result_start = this.nodes.size();
		const result_end = result_start + (end - start);
		const result_offset = result_start - start;

		this.nodes.grow(end - start);
		for i in start..end {
			this.nodes.append(this.nodes[i]);
			this.nodes[this.nodes.size() - 1].addIdOffset(result_offset);
		}

		return result_offset;
	}

	func dump(this: &CompilationUnit) -> String {
		var out: TreeFormatter = ("Module");
		out.value(this.name);

		for i in 0u..this.top_level_nodes.size() {
			this.dump(&&out, this.top_level_nodes[i], i == this.top_level_nodes.size() - 1);
		}

		return out.finalize();
	}

	func dump(this: &CompilationUnit, out: &&TreeFormatter, index: uint, is_last: bool) -> void {
		out.push(this.nodes[index].name(), is_last);
		out.span(this.nodes[index].span);

		match this.nodes[index] {
			case Empty
			| Garbage
			| ExternFunctionBody
			| DefaultFunctionBody -> {}
			case Pragma: &name -> out.attribute(name);
			case Import: &name -> out.attribute(name);
			case NamespaceDecl: &decl -> {
				for &annotation in decl.annotations {
					this.dump(&&out, annotation, false);
				}

				for &template_parameter in decl.template_parameters {
					this.dump(&&out, template_parameter, false);
				}

				this.dump(&&out, decl.body, true);
			}
			case TypeDecl: &decl -> {
				match decl.kind {
					case Struct -> out.value("struct");
					case Enum -> out.value("enum");
					case Variant -> out.value("variant");
				}
				out.attribute(decl.name);

				for &annotation in decl.annotations {
					this.dump(&&out, annotation, false);
				}

				for &template_parameter in decl.template_parameters {
					this.dump(&&out, template_parameter, false);
				}

				this.dump(&&out, decl.body, true);
			}
			case FunctionDecl: &decl -> {
				if decl.is_comptime {
					out.value("comptime");
				}

				out.attribute(decl.signature.name);

				for annotation in decl.annotations {
					this.dump(&&out, annotation, false);
				}

				for template_parameter in decl.template_parameters {
					this.dump(&&out, template_parameter, false);
				}

				for parameter in decl.signature.parameters {
					this.dump(&&out, parameter, false);
				}

				this.dump(&&out, decl.signature.return_type, false);

				this.dump(&&out, decl.body, true);
			}
			case AliasDecl: &data -> {
				out.value(data.name);
				this.dump(&&out, data.type, true);
			}
			case VarDecl: &decl -> {
				if !decl.is_parameter {
					out.attribute("const" if decl.is_const else "var");
				}
				out.value(this.name);

				this.dump(&&out, decl.type, false);
				this.dump(&&out, decl.initializer, true);
			}
			case CaseDecl: &decl -> {
				out.attribute(decl.name);
				this.dump(&&out, decl.payload, false);
				this.dump(&&out, decl.id, true);
			}
			case CompoundStmt: &children -> {
				for i in 0u..children.size() {
					this.dump(&&out, children[i], i == children.size() - 1);
				}
			}
			case IfStmt: &if_stmt -> {
				this.dump(&&out, if_stmt.condition, false);
				this.dump(&&out, if_stmt.then_branch, false);
				this.dump(&&out, if_stmt.else_branch, true);
			}
			case IfVarStmt: &if_var_stmt -> {
				this.dump(&&out, if_var_stmt.var_decl, false);
				this.dump(&&out, if_var_stmt.body, true);
			}
			case VarElseStmt: &var_else_stmt -> {
				out.attribute(var_else_stmt.capture_kind.toString() + var_else_stmt.capture_name);
				this.dump(&&out, var_else_stmt.var_decl, false);
				this.dump(&&out, var_else_stmt.body, true);
			}
			case WhileStmt: &while_stmt -> {
				this.dump(&&out, while_stmt.condition, false);
				this.dump(&&out, while_stmt.body, true);
			}
			case DoWhileStmt: &do_while_stmt -> {
				this.dump(&&out, do_while_stmt.body, false);
				this.dump(&&out, do_while_stmt.condition, true);
			}
			case ForStmt: &for_stmt -> {
				out.attribute(for_stmt.capture_kind.toString() + for_stmt.capture_name);
				this.dump(&&out, for_stmt.range, false);
				this.dump(&&out, for_stmt.body, true);
			}
			case CaseStmt: case_stmt -> {
				out.attribute(case_stmt.capture_kind.toString() + case_stmt.capture_name);
				for pattern in case_stmt.patterns {
					this.dump(&&out, pattern, false);
				}
				this.dump(&&out, case_stmt.body, true);
			}
			case ElseCaseStmt: body -> this.dump(&&out, body, true);
			case BreakStmt | ContinueStmt -> {}
			case DeferStmt: body -> this.dump(&&out, body, true);
			case ThrowStmt: expr -> this.dump(&&out, expr, true);
			case ReturnStmt: value -> this.dump(&&out, value, true);
			case YieldStmt: value -> this.dump(&&out, value, true);
			case DiscardStmt: expr -> this.dump(&&out, expr, true);
			case Name: &name -> {
				out.value(name.name);
				for i in 0u..name.template_parameters.size() {
					this.dump(&&out, name.template_parameters[i], i == name.template_parameters.size() - 1);
				}
			}
			case CharLiteralExpr: &literal -> out.attribute("\'" + literal.value + "\'" + literal.postfix);
			case StringLiteralExpr: &literal -> out.attribute("\"" + literal.value + "\"" + literal.postfix);
			case NumberLiteralExpr: &literal -> out.attribute(format(literal.value) + literal.postfix);
			case BoolLiteralExpr: value -> out.attribute(format(value));
			case ParenExpr: child -> this.dump(&&out, child, true);
			case UnaryOperatorExpr: &operator_expr -> {
				out.attribute(operator_expr.op.toString());
				this.dump(&&out, operator_expr.operand, false);
			}
			case BinaryOperatorExpr: &operator_expr -> {
				out.attribute(operator_expr.op.toString());
				this.dump(&&out, operator_expr.lhs, false);
				this.dump(&&out, operator_expr.rhs, true);
			}
			case CallExpr: &args -> {
				for i in 0u..args.size() {
					this.dump(&&out, args[i], i == args.size() - 1);
				}
			}
			case IndexExpr: &args -> {
				for i in 0u..args.size() {
					this.dump(&&out, args[i], i == args.size() - 1);
				}
			}
			case InlineIfExpr: &inline_if_expr -> {
				this.dump(&&out, inline_if_expr.condition, false);
				this.dump(&&out, inline_if_expr.then_value, false);
				this.dump(&&out, inline_if_expr.else_value, true);
			}
			case ArrayExpr: &elements -> {
				for i in 0u..elements.size() {
					this.dump(&&out, elements[i], i == elements.size() - 1);
				}
			}
			case TupleExpr: &elements -> {
				for i in 0u..elements.size() {
					out.push("TupleElement", i == elements.size() - 1);
					out.attribute(elements[i].name);
					out.span(elements[i].span);
					this.dump(&&out, elements[i].value, true);
					out.pop();
				}
			}
			case DictExpr: &elements -> {
				for i in 0u..elements.size() {
					out.push("DictElement", i == elements.size() - 1);
					out.span(elements[i].span);
					this.dump(&&out, elements[i].key, true);
					this.dump(&&out, elements[i].value, true);
					out.pop();
				}
			}
			case MatchExpr: &match_expr -> {
				this.dump(&&out, match_expr.value, false);
				this.dump(&&out, match_expr.body, true);
			}
			case FunctionRefExpr: &function -> {
				this.dump(&&out, function.name, false);
				for i in 0u..function.parameter_types.size() {
					this.dump(&&out, function.parameter_types[i], i == function.parameter_types.size() - 1);
				}
			}
			case AnonymousFunctionExpr: &function_decl -> this.dump(&&out, function_decl, true);
			case FunctionType: type -> {
				for t in type.parameter_types {
					this.dump(&&out, t, false);
				}
				this.dump(&&out, type.return_type, true);
			}
		}

		out.pop();
	}

	func dump(this: &CompilationUnit, out: &&TreeFormatter, annotation: &ParsedAnnotation, is_last: bool) -> void {
		out.push("Annotation", is_last);
		out.span(annotation.span);
		out.attribute(annotation.name);

		match annotation {
			case Flag -> {}
			case String: value -> out.value(value);
			case Number: value -> out.value(format(value));
		}

		out.pop();
	}

	func dump(this: &CompilationUnit, out: &&TreeFormatter, template_parameter: &ParsedTemplateParameterDecl, is_last: bool) -> void {
		out.push("TemplateParameterDecl", is_last);
		out.attribute(template_parameter.name);
		out.text(": ");
		out.attribute(template_parameter.concept);
		this.dump(&&out, template_parameter.value, true);
		out.pop();
	}
}

struct Program {
	var name: String;
	var options: CompilerOptions;

	var has_errors: bool;

	var files: SharedList!<CompilationUnit>;

	// namespaces
	var namespaces: SharedList!<Namespace>;
	var top_level_namespaces: List!<SharedHandle!<Namespace>>;
	var modules_by_path: Map!<String, SharedHandle!<Namespace>>;

	var core_namespace: SharedHandle!<Namespace>;

	// concepts
	var concepts: SharedList!<Concept>;
	var concepts_by_name: Map!<String, SharedHandle!<Concept>>;

	var any_concept: SharedHandle!<Concept>;
	var bool_concept: SharedHandle!<Concept>;
	var int_concept: SharedHandle!<Concept>;
	var uint_concept: SharedHandle!<Concept>;
	var string_concept: SharedHandle!<Concept>;

	// types
	var types: SharedList!<TypeDecl>;

	var void_type: Type;
	var never_type: Type;
	var error_type: Type;

	var bool_type: Type;

	var int_type: Type;
	var uint_type: Type;

	var byte_type: Type;

	// functions
	var functions: SharedList!<FunctionDecl>;

	var exit_function: SharedHandle!<FunctionDecl>;
	var abort_function: SharedHandle!<FunctionDecl>;
	var panic_function: SharedHandle!<FunctionDecl>;
	var assert_function: SharedHandle!<FunctionDecl>;
	var assert_error_function: SharedHandle!<FunctionDecl>;
	var main_function: SharedHandle!<FunctionDecl>;

	// llvm
	var llvm_context: LLVMContextRef;
	var llvm_module: LLVMModuleRef;
	var llvm_execution_engine: LLVMExecutionEngineRef;
	var data_layout: LLVMTargetDataRef;

	var string_globals: Map!<String, LLVMValueRef>;

	var di_builder: LLVMDIBuilderRef;
	var di_compile_unit: LLVMMetadataRef;

	func constructor(this: &&Program, options: CompilerOptions) -> void {
		this.name := options.program_name;
		this.options := options;

		this.has_errors := false;

		this.files := ();
		discard this.files.append(CompilationUnit(0u, 0u, "unknown", "unknown", "", List!<Span>()));

		this.namespaces := ();
		this.top_level_namespaces := ();

		this.llvm_context := LLVMContextCreate();
		this.llvm_module := LLVMModuleCreateWithNameInContext(this.name, this.llvm_context);
		LLVMSetSourceFileName(this.llvm_module, options.root_module_path);
		LLVMSetTarget(this.llvm_module, options.target_triple);
		LLVMSetDataLayout(this.llvm_module, options.target_data_layout);

		this.data_layout := LLVMGetModuleDataLayout(this.llvm_module);

		this.di_builder := ();
		if options.generate_debug_info {
			const int_type = LLVMIntTypeInContext(this.llvm_context, 64u);
			LLVMAddModuleFlag(this.llvm_module, LLVMModuleFlagBehavior::LLVMModuleFlagBehaviorError, "Dwarf Version", LLVMValueAsMetadata(LLVMConstInt(int_type, 5, false)));
			LLVMAddModuleFlag(this.llvm_module, LLVMModuleFlagBehavior::LLVMModuleFlagBehaviorWarning, "Debug Info Version", LLVMValueAsMetadata(LLVMConstInt(int_type, 3, false)));
			this.di_builder = LLVMCreateDIBuilder(this.llvm_module);

			this.files[0u].llvm_di_file = LLVMDIBuilderCreateFile(this.di_builder, "unknown", ".");

			this.di_compile_unit = LLVMDIBuilderCreateCompileUnit(
				this.di_builder,
				LLVMDWARFSourceLanguage::LLVMDWARFSourceLanguageC,
				this.files[0u].llvm_di_file,
				"",			// producer
				this.options.optimization_level != 0,
				"",			// flags
				0u,			// runtime version
				"",			// split name
				LLVMDWARFEmissionKind::LLVMDWARFEmissionFull,
				0u,			// dwo-id
				false,		// split debug inlining
				false,		// debug info for profiling
				"",			// sys-root
				"",			// sdk
			);

			this.files[0u].llvm_di_module = LLVMDIBuilderCreateModule(
				this.di_builder,
				this.di_compile_unit,
				this.files[0u].name,
				"",		// config macros
				"",		// include path
				"", 	// api notes file
			);
		}

		for i in 0u..options.import_search_paths.size() {
			var ns = this.namespaces.append(Namespace(format(i), List!<TemplateParameterDecl>(), SharedHandle!<Namespace>(), SharedHandle!<CompilationUnit>()));

			if this.di_builder != LLVMDIBuilderRef::null() {
				ns.llvm_di = LLVMDIBuilderCreateNameSpace(this.di_builder, this.files[0u].llvm_di_module, ns.name, true);
			}

			this.top_level_namespaces.append(ns);
		}

		this.llvm_execution_engine := ();

		LLVMLinkInMCJIT();
		LLVMInitializeX86TargetInfo();
		LLVMInitializeX86Target();
		LLVMInitializeX86TargetMC();
		LLVMInitializeX86AsmPrinter();

		match createJITCompilerForModule(this.llvm_module, min!<uint>(this.options.optimization_level, 3u)) {
			case Ok: ee -> this.llvm_execution_engine = ee;
			case Error: error -> panic(error);
		}
	}

	func destructor(this: &&Program) -> void {
		if this.di_builder != LLVMDIBuilderRef::null() {
			LLVMDisposeDIBuilder(this.di_builder);
		}

		LLVMDisposeExecutionEngine(this.llvm_execution_engine);
		LLVMContextDispose(this.llvm_context);

		LLVMShutdown();
	}

	func printError(this: &&Program, error: CompilationError) -> void {
		if error.type == Error {
			this.has_errors = true;
		}

		if this.options.hide_errors {
			return;
		}

		const span = error.span;
		const file = &this.files[span.file as uint];

		println(error.toString(file.path));

		if span.start == span.end {
			return;
		}

		var first_line = max!<int>(span.line as int - 1, 0) as uint;
		var last_line = span.line as uint + 1;
		while span.end > file.line_spans[last_line - 1].end && last_line < file.line_spans.size() {
			last_line++;
		}
		last_line = min!<uint>(last_line + 1, file.line_spans.size());

		const last_line_number = format(last_line);
		const max_line_number_width = last_line_number.size();

		for line in first_line..last_line {
			const line_span = file.line_spans[line];

			const line_number_str = format(line + 1);
			print(String(max_line_number_width - line_number_str.size() + 1, ' 'b) + line_number_str + " | ");

			const error_start = clamp!<uint>(span.start, line_span.start, line_span.end);
			const error_end = clamp!<uint>(span.end, line_span.start, line_span.end);

			print(file.source.substring(line_span.start..error_start));
			print("\e[31m");
			print(file.source.substring(error_start..error_end));
			print("\e[0m");
			print(file.source.substring(error_end..line_span.end));

			print("\n");
		}
	}

	func printErrors(this: &&Program, errors: &List!<CompilationError>) -> void {
		for e in errors {
			this.printError(e);
		}
	}

	func dump(this: &Program) -> String {
		var out: TreeFormatter = ("Program");
		out.attribute(this.name);
		if this.main_function.isAlive() {
			out.text(" main:");
			out.value(this.main_function.signature());
		}

		for concept in this.concepts {
			concept.dump(&&out, false);
		}

		for i in 0u..this.top_level_namespaces.size() {
			this.top_level_namespaces[i].dump(&&out, i == this.top_level_namespaces.size() - 1);
		}

		return out.finalize();
	}

	func createConcept(this: &&Program, concept: Concept) -> SharedHandle!<Concept> {
		const instance = this.concepts.append(concept);
		this.concepts_by_name[concept.name] = instance;
		return instance;
	}

	func getConcept(this: &Program, name: String) -> Optional!<SharedHandle!<Concept>> {
		return this.concepts_by_name.get(name);
	}

	func getOrCreateChildNamespace(this: &&Program, name: String, template_parameters: &List!<TemplateParameterDecl>, parent_namespace: SharedHandle!<Namespace>, file: SharedHandle!<CompilationUnit>) -> SharedHandle!<Namespace> {
		for child in parent_namespace.children {
			if child.name != name {
				continue;
			}

			if child.template_parameters != template_parameters {
				continue;
			}

			return child;
		}

		var child = this.namespaces.append(Namespace(name, template_parameters, parent_namespace, file));

		// add child to parent namespace
		parent_namespace.children.append(child);
		parent_namespace.children_by_name[name].append(child);
		parent_namespace.updateMinState(NamespaceState::Unchecked);

		// initialize visible namespaces
		child.visible_namespaces.add(child);
		if file == parent_namespace.file {
			child.visible_namespaces.add(parent_namespace.visible_namespaces);
		}

		// initialize llvm debug info
		if this.di_builder != LLVMDIBuilderRef::null() {
			child.llvm_di = LLVMDIBuilderCreateNameSpace(this.di_builder, parent_namespace.llvm_di, child.name, true);
		}

		return child;
	}

	func createModule(this: &&Program, file: SharedHandle!<CompilationUnit>) -> SharedHandle!<Namespace> {
		const namespaces = file.name.split("/");

		var module = this.top_level_namespaces[file.group];
		for i in 0u..(namespaces.size() - 1) {
			module = this.getOrCreateChildNamespace(namespaces[i], List!<TemplateParameterDecl>(), module, SharedHandle!<CompilationUnit>());
		}
		module = this.getOrCreateChildNamespace(namespaces[namespaces.size() - 1], List!<TemplateParameterDecl>(), module, file);

		this.modules_by_path.set(file.path, module);
		return module;
	}

	func getModule(this: &&Program, path: String) -> Optional!<SharedHandle!<Namespace>> {
		return this.modules_by_path.get(path);
	}

	func createType(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: &List!<TemplateParameterDecl>, body: TypeBody) -> SharedHandle!<TypeDecl> {
		var linked_namespace = this.getOrCreateChildNamespace(name, template_parameters, parent_namespace, parent_namespace.file);
		var type_decl = this.types.append(TypeDecl(name, linked_namespace.template_parameters, body));

		type_decl.parent_namespace = linked_namespace.parent;
		type_decl.linked_namespace = linked_namespace;

		linked_namespace.linked_type = type_decl;

		parent_namespace.types.append(type_decl);
		parent_namespace.types_by_name[name].append(type_decl);

		return type_decl;
	}

	func createType(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, body: TypeBody) -> SharedHandle!<TypeDecl> {
		return this.createType(parent_namespace, name, List!<TemplateParameterDecl>(), body);
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: &List!<TemplateParameterDecl>, parameter_types: &List!<Type>, return_type: Type, body: FunctionBody) -> SharedHandle!<FunctionDecl> {
		var function = this.functions.append(FunctionDecl(name, template_parameters, body));

		function.parent_namespace = parent_namespace;
		function.parameter_types = parameter_types;
		function.return_type = return_type;

		parent_namespace.functions.append(function);
		parent_namespace.functions_by_name[name].append(function);

		if !(body is Unchecked) {
			parent_namespace.addUncheckedFunction(function);
		}

		return function;
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: &List!<TemplateParameterDecl>, parameter_types: &List!<Type>, return_type: Type, body: BuiltinFunction) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, template_parameters, parameter_types, return_type, FunctionBody::Builtin(body));
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: &List!<TemplateParameterDecl>, body: FunctionBody) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, template_parameters, List!<Type>(), Type::unknown(), body);
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, template_parameters: &List!<TemplateParameterDecl>, body: BuiltinFunction) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, template_parameters, List!<Type>(), Type::unknown(), FunctionBody::Builtin(body));
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, parameter_types: &List!<Type>, return_type: Type, body: FunctionBody) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, List!<TemplateParameterDecl>(), parameter_types, return_type, body);
	}

	func createFunction(this: &&Program, parent_namespace: SharedHandle!<Namespace>, name: String, parameter_types: &List!<Type>, return_type: Type, body: BuiltinFunction) -> SharedHandle!<FunctionDecl> {
		return this.createFunction(parent_namespace, name, List!<TemplateParameterDecl>(), parameter_types, return_type, FunctionBody::Builtin(body));
	}

	func printLLVMIRToFile(this: &Program) -> Optional!<String> {
		const output_path = this.options.getOutputCodePath(".ll");
		if printModuleToFile(this.llvm_module, output_path) {
			return Some(output_path);
		} else {
			return None;
		}
	}

	func writeLLVMBitcodeToFile(this: &Program) -> Optional!<String> {
		const output_path = this.options.getOutputCodePath(".bc");
		if LLVMWriteBitcodeToFile(this.llvm_module, output_path) == 0 {
			return Some(output_path);
		} else {
			return None;
		}
	}

	func printLLVMIRString(this: &Program) -> String {
		return printModuleToString(this.llvm_module);
	}

	func finalizeDI(this: &Program) -> void {
		if this.di_builder != LLVMDIBuilderRef::null() {
			LLVMDIBuilderFinalize(this.di_builder);
		}
	}

	func runFunction(this: &Program, function: SharedHandle!<FunctionDecl>, args: &List!<LLVMGenericValueRef>) -> LLVMGenericValueRef {
		return LLVMRunFunction(this.llvm_execution_engine, function.llvm_func, args);
	}

	func runMainFunction(this: &Program, args: &List!<String>, env: &List!<String>) -> int {
		return LLVMRunFunctionAsMain(this.llvm_execution_engine, LLVMGetNamedFunction(this.llvm_module, "main"), args, env);
	}
}

variant Concept {
	var name: String;

	case Any;
	case Boolean;
	case Integer: bool;
	case String;

	func dump(this: &Concept, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("Concept", is_last);
		out.attribute(this.name);

		match this {
			case Any -> out.value("Any");
			case Boolean -> out.value("Boolean");
			case Integer: is_signed -> out.value("Integer " + ("signed" if is_signed else "unsigned"));
			case String -> out.value("String");
		}

		out.pop();
	}
}

struct TemplateParameterDecl {
	var name: String;

	var concept: SharedHandle!<Concept>;
	var is_variadic: bool;

	var value: TemplateParameter;

	func constructor(this: &&TemplateParameterDecl, name: String, concept: SharedHandle!<Concept>, is_variadic: bool) -> void {
		this.name := name;
		this.concept := concept;
		this.is_variadic := is_variadic;
		this.value := None;
	}

	func constructor(this: &&TemplateParameterDecl, name: String, concept: SharedHandle!<Concept>, is_variadic: bool, value: TemplateParameter) -> void {
		this.name := name;
		this.concept := concept;
		this.is_variadic := is_variadic;
		this.value := value;
	}

	func constructor(this: &&TemplateParameterDecl, other: TemplateParameterDecl) -> void = default;
	func destructor(this: &&TemplateParameterDecl) -> void = default;

	operator =(this: &&TemplateParameterDecl, other: TemplateParameterDecl) -> void = default;

	operator ==(this: TemplateParameterDecl, other: TemplateParameterDecl) -> bool = default;

	func signature(this: &TemplateParameterDecl) -> String {
		var result = this.name + ": ";
		result += ("..." if this.is_variadic else "");
		result += this.concept.name;

		if !(this.value is None) {
			result += " = ";
			result += format(this.value);
		}

		return result;
	}

	func dump(this: &TemplateParameterDecl, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("TemplateParameterDecl", is_last);
		out.attribute(this.name);
		out.text(":");
		out.attribute(this.concept.name);

		if !(this.value is None) {
			out.text(" =");
			out.value(format(this.value));
		}

		out.pop();
	}
}

variant TemplateParameter {
	case None;
	case Type: Type;
	case Boolean: bool;
	case Integer: int;
	case String: String;
	case Garbage;
}

struct Name {
	var span: Span;
	var segments: List!<NameSegment>;

	func constructor(this: &&Name) -> void = default;

	func constructor(this: &&Name, span: Span) -> void {
		this.span := span;
	}

	func constructor(this: &&Name, name: String) -> void {
		this.segments := (1u, NameSegment(name, List!<TemplateParameter>()));
	}

	func constructor(this: &&Name, span: Span, name: String, template_parameters: &List!<TemplateParameter>) -> void {
		this.span := span;
		this.segments := (1u, NameSegment(name, template_parameters));
	}

	func constructor(this: &&Name, name: String, template_parameters: &List!<TemplateParameter>) -> void {
		this.segments := (1u, NameSegment(name, template_parameters));
	}

	func constructor(this: &&Name, span: Span, segments: List!<NameSegment>) -> void {
		this.span := span;
		this.segments := segments;
	}

	func constructor(this: &&Name, other: Name) -> void = default;
	func destructor(this: &&Name) -> void = default;

	operator =(this: &&Name, other: Name) -> void = default;
	operator ==(@[shallow] this: Name, @[shallow] other: Name) -> bool = default;

	operator +(@[shallow] this: Name, @[shallow] segment: NameSegment) -> Name {
		var result = this;
		result.segments.append(segment);
		return result;
	}

	operator ..(@[shallow] lhs: Name, @[shallow] rhs: Name) -> Name {
		return Name(lhs.span..rhs.span, lhs.segments + rhs.segments);
	}

	func intersection(this: &Name, segments: &List!<NameSegment>) -> uint {
		for offset in 0u..this.segments.size() {
			if segments.startsWith(this.segments[offset..this.segments.size()]) {
				return this.segments.size() - offset;
			}
		}

		return 0u;
	}
}

enum NamespaceState {
	case IncompleteTemplate;
	case Unchecked;
	case UncheckedTypeBodies;
	case UncheckedFunctionSignatures;
	case UncheckedFunctionBodies;
	case Done;

	operator +(this: NamespaceState, delta: uint) -> NamespaceState {
		return (this as uint + delta) as NamespaceState;
	}
}

struct Namespace {
	var span: Span;
	var name_span: Span;
	var has_errors: bool;
	var file: SharedHandle!<CompilationUnit>;

	var name: String;
	var full_name: Name;
	var template_parameters: List!<TemplateParameterDecl>;

	var parent: SharedHandle!<Namespace>;
	var children: List!<SharedHandle!<Namespace>>;
	var children_by_name: Map!<String, List!<SharedHandle!<Namespace>>>;
	var aliases: Map!<String, SharedHandle!<Namespace>>;

	var imported_namespaces: Set!<SharedHandle!<Namespace>>;
	var visible_namespaces: Set!<SharedHandle!<Namespace>>;

	var template_instances: List!<SharedHandle!<Namespace>>;

	var linked_type: SharedHandle!<TypeDecl>;

	var types: List!<SharedHandle!<TypeDecl>>;
	var types_by_name: Map!<String, List!<SharedHandle!<TypeDecl>>>;

	var functions: List!<SharedHandle!<FunctionDecl>>;
	var functions_by_name: Map!<String, List!<SharedHandle!<FunctionDecl>>>;

	var comptime_variables: SharedList!<VarDecl>;
	var comptime_variables_by_name: Map!<String, SharedHandle!<VarDecl>>;

	var state: NamespaceState;
	var unchecked_bodies: List!<ParsedNamespaceDecl>;
	var unchecked_types: List!<SharedHandle!<TypeDecl>>;
	var unchecked_functions: List!<SharedHandle!<FunctionDecl>>;
	var unchecked_function_bodies: List!<SharedHandle!<FunctionDecl>>;

	var llvm_di: LLVMMetadataRef;

	func constructor(this: &&Namespace, name: String, template_parameters: &List!<TemplateParameterDecl>, parent: SharedHandle!<Namespace>, file: SharedHandle!<CompilationUnit>) -> void {
		this.file := file;

		this.name := name;
		this.template_parameters := template_parameters;
		this.parent := parent;
		this.state := Unchecked;

		var template_parameter_values: List!<TemplateParameter>;
		for p in template_parameters {
			if p.value is None {
				this.state = IncompleteTemplate;
			} else {
				template_parameter_values.append(p.value);
			}
		}

		var full_name: Name;
		if this.parent.isAlive() {
			full_name = this.parent.full_name + NameSegment(name, template_parameter_values);
		} else {
			full_name = Name(name, template_parameter_values);
		}

		this.full_name := full_name;
	}

	func constructor(this: &&Namespace, other: Namespace) -> void {
		this.file := other.file;
		this.name := other.name;
		this.full_name := other.full_name;
		this.template_parameters := other.template_parameters;

		this.parent := other.parent;

		this.state := other.state;
	}

	func destructor(this: &&Namespace) -> void = default;

	func signature(this: &Namespace) -> String {
		if this.parent.isAlive() {
			var result = this.parent.signature();
			result += "::";
			result += this.name;
			result += format(this.template_parameters);
			return result;
		}

		return this.name + format(this.template_parameters);
	}

	func dump(this: &Namespace, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("Namespace", is_last);
		out.attribute(this.signature());
		out.value(format(this.state));

		for parameter in this.template_parameters {
			parameter.dump(&&out, false);
		}

		for i in 0u..this.children.size() {
			this.children[i].dump(&&out, (i == this.children.size() - 1) && this.types.isEmpty() && this.functions.isEmpty()&& this.comptime_variables.isEmpty());
		}

		for i in 0u..this.types.size() {
			this.types[i].dump(&&out, (i == this.types.size() - 1) && this.functions.isEmpty()&& this.comptime_variables.isEmpty());
		}

		for i in 0u..this.functions.size() {
			this.functions[i].dump(&&out, (i == this.functions.size() - 1) && this.comptime_variables.isEmpty());
		}

		for i in 0u..this.comptime_variables.size() {
			this.comptime_variables[i].dump(&&out, i == this.comptime_variables.size() - 1);
		}

		out.pop();
	}

	func isIncompleteTemplate(this: &Namespace) -> bool {
		return this.state == IncompleteTemplate
	}

	func updateState(this: &&Namespace, new_state: NamespaceState) -> void {
		if this.state == IncompleteTemplate {
			return;
		}

		this.state = new_state;

		if this.parent.isAlive() {
			this.parent.updateMinState(new_state);
		}
	}

	func updateMinState(this: &&Namespace, min_state: NamespaceState) -> void {
		if this.state == IncompleteTemplate {
			return;
		}

		if this.state <= min_state {
			return;
		}

		this.state = min_state;

		if this.parent.isAlive() {
			this.parent.updateMinState(min_state);
		}
	}

	func addImportedNamespace(this: &&Namespace, other: SharedHandle!<Namespace>) -> void {
		this.imported_namespaces.add(other);
		this.addVisibleNamespace(other);
	}

	func addVisibleNamespace(this: &&Namespace, other: SharedHandle!<Namespace>) -> void {
		this.visible_namespaces.add(other);
		for c in this.children {
			c.addVisibleNamespace(other);
		}
	}

	func addUncheckedBody(this: &&Namespace, body: &ParsedNamespaceDecl) -> void {
		this.unchecked_bodies.append(body);
		this.updateMinState(NamespaceState::Unchecked);

		for instance in this.template_instances {
			instance.addUncheckedBody(body);
		}
	}

	func addUncheckedType(this: &&Namespace, type: SharedHandle!<TypeDecl>) -> void {
		this.unchecked_types.append(type);
		this.updateMinState(NamespaceState::UncheckedTypeBodies);
	}

	func addUncheckedFunction(this: &&Namespace, function: SharedHandle!<FunctionDecl>) -> void {
		this.unchecked_functions.append(function);
		this.updateMinState(NamespaceState::UncheckedFunctionSignatures);
	}

	func addUncheckedFunctionBody(this: &&Namespace, function: SharedHandle!<FunctionDecl>) -> void {
		this.unchecked_function_bodies.append(function);
		this.updateMinState(NamespaceState::UncheckedFunctionBodies);
	}

	func createComptimeVariable(this: &&Namespace, span: Span, name: String, type: Type, is_const: bool) -> SharedHandle!<VarDecl> {
		const variable = this.comptime_variables.append(VarDecl(span, 0u, name, type, is_const, false, true));
		this.comptime_variables_by_name.set(name, variable);
		return variable;
	}
}

struct TypeDecl {
	var span: Span;
	var name_span: Span;

	var name: String;
	var template_parameters: List!<TemplateParameterDecl>;
	var body: TypeBody;

	var parent_namespace: SharedHandle!<Namespace>;
	var linked_namespace: SharedHandle!<Namespace>;

	var unwrapped_type: SharedHandle!<TypeDecl>;

	var default_constructor: SharedHandle!<FunctionDecl>;
	var copy_constructor: SharedHandle!<FunctionDecl>;
	var destructor: SharedHandle!<FunctionDecl>;
	var op_assign: SharedHandle!<FunctionDecl>;
	var op_equal: SharedHandle!<FunctionDecl>;
	var op_compare: SharedHandle!<FunctionDecl>;

	var contained_types: Set!<SharedHandle!<TypeDecl>>;

	var parsed_annotations: List!<ParsedAnnotation>;

	var parsed_body: uint;

	// struct & variant
	var member_variables: List!<MemberVarDecl>;
	var member_variables_by_name: Map!<String, uint>;

	// enum & variant
	var parsed_id_type: uint;
	var id_type: Type;

	// only enum
	var enum_cases: List!<EnumCaseDecl>;
	var enum_cases_by_name: Map!<String, uint>;

	// only variant
	var variant_cases: List!<VariantCaseDecl>;
	var variant_cases_by_id: Map!<int, uint>;
	var variant_cases_by_name: Map!<String, uint>;

	// flags for codegen
	var is_packed: bool;

	// llvm
	var llvm_type: LLVMTypeRef;
	var llvm_di: LLVMMetadataRef;

	func constructor(this: &&TypeDecl, name: String, template_parameters: &List!<TemplateParameterDecl>, body: TypeBody) -> void {
		this.name := name;
		this.template_parameters := template_parameters;
		this.body := body;
		this.parsed_id_type := 0;
	}

	func constructor(this: &&TypeDecl, other: TypeDecl) -> void = default;
	func destructor(this: &&TypeDecl) -> void = default;

	func dump(this: &TypeDecl, out: &&TreeFormatter, is_last: bool) -> void {
		match this.body {
			case Empty -> out.push("EmptyTypeDecl", is_last);
			case Void -> out.push("VoidTypeDecl", is_last);
			case Bool -> out.push("BoolTypeDecl", is_last);
			case Byte -> out.push("ByteTypeDecl", is_last);
			case Int: size -> {
				out.push("IntTypeDecl", is_last);
				out.value(format(size));
			}
			case UInt: size -> {
				out.push("UIntTypeDecl", is_last);
				out.value(format(size));
			}
			case Float: size -> {
				out.push("FloatTypeDecl", is_last);
				out.value(format(size));
			}
			case Pointer: pointer_type -> {
				out.push("PointerTypeDecl", is_last);
				out.attribute("var" if pointer_type.is_mutable else "const");
				out.value(pointer_type.pointee_type.signature());
			}
			case Function -> out.push("FunctionTypeDecl", is_last);
			case Tuple -> out.push("TupleTypeDecl", is_last);
			case Array: array_type -> {
				out.push("ArrayTypeDecl", is_last);
				out.value(array_type.element_type.signature());
				out.value(format(array_type.size));
			}
			case Range: type -> {
				out.push("Range", is_last);
				out.value(type.element_type.signature());
				out.value(format(type.is_mutable));
			}
			case RangeIterator: type -> {
				out.push("RangeIterator", is_last);
				out.value(type.element_type.signature());
				out.value(format(type.is_mutable));
			}
			case NumericRange: type -> {
				out.push("NumericRange", is_last);
				out.value(type.signature());
			}
			case NumericIterator: type -> {
				out.push("NumericIterator", is_last);
				out.value(type.signature());
			}
			case Enum -> out.push("EnumTypeDecl", is_last);
			case Struct -> out.push("StructTypeDecl", is_last);
			case Variant -> out.push("VariantTypeDecl", is_last);
			case Unchecked -> out.push("UncheckedType", is_last);
		}

		out.attribute(this.signature());

		for i in 0u..this.template_parameters.size() {
			this.template_parameters[i].dump(&&out, (i == this.template_parameters.size() - 1) && this.member_variables.isEmpty() && this.enum_cases.isEmpty() && this.variant_cases.isEmpty());
		}

		for i in 0u..this.member_variables.size() {
			this.member_variables[i].dump(&&out, (i == this.member_variables.size() - 1) && this.enum_cases.isEmpty() && this.variant_cases.isEmpty());
		}

		for i in 0u..this.enum_cases.size() {
			this.enum_cases[i].dump(&&out, i == this.enum_cases.size() - 1);
		}

		for i in 0u..this.variant_cases.size() {
			this.variant_cases[i].dump(&&out, i == this.variant_cases.size() - 1);
		}

		out.pop();
	}

	func signature(this: &TypeDecl) -> String {
		return this.linked_namespace.signature();
	}

	func isIncompleteTemplate(this: &TypeDecl) -> bool {
		for parameter in this.template_parameters {
			if parameter.value is None {
				return true;
			}
		}

		return false;
	}

	func addContainedType(this: &&TypeDecl, type: Type) -> void {
		if type.isUnknown() {
			return;
		}

		if type.reference_kind == None {
			this.contained_types.add(type.decl);
		}
	}

	func createMemberVariable(this: &&TypeDecl, span: Span, name: String, type: Type, initializer: &Expr) -> void {
		if this.member_variables_by_name.contains(name) {
			return;
		}

		this.member_variables_by_name.set(name, this.member_variables.size());
		this.member_variables.append(MemberVarDecl(span, this.member_variables.size(), name, type, initializer));

		this.addContainedType(type);
	}

	func getMemberVariable(this: &TypeDecl, name: String) -> Optional!<MemberVarDecl> {
		for v in this.member_variables {
			if v.name == name {
				return Some(v);
			}
		}

		return None;
	}

	func getNextCaseId(this: &TypeDecl) -> int {
		if this.body is Enum {
			if const prev_case = this.enum_cases.last() {
				return prev_case.id + 1;
			}
		} else if this.body is Variant {
			if const prev_case = this.variant_cases.last() {
				return prev_case.id + 1;
			}
		}
		return 0;
	}

	func createEnumCase(this: &&TypeDecl, span: Span, id: int, name: String) -> void {
		this.enum_cases_by_name.set(name, this.enum_cases.size());
		this.enum_cases.append(EnumCaseDecl(span, id, name));
	}

	func getEnumCase(this: &TypeDecl, name: String) -> Optional!<EnumCaseDecl> {
		const index = this.enum_cases_by_name.get(name) else {
			return None;
		}

		return Some(this.enum_cases[index]);
	}

	func createVariantCase(this: &&TypeDecl, span: Span, id: int, name: String, payload: Type) -> void {
		this.variant_cases_by_name.set(name, this.variant_cases.size());
		this.variant_cases_by_id.set(id, this.variant_cases.size());
		this.variant_cases.append(VariantCaseDecl(span, id, name, payload));
		this.addContainedType(payload);
	}

	func getVariantCase(this: &TypeDecl, name: String) -> Optional!<VariantCaseDecl> {
		const index = this.variant_cases_by_name.get(name) else {
			return None;
		}

		return Some(this.variant_cases[index]);
	}

	func getVariantCase(this: &TypeDecl, id: int) -> Optional!<VariantCaseDecl> {
		const index = this.variant_cases_by_id.get(id) else {
			return None;
		}

		return Some(this.variant_cases[index]);
	}
}

struct Type {
	var decl: SharedHandle!<TypeDecl>;
	var reference_kind: ReferenceKind;

	func constructor(this: &&Type, decl: SharedHandle!<TypeDecl>) -> void {
		this.decl := decl;
		this.reference_kind := None;
	}

	func constructor(this: &&Type, decl: SharedHandle!<TypeDecl>, reference_kind: ReferenceKind) -> void {
		this.decl := decl;
		this.reference_kind := reference_kind;
	}

	func constructor(this: &&Type) -> void = default;
	func constructor(this: &&Type, other: Type) -> void = default;
	func destructor(this: &&Type) -> void = default;

	operator =(this: &&Type, other: Type) -> void = default;

	operator ==(this: Type, other: Type) -> bool = default;
	operator <=>(this: Type, other: Type) -> int = default;

	func unknown() -> Type {
		return Type(SharedHandle!<TypeDecl>(), ReferenceKind::None);
	}

	func isUnknown(this: &Type) -> bool {
		return this.decl.isEmpty();
	}

	func isAlive(this: &Type) -> bool {
		return this.decl.isAlive();
	}

	func signature(this: &Type) -> String {
		if this.decl.isAlive() {
			return this.reference_kind.toString() + this.decl.signature();
		}

		return "unknown";
	}

	func base(this: &Type) -> Type {
		return Type(this.decl, ReferenceKind::None);
	}

	func constRef(this: &Type) -> Type {
		return Type(this.decl, ReferenceKind::Const);
	}

	func varRef(this: &Type) -> Type {
		return Type(this.decl, ReferenceKind::Var);
	}

	func isIncompleteTemplate(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		return this.decl.isIncompleteTemplate();
	}

	func isIntType(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Bool
			| Byte
			| Int
			| UInt
			| Enum -> return true;
			else -> return false;
		}
	}

	func isSigned(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Int
			| Float -> return true;
			else -> return false;
		}
	}

	func isFloatType(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Float -> return true;
			else -> return false;
		}
	}

	func isPtrType(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Pointer -> return true;
			else -> return false;
		}
	}

	func isConstPtrType(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Pointer: pointer_type -> return !pointer_type.is_mutable;
			else -> return false;
		}
	}

	func isPrimitive(this: &Type) -> bool {
		if this.reference_kind != None {
			return true; // reference types are always primitive
		}

		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Void
			| Bool
			| Byte
			| Int
			| UInt
			| Float
			| Pointer
			| Function
			| Enum -> return true;
			case Array: array_type -> return array_type.element_type.isPrimitive();
			else -> return false;
		}
	}

	func isVariant(this: &Type) -> bool {
		if this.decl.isEmpty() {
			return false;
		}

		match this.decl.body {
			case Variant -> return true;
			else -> return false;
		}
	}

	func getPrimitiveSizeInBits(this: &Type) -> uint {
		if this.reference_kind != None {
			return sizeOf!<ptr!<byte, false>>() * 8;
		}

		if this.decl.isEmpty() {
			return 0;
		}

		match this.decl.body {
			case Void -> return 0;
			case Bool -> return 1;
			case Byte -> return 8;
			case Int: bits -> return bits;
			case UInt: bits -> return bits;
			case Float: bits -> return bits;
			case Pointer -> return sizeOf!<ptr!<byte, false>>() * 8;
			case Enum -> return this.decl.id_type.getPrimitiveSizeInBits();
			else -> return 0;
		}
	}

	func getBitMask(this: &Type) -> int {
		return -1 >> (sizeOf!<uint>() * 8 - this.getPrimitiveSizeInBits()) as int;
	}
}

struct FunctionDecl {
	var span: Span;
	var signature_span: Span;
	var has_errors: bool;

	var name: String;
	var template_parameters: List!<TemplateParameterDecl>;
	var body: FunctionBody;

	var parent_namespace: SharedHandle!<Namespace>;

	var extern_name: String;

	var parameter_types: List!<Type>;
	var return_type: Type;

	var variables: SharedList!<VarDecl>;
	var parameters: List!<SharedHandle!<VarDecl>>;

	var is_copy_constructor: bool;

	// llvm
	var llvm_func: LLVMValueRef;
	var llvm_type: LLVMTypeRef;
	var llvm_di: LLVMMetadataRef;

	func constructor(this: &&FunctionDecl, name: String, template_parameters: &List!<TemplateParameterDecl>, body: FunctionBody) -> void {
		this.name := name;
		this.template_parameters := template_parameters;
		this.body := body;
	}

	func constructor(this: &&FunctionDecl, other: FunctionDecl) -> void {
		this.name := other.name;
		this.template_parameters := other.template_parameters;
		this.body := other.body;
	}

	func destructor(this: &&FunctionDecl) -> void = default;

	func dump(this: &FunctionDecl, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("FunctionDecl", is_last);
		out.attribute(this.signature());
		out.span(this.span);

		for parameter in this.template_parameters {
			parameter.dump(&&out, false);
		}

		for variable in this.variables {
			if variable.is_parameter {
				variable.dump(&&out, false);
			}
		}

		match this.body {
			case Empty -> {
				out.push("EmptyFunction", true);
				out.pop();
			}
			case Extern -> {
				out.push("ExternFunction", true);
				out.pop();
			}
			case Builtin: f -> {
				out.push("BuiltinFunction", true);
				out.pop();
			}
			case Stmt: stmt -> stmt.dump(&&out, true);
			case Unchecked -> {
				out.push("UncheckedFunction", true);
				out.pop();
			}
		}

		out.pop();
	}

	func signature(this: &FunctionDecl) -> String {
		var result = this.parent_namespace.signature();

		result += "::";
		result += this.name;
		result += this.template_parameters.format();
		result += "(";

		for i in 0u..this.parameter_types.size() {
			if i != 0 {
				result += ", ";
			}
			result += this.parameter_types[i].signature();
		}

		result += ") -> ";
		result += this.return_type.signature();
		return result;
	}

	func createParameter(this: &&FunctionDecl, span: Span, name: String, type: Type) -> void {
		const variable = this.variables.append(VarDecl(span, this.variables.size(), name, type, type.reference_kind != Var, true, false));
		this.parameters.append(variable);
	}

	func createVariable(this: &&FunctionDecl, span: Span, name: String, type: Type, is_const: bool, is_comptime: bool) -> SharedHandle!<VarDecl> {
		return this.variables.append(VarDecl(span, this.variables.size(), name, type, is_const, false, is_comptime));
	}

	func isIncompleteTemplate(this: &FunctionDecl) -> bool {
		for parameter in this.template_parameters {
			if parameter.value is None {
				return true;
			}
		}

		return false;
	}
}

variant TypeBody {
	case Empty;

	case Void;
	case Bool;
	case Byte;

	// size in bits attached, 0 -> pointer sized
	case Int: uint;
	case UInt: uint;

	// size in bits attached
	case Float: uint;

	case Pointer: (pointee_type: Type, is_mutable: bool);
	case Function: (parameter_types: List!<Type>, return_type: Type);

	case Tuple;

	case Array: (element_type: Type, size: uint);

	case Range: (element_type: Type, is_mutable: bool);
	case RangeIterator: (element_type: Type, is_mutable: bool);

	case NumericRange: Type;
	case NumericIterator: Type;

	case Struct;
	case Enum;
	case Variant;

	case Unchecked: ParsedTypeDecl;
}

variant FunctionBody {
	case Empty;
	case Extern;
	case Builtin: BuiltinFunction;
	case Stmt: Stmt;
	case Unchecked: ParsedFunctionDecl;
}

struct VarDecl {
	var span: Span;

	var id: uint;
	var name: String;
	var type: Type;

	var is_const: bool;
	var is_parameter: bool;
	var is_comptime: bool;
	var is_unused: bool;

	var constructor_call: Expr;
	var destructor_call: Expr;

	// comptime only
	var value: Expr;

	// parameters only
	var is_shallow_parameter: bool;

	func constructor(this: &&VarDecl, span: Span, id: uint, name: String, type: Type, is_const: bool, is_parameter: bool, is_comptime: bool) -> void {
		this.span := span;

		this.id := id;
		this.name := name;
		this.type := type;

		this.is_const := is_const;
		this.is_parameter := is_parameter;
		this.is_comptime := is_comptime;

		this.constructor_call := Expr::Undefined(Span(), Type::unknown());
		this.destructor_call := Expr::Undefined(Span(), Type::unknown());

		this.value := Expr::Undefined(Span(), Type::unknown());

		this.is_shallow_parameter = false;
	}

	func constructor(this: &&VarDecl, other: VarDecl) -> void = default;
	func destructor(this: &&VarDecl) -> void = default;

	operator =(this: &&VarDecl, other: VarDecl) -> void = default;

	operator ==(@[shallow] this: VarDecl, @[shallow] other: VarDecl) -> bool {
		return this.id == other.id;
	}

	func dump(this: &VarDecl, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("ParameterDecl" if this.is_parameter else "VarDecl", is_last);

		out.attribute(("#" if this.is_parameter else "") + this.name);
		out.value(format(this.id));
		out.text(" :");
		out.value(this.type.signature());

		if this.is_comptime {
			out.value("comptime");
		}

		out.value("const" if this.is_const else "var");
		out.span(this.span);

		this.constructor_call.dump(&&out, false);
		this.destructor_call.dump(&&out, !this.is_comptime);

		if this.is_comptime {
			this.value.dump(&&out, true);
		}

		out.pop();
	}

	func signature(this: &VarDecl) -> String {
		return ("const " if this.is_const else "var ") + this.name + ": " + this.type.signature();
	}
}

enum PrimitiveOp {
	case NoOp;
	case ConstNull;
	case Copy;

	case BitwiseEQ;
	case BitwiseNE;

	case BitwiseAnd;
	case BitwiseOr;
	case BitwiseXOr;
	case BitwiseNot;
	case BitwiseShl;
	case BitwiseLShr;
	case BitwiseAShr;

	case IntAdd;
	case IntSub;
	case IntMul;
	case IntNeg;
	case IntInc;
	case IntDec;

	case SIntLT;
	case SIntLE;
	case SIntGT;
	case SIntGE;
	case SIntCmp;

	case SIntDiv;
	case SIntMod;

	case UIntLT;
	case UIntLE;
	case UIntGT;
	case UIntGE;
	case UIntCmp;

	case UIntDiv;
	case UIntMod;

	case FloatEQ;
	case FloatNE;
	case FloatLT;
	case FloatLE;
	case FloatGT;
	case FloatGE;
	case FloatCmp;

	case FloatAdd;
	case FloatSub;
	case FloatMul;
	case FloatDiv;
	case FloatMod;
	case FloatNeg;

	case Assign = 64;

	operator |(lhs: PrimitiveOp, rhs: PrimitiveOp) -> PrimitiveOp = default;

	func isAssignment(op: PrimitiveOp) -> bool {
		return ((op as uint) & 64) != 0;
	}

	func getOp(op: PrimitiveOp) -> PrimitiveOp {
		return ((op as uint) & ~64u) as PrimitiveOp;
	}
}

variant BuiltinFunction {
	var base_type: Type;

	case Empty;
	case PrimitiveOp: PrimitiveOp;

	case PointerToRef;
	case RefToPointer;
	case PointerCast;

	case PointerDiff;
	case PointerOffset;
	case PointerOpIndex;

	case FunctionPointerCall;

	// base type is source type, attached type target
	case IntCast: Type;
	case FloatCast: Type;
	case IntToFloat: Type;
	case FloatToInt: Type;

	// base type is first template parameter
	case SizeOf;
	case AlignmentOf;
	case ReferenceKindOf;
	case HasDefaultConstructor;
	case HasCopyConstructor;

	case Assert;
	case AssertError;

	case RangeGetData;
	case RangeGetSize;

	// attached type is iterator type
	case RangeGetIterator: Type;

	case RangeIteratorHasNext;
	case RangeIteratorGetNext;

	// attached type is range type
	case NumericTypeRangeOperator: Type;

	// attached type is numeric type
	case NumericRangeSetStep: Type;

	// attached type is iterator type
	case NumericRangeGetIterator: Type;

	// attached type is numeric type
	case NumericIteratorHasNext: Type;
	case NumericIteratorGetNext: Type;

	// attached value is id of target case
	case VariantOpUnsafeAs: int;
	case VariantOpIs: int;

	case ArrayGetSize;
	case ArrayGetDataPointer;

	case StructValueConstructor;
	case StructDefaultConstructor;
	case StructCopyConstructor;
	case StructDestructor;
	case StructOpAssign;
	case StructOpEqual;
	case StructOpCmp;

	case VariantCaseConstructor: int;
	case VariantCopyConstructor;
	case VariantDestructor;
	case VariantOpAssign;
	case VariantOpEqual;

	case ArrayDefaultConstructor;
	case ArrayCopyConstructor;
	case ArrayDestructor;
	case ArrayOpAssign;
	case ArrayOpEqual;

	func isInlineable(this: &BuiltinFunction) -> bool {
		match this {
			case PrimitiveOp
			| PointerToRef
			| RefToPointer
			| PointerCast
			| PointerDiff
			| PointerOffset
			| PointerOpIndex
			| FunctionPointerCall
			| IntCast
			| FloatCast
			| IntToFloat
			| FloatToInt
			| SizeOf
			| AlignmentOf
			| ReferenceKindOf
			| HasDefaultConstructor
			| HasCopyConstructor
			| Assert
			| AssertError
			| RangeGetData
			| RangeGetSize
			| RangeGetIterator
			| RangeIteratorHasNext
			| RangeIteratorGetNext
			| NumericTypeRangeOperator
			| NumericRangeSetStep
			| NumericRangeGetIterator
			| NumericIteratorHasNext
			| NumericIteratorGetNext
			| VariantOpUnsafeAs
			| VariantOpIs
			| ArrayGetSize
			| ArrayGetDataPointer -> return true;
			else -> return false;
		}
	}
}

variant Stmt {
	var span: Span;

	case Empty;

	case Compound: CompoundStmt;

	case Expr: Expr;

	case If: Box!<IfStmt>;
	case While: Box!<WhileStmt>;
	case For: Box!<ForStmt>;

	case Case: Box!<CaseStmt>;
	case ElseCase: Box!<Stmt>;

	case Break;
	case Continue;
	case Yield;

	case Return: Expr;

	case LifeTimeStart: SharedHandle!<VarDecl>;
	case LifeTimeEnd: SharedHandle!<VarDecl>;

	func dump(this: &Stmt, out: &&TreeFormatter, is_last: bool) -> void {
		match this {
			case Empty -> {
				out.push("EmptyStmt", is_last);
				out.span(this.span);
				out.pop();
			}
			case Compound: compound_stmt -> compound_stmt.dump(&&out, is_last);
			case Expr: expr -> expr.dump(&&out, is_last);
			case If: if_stmt -> {
				out.push("IfStmt", is_last);
				out.span(this.span);

				if_stmt.condition.dump(&&out, false);
				if_stmt.then_branch.dump(&&out, false);
				if_stmt.else_branch.dump(&&out, true);

				out.pop();
			}
			case While: while_stmt -> {
				match while_stmt.kind {
					case While -> out.push("WhileStmt", is_last);
					case DoWhile -> out.push("DoWhileStmt", is_last);
				}
				out.span(this.span);

				while_stmt.condition.dump(&&out, false);
				while_stmt.body.dump(&&out, false);

				out.pop();
			}
			case For: for_stmt -> {
				out.push("ForStmt", is_last);
				out.span(this.span);

				for_stmt.iterator.dump(&&out, false);
				for_stmt.body.dump(&&out, false);

				out.pop();
			}
			case Case -> {}
			case ElseCase -> {}
			case Break -> {
				out.push("BreakStmt", is_last);
				out.span(this.span);
				out.pop();
			}
			case Continue -> {
				out.push("ContinueStmt", is_last);
				out.span(this.span);
				out.pop();
			}
			case Yield -> {
				out.push("YieldStmt", is_last);
				out.span(this.span);
				out.pop();
			}
			case Return: value -> {
				out.push("ReturnStmt", is_last);
				out.span(this.span);
				value.dump(&&out, true);
				out.pop();
			}
			case LifeTimeStart: variable -> {
				variable.dump(&&out, is_last);
			}
			case LifeTimeEnd: variable -> {
				out.push("LifeTimeEnd", is_last);
				out.value(variable.name);
				out.span(variable.span);
				out.pop();
			}
		}
	}

	func isTerminator(this: &Stmt, never_type: Type, yield_is_terminator: bool) -> bool {
		match this {
			case Empty -> return false;
			case Compound: compound_stmt -> return compound_stmt.isTerminator(never_type, yield_is_terminator);
			case Expr: expr -> return expr.type == never_type;
			case If: if_stmt -> return if_stmt.then_branch.isTerminator(never_type, yield_is_terminator) && if_stmt.else_branch.isTerminator(never_type, yield_is_terminator);
			case While: while_stmt -> return while_stmt.kind == DoWhile && while_stmt.body.isTerminator(never_type, yield_is_terminator);
			case For: for_stmt -> return false;
			case Case: case_stmt -> return false;
			case ElseCase: body -> return body.isTerminator(never_type, yield_is_terminator);
			case Break | Continue | Return -> return true;
			case Yield -> return yield_is_terminator;
			case LifeTimeStart | LifeTimeEnd -> return false;
		}
	}
}

struct CompoundStmt {
	var span: Span;
	var children: SharedPtr!<List!<Stmt>>;

	func constructor(this: &&CompoundStmt, span: Span) -> void {
		this.span := span;
		this.children := SharedPtr!<List!<Stmt>>::new(List!<Stmt>());
	}

	func constructor(this: &&CompoundStmt, other: CompoundStmt) -> void = default;
	func destructor(this: &&CompoundStmt) -> void = default;

	operator =(this: &&CompoundStmt, other: CompoundStmt) -> void = default;

	operator ==(@[shallow] this: CompoundStmt, @[shallow] other: CompoundStmt) -> bool {
		return this.children.data == other.children.data;
	}

	func dump(this: &CompoundStmt, out: &&TreeFormatter, is_last: bool) -> void {
		out.push("CompoundStmt", is_last);
		out.span(this.span);

		for i in 0u..this.children.size() {
			this.children[i].dump(&&out, i == this.children.size() - 1);
		}

		out.pop();
	}

	func isTerminator(this: &CompoundStmt, never_type: Type, yield_is_terminator: bool) -> bool {
		if const last = this.children.last() {
			return last.isTerminator(never_type, yield_is_terminator);
		}
		return false;
	}
}

variant Expr {
	var span: Span;
	var type: Type;

	case Undefined;

	case Void;
	case Integer: int;
	case Float: f64;
	case String: String;

	case ConstAggregate: List!<Expr>;

	case Call: CallExpr;
	case Match: Box!<MatchExpr>;

	case VarInvoke: SharedHandle!<VarDecl>;
	case MemberVarInvoke: Box!<MemberVarInvokeExpr>;

	case Dereference: Box!<Expr>;

	case ShallowCopy: Box!<ShallowCopyExpr>;

	case TypeRef: Type;
	case FunctionRef: SharedHandle!<FunctionDecl>;

	func constructor(this: &&Expr) -> void {
		this.constructor!<0>(Span(), Type::unknown());
	}

	template <Id: int = 11>
	func constructor(this: &&Expr, data: &ShallowCopyExpr, span: Span, type: Type) -> void {
		this.constructor!<11>(Box!<ShallowCopyExpr>(data), span, type);
	}

	func toBool(this: &Expr) -> bool {
		match this {
			case Integer: val -> return (val & this.type.getBitMask()) as bool;
			else -> return false;
		}
	}

	func toInt(this: &Expr) -> int {
		match this {
			case Integer: val -> return (val & this.type.getBitMask());
			else -> return 0;
		}
	}

	func toUInt(this: &Expr) -> uint {
		match this {
			case Integer: val -> return (val & this.type.getBitMask()) as uint;
			else -> return 0u;
		}
	}

	func toFloat(this: &Expr) -> f64 {
		match this {
			case Float: val -> return val;
			else -> return 0.0;
		}
	}
}

alias NameSegment = (name: String, template_parameters: List!<TemplateParameter>);

alias MemberVarDecl = (span: Span, id: uint, name: String, type: Type, initializer: Expr);
alias EnumCaseDecl = (span: Span, id: int, name: String);
alias VariantCaseDecl = (span: Span, id: int, name: String, type: Type);

alias IfStmt = (condition: Expr, condition_cleanup: List!<Stmt>, then_branch: Stmt, else_branch: Stmt);

enum WhileStmtKind {
	case While;
	case DoWhile;
}

enum ForStmtKind {
	case Count;
	case Range;
}

alias WhileStmt = (condition: Expr, condition_cleanup: List!<Stmt>, body: Stmt, kind: WhileStmtKind);
alias ForStmt = (iterator: Expr, enumerator_variable: SharedHandle!<VarDecl>, body: Stmt, kind: ForStmtKind);
alias CaseStmt = (span: Span, patterns: List!<Expr>, body: Stmt);

enum ReturnKind {
	case None;		// function returns void or never
	case Value;		// most basic, no memory management
	case Variable;	// result gets stored in variable allocated by caller
	case Parameter;	// callee initializes variable allocated by caller, passed by reference as first parameter
	case VariableButYieldNone;	// same as variable, but result gets discarded. Used when initializing a variable with the result of a call (optimized)
}

alias CallExpr = (
	function: SharedHandle!<FunctionDecl>,
	parameters: SharedPtr!<List!<Expr>>,
	result_var: SharedHandle!<VarDecl>,
	return_kind: ReturnKind
);

alias MatchExpr = (value: Expr, cases: List!<CaseStmt>, else_case: Stmt, yield_var: SharedHandle!<VarDecl>);
alias MemberVarInvokeExpr = (object: Expr, id: uint);
alias ShallowCopyExpr = (destination: Expr, value: Expr);

func dump(this: &MemberVarDecl, out: &&TreeFormatter, is_last: bool) -> void {
	out.push("MemberVarDecl", is_last);
	out.attribute(this.name);
	out.value(this.type.signature());
	out.span(this.span);
	this.initializer.dump(&&out, true);
	out.pop();
}

func dump(this: &EnumCaseDecl, out: &&TreeFormatter, is_last: bool) -> void {
	out.push("EnumCaseDecl", is_last);
	out.attribute(this.name);
	out.value(format(this.id));
	out.span(this.span);
	out.pop();
}

func dump(this: &VariantCaseDecl, out: &&TreeFormatter, is_last: bool) -> void {
	out.push("VariantCaseDecl", is_last);
	out.attribute(this.name);
	out.value(format(this.id));
	out.value(this.type.signature());
	out.span(this.span);
	out.pop();
}

func dump(this: &Expr, out: &&TreeFormatter, is_last: bool) -> void {
	match this {
		case Undefined -> {
			out.push("UndefinedExpr", is_last);
			out.span(this.span);
			out.pop();
		}
		case Void -> {
			out.push("VoidExpr", is_last);
			out.span(this.span);
			out.pop();
		}
		case Integer: value -> {
			out.push("IntegerExpr", is_last);
			out.value(format(value));
			out.attribute(this.type.signature());
			out.span(this.span);
			out.pop();
		}
		case Float: value -> {
			out.push("FloatExpr", is_last);
			//out.value(format(value));
			out.attribute(this.type.signature());
			out.span(this.span);
			out.pop();
		}
		case String: value -> {
			out.push("StringExpr", is_last);
			out.value("\"" + value + "\"");
			out.attribute(this.type.signature());
			out.span(this.span);
			out.pop();
		}
		case ConstAggregate -> {}
		case Call: call_expr -> {
			out.push("CallExpr", is_last);
			out.value(call_expr.function.signature());
			out.attribute(format(call_expr.return_kind));
			out.span(this.span);

			if call_expr.result_var.isAlive() {
				call_expr.result_var.dump(&&out, call_expr.parameters.isEmpty());
			}

			for i in 0u..call_expr.parameters.size() {
				call_expr.parameters[i].dump(&&out, i == call_expr.parameters.size() - 1);
			}

			out.pop();
		}
		case Match: match_expr -> {
			out.push("MatchExpr", is_last);
			out.attribute(this.type.signature());
			out.span(this.span);

			match_expr.value.dump(&&out, false);
			if match_expr.yield_var.isAlive() {
				match_expr.yield_var.dump(&&out, false);
			}

			for c in match_expr.cases {
				out.push("CaseStmt", is_last);
				out.span(c.span);

				for pattern in c.patterns {
					pattern.dump(&&out, false);
				}

				c.body.dump(&&out, true);
				out.pop();
			}

			match_expr.else_case.dump(&&out, true);

			out.pop();
		}
		case VarInvoke: variable -> {
			out.push("VarInvokeExpr", is_last);
			out.value(("#" if variable.is_parameter else "") + variable.name);
			out.attribute(this.type.signature());
			out.span(this.span);
			out.pop();
		}
		case MemberVarInvoke: member_var_invoke_expr -> {
			out.push("MemberVarInvokeExpr", is_last);
			out.value(format(member_var_invoke_expr.id));
			out.attribute(this.type.signature());
			out.span(this.span);
			member_var_invoke_expr.object.dump(&&out, true);
			out.pop();
		}
		case Dereference: base -> {
			out.push("DereferenceExpr", is_last);
			out.attribute(this.type.signature());
			out.span(this.span);
			base.dump(&&out, true);
			out.pop();
		}
		case ShallowCopy: shallow_copy_expr -> {
			out.push("ShallowCopyExpr", is_last);
			out.span(this.span);
			shallow_copy_expr.destination.dump(&&out, false);
			shallow_copy_expr.value.dump(&&out, true);
			out.pop();
		}
		case TypeRef: type -> {
			out.push("TypeRefExpr", is_last);
			out.span(this.span);
			out.value(type.signature());
			out.pop();
		}
		case FunctionRef: function -> {
			out.push("FunctionRefExpr", is_last);
			out.span(this.span);
			out.value(function.signature());
			out.pop();
		}
	}
}

func addDereference(this: &Expr) -> Expr {
	match this.type.reference_kind {
		case None -> return this;
		else -> return Expr::Dereference(Box!<Expr>(this), this.span, this.type.base());
	}
}

func removeDereference(this: &Expr) -> Expr {
	match this {
		case Dereference: &base -> return base.operator unwrap();
		else -> return this;
	}
}

func format(template_parameter: &TemplateParameter) -> String {
	match template_parameter {
		case None -> return "<none>";
		case Type: t -> return t.signature();
		case Boolean: v -> return format(v);
		case Integer: v -> return format(v);
		case String: s -> return "\"" + s + "\"";
		case Garbage -> return "<garbage>";
	}
}

func format(template_parameters: &List!<TemplateParameterDecl>) -> String {
	if template_parameters.isEmpty() {
		return "";
	}

	var result = "!<";
	for i in 0u..template_parameters.size() {
		if i != 0 {
			result += ", ";
		}

		result += template_parameters[i].signature();
	}

	return result + ">";
}

func format(template_parameters: &List!<TemplateParameter>) -> String {
	if template_parameters.isEmpty() {
		return "";
	}

	var result = "!<";
	for i in 0u..template_parameters.size() {
		if i != 0 {
			result += ", ";
		}

		result += format(template_parameters[i]);
	}

	return result + ">";
}

func format(state: NamespaceState) -> String {
	assert(state >= IncompleteTemplate && state <= Done);

	match state {
		case IncompleteTemplate -> return "IncompleteTemplate";
		case Unchecked -> return "Unchecked";
		case UncheckedTypeBodies -> return "UncheckedTypeBodies";
		case UncheckedFunctionSignatures -> return "UncheckedFunctionSignatures";
		case UncheckedFunctionBodies -> return "UncheckedFunctionBodies";
		case Done -> return "Done";
	}
}

func format(this: &Name) -> String {
	var result = "";
	var first = true;
	for i in 0u..this.segments.size() {
		if i != 0 {
			result += "::";
		}
		result += this.segments[i].name;
		result += format(this.segments[i].template_parameters);
	}

	return result;
}

func format(types: &List!<Type>) -> String {
	var result = "(";
	for i in 0u..types.size() {
		if i != 0 {
			result += ", ";
		}

		result += types[i].signature();
	}

	return result + ")";
}

func format(return_kind: ReturnKind) -> String {
	match return_kind {
		case None -> return "None";
		case Value -> return "Value";
		case Variable -> return "Variable";
		case Parameter -> return "Parameter";
		case VariableButYieldNone -> return "VariableButYieldNone";
	}
}








func toString(this: ReferenceKind) -> String {
	match this {
		case None -> return "";
		case Const -> return "&";
		case Var -> return "&&";
	}
}

func format(parsed_number: ParsedNumber) -> String {
	return format(parsed_number.significant) + " * " + format(parsed_number.base) + "^" + format(parsed_number.exponent);
}

variant Node {
	var span: Span;
	var is_comptime: bool;

	case Empty;
	case Garbage;

	case ExternFunctionBody;
	case DefaultFunctionBody;

	case Pragma: String;
	case Import: String;

	case NamespaceDecl: ParsedNamespaceDecl;
	case TypeDecl: ParsedTypeDecl;
	case FunctionDecl: ParsedFunctionDecl;
	case AliasDecl: ParsedAliasDecl;

	case VarDecl: ParsedVarDecl;
	case CaseDecl: ParsedCaseDecl;

	case CompoundStmt: List!<uint>;

	case IfStmt: ParsedIfStmt;
	case IfVarStmt: ParsedIfVarStmt;
	case VarElseStmt: ParsedVarElseStmt;

	case WhileStmt: ParsedWhileStmt;
	case DoWhileStmt: ParsedDoWhileStmt;
	case ForStmt: ParsedForStmt;

	case CaseStmt: ParsedCaseStmt;
	case ElseCaseStmt: uint;

	case BreakStmt;
	case ContinueStmt;

	case DeferStmt: uint;
	case ThrowStmt: uint;
	case ReturnStmt: uint;
	case YieldStmt: uint;
	case DiscardStmt: uint;

	case Name: ParsedName;

	case CharLiteralExpr: ParsedCharLiteralExpr;
	case StringLiteralExpr: ParsedStringLiteralExpr;
	case NumberLiteralExpr: ParsedNumberLiteralExpr;
	case BoolLiteralExpr: bool;

	case ParenExpr: uint;

	case UnaryOperatorExpr: ParsedUnaryOperatorExpr;
	case BinaryOperatorExpr: ParsedBinaryOperatorExpr;
	case CallExpr: List!<uint>;
	case IndexExpr: List!<uint>;
	case InlineIfExpr: ParsedInlineIfExpr;

	case ArrayExpr: List!<uint>;
	case TupleExpr: List!<ParsedTupleElement>;
	case DictExpr: List!<ParsedDictElement>;

	case MatchExpr: ParsedMatchExpr;

	case FunctionRefExpr: ParsedFunctionRefExpr;
	case AnonymousFunctionExpr: uint;

	case FunctionType: ParsedFunctionType;

	func name(this: &Node) -> String {
		match this {
			case Empty -> return "Empty";
			case Garbage -> return "Garbage";
			case ExternFunctionBody -> return "ExternFunctionBody";
			case DefaultFunctionBody -> return "DefaultFunctionBody";
			case Pragma -> return "Pragma";
			case Import -> return "Import";
			case NamespaceDecl -> return "NamespaceDecl";
			case TypeDecl -> return "TypeDecl";
			case FunctionDecl -> return "FunctionDecl";
			case AliasDecl -> return "AliasDecl";
			case VarDecl -> return "VarDecl";
			case CaseDecl -> return "CaseDecl";
			case CompoundStmt -> return "CompoundStmt";
			case IfStmt -> return "IfStmt";
			case IfVarStmt -> return "IfVarStmt";
			case VarElseStmt -> return "VarElseStmt";
			case WhileStmt -> return "WhileStmt";
			case DoWhileStmt -> return "DoWhileStmt";
			case ForStmt -> return "ForStmt";
			case CaseStmt -> return "CaseStmt";
			case ElseCaseStmt -> return "ElseCaseStmt";
			case DeferStmt -> return "DeferStmt";
			case BreakStmt -> return "BreakStmt";
			case ContinueStmt -> return "ContinueStmt";
			case ThrowStmt -> return "ThrowStmt";
			case ReturnStmt -> return "ReturnStmt";
			case YieldStmt -> return "YieldStmt";
			case DiscardStmt -> return "DiscardStmt";
			case Name -> return "Name";
			case CharLiteralExpr -> return "CharLiteralExpr";
			case StringLiteralExpr -> return "StringLiteralExpr";
			case NumberLiteralExpr -> return "NumberLiteralExpr";
			case BoolLiteralExpr -> return "BoolLiteralExpr";
			case ParenExpr -> return "ParenExpr";
			case UnaryOperatorExpr -> return "UnaryOperatorExpr";
			case BinaryOperatorExpr -> return "BinaryOperatorExpr";
			case CallExpr -> return "CallExpr";
			case IndexExpr -> return "IndexExpr";
			case InlineIfExpr -> return "InlineIfExpr";
			case ArrayExpr -> return "ArrayExpr";
			case TupleExpr -> return "TupleExpr";
			case DictExpr -> return "DictExpr";
			case MatchExpr -> return "MatchExpr";
			case FunctionRefExpr -> return "FunctionRefExpr";
			case AnonymousFunctionExpr -> return "AnonymousFunctionExpr";
			case FunctionType -> return "FunctionType";
		}
	}

	func isAnonymousTuple(this: &Node) -> bool {
		match this {
			case TupleExpr: &elements -> {
				var is_anonymous = true;
				for &element in elements {
					is_anonymous &= element.name == "";
				}
				return is_anonymous;
			}
			else -> return false;
		}
	}

	func addIdOffset(this: &&Node, offset: uint) -> void {
		match this {
			case NamespaceDecl: &&decl -> {
				decl.first_node_id += offset;
				decl.last_node_id += offset;
				for &&p in decl.template_parameters {
					if p.value > 1 { p.value += offset; }
				}
				if decl.body > 1 { decl.body += offset; }
			}
			case TypeDecl: &&decl -> {
				decl.first_node_id += offset;
				decl.last_node_id += offset;
				for &&p in decl.template_parameters {
					if p.value > 1 { p.value += offset; }
				}
				if decl.id_type > 1 { decl.id_type += offset; }
				if decl.body > 1 { decl.body += offset; }
			}
			case FunctionDecl: &&decl -> {
				decl.first_node_id += offset;
				decl.last_node_id += offset;
				for &&p in decl.template_parameters {
					if p.value > 1 { p.value += offset; }
				}
				for &&p in decl.signature.parameters {
					if p > 1 { p += offset; }
				}
				if decl.signature.return_type > 1 { decl.signature.return_type += offset; }
				if decl.body > 1 { decl.body += offset; }
			}
			case AliasDecl: &&decl -> {
				if decl.type > 1 { decl.type += offset; }
			}
			case VarDecl: &&decl -> {
				if decl.type > 1 { decl.type += offset; }
				if decl.initializer > 1 { decl.initializer += offset; }
			}
			case CaseDecl: &&decl -> {
				if decl.payload > 1 { decl.payload += offset; }
				if decl.id > 1 { decl.id += offset; }
			}
			case CompoundStmt: &&children -> {
				for &&c in children {
					if c > 1 { c += offset; }
				}
			}
			case IfStmt: &&stmt -> {
				if stmt.condition > 1 { stmt.condition += offset; }
				if stmt.then_branch > 1 { stmt.then_branch += offset; }
				if stmt.else_branch > 1 { stmt.else_branch += offset; }
			}
			case IfVarStmt: &&stmt -> {
				if stmt.var_decl > 1 { stmt.var_decl += offset; }
				if stmt.body > 1 { stmt.body += offset; }
			}
			case VarElseStmt: &&stmt -> {
				if stmt.var_decl > 1 { stmt.var_decl += offset; }
				if stmt.body > 1 { stmt.body += offset; }
			}
			case WhileStmt: &&stmt -> {
				if stmt.condition > 1 { stmt.condition += offset; }
				if stmt.body > 1 { stmt.body += offset; }
			}
			case DoWhileStmt: &&stmt -> {
				if stmt.condition > 1 { stmt.condition += offset; }
				if stmt.body > 1 { stmt.body += offset; }
			}
			case ForStmt: &&stmt -> {
				if stmt.range > 1 { stmt.range += offset; }
				if stmt.body > 1 { stmt.body += offset; }
			}
			case CaseStmt: &&stmt -> {
				for &&pattern in stmt.patterns {
					if pattern > 1 { pattern += offset; }
				}
				if stmt.body > 1 { stmt.body += offset; }
			}
			case ElseCaseStmt: &&body -> {
				if body > 1 { body += offset; }
			}
			case DeferStmt: &&body -> {
				if body > 1 { body += offset; }
			}
			case ThrowStmt: &&value -> {
				if value > 1 { value += offset; }
			}
			case ReturnStmt: &&value -> {
				if value > 1 { value += offset; }
			}
			case YieldStmt: &&value -> {
				if value > 1 { value += offset; }
			}
			case DiscardStmt: &&value -> {
				if value > 1 { value += offset; }
			}
			case Name: &&name -> {
				for &&p in name.template_parameters {
					if p > 1 { p += offset; }
				}
			}
			case ParenExpr: &&child -> {
				if child > 1 { child += offset; }
			}
			case UnaryOperatorExpr: &&expr -> {
				if expr.operand > 1 { expr.operand += offset; }
			}
			case BinaryOperatorExpr: &&expr -> {
				if expr.lhs > 1 { expr.lhs += offset; }
				if expr.rhs > 1 { expr.rhs += offset; }
			}
			case CallExpr: &&args -> {
				for &&arg in args {
					if arg > 1 { arg += offset; }
				}
			}
			case IndexExpr: &&args -> {
				for &&arg in args {
					if arg > 1 { arg += offset; }
				}
			}
			case InlineIfExpr: &&expr -> {
				if expr.condition > 1 { expr.condition += offset; }
				if expr.then_value > 1 { expr.then_value += offset; }
				if expr.else_value > 1 { expr.else_value += offset; }
			}
			case ArrayExpr: &&elements -> {
				for &&e in elements {
					if e > 1 { e += offset; }
				}
			}
			case TupleExpr: &&elements -> {
				for &&e in elements {
					if e.value > 1 { e.value += offset; }
				}
			}
			case DictExpr: &&elements -> {
				for &&e in elements {
					if e.value > 1 { e.value += offset; }
					if e.key > 1 { e.key += offset; }
				}
			}
			case MatchExpr: &&expr -> {
				if expr.value > 1 { expr.value += offset; }
				if expr.body > 1 { expr.body += offset; }
			}
			case FunctionRefExpr: &&expr -> {
				if expr.name > 1 { expr.name += offset; }
				for &&type in expr.parameter_types {
					if type > 1 { type += offset; }
				}
			}
			case AnonymousFunctionExpr: &&function -> {
				if function > 1 { function += offset; }
			}
			case FunctionType: &&type -> {
				if type.return_type > 1 { type.return_type += offset; }
				for &&parameter in type.parameter_types {
					if parameter > 1 { parameter += offset; }
				}
			}
			else -> {}
		}
	}
}

variant ParsedAnnotation {
	var span: Span;
	var name: String;

	case Flag;
	case String: String;
	case Number: ParsedNumber;
}

enum TypeDeclKind {
	case Struct;
	case Enum;
	case Variant;
}

alias ParsedTemplateParameterDecl = (span: Span, name: String, concept: String, value: uint);

alias ParsedNamespaceDecl = (
	first_node_id: uint,
	last_node_id: uint,
	name_span: Span,
	annotations: List!<ParsedAnnotation>,
	template_parameters: List!<ParsedTemplateParameterDecl>,
	name: String,
	body: uint
);

alias ParsedTypeDecl = (
	first_node_id: uint,
	last_node_id: uint,
	name_span: Span,
	annotations: List!<ParsedAnnotation>,
	template_parameters: List!<ParsedTemplateParameterDecl>,
	kind: TypeDeclKind,
	name: String,
	id_type: uint,
	body: uint
);

alias ParsedFunctionSignature = (span: Span, name: String, parameters: List!<uint>, return_type: uint);
alias ParsedFunctionDecl = (
	first_node_id: uint,
	last_node_id: uint,
	span: Span,
	annotations: List!<ParsedAnnotation>,
	template_parameters: List!<ParsedTemplateParameterDecl>,
	is_comptime: bool,
	signature: ParsedFunctionSignature,
	body: uint
);

alias ParsedAliasDecl = (name: String, type: uint);
alias ParsedVarDecl = (annotations: List!<ParsedAnnotation>, name: String, type: uint, initializer: uint, is_const: bool, is_parameter: bool);
alias ParsedCaseDecl = (name: String, payload: uint, id: uint);

alias ParsedIfStmt = (condition: uint, then_branch: uint, else_branch: uint);
alias ParsedIfVarStmt = (var_decl: uint, body: uint);
alias ParsedVarElseStmt = (var_decl: uint, body: uint, capture_name: String, capture_kind: ReferenceKind);
alias ParsedWhileStmt = (condition: uint, body: uint);
alias ParsedDoWhileStmt = (body: uint, condition: uint);
alias ParsedForStmt = (capture_name: String, capture_kind: ReferenceKind, capture_span: Span, range: uint, body: uint);
alias ParsedCaseStmt = (patterns: List!<uint>, capture_name: String, capture_kind: ReferenceKind, body: uint);

alias ParsedName = (name: String, template_parameters: List!<uint>);

alias ParsedCharLiteralExpr = (value: byte, postfix: String);
alias ParsedStringLiteralExpr = (value: String, postfix: String);
alias ParsedNumberLiteralExpr = (value: ParsedNumber, postfix: String);

alias ParsedUnaryOperatorExpr = (op: Operator, operand: uint);
alias ParsedBinaryOperatorExpr = (op: Operator, lhs: uint, rhs: uint);
alias ParsedInlineIfExpr = (condition: uint, then_value: uint, else_value: uint);

alias ParsedTupleElement = (span: Span, name: String, value: uint);
alias ParsedDictElement = (span: Span, key: uint, value: uint);

alias ParsedMatchExpr = (value: uint, body: uint);
alias ParsedFunctionRefExpr = (name: uint, parameter_types: List!<uint>);

alias ParsedFunctionType = (parameter_types: List!<uint>, return_type: uint);

