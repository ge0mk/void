import std/core;
import std/range;

import std/libc/stdlib;
import std/libc/string;

template <T: type>
struct List {
	var data: vptr!<T>;
	var size: uint;
	var capacity: uint;

	func constructor(this: &&List!<T>) -> void {
		this.data := vptr::null() as vptr!<T>;
		this.size := 0;
		this.capacity := 0;
	}

	func constructor(this: &&List!<T>, other: List!<T>) -> void {
		this.data := vptr::null() as vptr!<T>;
		this.size := 0;
		this.capacity := 0;

		this.grow(other.size());

		for index in 0u..other.size() {
			this.data[index].constructor(other[index]);
		}
		this.size = other.size();
	}

	func constructor(this: &&List!<T>, range: Range!<T>) -> void {
		this.data := vptr::null() as vptr!<T>;
		this.size := 0;
		this.capacity := 0;

		this.grow(range.size());

		for element in range {
			this.data[this.size].constructor(element);
			this.size += 1u;
		}
		this.size = range.size();
	}

	func constructor(this: &&List!<T>, range: VRange!<T>) -> void {
		this.data := vptr::null() as vptr!<T>;
		this.size := 0;
		this.capacity := 0;

		this.grow(range.size());

		for element in range {
			this.data[this.size].constructor(element);
			this.size += 1u;
		}
		this.size = range.size();
	}

	func constructor(this: &&List!<T>, size: uint, @[shallow] value: T) -> void {
		this.data := vptr::null() as vptr!<T>;
		this.size := 0;
		this.capacity := 0;

		this.grow(size);

		for index in 0u..size {
			this.data[index].constructor(value);
		}
		this.size = size;
	}

	operator =(this: &&List!<T>, other: List!<T>) -> void {
		this.clear();
		this.grow(other.size());

		for index in 0u..other.size() {
			this.data[index].constructor(other[index]);
		}
		this.size = other.size();
	}

	func destructor(this: &&List!<T>) -> void {
		this.clear();

		if this.data != vptr::null() {
			libc::stdlib::free(this.data as vptr);
		}
	}

	func size(this: &List!<T>) -> uint {
		return this.size;
	}

	func isEmpty(this: &List!<T>) -> bool {
		return this.size == 0u;
	}

	func data(this: &List!<T>) -> cptr!<T> {
		return this.data as cptr!<T>;
	}

	func at(this: &List!<T>, index: uint) -> Optional!<T> {
		if index >= this.size() {
			return None;
		}

		return Some(this.data[index]);
	}

	operator [](this: &List!<T>, index: uint) -> &T {
		if index >= this.size() {
			panic(Error::EBOUNDS);
		}

		return &this.data[index];
	}

	operator [](this: &&List!<T>, index: uint) -> &&T {
		if index >= this.size() {
			panic(Error::EBOUNDS);
		}

		return &&this.data[index];
	}

	operator [](this: &List!<T>, range: NumericRange!<uint>) -> Range!<T> {
		if range.end > this.size() {
			panic(Error::EBOUNDS);
		}

		if range.start > range.end || range.step != 1u {
			panic(Error::EINVAL);
		}

		return Range!<T>(this.data as cptr!<T> + range.start, range.end - range.start);
	}

	func first(this: &List!<T>) -> Optional!<T> {
		if this.isEmpty() {
			return None;
		}

		return Some(this.data[0u]);
	}

	func last(this: &List!<T>) -> Optional!<T> {
		if this.isEmpty() {
			return None;
		}

		return Some(this.data[this.size - 1u]);
	}

	func range(this: &List!<T>) -> Range!<T> {
		return Range!<T>(this.data as cptr!<T>, this.size);
	}

	func vrange(this: &&List!<T>) -> VRange!<T> {
		return VRange!<T>(this.data, this.size);
	}

	func iterator(this: &List!<T>) -> RangeIterator!<T> {
		return RangeIterator!<T>(this.data as cptr!<T>, this.data as cptr!<T> + this.size);
	}

	func iterator(this: &&List!<T>) -> VRangeIterator!<T> {
		return VRangeIterator!<T>(this.data, this.data + this.size);
	}

	func find(this: &List!<T>, @[shallow] value: T) -> Optional!<uint> {
		for index in 0u..this.size() {
			if this.data[index] == value {
				return Some(index);
			}
		}

		return None;
	}

	func contains(this: &List!<T>, @[shallow] value: T) -> bool {
		return this.find(value) is Some;
	}

	func startsWith(this: &List!<T>, values: Range!<T>) -> bool {
		if values.size() > this.size {
			return false;
		}

		for i in 0u..values.size() {
			if this.data[i] != values[i] {
				return false;
			}
		}

		return true;
	}

	func endsWith(this: &List!<T>, values: Range!<T>) -> bool {
		if values.size() > this.size {
			return false;
		}

		for i in 0u..values.size() {
			if this.data[this.size - i - 1] != values[values.size() - i - 1] {
				return false;
			}
		}

		return true;
	}

	func append(this: &&List!<T>, @[shallow] value: T) -> void {
		this.grow();
		this.data[this.size].constructor(value);
		this.size += 1u;
	}

	func append(this: &&List!<T>, values: Range!<T>) -> void {
		this.grow(this.size() + values.size());

		var index = 0u;
		for element in values {
			this.data[this.size + index].constructor(element);
			index += 1u;
		}
		this.size += values.size();
	}

	func append(this: &&List!<T>, @[shallow] values: List!<T>) -> void {
		this.append(values.range());
	}

	func insert(this: &&List!<T>, index: uint, @[shallow] value: T) -> void {
		if index > this.size() {
			panic(Error::EBOUNDS);
		}

		this.grow();
		memmove!<T>(this.data + index + 1, this.data as cptr!<T> + index, this.size - index);

		this.data[index].constructor(value);
		this.size += 1u;
	}

	func insert(this: &&List!<T>, index: uint, values: Range!<T>) -> void {
		if index > this.size() {
			panic(Error::EBOUNDS);
		}

		this.grow(this.size() + values.size());
		memmove!<T>(this.data + index + values.size(), this.data as cptr!<T> + index, this.size - index);

		var offset = index;
		for element in values {
			this.data[offset].constructor(element);
			offset += 1u;
		}
		this.size += values.size();
	}

	func insert(this: &&List!<T>, index: uint, @[shallow] values: List!<T>) -> void {
		this.insert(index, values.range());
	}

	func remove(this: &&List!<T>, index: uint) -> void {
		if index >= this.size() {
			panic(Error::EBOUNDS);
		}

		this.data[index].destructor();
		this.size -= 1u;
		memmove!<T>(this.data + index, this.data as cptr!<T> + index + 1, this.size - index);
	}

	func remove(this: &&List!<T>, range: NumericRange!<uint>) -> void {
		if range.start > this.size || range.end > this.size {
			panic(Error::EBOUNDS);
		}

		if range.start > range.end || range.step != 1u {
			panic(Error::EINVAL);
		}

		for index in range {
			this.data[index].destructor();
		}

		this.size -= range.end - range.start;
		memmove!<T>(this.data + range.start, this.data as cptr!<T> + range.end, this.size - range.start);
	}

	func removeLast(this: &&List!<T>) -> void {
		if this.size == 0 {
			panic(Error::EBOUNDS);
		}

		this.remove(this.size - 1);
	}

	func clear(this: &&List!<T>) -> void {
		for index in 0u..this.size() {
			this.data[index].destructor();
		}
		this.size = 0u;
	}

	operator ==(@[shallow] this: List!<T>, @[shallow] other: List!<T>) -> bool {
		if this.size() != other.size() {
			return false;
		}

		for i in 0u..this.size() {
			if this.data[i] != other.data[i] {
				return false;
			}
		}

		return true;
	}

	operator +(lhs: List!<T>, @[shallow] rhs: T) -> List!<T> {
		lhs.append(rhs);
		return lhs;
	}

	operator +(lhs: List!<T>, @[shallow] rhs: List!<T>) -> List!<T> {
		lhs.append(rhs);
		return lhs;
	}

	operator +=(this: &&List!<T>, @[shallow] value: T) -> void {
		this.append(value);
	}

	operator +=(this: &&List!<T>, @[shallow] other: List!<T>) -> void {
		this.append(other);
	}

	// ensure that memory for at least one more element is available
	func grow(this: &&List!<T>) -> void {
		if this.size < this.capacity {
			return;
		}

		this.grow(this.size * 3u / 2u + 1u);
	}

	// ensure that memory for at least 'new_capacity' elements is available
	func grow(this: &&List!<T>, new_capacity: uint) -> void {
		const old_capacity = this.capacity;
		if old_capacity >= new_capacity {
			return;
		}

		var new_data: vptr!<T>;
		if this.data == vptr::null() {
			new_data = libc::stdlib::malloc(new_capacity * sizeOf!<T>()) as vptr!<T>;
		} else {
			new_data = libc::stdlib::realloc(this.data as vptr, new_capacity * sizeOf!<T>()) as vptr!<T>;
		}

		if new_data == vptr::null() {
			panic(Error::ENOMEM);
		}

		this.data = new_data;
		this.capacity = new_capacity;

		memset!<T>(this.data + old_capacity, '\0'b, new_capacity - old_capacity);
	}
}
