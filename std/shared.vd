import std/core;
import std/libc/stdlib;

template <T: type>
struct refc {
	var strong_count: uint;
	var weak_count: uint;
	var value: T;
}

template <T: type>
struct SharedPtr {
	var data: vptr!<refc!<T>>;

	func constructor(this: &&SharedPtr!<T>, value: T) {
		this.data := libc::stdlib::malloc(sizeOf!<refc!<T>>()) as vptr!<refc!<T>>;
		this.data[0u].strong_count = 1;
		this.data[0u].weak_count = 1;
		this.data[0u].value.constructor(value);
	}

	func destructor(this: &&SharedPtr!<T>) {
		assert(this.data[0u].strong_count > 0);

		this.data[0u].strong_count--;
		if this.data[0u].strong_count == 0 {
			this.data[0u].value.destructor();
			this.data[0u].weak_count--;
		}

		if this.data[0u].weak_count == 0 {
			libc::stdlib::free(this.data as vptr);
		}
	}

	func constructor(this: &&SharedPtr!<T>, other: SharedPtr!<T>) {
		this.data := other.data;
		this.data[0u].strong_count++;
	}

	func constructor(this: &&SharedPtr!<T>, other: WeakPtr!<T>) {
		assert(other.data != vptr::null());

		this.data := other.data;
		this.data[0u].strong_count++;
	}

	operator =(this: &&SharedPtr!<T>, other: SharedPtr!<T>) -> void {
		this.destructor();
		this.constructor(other);
	}

	operator ==(this: SharedPtr!<T>, other: SharedPtr!<T>) -> bool = default;
	operator <=>(this: SharedPtr!<T>, other: SharedPtr!<T>) -> int = default;

	func new(value: T) -> SharedPtr!<T> {
		return SharedPtr!<T>(value);
	}

	operator unwrap(this: SharedPtr!<T>) -> T {
		return this.data.value().value;
	}

	operator unwrap(this: &SharedPtr!<T>) -> &T {
		return &this.data.value().value;
	}

	operator unwrap(this: &&SharedPtr!<T>) -> &&T {
		return &&this.data.value().value;
	}
}

template <T: type>
struct WeakPtr {
	var data: vptr!<refc!<T>>;

	func constructor(this: &&WeakPtr!<T>) -> void = default;

	func constructor(this: &&WeakPtr!<T>, other: SharedPtr!<T>) {
		this.data := other.data;
		if this.data != vptr::null() {
			this.data[0u].weak_count++;
		}
	}

	func constructor(this: &&WeakPtr!<T>, other: WeakPtr!<T>) {
		this.data := other.data;
		if this.data != vptr::null() {
			this.data[0u].weak_count++;
		}
	}

	func destructor(this: &&WeakPtr!<T>) {
		if this.data == vptr::null() {
			return;
		}

		assert(this.data[0u].weak_count > 0);

		this.data[0u].weak_count--;
		if this.data[0u].weak_count == 0 {
			libc::stdlib::free(this.data as vptr);
		}
	}

	operator =(this: &&WeakPtr!<T>, other: WeakPtr!<T>) -> void {
		this.destructor();
		this.constructor(other);
	}

	func isAlive(this: &WeakPtr!<T>) -> bool {
		if this.data == vptr::null() {
			return false;
		}

		return this.data[0u].strong_count > 0;
	}

	func lock(this: &WeakPtr!<T>) -> Optional!<SharedPtr!<T>> {
		if this.data == vptr::null() {
			return None;
		}

		if this.data[0u].strong_count <= 0 {
			return None;
		}

		return Some(SharedPtr!<T>(this));
	}

	func forceLock(this: &WeakPtr!<T>) -> SharedPtr!<T> {
		if this.data == vptr::null() {
			panic(Error::EOPTNONE);
		}

		if this.data[0u].strong_count <= 0 {
			panic(Error::EOPTNONE);
		}

		return SharedPtr!<T>(this);
	}

	operator ==(this: WeakPtr!<T>, other: WeakPtr!<T>) -> bool = default;
	operator <=>(this: WeakPtr!<T>, other: WeakPtr!<T>) -> int = default;
}
