import std/core;
import std/libc/stdlib;

template <T: type>
struct refc {
	var strong_count: uint;
	var weak_count: uint;
	var value: T;
}

template <T: type>
struct SharedPtr {
	var data: vptr!<refc!<T>>;

	func constructor(this: &&SharedPtr!<T>, data: vptr!<refc!<T>>) {
		this.data := data;
		this.data[0u].strong_count++;
	}

	func constructor(this: &&SharedPtr!<T>, other: SharedPtr!<T>) {
		this.data := other.data;
		this.data[0u].strong_count++;
	}

	func destructor(this: &&SharedPtr!<T>) {
		assert(this.data[0u].strong_count > 0);

		if this.data[0u].strong_count == 1 {
			this.data[0u].value.destructor();
		}

		this.data[0u].strong_count--;

		if this.data[0u].strong_count == 0 && this.data[0u].weak_count == 0 {
			libc::stdlib::free(this.data as vptr);
		}
	}

	operator =(this: &&SharedPtr!<T>, other: SharedPtr!<T>) -> void {
		this.destructor();
		this.constructor(other);
	}

	func new(value: T) -> SharedPtr!<T> {
		var data = libc::stdlib::malloc(sizeOf!<refc!<T>>()) as vptr!<refc!<T>>;
		data[0u].strong_count = 0;
		data[0u].weak_count = 0;
		data[0u].value.constructor(value);
		return SharedPtr!<T>(data);
	}

	operator unwrap(this: SharedPtr!<T>) -> T {
		return this.data.value().value;
	}

	operator unwrap(this: &SharedPtr!<T>) -> &T {
		return &this.data.value().value;
	}

	operator unwrap(this: &&SharedPtr!<T>) -> &&T {
		return &&this.data.value().value;
	}
}

template <T: type>
struct WeakPtr {
	var data: vptr!<refc!<T>>;

	func constructor(this: &&WeakPtr!<T>) -> void = default;

	func constructor(this: &&WeakPtr!<T>, data: vptr!<refc!<T>>) {
		this.data := data;
		if this.data != vptr::null() {
			this.data[0u].weak_count++;
		}
	}

	func constructor(this: &&WeakPtr!<T>, other: SharedPtr!<T>) {
		this.data := other.data;
		if this.data != vptr::null() {
			this.data[0u].weak_count++;
		}
	}

	func constructor(this: &&WeakPtr!<T>, other: WeakPtr!<T>) {
		this.data := other.data;
		if this.data != vptr::null() {
			this.data[0u].weak_count++;
		}
	}

	func destructor(this: &&WeakPtr!<T>) {
		if this.data != vptr::null() {
			this.data[0u].weak_count--;

			if this.data[0u].strong_count == 0 && this.data[0u].weak_count == 0 {
				libc::stdlib::free(this.data as vptr);
			}
		}
	}

	operator =(this: &&WeakPtr!<T>, other: WeakPtr!<T>) -> void {
		this.destructor();
		this.constructor(other);
	}

	func isAlive(this: WeakPtr!<T>) -> bool {
		if this.data == vptr::null() {
			return false;
		}

		return this.data[0u].strong_count > 0;
	}

	func lock(this: &WeakPtr!<T>) -> Optional!<SharedPtr!<T>> {
		if this.data == vptr::null() {
			return None;
		}

		if this.data[0u].strong_count <= 0 {
			return None;
		}

		return Some(SharedPtr!<T>(this.data));
	}

	operator <=>(this: WeakPtr!<T>, other: WeakPtr!<T>) -> int {
		return this.data <=> other.data;
	}
}
