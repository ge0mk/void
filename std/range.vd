import std/core;

template <T: type>
struct Range {
	var data: cptr!<T>;
	var size: uint;

	func constructor(this: &&Range!<T>, data: cptr!<T>, size: uint) -> void {
		this.data := data;
		this.size := size;
	}

	func constructor(this: &&Range!<T>, other: Range!<T>) -> void {
		this.data := other.data;
		this.size := other.size;
	}

	operator =(this: &&Range!<T>, other: Range!<T>) -> void {
		this.data = other.data;
		this.size = other.size;
	}

	func destructor(this: &&Range!<T>) -> void {}

	func data(this: &Range!<T>) -> cptr!<T> {
		return this.data;
	}

	func size(this: &Range!<T>) -> uint {
		return this.size;
	}

	operator [](this: &Range!<T>, index: uint) -> Result!<&T> {
		if index >= this.size {
			throw Error::EINVAL;
		}

		return Ok(&this.data[index]);
	}

	func find(this: Range!<T>, value: T) -> Optional!<uint> {
		for index in 0u..this.size() {
			if this.data[index] == value {
				return Some(index);
			}
		}

		return None;
	}

	func contains(this: Range!<T>, value: T) -> bool {
		return this.find(value) is Some;
	}

	operator ==(this: Range!<T>, other: Range!<T>) -> bool {
		if this.size != other.size {
			return false;
		}

		for i in 0u..this.size {
			if this.data[i] != other.data[i] {
				return false;
			}
		}

		return true;
	}

	func iterator(this: &Range!<T>) -> RangeIterator!<T> {
		return RangeIterator!<T>(this.data, this.data + this.size);
	}
}

template <T: type>
struct RangeIterator {
	var current: cptr!<T>;
	var end: cptr!<T>;

	func constructor(this: &&RangeIterator!<T>, begin: cptr!<T>, end: cptr!<T>) -> void {
		this.current := begin;
		this.end := end;
	}

	func destructor(this: &&RangeIterator!<T>) -> void {}

	func next(this: &&RangeIterator!<T>) -> Optional!<&T> {
		if this.current >= this.end {
			return None;
		}

		const r = Optional!<&T>::Some(&this.current.value());
		this.current = this.current + 1;
		return r;
	}
}

template <T: type>
struct VRange {
	var data: vptr!<T>;
	var size: uint;

	func constructor(this: &&VRange!<T>, data: vptr!<T>, size: uint) -> void {
		this.data := data;
		this.size := size;
	}

	func constructor(this: &&VRange!<T>, other: VRange!<T>) -> void {
		this.data := other.data;
		this.size := other.size;
	}

	operator =(this: &&VRange!<T>, other: VRange!<T>) -> void {
		this.data = other.data;
		this.size = other.size;
	}

	func destructor(this: &&VRange!<T>) -> void {}

	func data(this: &VRange!<T>) -> vptr!<T> {
		return this.data;
	}

	func size(this: &VRange!<T>) -> uint {
		return this.size;
	}

	operator [](this: &VRange!<T>, index: uint) -> Result!<&&T> {
		if index >= this.size {
			throw Error::EINVAL;
		}

		return Ok(&&this.data[index]);
	}

	func find(this: VRange!<T>, value: T) -> Optional!<uint> {
		for index in 0u..this.size() {
			if this.data[index] == value {
				return Some(index);
			}
		}

		return None;
	}

	func contains(this: VRange!<T>, value: T) -> bool {
		return this.find(value) is Some;
	}

	operator ==(this: VRange!<T>, other: VRange!<T>) -> bool {
		if this.size != other.size {
			return false;
		}

		for i in 0u..this.size {
			if this.data[i] != other.data[i] {
				return false;
			}
		}

		return true;
	}

	func iterator(this: &VRange!<T>) -> VRangeIterator!<T> {
		return VRangeIterator!<T>(this.data, this.data + this.size);
	}
}

template <T: type>
struct VRangeIterator {
	var current: vptr!<T>;
	var end: vptr!<T>;

	func constructor(this: &&VRangeIterator!<T>, begin: vptr!<T>, end: vptr!<T>) -> void {
		this.current := begin;
		this.end := end;
	}

	func destructor(this: &&VRangeIterator!<T>) -> void {}

	func next(this: &&VRangeIterator!<T>) -> Optional!<&&T> {
		if this.current >= this.end {
			return None;
		}

		const r = Optional!<&&T>::Some(&&this.current.value());
		this.current = this.current + 1;
		return r;
	}
}
