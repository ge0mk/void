import std/core;

template <T: type, Mutable: bool>
struct Range {
	comptime if Mutable {
		alias data_ptr_type = vptr!<T>;
	} else {
		alias data_ptr_type = cptr!<T>;
	}

	var data: data_ptr_type;
	var size: uint;

	func constructor(this: &&Range!<T, Mutable>, data: data_ptr_type, size: uint) -> void {
		this.data := data;
		this.size := size;
	}

	func constructor(this: &&Range!<T, Mutable>, other: Range!<T, Mutable>) -> void {
		this.data := other.data;
		this.size := other.size;
	}

	comptime if !Mutable {
		func constructor(this: &&Range!<T, Mutable>, other: Range!<T, true>) -> void {
			this.data := other.data as data_ptr_type;
			this.size := other.size;
		}
	}

	func destructor(this: &&Range!<T, Mutable>) -> void {}

	operator =(this: &&Range!<T, Mutable>, other: Range!<T, Mutable>) -> void {
		this.data = other.data;
		this.size = other.size;
	}

	func data(this: &Range!<T, Mutable>) -> data_ptr_type {
		return this.data;
	}

	func size(this: &Range!<T, Mutable>) -> uint {
		return this.size;
	}

	func at(this: &Range!<T, Mutable>, index: uint) -> Optional!<&T> {
		if index >= this.size {
			return None;
		}

		return Some(&this.data[index]);
	}

	comptime if Mutable {
		operator [](this: &Range!<T, Mutable>, index: uint) -> &&T {
			assert(index < this.size, Error::EINVAL);
			return &&this.data[index];
		}
	} else {
		operator [](this: &Range!<T, Mutable>, index: uint) -> &T {
			assert(index < this.size, Error::EINVAL);
			return &this.data[index];
		}
	}

	func find(this: Range!<T, Mutable>, value: T) -> Optional!<uint> {
		for index in 0u..this.size() {
			if this.data[index] == value {
				return Some(index);
			}
		}

		return None;
	}

	func contains(this: Range!<T, Mutable>, value: T) -> bool {
		return this.find(value) is Some;
	}

	operator ==(this: Range!<T, Mutable>, other: Range!<T, Mutable>) -> bool {
		if this.size != other.size {
			return false;
		}

		for i in 0u..this.size {
			if this.data[i] != other.data[i] {
				return false;
			}
		}

		return true;
	}

	func iterator(this: &Range!<T, Mutable>) -> RangeIterator!<T, Mutable> {
		return RangeIterator!<T, Mutable>(this.data, this.data + this.size);
	}
}

template <T: type, Mutable: bool>
struct RangeIterator {
	comptime if Mutable {
		alias data_ptr_type = vptr!<T>;
	} else {
		alias data_ptr_type = cptr!<T>;
	}

	var current: data_ptr_type;
	var end: data_ptr_type;

	func constructor(this: &&RangeIterator!<T, Mutable>, begin: data_ptr_type, end: data_ptr_type) -> void {
		this.current := begin;
		this.end := end;
	}

	func constructor(this: &&RangeIterator!<T, Mutable>, other: RangeIterator!<T, Mutable>) -> void = default;
	func destructor(this: &&RangeIterator!<T, Mutable>) -> void = default;

	func hasNext(this: &RangeIterator!<T, Mutable>) -> bool {
		return this.current < this.end;
	}

	comptime if Mutable {
		func getNext(this: &&RangeIterator!<T, Mutable>) -> &&T {
			assert(this.current < this.end, Error::EINVAL);
			this.current = this.current + 1;
			return &&this.current[-1];
		}
	} else {
		func getNext(this: &&RangeIterator!<T, Mutable>) -> &T {
			assert(this.current < this.end, Error::EINVAL);
			this.current = this.current + 1;
			return &this.current[-1];
		}
	}
}
