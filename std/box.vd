import std/core;
import std/libc/stdlib;

template <T: type>
struct Box {
	var data: vptr!<T>;

	func constructor(this: &&Box!<T>, @[shallow] value: T) -> void {
		this.data := libc::stdlib::malloc(sizeOf!<T>()) as vptr!<T>;
		assert(this.data != vptr::null());
		this.data.value().constructor(value);
	}

	func constructor(this: &&Box!<T>, @[shallow] other: Box!<T>) -> void {
		this.data := libc::stdlib::malloc(sizeOf!<T>()) as vptr!<T>;
		assert(this.data != vptr::null());
		this.data.value().constructor(other.data.value());
	}

	func destructor(this: &&Box!<T>) -> void {
		this.data.value().destructor();
		libc::stdlib::free(this.data as vptr);
	}

	operator =(this: &&Box!<T>, @[shallow] other: Box!<T>) -> void {
		this.data.value() = other.data.value();
	}

	operator ==(@[shallow] this: Box!<T>, @[shallow] other: Box!<T>) -> bool {
		return this.data.value() == other.data.value();
	}

	operator ==(@[shallow] this: Box!<T>, @[shallow] other: T) -> bool {
		return this.data.value() == other;
	}

	operator unwrap(@[shallow] this: Box!<T>) -> T {
		return this.data.value();
	}

	operator unwrap(this: &Box!<T>) -> &T {
		return &this.data.value();
	}

	operator unwrap(this: &&Box!<T>) -> &&T {
		return &&this.data.value();
	}
}
