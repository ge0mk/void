import std/core;
import std/libc/stdlib;

template <T: type>
struct Box {
	var data: vptr!<T>;

	func constructor(this: &&Box!<T>, @[shallow] other: Box!<T>) -> void {
		this.data := libc::stdlib::malloc(sizeOf!<T>()) as vptr!<T>;
		assert(this.data != vptr::null());
		this.data[0u].constructor(other.data[0u]);
	}

	func constructor(this: &&Box!<T>, @[shallow] value: T) -> void {
		this.data := libc::stdlib::malloc(sizeOf!<T>()) as vptr!<T>;
		assert(this.data != vptr::null());
		this.data[0u].constructor(value);
	}

	func destructor(this: &&Box!<T>) -> void {
		this.data[0u].destructor();
		libc::stdlib::free(this.data as vptr);
	}

	operator =(this: &&Box!<T>, @[shallow] other: Box!<T>) -> void {
		this.data[0u] = other.data[0u];
	}

	operator =(this: &&Box!<T>, @[shallow] value: T) -> void {
		this.data[0u] = value;
	}

	operator ==(@[shallow] this: Box!<T>, @[shallow] other: Box!<T>) -> bool {
		return this.data[0u] == other.data[0u];
	}

	operator ==(@[shallow] this: Box!<T>, @[shallow] value: T) -> bool {
		return this.data[0u] == value;
	}

	operator unwrap(this: &Box!<T>) -> &T {
		return &this.data[0u];
	}

	operator unwrap(this: &&Box!<T>) -> &&T {
		return &&this.data[0u];
	}
}
