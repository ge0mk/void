import std/core;
import std/range;
import std/list;

import std/libc/math;
import std/libc/stdlib;
import std/libc/string;

struct String {
	var data: vptr!<byte>;
	var size: uint;
	var capacity: uint;
	var is_owner: bool;

	func constructor(this: &&String) = default;

	func constructor(this: &&String, other: String) -> void {
		this.data := libc::stdlib::malloc(other.size() * sizeOf!<byte>()) as vptr!<byte>;
		memcpy!<byte>(this.data, other.data(), other.size());
		this.size := other.size();
		this.capacity := other.size();
		this.is_owner := true;
	}

	func constructor(this: &&String, size: uint, fill_char: byte) -> void {
		this.data := libc::stdlib::malloc(size * sizeOf!<byte>()) as vptr!<byte>;
		memset!<byte>(this.data, fill_char, size);
		this.size := size;
		this.capacity := size;
		this.is_owner := true;
	}

	func constructor(this: &&String, bytes: Range!<byte>) -> void {
		this.data := libc::stdlib::malloc(bytes.size() * sizeOf!<byte>()) as vptr!<byte>;
		memcpy!<byte>(this.data, bytes.data(), bytes.size());
		this.size := bytes.size();
		this.capacity := bytes.size();
		this.is_owner := true;
	}

	func fromCString(data: cptr!<byte>) -> String {
		return String(Range!<byte>(data, strlen(data)));
	}

	func fromErrorCode(error: Error) -> String {
		return String::fromCString(libc::string::strerror(error));
	}

	operator =(this: &&String, other: String) -> void {
		this.grow(other.size());
		memcpy!<byte>(this.data, other.data(), other.size());
		this.size = other.size();
	}

	func destructor(this: &&String) {
		if this.is_owner {
			libc::stdlib::free(this.data as vptr);
		}
	}

	func data(this: &String) -> cptr!<byte> {
		return this.data as cptr!<byte>;
	}

	func size(this: &String) -> uint {
		return this.size;
	}

	func isEmpty(this: &String) -> bool {
		return this.size == 0u;
	}

	func bytes(this: &String) -> Range!<byte> {
		return Range!<byte>(this.data as cptr!<byte>, this.size);
	}

	operator [](this: &String, index: uint) -> &byte {
		if index >= this.size() {
			panic(Error::EBOUNDS);
		}

		return &this.data[index];
	}

	operator [](this: &&String, index: uint) -> &&byte {
		if index >= this.size() {
			panic(Error::EBOUNDS);
		}

		return &&this.data[index];
	}

	operator [](this: &String, range: NumericRange!<uint>) -> Range!<byte> {
		if range.end > this.size() {
			panic(Error::EBOUNDS);
		}

		if range.start > range.end || range.step != 1u {
			panic(Error::EINVAL);
		}

		return Range!<byte>(this.data as cptr!<byte> + range.start, range.end - range.start);
	}

	func substring(this: &String, range: NumericRange!<uint>) -> String {
		return String(this[range]);
	}

	func at(this: &String, index: uint) -> Optional!<byte> {
		if index >= this.size() {
			return None;
		}

		return Some(this.data[index]);
	}

	func clear(this: &&String) {
		this.size = 0u;
	}

	func append(this: &&String, value: byte) -> void {
		this.grow();

		this.data[this.size] = value;
		this.size += 1u;
	}

	func append(this: &&String, other: String) -> void {
		this.append(other.bytes());
	}

	func append(this: &&String, bytes: Range!<byte>) -> void {
		this.grow(this.size + bytes.size());

		memcpy!<byte>(this.data + this.size, bytes.data() as cptr!<byte>, bytes.size());
		this.size += bytes.size();
	}

	func insert(this: &&String, index: uint, value: byte) -> void {
		if index > this.size {
			panic(Error::EBOUNDS);
		}

		this.grow();
		memmove!<byte>(this.data + index + 1, this.data as cptr!<byte> + index, this.size - index);

		this.data[index] = value;
		this.size += 1u;
	}

	func insert(this: &&String, index: uint, other: String) -> void {
		this.insert(index, other.bytes());
	}

	func insert(this: &&String, index: uint, bytes: Range!<byte>) -> void {
		if index > this.size {
			panic(Error::EBOUNDS);
		}

		this.grow(this.size + bytes.size());
		memmove!<byte>(this.data + index + bytes.size(), this.data as cptr!<byte> + index, this.size - index);
		memcpy!<byte>(this.data + index, bytes.data(), bytes.size());
		this.size += bytes.size();
	}

	func remove(this: &&String, index: uint) -> void {
		if index >= this.size {
			panic(Error::EBOUNDS);
		}

		this.size -= 1u;
		memmove!<byte>(this.data + index, this.data as cptr!<byte> + index + 1, this.size - index);
	}

	func remove(this: &&String, range: NumericRange!<uint>) -> void {
		if range.start > this.size || range.end > this.size {
			panic(Error::EBOUNDS);
		}

		if range.start > range.end || range.step != 1u {
			panic(Error::EINVAL);
		}

		this.size -= range.end - range.start;
		memmove!<byte>(this.data + range.start, this.data as cptr!<byte> + range.end, this.size - range.start);
	}

	func find(this: &String, start: uint, value: byte) -> Optional!<uint> {
		if start >= this.size {
			return None;
		}

		const pos = libc::string::memchr(this.data as cptr!<byte> + start, value as i32, this.size - start);
		if pos == cptr::null() {
			return None;
		}

		return Some((pos - this.data as cptr!<byte>) as uint);
	}

	func find(this: &String, value: byte) -> Optional!<uint> {
		const pos = libc::string::memchr(this.data as cptr!<byte>, value as i32, this.size);
		if pos == cptr::null() {
			return None;
		}

		return Some((pos - this.data as cptr!<byte>) as uint);
	}

	func find(this: &String, start: uint, needle: String) -> Optional!<uint> {
		if start >= this.size {
			return None;
		}

		const pos = libc::string::memmem(this.data as cptr!<byte> + start, this.size - start, needle.data(), needle.size());
		if pos == cptr::null() {
			return None;
		}

		return Some((pos - this.data as cptr!<byte>) as uint);
	}

	func find(this: &String, needle: String) -> Optional!<uint> {
		const pos = libc::string::memmem(this.data as cptr!<byte>, this.size, needle.data(), needle.size());
		if pos == cptr::null() {
			return None;
		}

		return Some((pos - this.data as cptr!<byte>) as uint);
	}

	func rfind(this: &String, end: uint, value: byte) -> Optional!<uint> {
		if end >= this.size {
			return None;
		}

		const pos = libc::string::memrchr(this.data as cptr!<byte>, value as i32, this.size - end);
		if pos == cptr::null() {
			return None;
		}

		return Some((pos - this.data as cptr!<byte>) as uint);
	}

	func rfind(this: &String, value: byte) -> Optional!<uint> {
		const pos = libc::string::memrchr(this.data as cptr!<byte>, value as i32, this.size);
		if pos == cptr::null() {
			return None;
		}

		return Some((pos - this.data as cptr!<byte>) as uint);
	}

	func contains(this: &String, value: byte) -> bool {
		return this.find(value) is Some;
	}

	func contains(this: &String, needle: String) -> bool {
		return this.find(needle) is Some;
	}

	func replace(this: &&String, range: NumericRange!<uint>, with: String) -> void {
		if range.start > this.size || range.end > this.size {
			panic(Error::EBOUNDS);
		}

		if range.start > range.end || range.step != 1u {
			panic(Error::EINVAL);
		}

		const difference = with.size() as int - range.size() as int;
		const count = (difference if difference >= 0 else -difference) as uint;
		if difference > 0 {
			this.grow(this.size + count);
		}

		memmove!<byte>(this.data + range.end + difference, this.data as cptr!<byte> + range.end, this.size - range.end);
		memcpy!<byte>(this.data + range.start, with.data(), with.size());

		if difference < 0 {
			this.size -= count;
		} else {
			this.size += count;
		}
	}

	func replace(this: &&String, pattern: byte, with: String) -> void {
		var start = 0u;
		var pos = this.find(start, pattern);

		while pos.hasValue() {
			const index = pos.value();
			this.replace(index..(index + 1u), with);
			start = index + with.size();
			pos = this.find(start, pattern);
		}
	}

	func replace(this: &&String, pattern: String, with: String) -> void {
		var start = 0u;
		var pos = this.find(start, pattern);

		while pos.hasValue() {
			const index = pos.value();
			this.replace(index..(index + pattern.size()), with);
			start = index + with.size();
			pos = this.find(start, pattern);
		}
	}

	func split(this: &String, separator: byte) -> List!<String> {
		var result = List!<String>();

		var segment_start = 0u;
		var segment_end = this.find(segment_start, separator);

		while segment_end.hasValue() {
			const segment = this[segment_start..(segment_end.value())];
			result.append(String(segment));

			segment_start = segment_end.value() + 1u;
			segment_end = this.find(segment_start, separator);
		}
		const segment = this[segment_start..this.size];
		result.append(String(segment));

		return result;
	}

	func split(this: &String, separator: String) -> List!<String> {
		var result = List!<String>();

		var segment_start = 0u;
		var segment_end = this.find(segment_start, separator);

		while segment_end.hasValue() {
			const segment = this[segment_start..(segment_end.value())];
			result.append(String(segment));

			segment_start = segment_end.value() + separator.size();
			segment_end = this.find(segment_start, separator);
		}
		const segment = this[segment_start..this.size];
		result.append(String(segment));

		return result;
	}

	func join(separator: String, segments: List!<String>) -> String {
		var result = String();
		for i in 0u..segments.size() {
			if i != 0 {
				result.append(separator);
			}
			result.append(segments[i]);
		}
		return result;
	}

	func startsWith(this: &String, other: String) -> bool {
		if this.size < other.size {
			return false;
		}

		for index in 0u..other.size {
			if this.data[index] != other.data[index] {
				return false;
			}
		}

		return true;
	}

	func endsWith(this: &String, other: String) -> bool {
		if this.size < other.size {
			return false;
		}

		const offset = this.size - other.size;
		for index in 0u..other.size {
			if this.data[index + offset] != other.data[index] {
				return false;
			}
		}

		return true;
	}

	operator <=>(this: String, other: String) -> int {
		for index in 0u..min(this.size, other.size) {
			const r = this.data[index] <=> other.data[index];
			if r != 0 {
				return r;
			}
		}

		return this.size <=> other.size;
	}

	operator +(this: String, value: byte) -> String {
		var result = this;
		result.append(value);
		return result;
	}

	operator +(this: String, other: String) -> String {
		var result = this;
		result.append(other);
		return result;
	}

	operator +=(this: &&String, value: byte) -> void {
		this.append(value);
	}

	operator +=(this: &&String, other: String) -> void {
		this.append(other);
	}

	// ensure that memory for at least one more element is available
	func grow(this: &&String) -> void {
		if this.size < this.capacity {
			return;
		}

		this.grow(this.size * 3u / 2u + 1u);
	}

	// ensure that memory for at least 'new_capacity' elements is available
	func grow(this: &&String, new_capacity: uint) -> void {
		const old_capacity = this.capacity;
		if old_capacity >= new_capacity && this.is_owner {
			return;
		}

		var new_data = vptr::null() as vptr!<byte>;
		if this.data == vptr::null() || !this.is_owner {
			new_data = libc::stdlib::malloc(new_capacity * sizeOf!<byte>()) as vptr!<byte>;
		} else {
			new_data = libc::stdlib::realloc(this.data as vptr, new_capacity * sizeOf!<byte>()) as vptr!<byte>;
		}

		if new_data == vptr::null() {
			panic(Error::ENOMEM);
		}

		if !this.is_owner {
			memcpy!<byte>(new_data, this.data as cptr!<byte>, old_capacity);
			this.is_owner = true;
		}

		if new_capacity > old_capacity {
			memset!<byte>(new_data + old_capacity, '\0'b, new_capacity - old_capacity);
		}

		this.data = new_data;
		this.capacity = new_capacity;
	}
}

// number: (0[bodx])?[0-9]+(\.[0-9]+(e[+-]?[0-9]+)?)?
// base set by prefix 0[bodx], default 10 (decimal)
// significant = [0-9]+(\.[0-9]+)? (decimal point is ignored)
// exponent = 'e[+-]?[0-9]+' - offset of decimal point from the right
// length = # of parsed bytes
struct ParsedNumber {
	var significant: int;
	var base: int;
	var exponent: int;
	var length: uint;

	func constructor(this: &&ParsedNumber, significant: int, base: int, exponent: int, length: uint) -> void {
		this.significant := significant;
		this.base := base;
		this.exponent := exponent;
		this.length := length;

		this.normalize();
	}

	func constructor(this: &&ParsedNumber, other: ParsedNumber) -> void = default;
	func destructor(this: &&ParsedNumber) -> void = default;

	operator =(this: &&ParsedNumber, other: ParsedNumber) -> void = default;

	operator ==(this: ParsedNumber, other: ParsedNumber) -> bool = default;

	// remove trailing zeros in the significant: 100 * 10^0 -> 1 * 10^2
	func normalize(this: &&ParsedNumber) -> void {
		if this.significant == 0 {
			return;
		}

		while this.significant % this.base == 0 {
			this.significant /= this.base;
			this.exponent += 1;
		}
	}

	func toInt(this: &ParsedNumber) -> int {
		const power = this.exponent if this.exponent > 0 else -this.exponent;
		var result = this.significant;
		var i = 0;

		while i < power {
			if this.exponent < 0 {
				result /= this.base;
			} else {
				result *= this.base;
			}
			i++;
		}

		return result;
	}

	func toFloat(this: &ParsedNumber) -> f64 {
		return this.significant as f64 * pow(this.base as f64, this.exponent as f64);
	}

	func isInteger(this: &ParsedNumber) -> bool {
		if this.exponent >= 0 {
			return true;
		}

		const power = -this.exponent;
		var result = this.significant;
		var i = 0;

		while i < power {
			if result % this.base != 0 { // next division would produce decimals
				return false;
			}

			result /= this.base;
			i++;
		}

		return true;
	}
}

func isAlpha(val: byte) -> bool {
	return (val >= 'A'b && val <= 'Z'b) || (val >= 'a'b && val <= 'z'b);
}

func isDigit(val: byte) -> bool {
	return val >= '0'b && val <= '9'b;
}

func isSpace(b: byte) -> bool {
	return b == ' 'b || b == '\t'b || b == '\n'b || b == '\r'b;
}

func isDigit(val: byte, base: int) -> bool {
	match base {
		case 2 -> return val == '0'b || val == '1'b;
		case 8 -> return val >= '0'b && val <= '7'b;
		case 10 -> return val >= '0'b && val <= '9'b;
		case 16 -> return (val >= '0'b && val <= '9'b)
						|| (val >= 'A'b && val <= 'F'b)
						|| (val >= 'a'b && val <= 'f'b);
		else -> return val >= '0'b && val <= '9'b;
	}
}

func parseDigit(val: byte, base: int) -> int {
	match base {
		case 16 -> {
			if val >= '0'b && val <= '9'b {
				return val as int - '0'b as int;
			} else if val >= 'A'b && val <= 'F'b {
				return val as int - 'A'b as int + 10;
			} else if val >= 'a'b && val <= 'f'b {
				return val as int - 'a'b as int + 10;
			} else {
				return -1;
			}
		}
		else -> return val as int - '0'b as int;
	}
}

func parseNumber(str: String, start: uint) -> ParsedNumber {
	var index = start;
	var negative = false;
	var significant = 0;
	var base = 10;
	var exponent = 0;
	var offset = 0;

	if str[index] == '-'b {
		negative = true;
		index++;
	}

	if str.size() - index >= 3 {
		if str[index] == '0'b && isAlpha(str[index + 1]) {
			match str[index + 1] {
				case 'b'b -> base = 2;
				case 'o'b -> base = 8;
				case 'd'b -> base = 10;
				case 'x'b -> base = 16;
				else -> return ParsedNumber(0, 10, 0, 1u);
			}

			if isDigit(str[index + 2], base) {
				index += 2;
			} else {
				// 0x -> number 0 with postfix x
				return ParsedNumber(0, 10, 0, 1u);
			}
		}
	}

	if !isDigit(str[index], base) {
		return ParsedNumber(0, 0, 0, 0u);
	}

	while isDigit(str[index], base) {
		const digit = parseDigit(str[index], base);
		significant = significant * base + digit;
		index++;

		if index >= str.size() {
			break;
		}
	}

	if str.size() - index >= 2 {
		if str[index] == '.'b && isDigit(str[index + 1], base) {
			index++;

			while isDigit(str[index], base) {
				const digit = parseDigit(str[index], base);
				significant = significant * base + digit;
				offset++;
				index++;

				if index >= str.size() {
					break;
				}
			}
		}
	}

	if negative {
		significant *= -1;
	}

	const significant_end = index;

	if str.size() - index >= 2 {
		if str[index] == 'e'b || str[index] == 'E'b {
			index++;

			var exponent_sign = 1;
			if str[index] == '-'b {
				exponent_sign = -1;
				index++;
			} else if str[index] == '+'b {
				index++;
			}

			if !isDigit(str[index], base) {
				return ParsedNumber(significant, base, exponent - offset, significant_end - start);
			}

			while isDigit(str[index], base) {
				const digit = parseDigit(str[index], base);
				exponent = exponent * base + digit;
				index++;

				if index >= str.size() {
					break;
				}
			}

			exponent *= exponent_sign;
		}
	}

	return ParsedNumber(significant, base, exponent - offset, index - start);
}
